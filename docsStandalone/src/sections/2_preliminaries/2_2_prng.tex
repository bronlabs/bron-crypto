% □ PRNG
% □ Why?
% □ When to use?
% Testing process (prng tester/test vector)
%------------------------------------------------------------------------------%
\subsubsection{Random Number Generation}\label{sec:rng}
%------------------------------------------------------------------------------%


Most cryptographic applications (e.g., key generation, nonces for  ECDSA, secret sharing and masking) require a mechanism to generate random numbers. We model this mechanism in Functionality \ref{alg:prng}.

\input{src/algorithms/primitives/F_rand.tex}

The  "quality" (\textit{entropy}) of the randomness required for these applications varies. While creating a nonce in some protocols needs only uniqueness\footnote{In practice, this could even be achieved with a deterministic counter.} (e.g., the \textit{Session ID} of \autoref{sec:mpc_agreeonrandom}), the generation of a private key (e.g., public-key encryption, signature schemes) requires high-entropy randomness generation. Based on the properties of the randomness source used, we distinguish three types of random number generators:
\begin{itemize}
    \item \textbf{True Random Number Generators (TRNGs)}: These generators use a physical source of randomness (e.g., thermal noise, radioactive decay, etc.) to generate random numbers. The output of these generators is unpredictable and statistically independent. However, the generation of random numbers with TRNGs is slow, as the entropy collection is limited by the variability of the physical process used.
    \item \textbf{Cryptographically-Secure Pseudo-Random Number Generators (CSPRNGs)}: These generators use an algorithm to generate random numbers by deterministically  "extending" a high-entropy source used as seed. The output of these generators is unpredictable and statistically independent up to a certain degree (computational indistinguishability from true random with a certain computational security parameter). They are significantly faster than TRNGs and require no special hardware.
    \item Standard \textbf{Pseudo-Random Number Generators (PRNGs)}: These generators use a deterministic algorithm to generate random numbers without cryptographic guarantees.Offering limited statistical properties, they are much faster than CSPRNGs yet they are not suitable for cryptographic applications. PRNGs such as the Mersenne Twister~\cite{matsumoto1998mersenne} are popularly used in statistical simulations (e.g., Monte Carlo) and video-games with loose randomness requirements.
\end{itemize}

CSPRNGs are suited to replace TRNGs for cryptographic applications, provided that they are properly seeded. By seeding them with entropy obtained from a high-quality source such as the operating system's randomness API or an external TRNG, CSPRNGs "extend" the seeds to produce a long sequence  of cryptographically secure random numbers at a faster rate than the entropy source they consume. 
CSPRNGs are often constructed on cryptographic primitives such as ciphers and cryptographic hashes. To qualify as such, CSPRNGs must both pass statistical randomness tests and hold up well under adversarial conditions. In particular, CSPRNGs should satisfy the following properties:

\begin{itemize}
    \item Every CSPRNG should satisfy the \textit{next-bit test}. That is, given the first $i$ bits of a random sequence, there is no polynomial-time algorithm that can predict the $(k+1)-$th bit with probability of success non-negligibly better than $50\%$ \cite{katz2007introduction}. As a byproduct, CSPRNGs should pass the \textit{statistical randomness tests} often used to characterize the quality of PRNGs (e.g., Diehard~\cite{marsaglia2008diehard}, TestU01~\cite{l2007testu01}).
    \item If part or all of a CSPRNG's internal state is revealed, it should be infeasible to reconstruct the stream of random numbers prior to the revelation. Additionally, if there is an entropy input while running, it should be infeasible to use knowledge of the input's state to predict future conditions of the CSPRNG state.
\end{itemize}

\paragraph{Library-wide CSPRNG.}\label{sec:nistcsprng}
We select a construction from the NIST SP 800-90A standard~\cite{barker2012ctrdrbg} called \textsf{CTR\_DRBG} (Counter mode Deterministic Random Bit Generator, based on AES in counter mode) to act as the base cryptographically secure random number generator for all our cryptographic operations. We seed this construction with a high-entropy source obtained from the Operating System's randomness API (e.g., \textsf{/dev/random} in Linux\footnote{\url{https://man7.org/linux/man-pages/man4/urandom.4.html}}, \textsf{BCryptGenRandom} in Windows\footnote{\url{https://learn.microsoft.com/en-us/windows/win32/seccng/cng-portal}}). As a distinctive feature, the seed is automatically updated after generating a certain number of bits (a.k.a. \textit{reseeding}) by sampling a fresh seed from the high-entropy source. We refer to the NIST SP 800-90A standard~\cite{barker2012ctrdrbg} for details on the construction and its security analysis, as well as the NIST Deterministic Random Bit Generator Validation System (DRBGVS)~\cite{keller2009nist} to validate our implementation. 

\paragraph{CSPRNG Wrapper}\label{sec:csprng_wrapper}

In some cases, the entropy source of the CSPRNG may be compromised due to faulty hardware or other reasons. To mitigate this risk we implement RFC8937~\cite{cremers2020rfc}, a randomness wrapper that ties the security of the CSPRNG not only to the high-entropy source, but also to a deterministic signing key held by the device. We summarize the construction in Algorithm \ref{alg:prngwrapper}, We refer to RFC8937~\cite{cremers2020rfc} for its security analysis.


\input{src/algorithms/primitives/prngwrapper.tex} 


We incorporate the \fnref{PrngWrapper} as an intermediate step in the seeding and reseeding of the {CTR\_DRBG}. For the sake of clarity, we name the resulting construction as \fnref{krand} and describe it in Algorithm \ref{alg:krand}.

\input{src/algorithms/primitives/krand.tex}

We employ \fnref{krand} as the main CSPRNG for all our primitives and protocols. From this point onwards, we denote $\sample{r}{\Z_q}$ to represent $\assign{r}{\fnref{krand}.\fn{Sample}(|q|)}$, uniformly sampling a value $r$ from a set ($\Z_q$ in this example) by using an instance of \fnref{krand}. In cases where $q$ is not a power of two, an unless specified otherwise\footnote{Non-constant-time implementations might avoid this,  resorting instead to \textit{rejection sampling}: sampling a bit-string $r \in \Z_{2^{|q|}}$ of bit-length $|q|$ as many times as needed until $r>q$} we sample a sufficiently large number $\sample{r}{\Z_{2^{|q|+\kappa}}}$ and reduce it $\assign{r}{r'\mod q}$ at the cost of some acceptably low bias ($\approx 2^{-\kappa}$). We tested the quality of all our CSPRNGs with the test suite TestU01~\cite{l2007testu01}, passing all tests.