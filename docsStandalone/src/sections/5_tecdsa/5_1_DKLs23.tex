% a. DKLs23: [Alberto]
% § Differences from the paper:
%     □ Typo
%     □ Zero share sampling not maintaining an index (confirm if that’s the c ase)
%     □ DKG
%     □ Base OT
% § Some points on performance
% § Mention it’ll still be UC even if fiat shamir (author explanation)
% Mention Zero share sampling for 2 party issue (author explanation)
%------------------------------------------------------------------------------%
\subsection{DKLs23}\label{sec:dkls23}
%------------------------------------------------------------------------------%

As our principal threshold ECDSA protocol, we select the 3-round $t$-out-of-$n$ signing protocol of \cite{DKLS23} realizing the standard ECDSA signature scheme (Scheme \ref{alg:ecdsa}) with UC security against $t-1$ static corruptions. The full description can be found in Protocol 3.6 of \cite{DKLS23}. We are largely faithful to the original paper, save for the following changes:
\begin{itemize}
    \item We fix a typo in the second consistency check (Step 8 of Protocol 3.6 in \cite{DKLS23}), writing $\pk_j$ instead of $\lambda_j \cdot \party{j}$.
    \item For the $\idealfn{Zero}$ functionality, instead of concatenating the seeds with an index, we salt the shared seeds with the session id. This session id is derived from the \fn{AgreeOnRandom} primitive (\autoref{sec:mpc_agreeonrandom}) per signing session.
    \item $R_i$ is included in the partial signature, for the aggregator to compute the sum and the recovery ID independently while normalizing the signature.
    \item For DKG we resort to GJKR05~\cite{gennaroDKG} instead of their pick based on the DKG of DKLs19~\cite{DKLs19}.
    \item For the discrete log proofs we resort to the randomized Fischlin transformation (Figure 9 of \cite{kondiShelatTransform}, described in Scheme \ref{alg:fischlin}) to achieve non interactivity, replacing the common Fiat-Shamir transform \cite{fiatShamirTransform} that would not be UC secure in this context.
    \item As the paper recommends and separately confirmed by the authors, the OT extension required by the $\idealfn{RVOLE}$ functionality (and instantiated with SoftSpokenOT~\cite{softspokenot} in our case) is made non-interactive with Fiat-Shamir while retaining UC security\footnote{This is achieved, among other reasons, thanks to the existence of fresh randomness in the transcript, tied to the generation of a fresh session ID per run of the protocol.}.
\end{itemize}


\subsubsection{Random VOLE} 

DKLs23's signing protocol builds upon a $\idealfn{RVOLE}$ functionality, which we detail below in the honest case\footnote{The extra details for the malicious case are detailed in Functionality 3.5 of \cite{DKLS23}}. We incorporate an additional optimization suggested in Section 5.1 of \cite{DKLS23}.

\input{src/algorithms/threshold_signatures/F_RVOLE.tex}

To realize this functionality, we follow the instructions from \cite{DKLS23} to implement a forced-reuse variant the $\pi^\ell_{2PMul}$ protocol from \cite[Protocol 1]{DKLs19} where $b$ is fixed for all the elements in the batch of size $\ell$ by reusing Bob's OT instances. Protocol \ref{alg:rvole} details the implementation of this variant. Trivially, by providing random input values, this protocol becomes a randomized multiplication protocol. We fix a typo\footnote{Corroborated by the authors~\cite{DKLSCommunication}} from the original paper in our step 2.7, correctly writing $\vecti{\theta}{i,k}$ instead of $\vecti{\theta}{k,k}$

\subsubsection{Signing} 

We detail our instantiation of \cite[Protocol 3.6]{DKLS23} in Protocol \ref{alg:dkls23_sign}. The \fn{Init} for \cite{DKLS23} is composed of a standard DKG (picked from Section \ref{sec:key_generation}), the setup for $\idealfn{Zero}$ functionality (generating the random pairwise seeds), and the setup for the $\idealfn{RVOLE}$ functionality (e.g., running the base OTs for OTe).

\input{src/algorithms/threshold_signatures/rvole}


\input{src/algorithms/threshold_signatures/dkls23_sign}



