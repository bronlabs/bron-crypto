\begin{protocol}[H]
    \caption{$\quad\fn{DKLs23.Sign}$}
    \label{alg:dkls23_sign}
    \begin{algorithmic}[1]
        \begin{alginfo}
            $t$-out-of-$n$ threshold signing protocol from \cite{DKLS23}, realizing the standard \fnref{ECDSA} functionality with UC security for a group $\G(q,\g{G})$.  The protocol builds on $\fnref[gennarodkg]{DKG}$, $\fnref{Przs}$, $\fnref{RVOLE}_{2,q}$, a $\fnref[dlc]{Commitment}$ scheme and a hash function $\fn{H}$.
        \end{alginfo}  
        \Players \begin{itemize}[leftmargin=0pt,label=, itemsep=-2pt]
            \item Key share holders: $\{\party{i}\}_{i \in \range{n}}$ holding $\{x_i\}_{i \in \range{n}}$ and public key $\g{Q}$
            \item \hspace{28pt}Quorum of signers: $\{\party{i}\}_{i \in \set{S}}$ for $\set{S} \ins \subrange{t}{n}$ and $\set{S}^* \equals \set{S} \setminuss \{i\}$
        \end{itemize}
        \Require A session identifier $sid$, and a message $\vect{m}$
        \Ensure A partial signature $\sigma_i$ per $\party{i}$. A signature $\sigma$ after aggregation

        \vspace{-12pt}
        \AlgRoundZero{$\party{i}$}{\fndef[dkls23]{Init}}{}{$(x_i, \g{Q}, \zeta_i)$}
            \State Run $\assign{(\g{Q}, x_i)}{\fnref[gennarodkg]{DKG}}$ to obtain a public and a private key share
            \State Run $\fnref{Przs}.\fnref[przs]{Setup1}()$, $\fnref{Przs}.\fnref[przs]{Setup2}()$ and $\fnref{Przs}.\fnref[przs]{Setup3}()$ to setup zero sharing
                \State Run $\fnref{RVOLE}.\fnref[rvole]{Setup}()$  as Alice with $\party{k}$ as Bob $\forall k \ins \range{n} \setminuss \{i\}$
                \State Run $\fnref{RVOLE}.\fnref[rvole]{Setup}()$  as Bob with $\party{k}$ as Alice $\forall k \ins \range{n} \setminuss \{i\}$

        \vspace{-12pt}
        \setalglineno{1}
        \AlgRound{$\party{i}$}{\fndef[dkls23]{Round1}}{}{$(R_i, \{c'_{ij}, \gamma_{ij}\}_{j \in \set{S}^*})$}
            \State Sample $\sample{\phi_i}{\Z_q}$ as an inversion mask and $\sample{r_i}{\Z_q}$ as an instance key
            \State $\assign{R_i}{r_i \cdot \g{G}}$ as the public instance key
            \For{$j \in \set{S}^*$}
                \State Run $\assign{(c'_{ij},w_{ij})}{\fnref[blc]{Commit}(i \concat j \concat sid \concat R_i)}$
                \State Run $\assign{(\gamma_{ij}, b_{ij})}{\fnref{RVOLE}.\fnref[rvole]{Round1}()}$ as Bob
                \State $\sendTo{\party{j}}{c'_{ij}, \gamma_{ij}}$
            \EndFor
            \State $\idealfnref{Broadcast}(R_i)$

        \vspace{-12pt}
        \setalglineno{1}
        \AlgRound{$\party{i}$}{\fndef[dkls23]{Round2}}{$\{R_j, c'_{ji}, \gamma_{ji}\}_{j \in \set{S}^*}$}{$(\{\vect{\mu}^{rnd2}_{ij}, \Gamma^u_{ij}$, $\Gamma^v_{ij}$, $b_{ij}, w_{ij}\}_{j \in \set{S}^*}, R_i, P_i)$}
            \State Run $\assign{\zeta_i}{\fnref{Przs}.\fnref[przs]{Sample}()}$ to get a zero share
            \State $\assign{a_i}{\fnref{ShamirToAdditive}(i, \set{S}, x_i)}$
            \State $\assign{sk_i}{a_i + \zeta_i}$ and $\assign{P_i}{sk_i \cdot \g{G}}$ as refreshed instance key shares
            \For{$j \in \set{S}^*$}
                \State Run $\assign{(\vect{\mu}^{rnd2}, \vect{c}\!\equiv\!\{c^u,c^v\})_{ij}}{\fnref{RVOLE}.\fnref[rvole]{Round2}(\gamma_{ij}, \vect{a}\equals\{r_i, sk_i\})}$ as Alice
                \State $\assign{\Gamma^u_{ij}}{c^u_{ij} \cdot \g{G}}$ and $\assign{\Gamma^v_{ij}}{c^v_{ij} \cdot \g{G}}$
                \State $\assign{\psi_{ij}}{\phi_i - b_{i,j}}$
                \State $\sendTo{\party{j}}{\vect{\mu}^{rnd2}_{ij}, \Gamma^u_{ij}$, $\Gamma^v_{ij}$, $b_{ij}, w_{ij}, R_i}$ 
            \EndFor
            \State $\idealfn{Broadcast}(P_i)$

        \vspace{-12pt}
        \setalglineno{1}
        \AlgRound{$\party{i}$}{\fndef[dkls23]{Round3}}{$\vect{m}, \{\vect{\tilde{a}}_{ji}, \vect{\eta}_{ji}, \mu_{ji}, \Gamma^u_{ji}$, $\Gamma^v_{ji}$, $b_{ji}, w_{ji}, P_j\}_{j \in \set{S}^*}$}{$\sigma_i$}
        \For{$j \in \set{S}^*$}
            \State Run $\fnref[blc]{Open}(j || i || sid || R_j, c'_{ji}, w_{ji})$, $\ABORT$ if it fails
            \State Run $\assign{(\vect{d}\equiv\{d^u_{ij},d^v_{ij}\})}{\fnref{RVOLE}.\fnref[rvole]{Round3}(\vect{\mu}^{rnd2}_{ij}\equals\{\vect{\tilde{a}}, \vect{\eta}, \mu\})}$ as Bob
            \State Check if $\isequal{b_{ji} \cdot R_j - \Gamma^u_{ji}}{ d^u_{ij} \cdot \g{G}}$ otherwise $\ABORT$
            \State  Check if $\isequal{b_{ji} \cdot P_i - \Gamma^v_{ji} }{d^v_{ij} \cdot \g{G}}$ otherwise $\ABORT$
        \EndFor
        \State Check if $\isequal{\sum_{j\in\set{S}} \g{P}_j}{\g{Q}}$, otherwise $\ABORT$
        \State $\assign{R}{\sum_{j\in\set{S}} R_j}$
        \State $\assign{u_i}{r_i \cdot (\phi_i + \sum_{j\in\set{S}^*} \psi_{ji}) + \sum_{j\in\set{S}^*} (c^u_{ij} + d^u_{ij})}$
        \State $\assign{v_i}{sk_i \cdot (\phi_i + \sum_{j\in\set{S}^*} \psi_{ji}) + \sum_{j\in\set{S}^*} (c^v_{ij} + d^v_{ij})}$
        \State $\assign{w_i}{\fn{SHA2}(\vect{m}) \cdot \phi_i + (R_x) \cdot v_i}$
        \State \Return $\sigma_i \equals \{u_i, w_i\}$

        \algstore{dkls23_sign}
    \end{algorithmic}
\end{protocol}
\begin{protocol}[H]
    \begin{algorithmic}[1]
        \algrestore{dkls23_sign}
        \vspace{-6pt}
        \Statex
        \AlgFnct{\fndef[dkls23]{Aggregate}}{}{$\g{Q}, \{u_j, w_j, R_j\}_{j \in \set{S}}$}{$\sigma\;$}
        \setalglineno{1}
        \State $\assign{R}{\sum \g{R}_j}$ and $\assign{r}{\g{R}_x}$
        \State $\assign{s}{\frac{\sum w_j}{\sum u_j}}$
        \State $\assign{v}{(\g{R}_y \mod 2) + 2( \isgeq{\g{R}_x}{q})}$ as the recovery identifier $\in \Z_4$
        \If{$ \isgt{(-s \mod q)}{s}$} \Commentg{(Normalize to "low $s$ form")}
            \State $\assign{s}{(-s) \mod q}$
            \State $\assign{v}{(v + 2) \mod 4}$
        \EndIf
        \State Run $\fnref{ECDSA}.\fnref[ecdsa]{Verify}(\g{Q}, \vect{m}, \sigma \equals(r,s,v))$ to check if the signature is valid
        \Statex \Return $\sigma \equals (r, s, v)$ as the signature
    \end{algorithmic}
\end{protocol}



