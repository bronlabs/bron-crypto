// Code generated by bron-crypto. DO NOT EDIT.

package {{ .Pkg }}

import (
	"encoding/hex"
	"io"
	"math/big"
	"slices"
)

const (
	{{ .TypeName -}}Limbs     = {{ .Limbs }}
	{{ .TypeName -}}SatLimbs  = {{ .TypeName -}}Limbs + 1
	{{ .TypeName -}}Bits      = {{ .BitLen }}
	{{ .TypeName -}}Bytes     = 8 * ((({{ .TypeName -}}Bits - 1) / 64) + 1)
	{{ .TypeName -}}WideBytes = 2 * {{ .TypeName -}}Bytes
	{{ .TypeName -}}DivSteps  = ((49 * {{ .TypeName -}}Bits) + 57) / 17
	{{ .TypeName -}}E         = {{ .E }}
)

var (
	{{ .TypeName -}}ProgenitorExp = [...]byte{ {{- .ProgenitorExponent -}} }
	{{ .TypeName -}}Modulus       = [...]byte{ {{- .Modulus -}} }
	{{ .TypeName -}}RootOfUnity   {{ .TypeName }}
)

func init() {
	{{ .TypeName -}}RootOfUnity.MustSetHex("{{- .RootOfUnity -}}")
}

type {{ .TypeName }} struct {
	{{ .FiatPrefix -}}MontgomeryDomainFieldElement

	_ [0]func()
}

func (f *{{- .TypeName }}) Set(v *{{- .TypeName }}) {
	*f = *v
}

func (f *{{- .TypeName }}) SetZero() {
	*f = {{ .TypeName }}{}
}

func (f *{{- .TypeName }}) SetOne() {
	{{ .FiatPrefix -}}SetOne(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
}

func (f *{{- .TypeName }}) SetUint64(v uint64) {
	limbs := [{{ .TypeName -}}Limbs]uint64{v}
	f.SetLimbs(limbs[:])
}

func (f *{{- .TypeName }}) SetLimbs(data []uint64) (ok uint64) {
	{{ .FiatPrefix -}}ToMontgomery(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, (*{{- .FiatPrefix -}}NonMontgomeryDomainFieldElement)(data))
	return 1
}

func (f *{{- .TypeName }}) SetBytes(data []byte) (ok uint64) {
	if len(data) != {{ .TypeName -}}Bytes {
		return 0
	}

	var nonMonty {{ .FiatPrefix -}}NonMontgomeryDomainFieldElement
	{{ .FiatPrefix -}}FromBytes((*[{{ .TypeName -}}Limbs]uint64)(&nonMonty), (*[{{ .TypeName -}}Bytes]uint8)(data))
	{{ .FiatPrefix -}}ToMontgomery(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &nonMonty)
	return 1
}

func (f *{{- .TypeName }}) SetBytesWide(data []byte) (ok uint64) {
	if len(data) > {{ .TypeName -}}WideBytes {
		return 0
	}

	var wideData [{{ .TypeName -}}WideBytes]uint8
	copy(wideData[:], data)

	var d1, d0 [{{ .TypeName -}}Limbs]uint64
	{{ .FiatPrefix -}}FromBytes(&d0, (*[{{ .TypeName -}}Bytes]uint8)(wideData[:{{ .TypeName -}}Bytes]))
	{{ .FiatPrefix -}}FromBytes(&d1, (*[{{ .TypeName -}}Bytes]uint8)(wideData[{{ .TypeName -}}Bytes:]))

	// d0*r2 + d1*r3
	{{ .FiatPrefix -}}ToMontgomery((*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&d0), (*{{- .FiatPrefix -}}NonMontgomeryDomainFieldElement)(&d0))
	{{ .FiatPrefix -}}ToMontgomery((*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&d1), (*{{- .FiatPrefix -}}NonMontgomeryDomainFieldElement)(&d1))
	{{ .FiatPrefix -}}ToMontgomery((*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&d1), (*{{- .FiatPrefix -}}NonMontgomeryDomainFieldElement)(&d1))
	{{ .FiatPrefix -}}Add(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, (*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&d0), (*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&d1))
	return 1
}

func (f *{{- .TypeName }}) SetUniformBytes(componentsData ...[]byte) (ok uint64) {
	if len(componentsData) != 1 {
		return 0
	}

	return f.SetBytesWide(componentsData[0])
}

func (f *{{- .TypeName }}) SetRandom(prng io.Reader) (ok uint64) {
	var uniformBytes [({{ .TypeName -}}Bits + 128 + 7) / 8]byte
	_, err := io.ReadFull(prng, uniformBytes[:])
	if err != nil {
		return 0
	}
	return f.SetUniformBytes(uniformBytes[:])
}

func (f *{{- .TypeName }}) Select(choice uint64, z, nz *{{- .TypeName }}) {
	{{ .FiatPrefix -}}Selectznz((*[{{ .TypeName -}}Limbs]uint64)(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement), {{- .FiatPrefix -}}Uint1(choice), (*[{{ .TypeName -}}Limbs]uint64)(&z.{{- .FiatPrefix -}}MontgomeryDomainFieldElement), (*[{{ .TypeName -}}Limbs]uint64)(&nz.{{- .FiatPrefix -}}MontgomeryDomainFieldElement))
}

func (f *{{- .TypeName }}) Add(lhs, rhs *{{- .TypeName }}) {
	{{ .FiatPrefix -}}Add(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &lhs.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &rhs.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
}

func (f *{{- .TypeName }}) Sub(lhs, rhs *{{- .TypeName }}) {
	{{ .FiatPrefix -}}Sub(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &lhs.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &rhs.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
}

func (f *{{- .TypeName }}) Neg(v *{{- .TypeName }}) {
	{{ .FiatPrefix -}}Opp(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &v.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
}

func (f *{{- .TypeName }}) Mul(lhs, rhs *{{- .TypeName }}) {
	{{ .FiatPrefix -}}Mul(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &lhs.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &rhs.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
}

func (f *{{- .TypeName }}) Square(v *{{- .TypeName }}) {
	{{ .FiatPrefix -}}Square(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, &v.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
}

func (f *{{- .TypeName }}) Inv(a *{{- .TypeName }}) (ok uint64) {
	var precomp, h, v, r, out4, out5 [{{ .TypeName -}}Limbs]uint64
	var ff, g, out2, out3 [{{ .TypeName -}}SatLimbs]uint64
	var out1, inverted uint64

	d := uint64(1)
	{{ .FiatPrefix -}}DivstepPrecomp(&precomp)
	{{ .FiatPrefix -}}FromMontgomery((*{{- .FiatPrefix -}}NonMontgomeryDomainFieldElement)(g[:{{ .TypeName -}}Limbs]), &a.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
	{{ .FiatPrefix -}}Msat(&ff)
	{{ .FiatPrefix -}}SetOne((*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&r))

	for i := 0; i < {{ .TypeName -}}DivSteps-({{ .TypeName -}}DivSteps%2); i += 2 {
		{{ .FiatPrefix -}}Divstep(&out1, &out2, &out3, &out4, &out5, d, &ff, &g, &v, &r)
		{{ .FiatPrefix -}}Divstep(&d, &ff, &g, &v, &r, out1, &out2, &out3, &out4, &out5)
	}
	if ({{ .TypeName -}}DivSteps % 2) != 0 { // compile time if - always true
		{{ .FiatPrefix -}}Divstep(&out1, &out2, &out3, &out4, &out5, d, &ff, &g, &v, &r)
		v = out4
		ff = out2
	}

	{{ .FiatPrefix -}}Opp((*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&h), (*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&v))
	{{ .FiatPrefix -}}Selectznz(&v, {{ .FiatPrefix -}}Uint1(ff[{{ .TypeName -}}Limbs]>>63), &v, &h)
	{{ .FiatPrefix -}}Mul(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement, (*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&v), (*{{- .FiatPrefix -}}MontgomeryDomainFieldElement)(&precomp))
	{{ .FiatPrefix -}}Nonzero(&inverted, (*[{{ .TypeName -}}Limbs]uint64)(&f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement))

	return (inverted | -inverted) >> 63
}

func (f *{{- .TypeName }}) Div(lhs, rhs *{{- .TypeName }}) (ok uint64) {
	var rhsInv {{ .TypeName }}
	ok = rhsInv.Inv(rhs)
	f.Mul(lhs, &rhsInv)
	return ok
}

func (f *{{- .TypeName }}) Sqrt(x *{{- .TypeName }}) (ok uint64) {
	return {{ .SqrtCall -}}(f, x, &{{ .TypeName -}}RootOfUnity, {{ .TypeName -}}E, {{ .TypeName -}}ProgenitorExp[:])
}

func (f *{{- .TypeName }}) IsNonZero() uint64 {
	// montgomery form might not be "fully reduced"
	var nonMonty {{ .FiatPrefix -}}NonMontgomeryDomainFieldElement
	{{ .FiatPrefix -}}FromMontgomery(&nonMonty, &f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)

	var nonZero uint64
	{{ .FiatPrefix -}}Nonzero(&nonZero, (*[{{ .TypeName -}}Limbs]uint64)(&nonMonty))
	return (nonZero | -nonZero) >> 63
}

func (f *{{- .TypeName }}) IsZero() uint64 {
	return f.IsNonZero() ^ 1
}

func (f *{{- .TypeName }}) IsOne() uint64 {
	var one {{ .TypeName }}
	one.SetOne()
	return f.Equals(&one)
}

func (f *{{- .TypeName }}) Equals(v *{{- .TypeName }}) uint64 {
	var diff {{ .TypeName }}
	diff.Sub(f, v)
	return diff.IsZero()
}

func (f *{{- .TypeName }}) ComponentsBytes() [][]byte {
	return [][]byte{f.Bytes()}
}

func (f *{{- .TypeName }}) Bytes() []byte {
	var nonMonty {{ .FiatPrefix -}}NonMontgomeryDomainFieldElement
	{{ .FiatPrefix -}}FromMontgomery(&nonMonty, &f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
	var data [{{ .TypeName -}}Bytes]byte
	{{ .FiatPrefix -}}ToBytes(&data, (*[{{ .TypeName -}}Limbs]uint64)(&nonMonty))
	return data[:]

}

func (f *{{- .TypeName }}) Limbs() []uint64 {
	var nonMonty {{ .FiatPrefix -}}NonMontgomeryDomainFieldElement
	{{ .FiatPrefix -}}FromMontgomery(&nonMonty, &f.{{- .FiatPrefix -}}MontgomeryDomainFieldElement)
	return nonMonty[:]
}

func (f *{{- .TypeName }}) MustSetHex(v string) {
	data, err := hex.DecodeString(v)
	if err != nil {
		panic(err)
	}
	slices.Reverse(data)
	ok := f.SetBytes(data)
	if ok != 1 {
		panic("invalid data")
	}
}

func (f *{{- .TypeName }}) Hex() string {
	data := f.Bytes()
	slices.Reverse(data)
	return hex.EncodeToString(data)
}

func (f *{{- .TypeName }}) Degree() uint64 {
	return 1
}

func (f *{{- .TypeName }}) String() string {
	fBytes := f.Bytes()
	slices.Reverse(fBytes)
	fBi := new(big.Int).SetBytes(fBytes)
	return fBi.String()
}

func (f *{{- .TypeName }}) GoString() string {
	fBytes := f.Bytes()
	slices.Reverse(fBytes)
	return "0x" + hex.EncodeToString(f.Bytes())
}
