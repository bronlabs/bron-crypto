
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>algebra: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bronlabs/bron-crypto/pkg/base/algebra/basic.go (0.0%)</option>
				
				<option value="file1">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/cubic.go (87.7%)</option>
				
				<option value="file2">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/misc.go (0.0%)</option>
				
				<option value="file3">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/pow.go (100.0%)</option>
				
				<option value="file4">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/quadratic.go (88.1%)</option>
				
				<option value="file5">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/sqrt.go (100.0%)</option>
				
				<option value="file6">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/testutils/fp.go (51.9%)</option>
				
				<option value="file7">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/testutils/json.go (82.4%)</option>
				
				<option value="file8">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/testutils/ops.go (100.0%)</option>
				
				<option value="file9">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/mul.go (0.0%)</option>
				
				<option value="file10">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/properties/fieldal.go (0.0%)</option>
				
				<option value="file11">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/properties/groupal.go (0.0%)</option>
				
				<option value="file12">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/properties/monoidal.go (0.0%)</option>
				
				<option value="file13">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/properties/ringal.go (0.0%)</option>
				
				<option value="file14">github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/properties/utils.go (0.0%)</option>
				
				<option value="file15">github.com/bronlabs/bron-crypto/pkg/base/algebra/operators.go (0.0%)</option>
				
				<option value="file16">github.com/bronlabs/bron-crypto/pkg/base/algebra/properties/generator.go (0.0%)</option>
				
				<option value="file17">github.com/bronlabs/bron-crypto/pkg/base/algebra/properties/model.go (0.0%)</option>
				
				<option value="file18">github.com/bronlabs/bron-crypto/pkg/base/algebra/properties/models.go (0.0%)</option>
				
				<option value="file19">github.com/bronlabs/bron-crypto/pkg/base/algebra/properties/ops.go (0.0%)</option>
				
				<option value="file20">github.com/bronlabs/bron-crypto/pkg/base/algebra/properties/properties.go (0.0%)</option>
				
				<option value="file21">github.com/bronlabs/bron-crypto/pkg/base/base58/base58.go (89.2%)</option>
				
				<option value="file22">github.com/bronlabs/bron-crypto/pkg/base/base58/base58check.go (100.0%)</option>
				
				<option value="file23">github.com/bronlabs/bron-crypto/pkg/base/binaryfields/bf128/bf128.go (56.8%)</option>
				
				<option value="file24">github.com/bronlabs/bron-crypto/pkg/base/bitvec/bitvec.go (0.0%)</option>
				
				<option value="file25">github.com/bronlabs/bron-crypto/pkg/base/cgo/boring/bn.go (31.1%)</option>
				
				<option value="file26">github.com/bronlabs/bron-crypto/pkg/base/cgo/boring/bnctx.go (90.0%)</option>
				
				<option value="file27">github.com/bronlabs/bron-crypto/pkg/base/cgo/boring/bnmontctx.go (83.3%)</option>
				
				<option value="file28">github.com/bronlabs/bron-crypto/pkg/base/cgo/boring/dh.go (84.0%)</option>
				
				<option value="file29">github.com/bronlabs/bron-crypto/pkg/base/cgo/boring/glue.go (52.4%)</option>
				
				<option value="file30">github.com/bronlabs/bron-crypto/pkg/base/ct/bytes.go (92.0%)</option>
				
				<option value="file31">github.com/bronlabs/bron-crypto/pkg/base/ct/ct.go (100.0%)</option>
				
				<option value="file32">github.com/bronlabs/bron-crypto/pkg/base/ct/ints.go (97.6%)</option>
				
				<option value="file33">github.com/bronlabs/bron-crypto/pkg/base/ct/slices.go (100.0%)</option>
				
				<option value="file34">github.com/bronlabs/bron-crypto/pkg/base/curves/curve25519/cbor.go (0.0%)</option>
				
				<option value="file35">github.com/bronlabs/bron-crypto/pkg/base/curves/curve25519/curve.go (55.5%)</option>
				
				<option value="file36">github.com/bronlabs/bron-crypto/pkg/base/curves/curve25519/field.go (0.0%)</option>
				
				<option value="file37">github.com/bronlabs/bron-crypto/pkg/base/curves/curve25519/scalar.go (50.0%)</option>
				
				<option value="file38">github.com/bronlabs/bron-crypto/pkg/base/curves/curve25519/subgroup.go (0.0%)</option>
				
				<option value="file39">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/cbor.go (60.0%)</option>
				
				<option value="file40">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/curve.go (19.7%)</option>
				
				<option value="file41">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/field.go (13.8%)</option>
				
				<option value="file42">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl/fiat_fp.gen.go (91.9%)</option>
				
				<option value="file43">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl/fiat_fq.gen.go (21.9%)</option>
				
				<option value="file44">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl/fields.go (0.0%)</option>
				
				<option value="file45">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl/fp.go (75.3%)</option>
				
				<option value="file46">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl/fq.gen.go (10.5%)</option>
				
				<option value="file47">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl/params.go (78.6%)</option>
				
				<option value="file48">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/primecurve.go (0.0%)</option>
				
				<option value="file49">github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/scalar.go (9.3%)</option>
				
				<option value="file50">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points/edwards.go (0.0%)</option>
				
				<option value="file51">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points/testutils/json.go (0.0%)</option>
				
				<option value="file52">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points/weierstrass.go (0.0%)</option>
				
				<option value="file53">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/expander.go (0.0%)</option>
				
				<option value="file54">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/expanders/xmd.go (96.9%)</option>
				
				<option value="file55">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/expanders/xof.go (93.3%)</option>
				
				<option value="file56">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/h2f.go (0.0%)</option>
				
				<option value="file57">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/elligator2/curve25519.go (0.0%)</option>
				
				<option value="file58">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/elligator2/edwards25519.go (0.0%)</option>
				
				<option value="file59">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu/isogeny.go (0.0%)</option>
				
				<option value="file60">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu/nonzero.go (0.0%)</option>
				
				<option value="file61">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu/sqrt.go (0.0%)</option>
				
				<option value="file62">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu/sswu.go (0.0%)</option>
				
				<option value="file63">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu/zero.go (0.0%)</option>
				
				<option value="file64">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits/curve.go (0.0%)</option>
				
				<option value="file65">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits/finite_field.go (0.0%)</option>
				
				<option value="file66">github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits/prime_field.go (0.0%)</option>
				
				<option value="file67">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/cbor.go (80.0%)</option>
				
				<option value="file68">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/curve.go (27.1%)</option>
				
				<option value="file69">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/elliptic.go (7.5%)</option>
				
				<option value="file70">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/field.go (13.8%)</option>
				
				<option value="file71">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl/fiat_fp.gen.go (100.0%)</option>
				
				<option value="file72">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl/fiat_fq.gen.go (22.3%)</option>
				
				<option value="file73">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl/fields.go (0.0%)</option>
				
				<option value="file74">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl/fp.gen.go (68.6%)</option>
				
				<option value="file75">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl/fq.gen.go (10.5%)</option>
				
				<option value="file76">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl/params.go (88.6%)</option>
				
				<option value="file77">github.com/bronlabs/bron-crypto/pkg/base/curves/k256/scalar.go (21.9%)</option>
				
				<option value="file78">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/cbor.go (80.0%)</option>
				
				<option value="file79">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/curve.go (20.9%)</option>
				
				<option value="file80">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/field.go (21.2%)</option>
				
				<option value="file81">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl/fiat_fp.gen.go (100.0%)</option>
				
				<option value="file82">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl/fiat_fq.gen.go (22.5%)</option>
				
				<option value="file83">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl/fields.go (0.0%)</option>
				
				<option value="file84">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl/fp.gen.go (68.6%)</option>
				
				<option value="file85">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl/fq.gen.go (10.5%)</option>
				
				<option value="file86">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl/params.go (93.3%)</option>
				
				<option value="file87">github.com/bronlabs/bron-crypto/pkg/base/curves/p256/scalar.go (27.8%)</option>
				
				<option value="file88">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/bls12381.go (0.0%)</option>
				
				<option value="file89">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/cbor.go (80.0%)</option>
				
				<option value="file90">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/g1.go (19.1%)</option>
				
				<option value="file91">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/g1_field.go (13.8%)</option>
				
				<option value="file92">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/g2.go (23.3%)</option>
				
				<option value="file93">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/g2_field.go (36.4%)</option>
				
				<option value="file94">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/gt.go (0.0%)</option>
				
				<option value="file95">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/fiat_fp.gen.go (100.0%)</option>
				
				<option value="file96">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/fiat_fq.gen.go (22.0%)</option>
				
				<option value="file97">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/fields.go (76.5%)</option>
				
				<option value="file98">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/fp.gen.go (71.4%)</option>
				
				<option value="file99">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/fq.gen.go (10.5%)</option>
				
				<option value="file100">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/g1_params.go (97.9%)</option>
				
				<option value="file101">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/g2_params.go (98.3%)</option>
				
				<option value="file102">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/gt.go (69.4%)</option>
				
				<option value="file103">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl/pairings.go (97.3%)</option>
				
				<option value="file104">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/pairing.go (0.0%)</option>
				
				<option value="file105">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/scalar.go (13.8%)</option>
				
				<option value="file106">github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/pairable.go (0.0%)</option>
				
				<option value="file107">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/cbor.go (80.0%)</option>
				
				<option value="file108">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/elliptic.go (3.0%)</option>
				
				<option value="file109">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/fp.go (19.4%)</option>
				
				<option value="file110">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/fq.go (19.4%)</option>
				
				<option value="file111">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl/ep_params.go (90.0%)</option>
				
				<option value="file112">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl/eq_params.go (90.0%)</option>
				
				<option value="file113">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl/fiat_fp.gen.go (100.0%)</option>
				
				<option value="file114">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl/fiat_fq.gen.go (100.0%)</option>
				
				<option value="file115">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl/fields.go (0.0%)</option>
				
				<option value="file116">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl/fp.gen.go (68.6%)</option>
				
				<option value="file117">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl/fq.gen.go (68.6%)</option>
				
				<option value="file118">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/pallas.go (18.6%)</option>
				
				<option value="file119">github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/vesta.go (19.3%)</option>
				
				<option value="file120">github.com/bronlabs/bron-crypto/pkg/base/datastructures/bimap/concurrent.go (98.7%)</option>
				
				<option value="file121">github.com/bronlabs/bron-crypto/pkg/base/datastructures/bimap/immutable.go (100.0%)</option>
				
				<option value="file122">github.com/bronlabs/bron-crypto/pkg/base/datastructures/bimap/mutable.go (97.4%)</option>
				
				<option value="file123">github.com/bronlabs/bron-crypto/pkg/base/datastructures/datastructures.go (0.0%)</option>
				
				<option value="file124">github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap/comparable.go (88.8%)</option>
				
				<option value="file125">github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap/concurrent.go (98.7%)</option>
				
				<option value="file126">github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap/hashable.go (97.6%)</option>
				
				<option value="file127">github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset/comparable.go (95.4%)</option>
				
				<option value="file128">github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset/concurrent.go (95.5%)</option>
				
				<option value="file129">github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset/hashable.go (95.8%)</option>
				
				<option value="file130">github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset/immutable.go (90.0%)</option>
				
				<option value="file131">github.com/bronlabs/bron-crypto/pkg/base/errors.go (0.0%)</option>
				
				<option value="file132">github.com/bronlabs/bron-crypto/pkg/base/errs/codegen/error_functions/main.go (0.0%)</option>
				
				<option value="file133">github.com/bronlabs/bron-crypto/pkg/base/errs/codegen/known_errors/main.go (0.0%)</option>
				
				<option value="file134">github.com/bronlabs/bron-crypto/pkg/base/errs/error_functions.gen.go (0.0%)</option>
				
				<option value="file135">github.com/bronlabs/bron-crypto/pkg/base/errs/errors.go (0.0%)</option>
				
				<option value="file136">github.com/bronlabs/bron-crypto/pkg/base/errs2/errs.go (34.7%)</option>
				
				<option value="file137">github.com/bronlabs/bron-crypto/pkg/base/errs2/stackframe.go (100.0%)</option>
				
				<option value="file138">github.com/bronlabs/bron-crypto/pkg/base/errs2/utils.go (0.0%)</option>
				
				<option value="file139">github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal/infinite.go (94.7%)</option>
				
				<option value="file140">github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal/known.go (86.7%)</option>
				
				<option value="file141">github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal/unknown.go (94.1%)</option>
				
				<option value="file142">github.com/bronlabs/bron-crypto/pkg/base/nt/crt/crt.go (96.6%)</option>
				
				<option value="file143">github.com/bronlabs/bron-crypto/pkg/base/nt/crt/crt_multi.go (97.0%)</option>
				
				<option value="file144">github.com/bronlabs/bron-crypto/pkg/base/nt/modular/cbor.go (87.2%)</option>
				
				<option value="file145">github.com/bronlabs/bron-crypto/pkg/base/nt/modular/primes.go (99.1%)</option>
				
				<option value="file146">github.com/bronlabs/bron-crypto/pkg/base/nt/modular/squares.go (94.0%)</option>
				
				<option value="file147">github.com/bronlabs/bron-crypto/pkg/base/nt/modular/unknown.go (50.0%)</option>
				
				<option value="file148">github.com/bronlabs/bron-crypto/pkg/base/nt/nt.go (76.3%)</option>
				
				<option value="file149">github.com/bronlabs/bron-crypto/pkg/base/nt/num/cbor.go (82.9%)</option>
				
				<option value="file150">github.com/bronlabs/bron-crypto/pkg/base/nt/num/n.go (79.6%)</option>
				
				<option value="file151">github.com/bronlabs/bron-crypto/pkg/base/nt/num/nplus.go (93.7%)</option>
				
				<option value="file152">github.com/bronlabs/bron-crypto/pkg/base/nt/num/q.go (87.9%)</option>
				
				<option value="file153">github.com/bronlabs/bron-crypto/pkg/base/nt/num/z.go (91.2%)</option>
				
				<option value="file154">github.com/bronlabs/bron-crypto/pkg/base/nt/num/zn.go (87.3%)</option>
				
				<option value="file155">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/cbor.go (83.3%)</option>
				
				<option value="file156">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/int.go (87.1%)</option>
				
				<option value="file157">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/internal/euclidean_div.go (100.0%)</option>
				
				<option value="file158">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/internal/gcd.go (100.0%)</option>
				
				<option value="file159">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/modulus.go (92.4%)</option>
				
				<option value="file160">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/modulus_cgo.go (84.5%)</option>
				
				<option value="file161">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/nat.go (93.7%)</option>
				
				<option value="file162">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/nat_cgo.go (86.7%)</option>
				
				<option value="file163">github.com/bronlabs/bron-crypto/pkg/base/nt/numct/utils_cgo.go (77.8%)</option>
				
				<option value="file164">github.com/bronlabs/bron-crypto/pkg/base/nt/znstar/cbor.go (61.0%)</option>
				
				<option value="file165">github.com/bronlabs/bron-crypto/pkg/base/nt/znstar/group_trait.go (52.2%)</option>
				
				<option value="file166">github.com/bronlabs/bron-crypto/pkg/base/nt/znstar/paillier.go (69.0%)</option>
				
				<option value="file167">github.com/bronlabs/bron-crypto/pkg/base/nt/znstar/rsa.go (67.3%)</option>
				
				<option value="file168">github.com/bronlabs/bron-crypto/pkg/base/nt/znstar/unit_trait.go (46.9%)</option>
				
				<option value="file169">github.com/bronlabs/bron-crypto/pkg/base/order.go (91.5%)</option>
				
				<option value="file170">github.com/bronlabs/bron-crypto/pkg/base/polynomials/cbor.go (0.0%)</option>
				
				<option value="file171">github.com/bronlabs/bron-crypto/pkg/base/polynomials/interpolation/lagrange/lagrange.go (93.5%)</option>
				
				<option value="file172">github.com/bronlabs/bron-crypto/pkg/base/polynomials/polynomial.go (89.7%)</option>
				
				<option value="file173">github.com/bronlabs/bron-crypto/pkg/base/polynomials/polynomial_module.go (91.9%)</option>
				
				<option value="file174">github.com/bronlabs/bron-crypto/pkg/base/prng/csprng/fkechacha20/fkechacha20.go (71.4%)</option>
				
				<option value="file175">github.com/bronlabs/bron-crypto/pkg/base/prng/csprng/nist/nist.go (50.6%)</option>
				
				<option value="file176">github.com/bronlabs/bron-crypto/pkg/base/prng/csprng/nist/nist_ctrDRBG.go (82.0%)</option>
				
				<option value="file177">github.com/bronlabs/bron-crypto/pkg/base/prng/csprng/nist/testutils/nist_validation_utils.go (0.0%)</option>
				
				<option value="file178">github.com/bronlabs/bron-crypto/pkg/base/prng/csprng/rfc8937/rfc8937.go (73.9%)</option>
				
				<option value="file179">github.com/bronlabs/bron-crypto/pkg/base/prng/csprng/testutils/csprng.go (0.0%)</option>
				
				<option value="file180">github.com/bronlabs/bron-crypto/pkg/base/prng/csprng/threadsafe.go (0.0%)</option>
				
				<option value="file181">github.com/bronlabs/bron-crypto/pkg/base/prng/pcg/pcg.go (100.0%)</option>
				
				<option value="file182">github.com/bronlabs/bron-crypto/pkg/base/serde/serde.go (0.0%)</option>
				
				<option value="file183">github.com/bronlabs/bron-crypto/pkg/base/types.go (0.0%)</option>
				
				<option value="file184">github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils/algebrautils.go (95.5%)</option>
				
				<option value="file185">github.com/bronlabs/bron-crypto/pkg/base/utils/common.go (100.0%)</option>
				
				<option value="file186">github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils/iterutils.go (87.3%)</option>
				
				<option value="file187">github.com/bronlabs/bron-crypto/pkg/base/utils/maputils/maputils.go (100.0%)</option>
				
				<option value="file188">github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils/mathutils.go (20.0%)</option>
				
				<option value="file189">github.com/bronlabs/bron-crypto/pkg/base/utils/nocopy/nocopy.go (0.0%)</option>
				
				<option value="file190">github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils/combinations.go (90.9%)</option>
				
				<option value="file191">github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils/sliceutils.go (97.6%)</option>
				
				<option value="file192">github.com/bronlabs/bron-crypto/pkg/commitments/hash/hash.go (47.8%)</option>
				
				<option value="file193">github.com/bronlabs/bron-crypto/pkg/commitments/pedersen/commitment.go (66.7%)</option>
				
				<option value="file194">github.com/bronlabs/bron-crypto/pkg/commitments/pedersen/committer.go (95.0%)</option>
				
				<option value="file195">github.com/bronlabs/bron-crypto/pkg/commitments/pedersen/key.go (34.8%)</option>
				
				<option value="file196">github.com/bronlabs/bron-crypto/pkg/commitments/pedersen/message.go (58.6%)</option>
				
				<option value="file197">github.com/bronlabs/bron-crypto/pkg/commitments/pedersen/scheme.go (84.6%)</option>
				
				<option value="file198">github.com/bronlabs/bron-crypto/pkg/commitments/pedersen/witness.go (51.5%)</option>
				
				<option value="file199">github.com/bronlabs/bron-crypto/pkg/commitments/utils.go (0.0%)</option>
				
				<option value="file200">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/hpke.go (45.3%)</option>
				
				<option value="file201">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal/aead.go (76.9%)</option>
				
				<option value="file202">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal/cbor.go (88.6%)</option>
				
				<option value="file203">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal/kdf.go (81.6%)</option>
				
				<option value="file204">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal/kem.go (77.3%)</option>
				
				<option value="file205">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal/types.go (76.2%)</option>
				
				<option value="file206">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal/vectors.go (100.0%)</option>
				
				<option value="file207">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/kem.go (0.0%)</option>
				
				<option value="file208">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/participants.go (31.0%)</option>
				
				<option value="file209">github.com/bronlabs/bron-crypto/pkg/encryption/hpke/rfc.go (66.7%)</option>
				
				<option value="file210">github.com/bronlabs/bron-crypto/pkg/encryption/kemdem.go (0.0%)</option>
				
				<option value="file211">github.com/bronlabs/bron-crypto/pkg/encryption/paillier/cbor.go (90.7%)</option>
				
				<option value="file212">github.com/bronlabs/bron-crypto/pkg/encryption/paillier/ciphertexts.go (75.4%)</option>
				
				<option value="file213">github.com/bronlabs/bron-crypto/pkg/encryption/paillier/keys.go (73.1%)</option>
				
				<option value="file214">github.com/bronlabs/bron-crypto/pkg/encryption/paillier/nonces.go (28.1%)</option>
				
				<option value="file215">github.com/bronlabs/bron-crypto/pkg/encryption/paillier/paillier.go (74.2%)</option>
				
				<option value="file216">github.com/bronlabs/bron-crypto/pkg/encryption/paillier/participants.go (82.1%)</option>
				
				<option value="file217">github.com/bronlabs/bron-crypto/pkg/encryption/paillier/plaintexts.go (77.1%)</option>
				
				<option value="file218">github.com/bronlabs/bron-crypto/pkg/hashing/bip340/bip340.go (0.0%)</option>
				
				<option value="file219">github.com/bronlabs/bron-crypto/pkg/hashing/hash.go (0.0%)</option>
				
				<option value="file220">github.com/bronlabs/bron-crypto/pkg/hashing/kmac/kmac.go (86.0%)</option>
				
				<option value="file221">github.com/bronlabs/bron-crypto/pkg/hashing/poseidon/constants.go (75.0%)</option>
				
				<option value="file222">github.com/bronlabs/bron-crypto/pkg/hashing/poseidon/poseidon.go (75.6%)</option>
				
				<option value="file223">github.com/bronlabs/bron-crypto/pkg/key_agreement/cbor.go (90.0%)</option>
				
				<option value="file224">github.com/bronlabs/bron-crypto/pkg/key_agreement/dh/dhc/cbor.go (85.3%)</option>
				
				<option value="file225">github.com/bronlabs/bron-crypto/pkg/key_agreement/dh/dhc/dhc.go (74.7%)</option>
				
				<option value="file226">github.com/bronlabs/bron-crypto/pkg/key_agreement/key_agreement.go (80.8%)</option>
				
				<option value="file227">github.com/bronlabs/bron-crypto/pkg/network/echo/exchange.go (0.0%)</option>
				
				<option value="file228">github.com/bronlabs/bron-crypto/pkg/network/echo/participant.go (66.7%)</option>
				
				<option value="file229">github.com/bronlabs/bron-crypto/pkg/network/echo/rounds.go (89.8%)</option>
				
				<option value="file230">github.com/bronlabs/bron-crypto/pkg/network/echo/runner.go (0.0%)</option>
				
				<option value="file231">github.com/bronlabs/bron-crypto/pkg/network/exchange.go (0.0%)</option>
				
				<option value="file232">github.com/bronlabs/bron-crypto/pkg/network/exchange/exchange.go (0.0%)</option>
				
				<option value="file233">github.com/bronlabs/bron-crypto/pkg/network/network.go (0.0%)</option>
				
				<option value="file234">github.com/bronlabs/bron-crypto/pkg/network/router.go (0.0%)</option>
				
				<option value="file235">github.com/bronlabs/bron-crypto/pkg/network/testutils/cbor.go (0.0%)</option>
				
				<option value="file236">github.com/bronlabs/bron-crypto/pkg/network/testutils/coordinator.go (0.0%)</option>
				
				<option value="file237">github.com/bronlabs/bron-crypto/pkg/network/testutils/executor.go (0.0%)</option>
				
				<option value="file238">github.com/bronlabs/bron-crypto/pkg/network/testutils/testutils.go (0.0%)</option>
				
				<option value="file239">github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot/bbot.go (30.5%)</option>
				
				<option value="file240">github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot/ka.go (79.2%)</option>
				
				<option value="file241">github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot/participant.go (75.0%)</option>
				
				<option value="file242">github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot/popf.go (76.1%)</option>
				
				<option value="file243">github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot/rounds.go (77.5%)</option>
				
				<option value="file244">github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot/testutils/bbot.go (0.0%)</option>
				
				<option value="file245">github.com/bronlabs/bron-crypto/pkg/ot/base/vsot/messages.go (66.7%)</option>
				
				<option value="file246">github.com/bronlabs/bron-crypto/pkg/ot/base/vsot/participant.go (78.6%)</option>
				
				<option value="file247">github.com/bronlabs/bron-crypto/pkg/ot/base/vsot/rounds.go (77.0%)</option>
				
				<option value="file248">github.com/bronlabs/bron-crypto/pkg/ot/base/vsot/vsot.go (71.1%)</option>
				
				<option value="file249">github.com/bronlabs/bron-crypto/pkg/ot/bits.go (0.0%)</option>
				
				<option value="file250">github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken/gob.go (0.0%)</option>
				
				<option value="file251">github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken/messages.go (83.3%)</option>
				
				<option value="file252">github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken/participants.go (74.2%)</option>
				
				<option value="file253">github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken/rounds.go (83.5%)</option>
				
				<option value="file254">github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken/softspoken.go (18.8%)</option>
				
				<option value="file255">github.com/bronlabs/bron-crypto/pkg/ot/ot.go (0.0%)</option>
				
				<option value="file256">github.com/bronlabs/bron-crypto/pkg/proofs/dlog/batch_schnorr/protocol.go (46.9%)</option>
				
				<option value="file257">github.com/bronlabs/bron-crypto/pkg/proofs/dlog/dlog.go (0.0%)</option>
				
				<option value="file258">github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr/protocol.go (88.9%)</option>
				
				<option value="file259">github.com/bronlabs/bron-crypto/pkg/proofs/internal/meta/maurer09/protocol.go (0.0%)</option>
				
				<option value="file260">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lp/messages.go (60.0%)</option>
				
				<option value="file261">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lp/participants.go (63.6%)</option>
				
				<option value="file262">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lp/rounds.go (76.7%)</option>
				
				<option value="file263">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lp/utils.go (66.7%)</option>
				
				<option value="file264">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lpdl/messages.go (56.7%)</option>
				
				<option value="file265">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lpdl/participants.go (70.3%)</option>
				
				<option value="file266">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lpdl/rounds.go (70.7%)</option>
				
				<option value="file267">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/nthroot/protocol.go (94.4%)</option>
				
				<option value="file268">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/nthroot/verify.go (100.0%)</option>
				
				<option value="file269">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/pailliern/pailliern.go (78.9%)</option>
				
				<option value="file270">github.com/bronlabs/bron-crypto/pkg/proofs/paillier/range/range.go (85.6%)</option>
				
				<option value="file271">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/compiler.go (100.0%)</option>
				
				<option value="file272">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fiatshamir/fiat_shamir.go (79.2%)</option>
				
				<option value="file273">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fiatshamir/prover.go (75.0%)</option>
				
				<option value="file274">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fiatshamir/verifier.go (93.3%)</option>
				
				<option value="file275">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fischlin/fischlin.go (75.0%)</option>
				
				<option value="file276">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fischlin/params.go (40.0%)</option>
				
				<option value="file277">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fischlin/prover.go (85.7%)</option>
				
				<option value="file278">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fischlin/utils.go (90.9%)</option>
				
				<option value="file279">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fischlin/verifier.go (84.8%)</option>
				
				<option value="file280">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/randfischlin/fischlin.go (70.6%)</option>
				
				<option value="file281">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/randfischlin/prover.go (86.0%)</option>
				
				<option value="file282">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/randfischlin/utils.go (82.4%)</option>
				
				<option value="file283">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/randfischlin/verifier.go (90.0%)</option>
				
				<option value="file284">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/zk/common.go (75.0%)</option>
				
				<option value="file285">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/zk/prover.go (84.8%)</option>
				
				<option value="file286">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/zk/verifier.go (87.9%)</option>
				
				<option value="file287">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compose/sigand/and.go (64.1%)</option>
				
				<option value="file288">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compose/sigand/cartesian.go (62.2%)</option>
				
				<option value="file289">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compose/sigor/cartesian.go (66.0%)</option>
				
				<option value="file290">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compose/sigor/or.go (72.7%)</option>
				
				<option value="file291">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/prover.go (0.0%)</option>
				
				<option value="file292">github.com/bronlabs/bron-crypto/pkg/proofs/sigma/verifier.go (0.0%)</option>
				
				<option value="file293">github.com/bronlabs/bron-crypto/pkg/signatures/bip32.go (0.0%)</option>
				
				<option value="file294">github.com/bronlabs/bron-crypto/pkg/signatures/bls/bls.go (54.7%)</option>
				
				<option value="file295">github.com/bronlabs/bron-crypto/pkg/signatures/bls/core.go (62.5%)</option>
				
				<option value="file296">github.com/bronlabs/bron-crypto/pkg/signatures/bls/participants.go (65.1%)</option>
				
				<option value="file297">github.com/bronlabs/bron-crypto/pkg/signatures/bls/types.go (73.0%)</option>
				
				<option value="file298">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/ecdsa.go (38.5%)</option>
				
				<option value="file299">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/keygen.go (0.0%)</option>
				
				<option value="file300">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/pk.go (38.2%)</option>
				
				<option value="file301">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/scheme.go (60.0%)</option>
				
				<option value="file302">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/signature.go (39.3%)</option>
				
				<option value="file303">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/signer.go (71.8%)</option>
				
				<option value="file304">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/sk.go (40.9%)</option>
				
				<option value="file305">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/suite.go (61.1%)</option>
				
				<option value="file306">github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa/verifier.go (71.4%)</option>
				
				<option value="file307">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/bip340/bip340.go (65.0%)</option>
				
				<option value="file308">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/bip340/variant.go (45.6%)</option>
				
				<option value="file309">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/generic.go (0.0%)</option>
				
				<option value="file310">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/mina/encoding.go (84.6%)</option>
				
				<option value="file311">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/mina/mina.go (65.0%)</option>
				
				<option value="file312">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/mina/prefix.go (94.8%)</option>
				
				<option value="file313">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/mina/roinput.go (98.2%)</option>
				
				<option value="file314">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/mina/tx.go (94.3%)</option>
				
				<option value="file315">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/mina/variant.go (91.7%)</option>
				
				<option value="file316">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/schnorr/schnorr.go (42.7%)</option>
				
				<option value="file317">github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike/schnorrlike.go (0.0%)</option>
				
				<option value="file318">github.com/bronlabs/bron-crypto/pkg/signatures/traits.go (0.0%)</option>
				
				<option value="file319">github.com/bronlabs/bron-crypto/pkg/threshold/aor/participant.go (78.6%)</option>
				
				<option value="file320">github.com/bronlabs/bron-crypto/pkg/threshold/aor/rounds.go (81.2%)</option>
				
				<option value="file321">github.com/bronlabs/bron-crypto/pkg/threshold/aor/runner.go (70.0%)</option>
				
				<option value="file322">github.com/bronlabs/bron-crypto/pkg/threshold/aor/testutils/utils.go (0.0%)</option>
				
				<option value="file323">github.com/bronlabs/bron-crypto/pkg/threshold/aor/utils.go (76.5%)</option>
				
				<option value="file324">github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro/participant.go (75.4%)</option>
				
				<option value="file325">github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro/rounds.go (82.8%)</option>
				
				<option value="file326">github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro/runner.go (70.0%)</option>
				
				<option value="file327">github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro/testutils/testutils.go (0.0%)</option>
				
				<option value="file328">github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro/utils.go (70.0%)</option>
				
				<option value="file329">github.com/bronlabs/bron-crypto/pkg/threshold/recovery/mislayer.go (77.8%)</option>
				
				<option value="file330">github.com/bronlabs/bron-crypto/pkg/threshold/recovery/recoverer.go (80.0%)</option>
				
				<option value="file331">github.com/bronlabs/bron-crypto/pkg/threshold/recovery/rounds.go (81.9%)</option>
				
				<option value="file332">github.com/bronlabs/bron-crypto/pkg/threshold/refresh/participant.go (80.0%)</option>
				
				<option value="file333">github.com/bronlabs/bron-crypto/pkg/threshold/refresh/rounds.go (80.0%)</option>
				
				<option value="file334">github.com/bronlabs/bron-crypto/pkg/threshold/rvole/bbot/mul.go (66.7%)</option>
				
				<option value="file335">github.com/bronlabs/bron-crypto/pkg/threshold/rvole/bbot/participant.go (76.1%)</option>
				
				<option value="file336">github.com/bronlabs/bron-crypto/pkg/threshold/rvole/bbot/rounds.go (87.7%)</option>
				
				<option value="file337">github.com/bronlabs/bron-crypto/pkg/threshold/rvole/softspoken/messages.go (61.1%)</option>
				
				<option value="file338">github.com/bronlabs/bron-crypto/pkg/threshold/rvole/softspoken/mul.go (71.4%)</option>
				
				<option value="file339">github.com/bronlabs/bron-crypto/pkg/threshold/rvole/softspoken/participant.go (75.0%)</option>
				
				<option value="file340">github.com/bronlabs/bron-crypto/pkg/threshold/rvole/softspoken/rounds.go (87.3%)</option>
				
				<option value="file341">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/additive/additive.go (94.3%)</option>
				
				<option value="file342">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman/output.go (66.7%)</option>
				
				<option value="file343">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman/scheme.go (89.5%)</option>
				
				<option value="file344">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman/secret.go (100.0%)</option>
				
				<option value="file345">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman/share.go (59.1%)</option>
				
				<option value="file346">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/linear.go (0.0%)</option>
				
				<option value="file347">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/pedersen/dealer_func.go (77.8%)</option>
				
				<option value="file348">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/pedersen/output.go (66.7%)</option>
				
				<option value="file349">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/pedersen/scheme.go (89.8%)</option>
				
				<option value="file350">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/pedersen/secret.go (100.0%)</option>
				
				<option value="file351">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/pedersen/share.go (63.5%)</option>
				
				<option value="file352">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir/output.go (100.0%)</option>
				
				<option value="file353">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir/scheme.go (81.5%)</option>
				
				<option value="file354">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir/secret.go (66.7%)</option>
				
				<option value="file355">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir/shamir.go (84.6%)</option>
				
				<option value="file356">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir/share.go (53.2%)</option>
				
				<option value="file357">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/threshold.go (0.0%)</option>
				
				<option value="file358">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/utils.go (0.0%)</option>
				
				<option value="file359">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/hjky/participant.go (77.8%)</option>
				
				<option value="file360">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/hjky/rounds.go (83.0%)</option>
				
				<option value="file361">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs/sampler.go (87.0%)</option>
				
				<option value="file362">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs/setup/messages.go (0.0%)</option>
				
				<option value="file363">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs/setup/participant.go (83.3%)</option>
				
				<option value="file364">github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs/setup/rounds.go (84.4%)</option>
				
				<option value="file365">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/base_shard.go (0.0%)</option>
				
				<option value="file366">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02/boldyreva02.go (0.0%)</option>
				
				<option value="file367">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02/keygen/keygen.go (0.0%)</option>
				
				<option value="file368">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02/signing/aggregator.go (73.2%)</option>
				
				<option value="file369">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02/signing/participant.go (78.8%)</option>
				
				<option value="file370">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02/testutils/testutils.go (0.0%)</option>
				
				<option value="file371">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/tbls.go (0.0%)</option>
				
				<option value="file372">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/dkls23.go (0.0%)</option>
				
				<option value="file373">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg/participant.go (83.3%)</option>
				
				<option value="file374">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg/rounds.go (81.4%)</option>
				
				<option value="file375">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg/testutils/dkg.go (0.0%)</option>
				
				<option value="file376">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg/utils.go (75.8%)</option>
				
				<option value="file377">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/trusted_dealer/dealer.go (83.9%)</option>
				
				<option value="file378">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/shard.go (0.0%)</option>
				
				<option value="file379">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign/participant.go (78.4%)</option>
				
				<option value="file380">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign/rounds.go (78.4%)</option>
				
				<option value="file381">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign/testutils/sign.go (0.0%)</option>
				
				<option value="file382">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign/utils.go (75.8%)</option>
				
				<option value="file383">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_bbot/participant.go (76.3%)</option>
				
				<option value="file384">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_bbot/rounds.go (78.0%)</option>
				
				<option value="file385">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_bbot/testutils/sign.go (0.0%)</option>
				
				<option value="file386">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_bbot/utils.go (77.3%)</option>
				
				<option value="file387">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_softspoken/participant.go (78.6%)</option>
				
				<option value="file388">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_softspoken/rounds.go (77.0%)</option>
				
				<option value="file389">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_softspoken/testutils/sign.go (0.0%)</option>
				
				<option value="file390">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_softspoken/utils.go (77.3%)</option>
				
				<option value="file391">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/decompose.go (0.0%)</option>
				
				<option value="file392">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/keygen/dkg/participant.go (70.4%)</option>
				
				<option value="file393">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/keygen/dkg/round.go (77.1%)</option>
				
				<option value="file394">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/keygen/dkg/testutils/dkg.go (0.0%)</option>
				
				<option value="file395">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/keygen/trusted_dealer/trusted_dealer.go (0.0%)</option>
				
				<option value="file396">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/lindell17.go (0.0%)</option>
				
				<option value="file397">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/shard.go (0.0%)</option>
				
				<option value="file398">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/signing/participant.go (67.4%)</option>
				
				<option value="file399">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/signing/rounds.go (72.9%)</option>
				
				<option value="file400">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/signing/signing.go (71.4%)</option>
				
				<option value="file401">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/tecdsa.go (0.0%)</option>
				
				<option value="file402">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22/keygen/keygen.go (0.0%)</option>
				
				<option value="file403">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22/lindell22.go (0.0%)</option>
				
				<option value="file404">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22/signing/aggregator.go (68.3%)</option>
				
				<option value="file405">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22/signing/participant.go (54.7%)</option>
				
				<option value="file406">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22/signing/rounds.go (80.4%)</option>
				
				<option value="file407">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22/testutils/testutils.go (0.0%)</option>
				
				<option value="file408">github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/tschnorr.go (0.0%)</option>
				
				<option value="file409">github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid/hagrid.go (0.0%)</option>
				
				<option value="file410">github.com/bronlabs/bron-crypto/pkg/transcripts/testutils/utils.go (0.0%)</option>
				
				<option value="file411">github.com/bronlabs/bron-crypto/pkg/transcripts/utils.go (0.0%)</option>
				
				<option value="file412">github.com/bronlabs/bron-crypto/thirdparty/golang/crypto/chacha20/chacha_arm64.go (0.0%)</option>
				
				<option value="file413">github.com/bronlabs/bron-crypto/thirdparty/golang/crypto/chacha20/chacha_generic.go (0.0%)</option>
				
				<option value="file414">github.com/bronlabs/bron-crypto/thirdparty/golang/crypto/chacha20/custom.go (0.0%)</option>
				
				<option value="file415">github.com/bronlabs/bron-crypto/thirdparty/golang/crypto/chacha20/xor.go (0.0%)</option>
				
				<option value="file416">github.com/bronlabs/bron-crypto/thirdparty/golang/crypto/internal/alias/alias.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package algebra

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra/crtp"
)

type (
        Element[E any]         = crtp.Element[E]
        Structure[E any]       = crtp.Structure[E]
        FiniteStructure[E any] = crtp.FiniteStructure[E]
        Quotient[E, M, A any]  = crtp.Quotient[E, M, A]
        Residue[E, M any]      = crtp.Residue[E, M]
)

func StructureIs[S crtp.Structure[E], E any](s Structure[E]) bool <span class="cov0" title="0">{
        _, ok := s.(S)
        return ok
}</span>

func StructureAs[S crtp.Structure[E], E any](s Structure[E]) (S, error) <span class="cov0" title="0">{
        out, ok := s.(S)
        if !ok </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidType.WithMessage("structure does not implement the expected type")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func StructureMustBeAs[S crtp.Structure[E], E any](s Structure[E]) S <span class="cov0" title="0">{
        out, err := StructureAs[S](s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package fields

import (
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

type CubicFieldExtensionArithmetic[BF impl.FiniteFieldElementLowLevel[BF]] interface {
        MulByCubicNonResidue(out BF, in BF)
        RootOfUnity(out BF)
        ProgenitorExponent() []uint8
        E() uint64
}

type CubicFieldExtensionImpl[BFP interface {
        *BF
        impl.FiniteFieldElementLowLevel[BFP]
}, A CubicFieldExtensionArithmetic[BFP], BF any] struct {
        U0 BF
        U1 BF
        U2 BF
}

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Set(v *CubicFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Set(&amp;v.U0)
        BFP(&amp;f.U1).Set(&amp;v.U1)
        BFP(&amp;f.U2).Set(&amp;v.U2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) SetZero() <span class="cov8" title="1">{
        BFP(&amp;f.U0).SetZero()
        BFP(&amp;f.U1).SetZero()
        BFP(&amp;f.U2).SetZero()
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) SetOne() <span class="cov8" title="1">{
        BFP(&amp;f.U0).SetOne()
        BFP(&amp;f.U1).SetZero()
        BFP(&amp;f.U2).SetZero()
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) SetBytes(data []byte) (ok ct.Bool) <span class="cov0" title="0">{
        componentsLen := len(data) / 3
        ok0 := BFP(&amp;f.U0).SetBytes(data[:componentsLen])
        ok1 := BFP(&amp;f.U1).SetBytes(data[componentsLen : 2*componentsLen])
        ok2 := BFP(&amp;f.U2).SetBytes(data[2*componentsLen:])
        return ok0 &amp; ok1 &amp; ok2
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(BFP(&amp;f.U0).Bytes(), BFP(&amp;f.U1).Bytes(), BFP(&amp;f.U2).Bytes())
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) SetUniformBytes(data ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        componentsLen := len(data) / 3
        ok0 := BFP(&amp;f.U0).SetUniformBytes(data[:componentsLen]...)
        ok1 := BFP(&amp;f.U1).SetUniformBytes(data[componentsLen : 2*componentsLen]...)
        ok2 := BFP(&amp;f.U2).SetUniformBytes(data[2*componentsLen:]...)
        return ok0 &amp; ok1 &amp; ok2
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        ok0 := BFP(&amp;f.U0).SetRandom(prng)
        ok1 := BFP(&amp;f.U1).SetRandom(prng)
        ok2 := BFP(&amp;f.U2).SetRandom(prng)
        return ok0 &amp; ok1 &amp; ok2
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Select(choice ct.Choice, z, nz *CubicFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Select(choice, &amp;z.U0, &amp;nz.U0)
        BFP(&amp;f.U1).Select(choice, &amp;z.U1, &amp;nz.U1)
        BFP(&amp;f.U2).Select(choice, &amp;z.U2, &amp;nz.U2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Add(lhs, rhs *CubicFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Add(&amp;lhs.U0, &amp;rhs.U0)
        BFP(&amp;f.U1).Add(&amp;lhs.U1, &amp;rhs.U1)
        BFP(&amp;f.U2).Add(&amp;lhs.U2, &amp;rhs.U2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Double(v *CubicFieldExtensionImpl[BFP, A, BF]) <span class="cov0" title="0">{
        BFP(&amp;f.U0).Double(&amp;v.U0)
        BFP(&amp;f.U1).Double(&amp;v.U1)
        BFP(&amp;f.U2).Double(&amp;v.U2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Sub(lhs, rhs *CubicFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Sub(&amp;lhs.U0, &amp;rhs.U0)
        BFP(&amp;f.U1).Sub(&amp;lhs.U1, &amp;rhs.U1)
        BFP(&amp;f.U2).Sub(&amp;lhs.U2, &amp;rhs.U2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Neg(v *CubicFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Neg(&amp;v.U0)
        BFP(&amp;f.U1).Neg(&amp;v.U1)
        BFP(&amp;f.U2).Neg(&amp;v.U2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Mul(lhs, rhs *CubicFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        var arith A
        var v0, v1, v2 BF
        var a0PlusA1, a0PlusA2, a1PlusA2 BF
        var c0, c1, c2 BF

        // v0 = a0*b0, v1 = a1*b1, v2 = a2*b2
        BFP(&amp;v0).Mul(&amp;lhs.U0, &amp;rhs.U0)
        BFP(&amp;v1).Mul(&amp;lhs.U1, &amp;rhs.U1)
        BFP(&amp;v2).Mul(&amp;lhs.U2, &amp;rhs.U2)
        BFP(&amp;a0PlusA1).Add(&amp;lhs.U0, &amp;lhs.U1)
        BFP(&amp;a0PlusA2).Add(&amp;lhs.U0, &amp;lhs.U2)
        BFP(&amp;a1PlusA2).Add(&amp;lhs.U1, &amp;lhs.U2)

        BFP(&amp;c2).Add(&amp;rhs.U0, &amp;rhs.U2)
        BFP(&amp;c2).Mul(&amp;c2, &amp;a0PlusA2)
        BFP(&amp;c2).Sub(&amp;c2, &amp;v0)
        BFP(&amp;c2).Add(&amp;c2, &amp;v1)
        BFP(&amp;c2).Sub(&amp;c2, &amp;v2)

        BFP(&amp;c0).Add(&amp;rhs.U1, &amp;rhs.U2)
        BFP(&amp;c0).Mul(&amp;c0, &amp;a1PlusA2)
        BFP(&amp;c0).Sub(&amp;c0, &amp;v1)
        BFP(&amp;c0).Sub(&amp;c0, &amp;v2)
        arith.MulByCubicNonResidue(&amp;c0, &amp;c0)
        BFP(&amp;c0).Add(&amp;c0, &amp;v0)

        arith.MulByCubicNonResidue(&amp;v2, &amp;v2)
        BFP(&amp;c1).Add(&amp;rhs.U0, &amp;rhs.U1)
        BFP(&amp;c1).Mul(&amp;c1, &amp;a0PlusA1)
        BFP(&amp;c1).Sub(&amp;c1, &amp;v0)
        BFP(&amp;c1).Sub(&amp;c1, &amp;v1)
        BFP(&amp;c1).Add(&amp;c1, &amp;v2)

        BFP(&amp;f.U0).Set(&amp;c0)
        BFP(&amp;f.U1).Set(&amp;c1)
        BFP(&amp;f.U2).Set(&amp;c2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Square(v *CubicFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        var arith A
        var v0, v1, v2 BF
        var c0, c1, c2 BF

        BFP(&amp;v0).Square(&amp;v.U0)
        BFP(&amp;v1).Square(&amp;v.U1)
        BFP(&amp;v2).Square(&amp;v.U2)

        BFP(&amp;c2).Add(&amp;v.U0, &amp;v.U2)
        BFP(&amp;c2).Square(&amp;c2)
        BFP(&amp;c2).Sub(&amp;c2, &amp;v0)
        BFP(&amp;c2).Add(&amp;c2, &amp;v1)
        BFP(&amp;c2).Sub(&amp;c2, &amp;v2)

        BFP(&amp;c0).Add(&amp;v.U1, &amp;v.U2)
        BFP(&amp;c0).Square(&amp;c0)
        BFP(&amp;c0).Sub(&amp;c0, &amp;v1)
        BFP(&amp;c0).Sub(&amp;c0, &amp;v2)
        arith.MulByCubicNonResidue(&amp;c0, &amp;c0)
        BFP(&amp;c0).Add(&amp;c0, &amp;v0)

        BFP(&amp;c1).Add(&amp;v.U0, &amp;v.U1)
        BFP(&amp;c1).Square(&amp;c1)
        BFP(&amp;c1).Sub(&amp;c1, &amp;v0)
        BFP(&amp;c1).Sub(&amp;c1, &amp;v1)
        arith.MulByCubicNonResidue(&amp;v2, &amp;v2)
        BFP(&amp;c1).Add(&amp;c1, &amp;v2)

        BFP(&amp;f.U0).Set(&amp;c0)
        BFP(&amp;f.U1).Set(&amp;c1)
        BFP(&amp;f.U2).Set(&amp;c2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Inv(arg *CubicFieldExtensionImpl[BFP, A, BF]) (ok ct.Bool) <span class="cov8" title="1">{
        var arith A
        var a, b, c, s, t BF

        // a' = a^2 - (b * c) * beta
        BFP(&amp;a).Mul(&amp;arg.U1, &amp;arg.U2)
        arith.MulByCubicNonResidue(&amp;a, &amp;a)
        BFP(&amp;t).Square(&amp;arg.U0)
        BFP(&amp;a).Sub(&amp;t, &amp;a)

        // b' = c^2 * beta - (a * b)
        BFP(&amp;b).Square(&amp;arg.U2)
        arith.MulByCubicNonResidue(&amp;b, &amp;b)
        BFP(&amp;t).Mul(&amp;arg.U0, &amp;arg.U1)
        BFP(&amp;b).Sub(&amp;b, &amp;t)

        // c' = b^2 - (a * c)
        BFP(&amp;c).Square(&amp;arg.U1)
        BFP(&amp;t).Mul(&amp;arg.U0, &amp;arg.U2)
        BFP(&amp;c).Sub(&amp;c, &amp;t)

        // t = ((b * c') + (c * b')) * beta + (a * a')
        BFP(&amp;s).Mul(&amp;arg.U1, &amp;c)
        BFP(&amp;t).Mul(&amp;arg.U2, &amp;b)
        BFP(&amp;s).Add(&amp;s, &amp;t)
        arith.MulByCubicNonResidue(&amp;s, &amp;s)
        BFP(&amp;t).Mul(&amp;arg.U0, &amp;a)
        BFP(&amp;s).Add(&amp;s, &amp;t)
        ok = BFP(&amp;t).Inv(&amp;s)

        if ok == 1 </span><span class="cov8" title="1">{
                var sanityCheck BF
                BFP(&amp;sanityCheck).Mul(&amp;t, &amp;s)
                if BFP(&amp;sanityCheck).IsOne() != 1 </span><span class="cov0" title="0">{
                        panic("sanity check failed")</span>
                }
        }

        // c0 = a' * t^-1
        <span class="cov8" title="1">var c0, c1, c2 BF
        BFP(&amp;c0).Mul(&amp;a, &amp;t)
        // c1 = b' * t^-1
        BFP(&amp;c1).Mul(&amp;b, &amp;t)
        // c2 = c' * t^-1
        BFP(&amp;c2).Mul(&amp;c, &amp;t)

        BFP(&amp;f.U0).Select(ok, &amp;f.U0, &amp;c0)
        BFP(&amp;f.U1).Select(ok, &amp;f.U1, &amp;c1)
        BFP(&amp;f.U2).Select(ok, &amp;f.U2, &amp;c2)

        // if ok == 1 {
        //        var sanityCheck CubicFieldExtensionImpl[BFPtr, A, BF]
        //        sanityCheck.Mul(f, arg)
        //        if sanityCheck.IsOne() != 1 {
        //                panic("sanity check failed")
        //        }
        //}

        return ok</span>
}

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Div(lhs, rhs *CubicFieldExtensionImpl[BFP, A, BF]) (ok ct.Bool) <span class="cov8" title="1">{
        var rhsInv, result CubicFieldExtensionImpl[BFP, A, BF]
        ok = rhsInv.Inv(rhs)
        result.Mul(lhs, &amp;rhsInv)

        f.Select(ok, f, &amp;result)
        return ok
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Sqrt(v *CubicFieldExtensionImpl[BFP, A, BF]) (ok ct.Bool) <span class="cov8" title="1">{
        var arith A
        var rootOfUnity CubicFieldExtensionImpl[BFP, A, BF]
        rootOfUnity.SetZero()
        arith.RootOfUnity(&amp;rootOfUnity.U0)

        ok = TonelliShanks(f, v, &amp;rootOfUnity, arith.E(), arith.ProgenitorExponent())
        return ok
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) IsNonZero() ct.Bool <span class="cov0" title="0">{
        return BFP(&amp;f.U0).IsNonZero() | BFP(&amp;f.U1).IsNonZero() | BFP(&amp;f.U2).IsNonZero()
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) IsZero() ct.Bool <span class="cov8" title="1">{
        return BFP(&amp;f.U0).IsZero() &amp; BFP(&amp;f.U1).IsZero() &amp; BFP(&amp;f.U2).IsZero()
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) IsOne() ct.Bool <span class="cov8" title="1">{
        return BFP(&amp;f.U0).IsOne() &amp; BFP(&amp;f.U1).IsZero() &amp; BFP(&amp;f.U2).IsZero()
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) Equal(rhs *CubicFieldExtensionImpl[BFP, A, BF]) ct.Bool <span class="cov8" title="1">{
        return BFP(&amp;f.U0).Equal(&amp;rhs.U0) &amp; BFP(&amp;f.U1).Equal(&amp;rhs.U1) &amp; BFP(&amp;f.U2).Equal(&amp;rhs.U2)
}</span>

func (f *CubicFieldExtensionImpl[BFP, A, BF]) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return slices.Concat(BFP(&amp;f.U0).ComponentsBytes(), BFP(&amp;f.U1).ComponentsBytes(), BFP(&amp;f.U2).ComponentsBytes())
}</span>

func (*CubicFieldExtensionImpl[BFP, A, BF]) ToHex() string <span class="cov0" title="0">{
        panic("implement me")</span>
}

func (*CubicFieldExtensionImpl[BFP, A, BF]) Degree() uint64 <span class="cov0" title="0">{
        return BFP(nil).Degree() * 3
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package fields

import (
        "golang.org/x/exp/constraints"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func IsNegative[FP impl.PrimeFieldElementPtrLowLevel[FP, F], F any](v *F) (neg ct.Bool) <span class="cov0" title="0">{
        var vNeg F
        FP(&amp;vNeg).Neg(v)
        _, _, gt := SliceCmpLE(FP(v).Limbs(), FP(&amp;vNeg).Limbs())
        return gt
}</span>

func IsOdd[FP impl.PrimeFieldElementPtrLowLevel[FP, F], F any](v *F) (odd ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(FP(v).Bytes()[0] &amp; 0b1)
}</span>

func Degree[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any]() uint64 <span class="cov0" title="0">{
        return FP(nil).Degree()
}</span>

// the slice is little-endian limb-like representation.
func SliceCmpLE[S ~[]E, E constraints.Unsigned](x, y S) (lt, eq, gt ct.Bool) <span class="cov0" title="0">{
        if len(x) != len(y) </span><span class="cov0" title="0">{
                panic("ct: slices have different lengths")</span>
        }

        <span class="cov0" title="0">gt = 0
        lt = 0
        eq = 1

        for i := len(x) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                isGt := ct.Greater(x[i], y[i])
                isLt := ct.Less(x[i], y[i])
                isEq := ct.Equal(x[i], y[i])

                // mask propagation to preserve first significant comparison
                gt |= isGt &amp; ^lt
                lt |= isLt &amp; ^gt
                eq &amp;= isEq
        }</span>
        <span class="cov0" title="0">return lt, eq, gt</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package fields

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func Pow[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any](result, base *F, exp []uint8) <span class="cov8" title="1">{
        var tmp, res F
        FP(&amp;res).SetOne()

        for i := len(exp) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                FP(&amp;res).Square(&amp;res)
                FP(&amp;tmp).Mul(&amp;res, base)
                FP(&amp;res).Select(ct.Choice((exp[i]&gt;&gt;7)&amp;1), &amp;res, &amp;tmp)
                FP(&amp;res).Square(&amp;res)
                FP(&amp;tmp).Mul(&amp;res, base)
                FP(&amp;res).Select(ct.Choice((exp[i]&gt;&gt;6)&amp;1), &amp;res, &amp;tmp)
                FP(&amp;res).Square(&amp;res)
                FP(&amp;tmp).Mul(&amp;res, base)
                FP(&amp;res).Select(ct.Choice((exp[i]&gt;&gt;5)&amp;1), &amp;res, &amp;tmp)
                FP(&amp;res).Square(&amp;res)
                FP(&amp;tmp).Mul(&amp;res, base)
                FP(&amp;res).Select(ct.Choice((exp[i]&gt;&gt;4)&amp;1), &amp;res, &amp;tmp)
                FP(&amp;res).Square(&amp;res)
                FP(&amp;tmp).Mul(&amp;res, base)
                FP(&amp;res).Select(ct.Choice((exp[i]&gt;&gt;3)&amp;1), &amp;res, &amp;tmp)
                FP(&amp;res).Square(&amp;res)
                FP(&amp;tmp).Mul(&amp;res, base)
                FP(&amp;res).Select(ct.Choice((exp[i]&gt;&gt;2)&amp;1), &amp;res, &amp;tmp)
                FP(&amp;res).Square(&amp;res)
                FP(&amp;tmp).Mul(&amp;res, base)
                FP(&amp;res).Select(ct.Choice((exp[i]&gt;&gt;1)&amp;1), &amp;res, &amp;tmp)
                FP(&amp;res).Square(&amp;res)
                FP(&amp;tmp).Mul(&amp;res, base)
                FP(&amp;res).Select(ct.Choice((exp[i]&gt;&gt;0)&amp;1), &amp;res, &amp;tmp)
        }</span>

        <span class="cov8" title="1">FP(result).Set(&amp;res)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package fields

import (
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

type QuadraticFieldExtensionArithmetic[BFP impl.FiniteFieldElementLowLevel[BFP]] interface {
        MulByQuadraticNonResidue(out BFP, in BFP)
}

type QuadraticFieldExtensionImpl[BFP impl.FiniteFieldElementPtrLowLevel[BFP, BF], A QuadraticFieldExtensionArithmetic[BFP], BF any] struct {
        U0 BF
        U1 BF
}

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Set(v *QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Set(&amp;v.U0)
        BFP(&amp;f.U1).Set(&amp;v.U1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) SetZero() <span class="cov8" title="1">{
        BFP(&amp;f.U0).SetZero()
        BFP(&amp;f.U1).SetZero()
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) SetOne() <span class="cov8" title="1">{
        BFP(&amp;f.U0).SetOne()
        BFP(&amp;f.U1).SetZero()
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) SetBytes(data []byte) (ok ct.Bool) <span class="cov0" title="0">{
        componentsLen := len(data) / 2
        ok0 := BFP(&amp;f.U0).SetBytes(data[:componentsLen])
        ok1 := BFP(&amp;f.U1).SetBytes(data[componentsLen:])
        return ok0 &amp; ok1
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(BFP(&amp;f.U0).Bytes(), BFP(&amp;f.U1).Bytes())
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        componentsDataLen := len(componentsData) / 2
        l := componentsData[:componentsDataLen]
        h := componentsData[componentsDataLen:]
        okl := BFP(&amp;f.U0).SetUniformBytes(l...)
        okh := BFP(&amp;f.U1).SetUniformBytes(h...)
        return okl &amp; okh
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        ok0 := BFP(&amp;f.U0).SetRandom(prng)
        ok1 := BFP(&amp;f.U1).SetRandom(prng)
        return ok0 &amp; ok1
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Select(choice ct.Choice, z, nz *QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Select(choice, &amp;z.U0, &amp;nz.U0)
        BFP(&amp;f.U1).Select(choice, &amp;z.U1, &amp;nz.U1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Add(lhs, rhs *QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Add(&amp;lhs.U0, &amp;rhs.U0)
        BFP(&amp;f.U1).Add(&amp;lhs.U1, &amp;rhs.U1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Double(v *QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov0" title="0">{
        BFP(&amp;f.U0).Double(&amp;v.U0)
        BFP(&amp;f.U1).Double(&amp;v.U1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Sub(lhs, rhs *QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Sub(&amp;lhs.U0, &amp;rhs.U0)
        BFP(&amp;f.U1).Sub(&amp;lhs.U1, &amp;rhs.U1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Neg(v *QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Neg(&amp;v.U0)
        BFP(&amp;f.U1).Neg(&amp;v.U1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Mul(lhs, rhs *QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        var arith A
        var v0, v1 BF
        var c0, c1 BF

        // v0 = a0*b0, v1 = b1*v1
        BFP(&amp;v0).Mul(&amp;lhs.U0, &amp;rhs.U0)
        BFP(&amp;v1).Mul(&amp;lhs.U1, &amp;rhs.U1)

        // c0 = v0 + beta * v1
        arith.MulByQuadraticNonResidue(&amp;c0, &amp;v1)
        BFP(&amp;c0).Add(&amp;c0, &amp;v0)

        // c1 = (a0 + a1)(b0 + b1) - v0 - v1
        var a0PlusA1 BF
        BFP(&amp;a0PlusA1).Add(&amp;lhs.U0, &amp;lhs.U1)
        BFP(&amp;c1).Add(&amp;rhs.U0, &amp;rhs.U1)
        BFP(&amp;c1).Mul(&amp;c1, &amp;a0PlusA1)
        BFP(&amp;c1).Sub(&amp;c1, &amp;v0)
        BFP(&amp;c1).Sub(&amp;c1, &amp;v1)

        BFP(&amp;f.U0).Set(&amp;c0)
        BFP(&amp;f.U1).Set(&amp;c1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Square(v *QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        var arith A
        var v0 BF
        var c0, c1 BF
        BFP(&amp;v0).Mul(&amp;v.U0, &amp;v.U1)

        // c1 = 2v0
        BFP(&amp;c1).Add(&amp;v0, &amp;v0)

        // c0 = (a0 + a1)(a0 + beta * a1) - v0 - beta * v0
        var a0PlusA1 BF
        BFP(&amp;a0PlusA1).Add(&amp;v.U0, &amp;v.U1)
        arith.MulByQuadraticNonResidue(&amp;c0, &amp;v.U1)
        BFP(&amp;c0).Add(&amp;c0, &amp;v.U0)
        BFP(&amp;c0).Mul(&amp;c0, &amp;a0PlusA1)
        BFP(&amp;c0).Sub(&amp;c0, &amp;v0)
        arith.MulByQuadraticNonResidue(&amp;v0, &amp;v0)
        BFP(&amp;c0).Sub(&amp;c0, &amp;v0)

        BFP(&amp;f.U0).Set(&amp;c0)
        BFP(&amp;f.U1).Set(&amp;c1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Inv(v *QuadraticFieldExtensionImpl[BFP, A, BF]) (ok ct.Bool) <span class="cov8" title="1">{
        var arith A
        var betaA1Squared BF
        BFP(&amp;betaA1Squared).Square(&amp;v.U1)
        arith.MulByQuadraticNonResidue(&amp;betaA1Squared, &amp;betaA1Squared)

        var nom, den BF
        BFP(&amp;nom).Square(&amp;v.U0)
        BFP(&amp;nom).Sub(&amp;nom, &amp;betaA1Squared)
        ok = BFP(&amp;den).Inv(&amp;nom)

        if ok == 1 </span><span class="cov8" title="1">{
                var sanityCheck BF
                BFP(&amp;sanityCheck).Mul(&amp;den, &amp;nom)
                if BFP(&amp;sanityCheck).IsOne() != 1 </span><span class="cov0" title="0">{
                        panic("sanity check failed")</span>
                }
        }

        <span class="cov8" title="1">var c0, c1 BF
        BFP(&amp;c0).Mul(&amp;v.U0, &amp;den)
        BFP(&amp;c1).Neg(&amp;v.U1)
        BFP(&amp;c1).Mul(&amp;c1, &amp;den)

        if ok == 1 </span><span class="cov8" title="1">{
                var sanityCheck QuadraticFieldExtensionImpl[BFP, A, BF]
                BFP(&amp;sanityCheck.U0).Set(&amp;c0)
                BFP(&amp;sanityCheck.U1).Set(&amp;c1)
                sanityCheck.Mul(&amp;sanityCheck, v)
                if sanityCheck.IsOne() != 1 </span><span class="cov0" title="0">{
                        panic("sanity check failed")</span>
                }
        }

        <span class="cov8" title="1">BFP(&amp;f.U0).Select(ok, &amp;f.U0, &amp;c0)
        BFP(&amp;f.U1).Select(ok, &amp;f.U1, &amp;c1)

        return ok</span>
}

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Div(lhs, rhs *QuadraticFieldExtensionImpl[BFP, A, BF]) (ok ct.Bool) <span class="cov8" title="1">{
        var result, rhsInv QuadraticFieldExtensionImpl[BFP, A, BF]
        ok = rhsInv.Inv(rhs)
        result.Mul(lhs, &amp;rhsInv)

        f.Select(ok, f, &amp;result)
        return ok
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Sqrt(v *QuadraticFieldExtensionImpl[BFP, A, BF]) (ok ct.Bool) <span class="cov8" title="1">{
        var arith A
        var betaA1Square, half, pos, neg, com BF

        BFP(&amp;half).SetOne()
        BFP(&amp;half).Add(&amp;half, &amp;half)
        ok1 := BFP(&amp;half).Inv(&amp;half)

        BFP(&amp;betaA1Square).Square(&amp;v.U1)
        arith.MulByQuadraticNonResidue(&amp;betaA1Square, &amp;betaA1Square)

        BFP(&amp;pos).Square(&amp;v.U0)
        BFP(&amp;pos).Sub(&amp;pos, &amp;betaA1Square)
        ok2 := BFP(&amp;pos).Sqrt(&amp;pos)
        BFP(&amp;neg).Set(&amp;pos)
        BFP(&amp;pos).Add(&amp;v.U0, &amp;pos)
        BFP(&amp;neg).Sub(&amp;v.U0, &amp;neg)
        BFP(&amp;pos).Mul(&amp;pos, &amp;half)
        BFP(&amp;neg).Mul(&amp;neg, &amp;half)
        ok3p := BFP(&amp;pos).Sqrt(&amp;pos)
        ok3n := BFP(&amp;neg).Sqrt(&amp;neg)

        okp := ok1 &amp; ok2 &amp; ok3p
        okn := ok1 &amp; ok2 &amp; ok3n

        BFP(&amp;com).Select(okp, &amp;com, &amp;pos)
        BFP(&amp;com).Select(okn, &amp;com, &amp;neg)
        BFP(&amp;com).Add(&amp;com, &amp;com)
        ok4 := BFP(&amp;com).Inv(&amp;com)
        BFP(&amp;com).Mul(&amp;com, &amp;v.U1)

        BFP(&amp;f.U0).Select(okp&amp;ok4, &amp;f.U0, &amp;pos)
        BFP(&amp;f.U0).Select(okn&amp;ok4, &amp;f.U0, &amp;neg)
        BFP(&amp;f.U1).Select((okp|okn)&amp;ok4, &amp;f.U0, &amp;com)

        return (okp | okn) &amp; ok4
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) IsNonZero() ct.Bool <span class="cov0" title="0">{
        return BFP(&amp;f.U0).IsNonZero() | BFP(&amp;f.U1).IsNonZero()
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) IsZero() ct.Bool <span class="cov8" title="1">{
        return BFP(&amp;f.U0).IsZero() &amp; BFP(&amp;f.U1).IsZero()
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) IsOne() ct.Bool <span class="cov8" title="1">{
        return BFP(&amp;f.U0).IsOne() &amp; BFP(&amp;f.U1).IsZero()
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) Equal(rhs *QuadraticFieldExtensionImpl[BFP, A, BF]) ct.Bool <span class="cov8" title="1">{
        return BFP(&amp;f.U0).Equal(&amp;rhs.U0) &amp; BFP(&amp;f.U1).Equal(&amp;rhs.U1)
}</span>

func (f *QuadraticFieldExtensionImpl[BFP, A, BF]) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return slices.Concat(BFP(&amp;f.U0).ComponentsBytes(), BFP(&amp;f.U1).ComponentsBytes())
}</span>

func (*QuadraticFieldExtensionImpl[BFP, A, BF]) Degree() uint64 <span class="cov0" title="0">{
        return BFP(nil).Degree() * 2
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package fields

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func TonelliShanks[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any](out, x, ethRootOfUnity *F, e uint64, progenitorExp []uint8) (ok ct.Bool) <span class="cov8" title="1">{
        var y, s, t, z F

        Pow[FP](&amp;y, x, progenitorExp)
        FP(&amp;s).Mul(&amp;y, x)
        FP(&amp;t).Mul(&amp;s, &amp;y)
        FP(&amp;z).Set(ethRootOfUnity)

        for k := e; k &gt; 1; k-- </span><span class="cov8" title="1">{
                var b F
                FP(&amp;b).Set(&amp;t)
                for i := uint64(1); i &lt; k-1; i++ </span><span class="cov8" title="1">{
                        FP(&amp;b).Square(&amp;b)
                }</span>
                <span class="cov8" title="1">var sz, tz F
                FP(&amp;sz).Mul(&amp;s, &amp;z)
                FP(&amp;s).Select(FP(&amp;b).IsOne(), &amp;sz, &amp;s)
                FP(&amp;z).Square(&amp;z)
                FP(&amp;tz).Mul(&amp;t, &amp;z)
                FP(&amp;t).Select(FP(&amp;b).IsOne(), &amp;tz, &amp;t)</span>
        }

        <span class="cov8" title="1">var ss F
        FP(&amp;ss).Square(&amp;s)
        ok = FP(x).Equal(&amp;ss)
        FP(out).Select(ok, out, &amp;s)
        return ok</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package testutils

import (
        "encoding/binary"
        "io"
        "math/bits"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const TestFpModulus = 0x429d16a1

var (
        _ impl.PrimeFieldElementLowLevel[*TestFp] = (*TestFp)(nil)

        TestFpE             = uint64(bits.TrailingZeros64(uint64(TestFpModulus) - 1))
        TestFpProgenitorExp = binary.LittleEndian.AppendUint32(nil, TestFpModulus&gt;&gt;(TestFpE+1))
        TestFpRootOfUnity   = uint64(0xa93059e)
)

type TestFp uint64

func (fp *TestFp) Set(v *TestFp) <span class="cov8" title="1">{
        *fp = *v
}</span>

func (fp *TestFp) SetZero() <span class="cov0" title="0">{
        *fp = 0
}</span>

func (fp *TestFp) SetOne() <span class="cov8" title="1">{
        *fp = 1
}</span>

func (fp *TestFp) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">fp.SetBytesWide(componentsData[0])
        return 1</span>
}

func (fp *TestFp) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        if prng == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var data [8]byte
        _, err := io.ReadFull(prng, data[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">*fp = TestFp(binary.LittleEndian.Uint64(data[:]) % TestFpModulus)
        return 1</span>
}

func (fp *TestFp) Select(choice ct.Choice, z, nz *TestFp) <span class="cov8" title="1">{
        switch choice </span>{
        case 0:<span class="cov8" title="1">
                *fp = *z
                return</span>
        case 1:<span class="cov8" title="1">
                *fp = *nz
                return</span>
        }

        <span class="cov0" title="0">panic("invalid choice")</span>
}

func (fp *TestFp) Add(lhs, rhs *TestFp) <span class="cov8" title="1">{
        *fp = (*lhs + *rhs) % TestFpModulus
}</span>

func (fp *TestFp) Double(v *TestFp) <span class="cov0" title="0">{
        *fp = (*v + *v) % TestFpModulus
}</span>

func (fp *TestFp) Sub(lhs, rhs *TestFp) <span class="cov8" title="1">{
        *fp = (TestFpModulus + *lhs - *rhs) % TestFpModulus
}</span>

func (fp *TestFp) Neg(v *TestFp) <span class="cov8" title="1">{
        *fp = (TestFpModulus - *v) % TestFpModulus
}</span>

func (fp *TestFp) Mul(lhs, rhs *TestFp) <span class="cov8" title="1">{
        *fp = (*lhs * *rhs) % TestFpModulus
}</span>

func (fp *TestFp) Square(v *TestFp) <span class="cov8" title="1">{
        *fp = (*v * *v) % TestFpModulus
}</span>

func (fp *TestFp) Inv(v *TestFp) (ok ct.Bool) <span class="cov8" title="1">{
        if *v == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var vInv TestFp
        fields.Pow(&amp;vInv, v, binary.LittleEndian.AppendUint64(nil, TestFpModulus-2))

        var sanityCheck TestFp
        sanityCheck.Mul(&amp;vInv, v)
        if sanityCheck.IsOne() != 1 </span><span class="cov0" title="0">{
                panic("sanity check failed")</span>
        }

        <span class="cov8" title="1">*fp = vInv
        return 1</span>
}

func (fp *TestFp) Div(lhs, rhs *TestFp) (ok ct.Bool) <span class="cov8" title="1">{
        if *rhs == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var rhsInv TestFp
        fields.Pow(&amp;rhsInv, rhs, binary.LittleEndian.AppendUint64(nil, TestFpModulus-2))
        *fp = (*lhs * rhsInv) % TestFpModulus
        return 1</span>
}

func (fp *TestFp) Sqrt(v *TestFp) (ok ct.Bool) <span class="cov8" title="1">{
        return fields.TonelliShanks(fp, v, (*TestFp)(&amp;TestFpRootOfUnity), TestFpE, TestFpProgenitorExp)
}</span>

func (fp *TestFp) IsNonZero() ct.Bool <span class="cov0" title="0">{
        if *fp != 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

func (fp *TestFp) IsZero() ct.Bool <span class="cov0" title="0">{
        if *fp == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov0" title="0">return 0</span>
}

func (fp *TestFp) IsOne() ct.Bool <span class="cov8" title="1">{
        if *fp == 1 </span><span class="cov8" title="1">{
                return 1
        }</span>

        <span class="cov8" title="1">return 0</span>
}

func (fp *TestFp) Equal(rhs *TestFp) ct.Bool <span class="cov8" title="1">{
        if *fp == *rhs </span><span class="cov8" title="1">{
                return 1
        }</span>

        <span class="cov8" title="1">return 0</span>
}

func (fp *TestFp) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{fp.Bytes()}
}</span>

func (fp *TestFp) SetUint64(u uint64) <span class="cov0" title="0">{
        *fp = TestFp(u % TestFpModulus)
}</span>

func (fp *TestFp) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        if len(data) != 1 || bits.Len64(data[0]) &gt; 32 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">*fp = TestFp(data[0] % TestFpModulus)
        return 1</span>
}

func (fp *TestFp) SetBytes(data []byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(data) != 4 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var wideData [8]byte
        copy(wideData[:], data)
        *fp = TestFp(binary.LittleEndian.Uint64(wideData[:]) % TestFpModulus)
        return 1</span>
}

func (fp *TestFp) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) &gt; 8 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var wideData [8]byte
        copy(wideData[:], data)
        *fp = TestFp(binary.LittleEndian.Uint64(wideData[:]) % TestFpModulus)
        return 1</span>
}

func (fp *TestFp) Bytes() []byte <span class="cov0" title="0">{
        return binary.LittleEndian.AppendUint32(nil, uint32(*fp))
}</span>

func (fp *TestFp) Limbs() []uint64 <span class="cov0" title="0">{
        return []uint64{uint64(*fp)}
}</span>

func (*TestFp) Degree() uint64 <span class="cov0" title="0">{
        return 1
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package testutils

import (
        "encoding/json"
        "fmt"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
)

type FiniteFieldElementJSON[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        V F
}

func (f *FiniteFieldElementJSON[FP, F]) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type innerType []string
        var innerData innerType
        err := json.Unmarshal(data, &amp;innerData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">uniformBytes := make([][]byte, len(innerData))
        for i, s := range innerData </span><span class="cov8" title="1">{
                bi, ok := new(big.Int).SetString(s, 0)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid number string: %s", s)
                }</span>
                <span class="cov8" title="1">biBytes := bi.Bytes()
                slices.Reverse(biBytes)
                uniformBytes[i] = biBytes</span>
        }

        <span class="cov8" title="1">ok := FP(&amp;f.V).SetUniformBytes(uniformBytes...)
        if ok != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid uniform bytes")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package testutils

import (
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/stretchr/testify/require"
)

type BinaryOpVectors[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        Vectors []BinaryOpVector[FP, F] `json:"vectors"`
}

type BinaryOpVector[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        A FiniteFieldElementJSON[FP, F] `json:"a"`
        B FiniteFieldElementJSON[FP, F] `json:"b"`
        C FiniteFieldElementJSON[FP, F] `json:"c"`
}

type BinaryOpVectorsWithOk[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        Vectors []BinaryOpVectorWithOk[FP, F] `json:"vectors"`
}

type BinaryOpVectorWithOk[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        A  FiniteFieldElementJSON[FP, F] `json:"a"`
        B  FiniteFieldElementJSON[FP, F] `json:"b"`
        C  FiniteFieldElementJSON[FP, F] `json:"c"`
        Ok ct.Bool                       `json:"ok"`
}

type UnaryOpVectors[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        Vectors []UnaryOpVector[FP, F] `json:"vectors"`
}

type UnaryOpVector[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        A FiniteFieldElementJSON[FP, F] `json:"a"`
        C FiniteFieldElementJSON[FP, F] `json:"c"`
}

type UnaryOpVectorsWithOk[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        Vectors []UnaryOpVectorWithOk[FP, F] `json:"vectors"`
}

type UnaryOpVectorWithOk[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any] struct {
        A  FiniteFieldElementJSON[FP, F] `json:"a"`
        C  FiniteFieldElementJSON[FP, F] `json:"c"`
        Ok ct.Bool                       `json:"ok"`
}

func TestUnaryOp[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any](tb testing.TB, a, c *F, op func(c, a *F)) <span class="cov8" title="1">{
        tb.Helper()
        var actualC F
        op(&amp;actualC, a)
        require.True(tb, FP(&amp;actualC).Equal(c) == 1)
}</span>

func TestUnaryOpWithOk[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any](tb testing.TB, a, c *F, ok ct.Bool, op func(c, a *F) ct.Bool) <span class="cov8" title="1">{
        tb.Helper()
        var actualC F
        actualOk := op(&amp;actualC, a)
        require.True(tb, FP(&amp;actualC).Equal(c) == 1)
        require.True(tb, actualOk == ok)
}</span>

func TestBinaryOp[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any](tb testing.TB, a, b, c *F, op func(c, a, b *F)) <span class="cov8" title="1">{
        tb.Helper()
        var actualC F
        op(&amp;actualC, a, b)
        require.True(tb, FP(&amp;actualC).Equal(c) == 1)
}</span>

func TestBinaryOpWithOk[FP impl.FiniteFieldElementPtrLowLevel[FP, F], F any](tb testing.TB, a, b, c *F, ok ct.Bool, op func(c, a, b *F) ct.Bool) <span class="cov8" title="1">{
        tb.Helper()
        var actualC F
        actualOk := op(&amp;actualC, a, b)
        require.True(tb, FP(&amp;actualC).Equal(c) == 1)
        require.True(tb, actualOk == ok)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package impl

import (
        "math/bits"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func ScalarMulLowLevel[PP GroupElementPtrLowLevel[PP, P], P any](out, pp *P, s []byte) <span class="cov0" title="0">{
        var precomputed [16]P

        PP(&amp;precomputed[0]).SetZero()
        PP(&amp;precomputed[1]).Set(pp)
        for i := 2; i &lt; 16; i += 2 </span><span class="cov0" title="0">{
                PP(&amp;precomputed[i]).Double(&amp;precomputed[i/2])
                PP(&amp;precomputed[i+1]).Add(&amp;precomputed[i], pp)
        }</span>

        <span class="cov0" title="0">var res P
        PP(&amp;res).SetZero()
        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                PP(&amp;res).Double(&amp;res)
                PP(&amp;res).Double(&amp;res)
                PP(&amp;res).Double(&amp;res)
                PP(&amp;res).Double(&amp;res)
                w := (s[i] &gt;&gt; 4) &amp; 0b1111
                PP(&amp;res).Add(&amp;res, &amp;precomputed[w])

                PP(&amp;res).Double(&amp;res)
                PP(&amp;res).Double(&amp;res)
                PP(&amp;res).Double(&amp;res)
                PP(&amp;res).Double(&amp;res)
                w = s[i] &amp; 0b1111
                PP(&amp;res).Add(&amp;res, &amp;precomputed[w])
        }</span>

        <span class="cov0" title="0">PP(out).Set(&amp;res)</span>
}

// MultiScalarMulLowLevel performs a Pippenger-style multi-scalar multiplication:
//
//        sum_i scalars[i] * points[i]
//
// using a fixed window size w.
//
// It assumes S.Bytes() is little-endian (LSB at index 0).
func MultiScalarMulLowLevel[PP GroupElementPtrLowLevel[PP, P], P any](
        out *P,
        points []*P,
        scalars [][]byte,
) <span class="cov0" title="0">{
        n := len(points)
        if n == 0 </span><span class="cov0" title="0">{
                panic("MultiScalarMul: no points")</span>
        }
        <span class="cov0" title="0">if n != len(scalars) </span><span class="cov0" title="0">{
                panic("MultiScalarMul: number of points and scalars must be equal")</span>
        }

        // Use naive method for small n.
        <span class="cov0" title="0">if n &lt;= 7 </span><span class="cov0" title="0">{
                var acc P
                PP(&amp;acc).SetZero()
                for i := range n </span><span class="cov0" title="0">{
                        var term P
                        ScalarMulLowLevel[PP](&amp;term, points[i], scalars[i])
                        PP(&amp;acc).Add(&amp;acc, &amp;term)
                }</span>
                <span class="cov0" title="0">PP(out).Set(&amp;acc)
                return</span>
        }

        // Precompute scalar bytes and max bit length.
        <span class="cov0" title="0">scalarBytes := make([][]byte, n)
        maxBits := 0
        for i, s := range scalars </span><span class="cov0" title="0">{
                scalarBytes[i] = s
                if numBits := len(s) * 8; numBits &gt; maxBits </span><span class="cov0" title="0">{
                        maxBits = numBits
                }</span>
        }
        <span class="cov0" title="0">if maxBits == 0 </span><span class="cov0" title="0">{
                // All scalars are zero.
                PP(out).SetZero()
                return
        }</span>

        // Choose window size w.
        // A heuristic: w  log2(n), but clamp to [2, 16].
        <span class="cov0" title="0">w := 0
        if n &gt; 0 </span><span class="cov0" title="0">{
                w = bits.Len(uint(n)) // log2(n) rounded up
        }</span>
        <span class="cov0" title="0">if w &lt; 2 </span><span class="cov0" title="0">{
                w = 2
        }</span>
        <span class="cov0" title="0">if w &gt; 16 </span><span class="cov0" title="0">{
                w = 16
        }</span>

        <span class="cov0" title="0">windowSize := 1 &lt;&lt; w
        numWindows := (maxBits + w - 1) / w // ceil(maxBits / w)

        // Helper: get window of w bits starting at bit position `start` (LSB = bit 0).
        // Assumes little-endian byte order (LSB at index 0).
        getWindow := func(b []byte, start int) uint </span><span class="cov0" title="0">{
                if len(b) == 0 </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">var acc uint
                for k := range w </span><span class="cov0" title="0">{
                        bitIndex := start + k
                        byteIndex := bitIndex / 8
                        if byteIndex &gt;= len(b) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">shift := uint(bitIndex % 8)
                        bit := (b[byteIndex] &gt;&gt; shift) &amp; 1
                        acc |= uint(bit) &lt;&lt; uint(k)</span>
                }
                <span class="cov0" title="0">return acc</span>
        }

        <span class="cov0" title="0">var acc P
        PP(&amp;acc).SetZero()
        for wIdx := numWindows - 1; wIdx &gt;= 0; wIdx-- </span><span class="cov0" title="0">{
                for range w </span><span class="cov0" title="0">{
                        PP(&amp;acc).Add(&amp;acc, &amp;acc)
                }</span>
                <span class="cov0" title="0">buckets := make([]PP, windowSize)
                for i := range buckets </span><span class="cov0" title="0">{
                        var b P
                        PP(&amp;b).SetZero()
                        buckets[i] = PP(&amp;b)
                }</span>
                <span class="cov0" title="0">startBit := wIdx * w
                for i := range n </span><span class="cov0" title="0">{
                        win := getWindow(scalarBytes[i], startBit)
                        if win == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">buckets[win].Add(buckets[win], points[i])</span>
                }

                // Summation by running sum from highest bucket down.
                // This gives: sum_{k=1}^{windowSize-1} k * bucket_k
                // with only ~windowSize additions.
                <span class="cov0" title="0">var running P
                PP(&amp;running).SetZero()
                for k := windowSize - 1; k &gt; 0; k-- </span><span class="cov0" title="0">{
                        if isIdentity := buckets[k].IsZero(); isIdentity == ct.False </span><span class="cov0" title="0">{
                                PP(&amp;running).Add(&amp;running, buckets[k])
                        }</span>
                        <span class="cov0" title="0">PP(&amp;acc).Add(&amp;acc, &amp;running)</span>
                }
        }

        <span class="cov0" title="0">PP(out).Set(&amp;acc)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package properties

import (
        "slices"
        "testing"

        "github.com/stretchr/testify/require"
        "pgregory.net/rapid"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

type FiniteFieldalLowLevel[FPtr impl.FiniteFieldElementPtrLowLevel[FPtr, F], F any] struct {
        RingalLowLevel[FPtr, F]

        gNonZero *rapid.Generator[FPtr]
}

func NewLowLevelFiniteFieldalPropertySuite[FPtr impl.FiniteFieldElementPtrLowLevel[FPtr, F], F any](t *testing.T, elementGen *rapid.Generator[FPtr]) *FiniteFieldalLowLevel[FPtr, F] <span class="cov0" title="0">{
        t.Helper()

        r := NewLowLevelRingalPropertySuite(t, elementGen)
        gNonZero := elementGen.Filter(func(f FPtr) bool </span><span class="cov0" title="0">{
                return f.IsNonZero() == ct.True
        }</span>)
        <span class="cov0" title="0">return &amp;FiniteFieldalLowLevel[FPtr, F]{
                RingalLowLevel: *r,
                gNonZero:       gNonZero,
        }</span>
}

func (s *FiniteFieldalLowLevel[FPtr, F]) MultiplicationIsCommutative(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b F
                aPtr := s.g.Draw(t, "a")
                bPtr := s.g.Draw(t, "b")
                FPtr(&amp;a).Set(aPtr)
                FPtr(&amp;b).Set(bPtr)

                var l, r F
                FPtr(&amp;l).Mul(&amp;a, &amp;b)
                FPtr(&amp;r).Mul(&amp;b, &amp;a)
                require.Equal(t, ct.True, FPtr(&amp;l).Equal(&amp;r))
        }</span>)
}

func (s *FiniteFieldalLowLevel[FPtr, F]) MultiplicationHasNonZeroInverse(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a F
                aPtr := s.gNonZero.Draw(t, "a")
                FPtr(&amp;a).Set(aPtr)

                var l F
                ok := FPtr(&amp;l).Inv(&amp;a)
                require.Equal(t, ct.True, ok)
                FPtr(&amp;l).Mul(&amp;l, &amp;a)
                require.Equal(t, ct.True, FPtr(&amp;l).IsOne())
        }</span>)
}

func (s *FiniteFieldalLowLevel[RPtr, R]) CanDivideByNonZero(t *testing.T) <span class="cov0" title="0">{
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b R
                aPtr := s.g.Draw(t, "a")
                bPtr := s.gNonZero.Draw(t, "b")
                RPtr(&amp;a).Set(aPtr)
                RPtr(&amp;b).Set(bPtr)

                var l R
                ok := RPtr(&amp;l).Div(&amp;a, &amp;b)
                require.Equal(t, ct.True, ok)
                RPtr(&amp;l).Mul(&amp;l, &amp;b)
                require.Equal(t, ct.True, RPtr(&amp;l).Equal(&amp;a))
        }</span>)
}

func (s *FiniteFieldalLowLevel[FPtr, F]) CanSerialiseToComponents(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a F
                aPtr := s.g.Draw(t, "a")
                FPtr(&amp;a).Set(aPtr)

                var l F
                data := FPtr(&amp;a).ComponentsBytes()
                ok := FPtr(&amp;l).SetUniformBytes(data...)
                require.Equal(t, ct.True, ok)
                require.Equal(t, ct.True, FPtr(&amp;l).Equal(&amp;a))
        }</span>)
}

func (s *FiniteFieldalLowLevel[FPtr, F]) CheckAll(t *testing.T) <span class="cov0" title="0">{
        t.Helper()

        s.RingalLowLevel.CheckAll(t)
        t.Run("multiplication is commutative", s.MultiplicationIsCommutative)
        t.Run("multiplication has non-zero inverse", s.MultiplicationHasNonZeroInverse)
        t.Run("can divide by non-zero", s.CanDivideByNonZero)
        t.Run("can serialise to components", s.CanSerialiseToComponents)
}</span>

type PrimeFieldalLowLevel[FPtr impl.PrimeFieldElementPtrLowLevel[FPtr, F], F any] struct {
        FiniteFieldalLowLevel[FPtr, F]

        gComputationalBytes *rapid.Generator[[]byte]
}

func NewLowLevelPrimeFieldalPropertySuite[FPtr impl.PrimeFieldElementPtrLowLevel[FPtr, F], F any](t *testing.T, g *rapid.Generator[FPtr]) *PrimeFieldalLowLevel[FPtr, F] <span class="cov0" title="0">{
        t.Helper()

        f := NewLowLevelFiniteFieldalPropertySuite(t, g)
        gComputationalBytes := rapid.SliceOfN(rapid.Byte(), base.ComputationalSecurityBytesCeil, base.ComputationalSecurityBytesCeil)
        return &amp;PrimeFieldalLowLevel[FPtr, F]{
                FiniteFieldalLowLevel: *f,
                gComputationalBytes:   gComputationalBytes,
        }
}</span>

func (s *PrimeFieldalLowLevel[FPtr, F]) CanSerialiseToLimbs(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a F
                aPtr := s.g.Draw(t, "a")
                FPtr(&amp;a).Set(aPtr)

                var l F
                limbs := FPtr(&amp;a).Limbs()
                ok := FPtr(&amp;l).SetLimbs(limbs)
                require.Equal(t, ct.True, ok)
                require.Equal(t, ct.True, FPtr(&amp;l).Equal(&amp;a))
        }</span>)
}

func (s *PrimeFieldalLowLevel[FPtr, F]) CanSetWideBytes(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a F
                aPtr := s.g.Draw(t, "a")
                FPtr(&amp;a).Set(aPtr)

                var l F
                data0 := FPtr(&amp;a).Bytes()
                data1 := s.gComputationalBytes.Draw(t, "data")
                data := slices.Concat(data0, data1)
                ok := FPtr(&amp;l).SetBytesWide(data)
                require.Equal(t, ct.True, ok)
        }</span>)
}

func (s *PrimeFieldalLowLevel[FPtr, F]) CheckAll(t *testing.T) <span class="cov0" title="0">{
        t.Helper()

        s.FiniteFieldalLowLevel.CheckAll(t)
        t.Run("can serialise to limbs", s.CanSerialiseToLimbs)
        t.Run("can set wide bytes", s.CanSetWideBytes)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package properties

import (
        "testing"

        "github.com/stretchr/testify/require"
        "pgregory.net/rapid"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func NewLowLevelGroupalPropertySuite[E impl.GroupElementPtrLowLevel[E, T], T any](
        t *testing.T,
        elementGen *rapid.Generator[E],
        isCommutative bool,
) *GroupalLowLevel[E, T] <span class="cov0" title="0">{
        t.Helper()

        return &amp;GroupalLowLevel[E, T]{
                MonoidalLowLevel: *NewLowLevelMonoidalPropertySuite(t, elementGen, isCommutative),
        }
}</span>

type GroupalLowLevel[E impl.GroupElementPtrLowLevel[E, T], T any] struct {
        MonoidalLowLevel[E, T]
}

func (p *GroupalLowLevel[E, T]) CheckAll(t *testing.T) <span class="cov0" title="0">{
        t.Helper()
        p.MonoidalLowLevel.CheckAll(t)
        t.Run("have additive inverse", p.CanNegate)
        t.Run("can subtract", p.CanSubtract)
}</span>

func (p *GroupalLowLevel[E, T]) CanNegate(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, negA T
                x := p.g.Draw(t, "x")
                E(&amp;a).Set(x)
                E(&amp;negA).Neg(E(&amp;a))
                E(&amp;a).Add(E(&amp;a), E(&amp;negA))
                require.Equal(t, ct.True, E(&amp;a).IsZero())
        }</span>)
}

func (p *GroupalLowLevel[E, T]) CanSubtract(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, aMinusB, aMinusBPlusB T
                x := p.g.Draw(t, "x")
                y := p.g.Draw(t, "y")
                E(&amp;a).Set(x)
                E(&amp;b).Set(y)

                E(&amp;aMinusB).Sub(E(&amp;a), E(&amp;b))
                E(&amp;aMinusBPlusB).Add(E(&amp;aMinusB), E(&amp;b))

                require.Equal(t, ct.True, E(&amp;a).Equal(E(&amp;aMinusBPlusB)))
        }</span>)
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package properties

import (
        "testing"

        "github.com/stretchr/testify/require"
        "pgregory.net/rapid"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func NewLowLevelMonoidalPropertySuite[E impl.MonoidElementPtrLowLevel[E, T], T any](t *testing.T, g *rapid.Generator[E], isCommutative bool) *MonoidalLowLevel[E, T] <span class="cov0" title="0">{
        t.Helper()
        require.NotNil(t, g, "generator must not be nil")
        return &amp;MonoidalLowLevel[E, T]{
                g:             g,
                isCommutative: isCommutative,
        }
}</span>

type MonoidalLowLevel[E impl.MonoidElementPtrLowLevel[E, T], T any] struct {
        g             *rapid.Generator[E]
        isCommutative bool
}

func (p *MonoidalLowLevel[E, T]) CheckAll(t *testing.T) <span class="cov0" title="0">{
        t.Helper()
        t.Run("can set", p.CanSet)
        t.Run("addition is associative", p.AdditionIsAssociative)
        t.Run("can double", p.Double)
        t.Run("addition has identity", p.ZeroIsNeutralElement)
        t.Run("zero is identifiable", p.ZeroIsIdentifiable)
        t.Run("can conditionally select", p.CanConditionallySelect)
        t.Run("can deserialize", p.CanSerializeDeserialize)
        t.Run("can equate", p.CanEquate)
        if p.isCommutative </span><span class="cov0" title="0">{
                t.Run("addition is commutative", p.AdditionIsCommutative)
        }</span>
}

func (p *MonoidalLowLevel[E, T]) CanSet(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a T
                b := p.g.Draw(t, "b")
                E(&amp;a).Set(b)
                require.Equal(t, ct.True, b.Equal(E(&amp;a)))
        }</span>)
}

func (p *MonoidalLowLevel[E, T]) AdditionIsAssociative(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, c, ab, abc, bc, a_bc T //nolint:staticcheck // a_bc is more readable.
                x := p.g.Draw(t, "x")
                y := p.g.Draw(t, "y")
                z := p.g.Draw(t, "z")

                E(&amp;a).Set(x)
                E(&amp;b).Set(y)
                E(&amp;c).Set(z)

                E(&amp;ab).Add(E(&amp;a), E(&amp;b))
                E(&amp;abc).Add(E(&amp;ab), E(&amp;c))

                E(&amp;bc).Add(E(&amp;b), E(&amp;c))
                E(&amp;a_bc).Add(E(&amp;a), E(&amp;bc))

                require.Equal(t, ct.True, E(&amp;abc).Equal(E(&amp;a_bc)))
        }</span>)
}

func (p *MonoidalLowLevel[E, T]) AdditionIsCommutative(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, c1, c2 T
                x := p.g.Draw(t, "x")
                y := p.g.Draw(t, "y")

                E(&amp;a).Set(x)
                E(&amp;b).Set(y)

                E(&amp;c1).Add(E(&amp;a), E(&amp;b))
                E(&amp;c2).Add(E(&amp;b), E(&amp;a))

                require.Equal(t, ct.True, E(&amp;c1).Equal(E(&amp;c2)))
        }</span>)
}

func (p *MonoidalLowLevel[E, T]) Double(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, c T
                x := p.g.Draw(t, "x")

                E(&amp;a).Set(x)
                E(&amp;b).Add(E(&amp;a), E(&amp;a))
                E(&amp;c).Double(E(&amp;a))

                require.Equal(t, ct.True, E(&amp;b).Equal(E(&amp;c)))
        }</span>)
}

func (p *MonoidalLowLevel[E, T]) ZeroIsNeutralElement(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, c, zero T
                x := p.g.Draw(t, "x")

                E(&amp;a).Set(x)
                E(&amp;zero).SetZero()

                E(&amp;b).Add(E(&amp;a), E(&amp;zero))
                E(&amp;c).Add(E(&amp;zero), E(&amp;a))

                require.Equal(t, ct.True, E(&amp;a).Equal(E(&amp;b)))
                require.Equal(t, ct.True, E(&amp;a).Equal(E(&amp;c)))
        }</span>)
}

func (p *MonoidalLowLevel[E, T]) ZeroIsIdentifiable(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var zero T
                E(&amp;zero).SetZero()
                require.Equal(t, ct.True, E(&amp;zero).IsZero())
                x := p.g.Draw(t, "x")
                require.NotEqual(t, x.IsZero(), x.IsNonZero())
        }</span>)
}

func (p *MonoidalLowLevel[E, T]) CanConditionallySelect(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, c1, c2, c3 T
                x := p.g.Draw(t, "x")
                y := p.g.Draw(t, "y")
                cond := ct.Choice(rapid.IntRange(0, 1).Draw(t, "cond"))

                E(&amp;a).Set(x)
                E(&amp;b).Set(y)

                E(&amp;c1).Select(cond, E(&amp;a), E(&amp;b))
                E(&amp;c2).Select(cond, E(&amp;a), E(&amp;b))
                E(&amp;c3).Select(cond.Not(), E(&amp;b), E(&amp;a))

                require.Equal(t, ct.True, E(&amp;c1).Equal(E(&amp;c2)))
                require.Equal(t, ct.True, E(&amp;c1).Equal(E(&amp;c3)))
        }</span>)
}

func (p *MonoidalLowLevel[E, T]) CanSerializeDeserialize(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b T
                x := p.g.Draw(t, "x")

                E(&amp;a).Set(x)
                data := E(&amp;a).Bytes()
                ok := E(&amp;b).SetBytes(data)
                require.Equal(t, ct.True, ok)
                require.Equal(t, ct.True, E(&amp;a).Equal(E(&amp;b)))
        }</span>)
}

func (p *MonoidalLowLevel[E, T]) CanEquate(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, c T
                x := p.g.Draw(t, "x")
                y := p.g.Draw(t, "y")

                E(&amp;a).Set(x)
                E(&amp;b).Set(x)
                E(&amp;c).Set(y)

                require.Equal(t, ct.True, E(&amp;a).Equal(E(&amp;b)))
                require.Equal(t, x.Equal(y), E(&amp;a).Equal(E(&amp;c)))
        }</span>)
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package properties

import (
        "testing"

        "github.com/stretchr/testify/require"
        "pgregory.net/rapid"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

type RingalLowLevel[RPtr impl.RingElementPtrLowLevel[RPtr, R], R any] struct {
        GroupalLowLevel[RPtr, R]
}

func NewLowLevelRingalPropertySuite[RPtr impl.RingElementPtrLowLevel[RPtr, R], R any](t *testing.T, elementGen *rapid.Generator[RPtr]) *RingalLowLevel[RPtr, R] <span class="cov0" title="0">{
        t.Helper()

        grupal := NewLowLevelGroupalPropertySuite(t, elementGen, true)
        return &amp;RingalLowLevel[RPtr, R]{
                GroupalLowLevel: *grupal,
        }
}</span>

func (s *RingalLowLevel[RPtr, R]) MultiplicationIsAssociate(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, c R
                aPtr := s.g.Draw(t, "a")
                bPtr := s.g.Draw(t, "b")
                cPtr := s.g.Draw(t, "c")
                RPtr(&amp;a).Set(aPtr)
                RPtr(&amp;b).Set(bPtr)
                RPtr(&amp;c).Set(cPtr)

                var l, r R
                RPtr(&amp;l).Mul(&amp;a, &amp;b)
                RPtr(&amp;l).Mul(&amp;l, &amp;c)
                RPtr(&amp;r).Mul(&amp;b, &amp;c)
                RPtr(&amp;r).Mul(&amp;a, &amp;r)
                require.Equal(t, ct.True, RPtr(&amp;l).Equal(RPtr(&amp;r)))
        }</span>)
}

func (s *RingalLowLevel[RPtr, R]) MultiplicationHasIdentity(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var one, a R
                aPtr := s.g.Draw(t, "a")
                RPtr(&amp;one).SetOne()
                RPtr(&amp;a).Set(aPtr)

                var l, r R
                RPtr(&amp;l).Mul(&amp;a, &amp;one)
                RPtr(&amp;r).Mul(&amp;one, &amp;a)
                require.Equal(t, ct.True, RPtr(&amp;one).IsOne())
                require.Equal(t, ct.True, RPtr(&amp;one).IsNonZero())
                require.Equal(t, ct.False, RPtr(&amp;one).IsZero())
                require.Equal(t, ct.True, RPtr(&amp;l).Equal(&amp;a))
                require.Equal(t, ct.True, RPtr(&amp;r).Equal(&amp;a))
        }</span>)
}

func (s *RingalLowLevel[RPtr, R]) MultiplicationIsLeftDistributive(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b, c R
                aPtr := s.g.Draw(t, "a")
                bPtr := s.g.Draw(t, "b")
                cPtr := s.g.Draw(t, "c")
                RPtr(&amp;a).Set(aPtr)
                RPtr(&amp;b).Set(bPtr)
                RPtr(&amp;c).Set(cPtr)

                var l, r, z R
                RPtr(&amp;l).Add(&amp;b, &amp;c)
                RPtr(&amp;l).Mul(&amp;a, &amp;l)
                RPtr(&amp;z).Mul(&amp;a, &amp;c)
                RPtr(&amp;r).Mul(&amp;a, &amp;b)
                RPtr(&amp;r).Add(&amp;r, &amp;z)
                require.Equal(t, ct.True, RPtr(&amp;l).Equal(&amp;r))
        }</span>)
}

func (s *RingalLowLevel[RPtr, R]) MultiplicationIsRightDistributive(t *testing.T) <span class="cov0" title="0">{
        t.Parallel()
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var b, c, a R
                bPtr := s.g.Draw(t, "b")
                cPtr := s.g.Draw(t, "c")
                aPtr := s.g.Draw(t, "a")
                RPtr(&amp;b).Set(bPtr)
                RPtr(&amp;c).Set(cPtr)
                RPtr(&amp;a).Set(aPtr)

                var l, r, z R
                RPtr(&amp;l).Add(&amp;b, &amp;c)
                RPtr(&amp;l).Mul(&amp;l, &amp;a)
                RPtr(&amp;z).Mul(&amp;b, &amp;a)
                RPtr(&amp;r).Mul(&amp;c, &amp;a)
                RPtr(&amp;r).Add(&amp;z, &amp;r)
                require.Equal(t, ct.True, RPtr(&amp;l).Equal(&amp;r))
        }</span>)
}

func (s *RingalLowLevel[RPtr, R]) CanSquare(t *testing.T) <span class="cov0" title="0">{
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a R
                aPtr := s.g.Draw(t, "a")
                RPtr(&amp;a).Set(aPtr)

                var l, r R
                RPtr(&amp;l).Square(&amp;a)
                RPtr(&amp;r).Mul(&amp;a, &amp;a)
                require.Equal(t, ct.True, RPtr(&amp;l).Equal(&amp;r))
        }</span>)
}

func (s *RingalLowLevel[RPtr, R]) MaybeHaveMultiplicativeInverse(t *testing.T) <span class="cov0" title="0">{
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a R
                aPtr := s.g.Draw(t, "a")
                RPtr(&amp;a).Set(aPtr)

                var l, r, one R
                ok := RPtr(&amp;l).Inv(&amp;a)
                if ok == ct.True </span><span class="cov0" title="0">{
                        RPtr(&amp;one).SetOne()
                        RPtr(&amp;r).Mul(&amp;l, &amp;a)
                        RPtr(&amp;l).Mul(&amp;a, &amp;l)
                        require.Equal(t, ct.True, RPtr(&amp;l).Equal(&amp;one))
                        require.Equal(t, ct.True, RPtr(&amp;r).Equal(&amp;one))
                }</span>
        })
}

func (s *RingalLowLevel[RPtr, R]) MaybeCanDivide(t *testing.T) <span class="cov0" title="0">{
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a, b R
                aPtr := s.g.Draw(t, "a")
                bPtr := s.g.Draw(t, "b")
                RPtr(&amp;a).Set(aPtr)
                RPtr(&amp;b).Set(bPtr)

                var l, r R
                ok := RPtr(&amp;l).Div(&amp;a, &amp;b)
                if ok == ct.True </span><span class="cov0" title="0">{
                        RPtr(&amp;r).Mul(&amp;l, &amp;b)
                        RPtr(&amp;l).Mul(&amp;b, &amp;l)
                        require.Equal(t, ct.True, RPtr(&amp;l).Equal(&amp;a))
                        require.Equal(t, ct.True, RPtr(&amp;r).Equal(&amp;a))
                }</span>
        })
}

func (s *RingalLowLevel[RPtr, R]) MaybeHaveSquareRoot(t *testing.T) <span class="cov0" title="0">{
        rapid.Check(t, func(t *rapid.T) </span><span class="cov0" title="0">{
                var a R
                aPtr := s.g.Draw(t, "a")
                RPtr(&amp;a).Set(aPtr)

                var r R
                ok := RPtr(&amp;r).Sqrt(&amp;a)
                if ok == ct.True </span><span class="cov0" title="0">{
                        RPtr(&amp;r).Mul(&amp;r, &amp;r)
                        require.Equal(t, ct.True, RPtr(&amp;r).Equal(&amp;a))
                }</span>
        })
}

func (s *RingalLowLevel[RPtr, R]) CheckAll(t *testing.T) <span class="cov0" title="0">{
        t.Helper()

        s.GroupalLowLevel.CheckAll(t)
        t.Run("multiplication is associative", s.MultiplicationIsAssociate)
        t.Run("multiplication has identity", s.MultiplicationHasIdentity)
        t.Run("multiplication is left distributive", s.MultiplicationIsLeftDistributive)
        t.Run("multiplication is right distributive", s.MultiplicationIsRightDistributive)
        t.Run("can square", s.CanSquare)
        t.Run("might have a multiplicative inverse", s.MaybeHaveMultiplicativeInverse)
        t.Run("might divide", s.MaybeCanDivide)
        t.Run("might have a square root", s.MaybeHaveSquareRoot)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package properties

import (
        "testing"

        "github.com/stretchr/testify/require"
        "pgregory.net/rapid"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func NewLowLevelUniformPrimeFieldElementGenerator[FPtr impl.PrimeFieldElementPtrLowLevel[FPtr, F], F any](t *testing.T, elementSize int) *rapid.Generator[FPtr] <span class="cov0" title="0">{
        t.Helper()

        require.Positive(t, elementSize, "element size must be positive")
        dataSize := elementSize + base.ComputationalSecurityBytesCeil
        uniformBytesGenerator := rapid.SliceOfN(rapid.Byte(), dataSize, dataSize)
        return rapid.Custom(func(t *rapid.T) FPtr </span><span class="cov0" title="0">{
                var fe F
                data := uniformBytesGenerator.Draw(t, "data")
                ok := FPtr(&amp;fe).SetBytesWide(data)
                require.Equal(t, ct.True, ok)
                return &amp;fe
        }</span>)
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package algebra

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra/crtp"
)

type (
        NAry[C any]                = crtp.NAry[C]
        Mapping[F, C any]          = crtp.Mapping[F, C]
        Product[P, C any]          = crtp.Product[P, C]
        CoProduct[P, C any]        = crtp.CoProduct[P, C]
        Power[P, C any]            = crtp.Power[P, C]
        TensorProduct[E, C, S any] = crtp.TensorProduct[E, C, S]
        Tensor[E, S any]           = crtp.Tensor[E, S]
)

type (
        Operand[E any]              crtp.Operand[E]
        FixedCapacityOperand[E any] crtp.FixedCapacityOperand[E]

        DualOperand[E any]              crtp.DualOperand[E]
        FixedCapacityDualOperand[E any] crtp.FixedCapacityDualOperand[E]

        Summand[E any]                   crtp.Summand[E]
        FixedCapacitySummand[E any]      crtp.FixedCapacitySummand[E]
        MaybeSummand[E any]              crtp.MaybeSummand[E]
        MaybeFixedCapacitySummand[E any] crtp.MaybeFixedCapacitySummand[E]

        Minuend[E any]                   crtp.Minuend[E]
        FixedCapacityMinuend[E any]      crtp.FixedCapacityMinuend[E]
        MaybeMinuend[E any]              crtp.MaybeMinuend[E]
        MaybeFixedCapacityMinuend[E any] crtp.MaybeFixedCapacityMinuend[E]

        Multiplicand[E any]                   crtp.Multiplicand[E]
        FixedCapacityMultiplicand[E any]      crtp.FixedCapacityMultiplicand[E]
        MaybeMultiplicand[E any]              crtp.MaybeMultiplicand[E]
        MaybeFixedCapacityMultiplicand[E any] crtp.MaybeFixedCapacityMultiplicand[E]

        Dividend[E any]                   crtp.Dividend[E]
        FixedCapacityDividend[E any]      crtp.FixedCapacityDividend[E]
        MaybeDividend[E any]              crtp.MaybeDividend[E]
        MaybeFixedCapacityDividend[E any] crtp.MaybeFixedCapacityDividend[E]

        ExponentiationBase[B, E any]                   crtp.ExponentiationBase[B, E]
        FixedCapacityExponentiationBase[B, E any]      crtp.FixedCapacityExponentiationBase[B, E]
        MaybeExponentiationBase[B, E any]              crtp.MaybeExponentiationBase[B, E]
        MaybeFixedCapacityExponentiationBase[B, E any] crtp.MaybeFixedCapacityExponentiationBase[B, E]

        IntegerExponentiationBase[B, I any]                   crtp.IntegerExponentiationBase[B, I]
        FixedCapacityIntegerExponentiationBase[B, I any]      crtp.FixedCapacityIntegerExponentiationBase[B, I]
        MaybeIntegerExponentiationBase[B, I any]              crtp.MaybeIntegerExponentiationBase[B, I]
        MaybeFixedCapacityIntegerExponentiationBase[B, I any] crtp.MaybeFixedCapacityIntegerExponentiationBase[B, I]

        Residuand[M, Q any] crtp.Residuand[M, Q]

        Conjunct[E any]      crtp.Conjunct[E]
        MaybeConjunct[E any] crtp.MaybeConjunct[E]

        Disjunct[E any]      crtp.Disjunct[E]
        MaybeDisjunct[E any] crtp.MaybeDisjunct[E]

        ExclusiveDisjunct[E any]      crtp.ExclusiveDisjunct[E]
        MaybeExclusiveDisjunct[E any] crtp.MaybeExclusiveDisjunct[E]

        ArithmeticNegand[E any]      crtp.ArithmeticNegand[E]
        MaybeArithmeticNegand[E any] crtp.MaybeArithmeticNegand[E]

        Inversand[E any]      crtp.Inversand[E]
        MaybeInversand[E any] crtp.MaybeInversand[E]

        BooleanNegand[E any]      crtp.BooleanNegand[E]
        MaybeBooleanNegand[E any] crtp.MaybeBooleanNegand[E]

        Shiftable[E, S any]      crtp.Shiftable[E, S]
        MaybeShiftable[E, S any] crtp.MaybeShiftable[E, S]

        LeftBitwiseShiftable[E any]            crtp.LeftBitwiseShiftable[E]
        FixedLengthLeftBitwiseShiftable[E any] crtp.FixedLengthLeftBitwiseShiftable[E]

        RightBitwiseShiftable[E any]            crtp.RightBitwiseShiftable[E]
        FixedLengthRightBitwiseShiftable[E any] crtp.FixedLengthRightBitwiseShiftable[E]

        Resizable[E, C any]      crtp.Resizable[E, C]
        ResizableCapacity[E any] crtp.ResizableCapacity[E]
)

type Homomorphism[E2 SemiGroupElement[E2], E1 SemiGroupElement[E1]] func(E1) E2

type HomomorphicLike[T any, TV SemiGroupElement[TV]] interface {
        base.Transparent[TV]
        crtp.Operand[T]
        base.Equatable[T]
}

type HomomorphicSummand[T any] interface {
        HomAdd(T) T
}

type HomomorphicMinued[T any] interface {
        HomSub(T) T
}

type HomomorphicNegand[T any] interface {
        HomNeg() T
}

type AdditivelyHomomorphicLike[T HomomorphicLike[T, TV], TV AdditiveSemiGroupElement[TV]] interface {
        HomomorphicLike[T, TV]
        crtp.Summand[T]
}

type AdditivelyHomomorphicLikeInCoDomain[T HomomorphicLike[T, TV], TV GroupElement[TV]] interface {
        HomomorphicLike[T, TV]
        HomomorphicSummand[T]
}

type MultiplicativelyHomomorphicLike[T HomomorphicLike[T, TV], TV MultiplicativeSemiGroupElement[TV]] interface {
        HomomorphicLike[T, TV]
        crtp.Multiplicand[T]
}

func Operator[E Operand[E]](a, b E) E <span class="cov0" title="0">{
        return a.Op(b)
}</span>

func FixedCapacityOperator[E FixedCapacityOperand[E]](a, b E, capacity int) E <span class="cov0" title="0">{
        return a.OpCap(b, capacity)
}</span>

func DualOperator[E DualOperand[E]](a, b E) E <span class="cov0" title="0">{
        return a.OtherOp(b)
}</span>

func FixedCapacityDualOperator[E FixedCapacityDualOperand[E]](a, b E, capacity int) E <span class="cov0" title="0">{
        return a.OtherOpCap(b, capacity)
}</span>

func Addition[E Summand[E]](a, b E) E <span class="cov0" title="0">{
        return a.Add(b)
}</span>

func FixedCapacityAddition[E FixedCapacitySummand[E]](a, b E, capacity int) E <span class="cov0" title="0">{
        return a.AddCap(b, capacity)
}</span>

func MaybeAddition[E MaybeSummand[E]](a, b E) (E, error) <span class="cov0" title="0">{
        return a.TryAdd(b)
}</span>

func MaybeFixedCapacityAddition[E MaybeFixedCapacitySummand[E]](a, b E, capacity int) (E, error) <span class="cov0" title="0">{
        return a.TryAddCap(b, capacity)
}</span>

func Subtraction[E Minuend[E]](a, b E) E <span class="cov0" title="0">{
        return a.Sub(b)
}</span>

func FixedCapacitySubtraction[E FixedCapacityMinuend[E]](a, b E, capacity int) E <span class="cov0" title="0">{
        return a.SubCap(b, capacity)
}</span>
func MaybeSubtraction[E MaybeMinuend[E]](a, b E) (E, error) <span class="cov0" title="0">{
        return a.TrySub(b)
}</span>

func MaybeFixedCapacitySubtraction[E MaybeFixedCapacityMinuend[E]](a, b E, capacity int) (E, error) <span class="cov0" title="0">{
        return a.TrySubCap(b, capacity)
}</span>

func Multiplication[E Multiplicand[E]](a, b E) E <span class="cov0" title="0">{
        return a.Mul(b)
}</span>

func FixedCapacityMultiplication[E FixedCapacityMultiplicand[E]](a, b E, capacity int) E <span class="cov0" title="0">{
        return a.MulCap(b, capacity)
}</span>

func MaybeMultiplication[E MaybeMultiplicand[E]](a, b E) (E, error) <span class="cov0" title="0">{
        return a.TryMul(b)
}</span>

func MaybeFixedCapacityMultiplication[E MaybeFixedCapacityMultiplicand[E]](a, b E, capacity int) (E, error) <span class="cov0" title="0">{
        return a.TryMulCap(b, capacity)
}</span>

func Division[E Dividend[E]](a, b E) E <span class="cov0" title="0">{
        return a.Div(b)
}</span>

func FixedCapacityDivision[E FixedCapacityDividend[E]](a, b E, capacity int) E <span class="cov0" title="0">{
        return a.DivCap(b, capacity)
}</span>

func MaybeDivision[E MaybeDividend[E]](a, b E) (E, error) <span class="cov0" title="0">{
        return a.TryDiv(b)
}</span>

func MaybeFixedCapacityDivision[E MaybeFixedCapacityDividend[E]](a, b E, capacity int) (E, error) <span class="cov0" title="0">{
        return a.TryDivCap(b, capacity)
}</span>

func Modulo[E Residuand[M, Q], M Element[M], Q Residue[Q, M]](x E, m M) (Q, error) <span class="cov0" title="0">{
        return x.Mod(m)
}</span>

func Exponentiate[A ExponentiationBase[A, E], E Element[E]](b A, exponent E) A <span class="cov0" title="0">{
        return b.Exp(exponent)
}</span>

func FixedCapacityExponentiate[A FixedCapacityExponentiationBase[A, E], E Element[E]](b A, exponent E, capacity int) A <span class="cov0" title="0">{
        return b.ExpCap(exponent, capacity)
}</span>

func MaybeExponentiate[A MaybeExponentiationBase[A, E], E Element[E]](b A, exponent E) (A, error) <span class="cov0" title="0">{
        return b.TryExp(exponent)
}</span>

func MaybeFixedCapacityExponentiate[A MaybeFixedCapacityExponentiationBase[A, E], E Element[E]](b A, exponent E, capacity int) (A, error) <span class="cov0" title="0">{
        return b.TryExpCap(exponent, capacity)
}</span>

func And[E Conjunct[E]](a, b E) E <span class="cov0" title="0">{
        return a.And(b)
}</span>

func MaybeAnd[E MaybeConjunct[E]](a, b E) (E, error) <span class="cov0" title="0">{
        return a.TryAnd(b)
}</span>

func Or[E Disjunct[E]](a, b E) E <span class="cov0" title="0">{
        return a.Or(b)
}</span>

func MaybeOr[E MaybeDisjunct[E]](a, b E) (E, error) <span class="cov0" title="0">{
        return a.TryOr(b)
}</span>

func Xor[E ExclusiveDisjunct[E]](a, b E) E <span class="cov0" title="0">{
        return a.Xor(b)
}</span>

func MaybeXor[E MaybeExclusiveDisjunct[E]](a, b E) (E, error) <span class="cov0" title="0">{
        return a.TryXor(b)
}</span>

func Negate[E ArithmeticNegand[E]](a E) E <span class="cov0" title="0">{
        return a.Neg()
}</span>

func MaybeNegate[E MaybeArithmeticNegand[E]](a E) (E, error) <span class="cov0" title="0">{
        return a.TryNeg()
}</span>

func Invert[E Inversand[E]](a E) E <span class="cov0" title="0">{
        return a.Inv()
}</span>

func MaybeInvert[E MaybeInversand[E]](a E) (E, error) <span class="cov0" title="0">{
        return a.TryInv()
}</span>

func Not[E BooleanNegand[E]](a E) E <span class="cov0" title="0">{
        return a.Not()
}</span>

func MaybeNot[E MaybeBooleanNegand[E]](a E) (E, error) <span class="cov0" title="0">{
        return a.TryNot()
}</span>

func Shift[E Shiftable[E, S], S any](a E, shift S) E <span class="cov0" title="0">{
        return a.Shift(shift)
}</span>

func MaybeShift[E MaybeShiftable[E, S], S any](a E, shift S) (E, error) <span class="cov0" title="0">{
        return a.TryShift(shift)
}</span>

func LeftBitwiseShift[E LeftBitwiseShiftable[E]](a E, shift uint) E <span class="cov0" title="0">{
        return a.Lsh(shift)
}</span>

func FixedLengthLeftBitwiseShift[E FixedLengthLeftBitwiseShiftable[E]](a E, shift uint, capacity int) E <span class="cov0" title="0">{
        return a.LshCap(shift, capacity)
}</span>

func RightBitwiseShift[E RightBitwiseShiftable[E]](a E, shift uint) E <span class="cov0" title="0">{
        return a.Rsh(shift)
}</span>

func FixedLengthRightBitwiseShift[E FixedLengthRightBitwiseShiftable[E]](a E, shift uint, capacity int) E <span class="cov0" title="0">{
        return a.RshCap(shift, capacity)
}</span>

func Resize[E Resizable[E, C], C any](a E, capacity C) E <span class="cov0" title="0">{
        return a.Resize(capacity)
}</span>

func ResizeCapacity[E ResizableCapacity[E]](a E, capacity int) E <span class="cov0" title="0">{
        return a.Resize(capacity)
}</span>

func IsLessThanOrEqual[E base.Comparable[E]](lhs, rhs E) bool <span class="cov0" title="0">{
        return lhs.IsLessThanOrEqual(rhs)
}</span>

func Compare[E base.WithInternalCompareMethod[E]](lhs, rhs E) base.Ordering <span class="cov0" title="0">{
        return lhs.Compare(rhs)
}</span>

func PartialCompare[E base.WithInternalPartialCompareMethod[E]](lhs, rhs E) base.PartialOrdering <span class="cov0" title="0">{
        return lhs.PartialCompare(rhs)
}</span>

func ScalarOp[E Actable[E, S], S Element[S]](sc S, a E) E <span class="cov0" title="0">{
        return a.ScalarOp(sc)
}</span>

func ScalarMultiply[E AdditivelyActable[E, S], S Element[S]](sc S, a E) E <span class="cov0" title="0">{
        return a.ScalarMul(sc)
}</span>

func ScalarExponentiate[E MultiplicativelyActable[E, S], S Element[S]](sc S, a E) E <span class="cov0" title="0">{
        return a.ScalarExp(sc)
}</span>

func Equal[E base.Equatable[E]](a, b E) bool <span class="cov0" title="0">{
        return a.Equal(b)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package properties

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "pgregory.net/rapid"
)

func UniformDomainGenerator[E algebra.Element[E]](domain algebra.FiniteStructure[E]) *rapid.Generator[E] <span class="cov0" title="0">{
        genFunc := func(t *rapid.T) E </span><span class="cov0" title="0">{
                entropyLen := domain.ElementSize()
                entropyData := rapid.SliceOfN(rapid.Byte(), 0, entropyLen).Draw(t, "preimage")
                return errs2.Must1(domain.Hash(entropyData))
        }</span>
        <span class="cov0" title="0">return rapid.Custom(genFunc)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package properties

import (
        "slices"
        "testing"

        "github.com/stretchr/testify/require"

        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

type Model[S Structure, E Element] struct {
        *Carrier[S, E]

        Theory []Axiom
}

func (m *Model[S, E]) Check(t *testing.T) <span class="cov0" title="0">{
        t.Helper()
        check(t, m.Theory...)
}</span>

type TwoSortedModel[
        S1, S2 Structure,
        E1, E2 Element,
] struct {
        *Carrier2[S1, S2, E1, E2]

        Theory []Axiom
}

func (m *TwoSortedModel[S1, S2, E1, E2]) Check(t *testing.T) <span class="cov0" title="0">{
        t.Helper()
        check(t, m.Theory...)
}</span>

func Union[S Structure, E Element](t *testing.T, models ...*Model[S, E]) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        require.NotEmpty(t, models)
        for _, m := range models </span><span class="cov0" title="0">{
                require.Equal(t, models[0].Value.Name(), m.Value.Name())
        }</span>
        <span class="cov0" title="0">return &amp;Model[S, E]{
                Carrier: models[0].Carrier,
                Theory: slices.Concat(
                        sliceutils.Map(
                                models,
                                func(m *Model[S, E]) []Axiom </span><span class="cov0" title="0">{ return m.Theory }</span>,
                        )...,
                ),
        }
}

func Union2[
        S1, S2 Structure,
        E1, E2 Element,
](t *testing.T, models ...*TwoSortedModel[S1, S2, E1, E2]) *TwoSortedModel[S1, S2, E1, E2] <span class="cov0" title="0">{
        t.Helper()
        require.NotEmpty(t, models)
        for _, m := range models </span><span class="cov0" title="0">{
                require.Equal(t, models[0].First.Value.Name(), m.First.Value.Name())
                require.Equal(t, models[0].Second.Value.Name(), m.Second.Value.Name())
        }</span>
        <span class="cov0" title="0">return &amp;TwoSortedModel[S1, S2, E1, E2]{
                Carrier2: models[0].Carrier2,
                Theory: slices.Concat(
                        sliceutils.Map(
                                models,
                                func(m *TwoSortedModel[S1, S2, E1, E2]) []Axiom </span><span class="cov0" title="0">{ return m.Theory }</span>,
                        )...,
                ),
        }
}

func UnionAlongFirst[
        S1, S2 Structure,
        E1, E2 Element,
](t *testing.T, model *TwoSortedModel[S1, S2, E1, E2], others ...*Model[S1, E1]) *TwoSortedModel[S1, S2, E1, E2] <span class="cov0" title="0">{
        t.Helper()
        require.NotEmpty(t, others)
        for _, m := range others </span><span class="cov0" title="0">{
                require.Equal(t, model.First.Value.Name(), m.Value.Name())
        }</span>
        <span class="cov0" title="0">return &amp;TwoSortedModel[S1, S2, E1, E2]{
                Carrier2: model.Carrier2,
                Theory: append(
                        model.Theory,
                        slices.Concat(
                                sliceutils.Map(
                                        others,
                                        func(m *Model[S1, E1]) []Axiom </span><span class="cov0" title="0">{ return m.Theory }</span>,
                                )...,
                        )...,
                ),
        }
}

func UnionAlongSecond[
        S1, S2 Structure,
        E1, E2 Element,
](t *testing.T, model *TwoSortedModel[S1, S2, E1, E2], others ...*Model[S2, E2]) *TwoSortedModel[S1, S2, E1, E2] <span class="cov0" title="0">{
        t.Helper()
        require.NotEmpty(t, others)
        for _, m := range others </span><span class="cov0" title="0">{
                require.Equal(t, model.Second.Value.Name(), m.Value.Name())
        }</span>
        <span class="cov0" title="0">return &amp;TwoSortedModel[S1, S2, E1, E2]{
                Carrier2: model.Carrier2,
                Theory: append(
                        model.Theory,
                        slices.Concat(
                                sliceutils.Map(
                                        others,
                                        func(m *Model[S2, E2]) []Axiom </span><span class="cov0" title="0">{ return m.Theory }</span>,
                                )...,
                        )...,
                ),
        }
}

func Pair[
        S1, S2 Structure,
        E1, E2 Element,
](t *testing.T, first *Model[S1, E1], second *Model[S2, E2]) *TwoSortedModel[S1, S2, E1, E2] <span class="cov0" title="0">{
        t.Helper()
        return &amp;TwoSortedModel[S1, S2, E1, E2]{
                Carrier2: &amp;Carrier2[S1, S2, E1, E2]{
                        First:  first.Carrier,
                        Second: second.Carrier,
                        Action: nil,
                },
                Theory: slices.Concat(first.Theory, second.Theory),
        }
}</span>

func PairWithAction[
        S1, S2 Structure,
        E1, E2 Element,
](t *testing.T, first *Model[S1, E1], second *Model[S2, E2], action *Action[E2, E1]) *TwoSortedModel[S1, S2, E1, E2] <span class="cov0" title="0">{
        t.Helper()
        return &amp;TwoSortedModel[S1, S2, E1, E2]{
                Carrier2: &amp;Carrier2[S1, S2, E1, E2]{
                        First:  first.Carrier,
                        Second: second.Carrier,
                        Action: action,
                },
                Theory: slices.Concat(first.Theory, second.Theory),
        }
}</span>

func check(t *testing.T, axioms ...Axiom) <span class="cov0" title="0">{
        t.Helper()
        for _, a := range axioms </span><span class="cov0" title="0">{
                t.Run(a.Name, func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Parallel()
                        a.CheckFunc(t)
                }</span>)
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package properties

import (
        "testing"

        "github.com/stretchr/testify/require"
        "pgregory.net/rapid"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
)

// ************************* Group-like.

func Set[S Structure, E Element](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        st := &amp;Carrier[S, E]{
                Value: structure,
                Dist:  g,
        }
        return &amp;Model[S, E]{
                Carrier: st,
                Theory:  nil,
        }
}</span>

func Magma[S algebra.Magma[E], E algebra.MagmaElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E], op *BinaryOperator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        st := &amp;Carrier[S, E]{
                Value: structure,
                Dist:  g,
        }
        return &amp;Model[S, E]{
                Carrier: st,
                Theory: append(
                        EqualityProperties(t, st, Equality[E]()),
                        ClosureProperty(t, st, op),
                ),
        }
}</span>

func SemiGroup[S algebra.SemiGroup[E], E algebra.SemiGroupElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E], op *BinaryOperator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        magmaModel := Magma(t, structure, g, op)
        return &amp;Model[S, E]{
                Carrier: magmaModel.Carrier,
                Theory: append(magmaModel.Theory,
                        AssociativityProperty(t, magmaModel.Carrier, op),
                ),
        }
}</span>

func AdditiveSemiGroup[S algebra.AdditiveSemiGroup[E], E algebra.AdditiveSemiGroupElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        semiGroup := SemiGroup(t, structure, g, Addition[E]())
        return &amp;Model[S, E]{
                Carrier: semiGroup.Carrier,
                Theory: append(semiGroup.Theory,
                        CanDoubleProperty(t, semiGroup.Carrier),
                ),
        }
}</span>

func CyclicSemiGroup[S algebra.CyclicSemiGroup[E], E algebra.CyclicSemiGroupElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E], op *BinaryOperator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        semiGroup := SemiGroup(t, structure, g, op)
        return &amp;Model[S, E]{
                Carrier: semiGroup.Carrier,
                Theory: append(semiGroup.Theory,
                        CyclicProperty(t, semiGroup.Carrier, op),
                ),
        }
}</span>

func MultiplicativeSemiGroup[S algebra.MultiplicativeSemiGroup[E], E algebra.MultiplicativeSemiGroupElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        semiGroup := SemiGroup(t, structure, g, Multiplication[E]())
        return &amp;Model[S, E]{
                Carrier: semiGroup.Carrier,
                Theory: append(semiGroup.Theory,
                        CanSquareProperty(t, semiGroup.Carrier),
                ),
        }
}</span>

func Monoid[S algebra.Monoid[E], E algebra.MonoidElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E], op *BinaryOperator[E], identity *Constant[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        semiGroup := SemiGroup(t, structure, g, op)
        return &amp;Model[S, E]{
                Carrier: semiGroup.Carrier,
                Theory: append(semiGroup.Theory,
                        IdentityProperty(t, semiGroup.Carrier, op, identity),
                ),
        }
}</span>

func AdditiveMonoid[S algebra.AdditiveMonoid[E], E algebra.AdditiveMonoidElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        monoid := Monoid(t, structure, g, Addition[E](), AdditiveIdentity(structure))
        additiveSemiGroup := AdditiveSemiGroup(t, structure, g)
        out := Union(t, monoid, additiveSemiGroup)
        out.Theory = append(monoid.Theory,
                CanDistinguishAdditiveIdentity(t, monoid.Carrier),
                CanTrySub(t, monoid.Carrier),
                CanTryNeg(t, monoid.Carrier),
        )
        return monoid
}</span>

func MultiplicativeMonoid[S algebra.MultiplicativeMonoid[E], E algebra.MultiplicativeMonoidElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        monoid := Monoid(t, structure, g, Multiplication[E](), MultiplicativeIdentity(structure))
        multiplicativeSemiGroup := MultiplicativeSemiGroup(t, structure, g)
        out := Union(t, monoid, multiplicativeSemiGroup)
        out.Theory = append(monoid.Theory,
                CanDistinguishMultiplicativeIdentity(t, monoid.Carrier),
                CanTryDiv(t, monoid.Carrier),
                CanTryInv(t, monoid.Carrier),
        )
        return monoid
}</span>

func CyclicMonoid[S algebra.CyclicMonoid[E], E algebra.CyclicMonoidElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E], op *BinaryOperator[E], identity *Constant[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        monoid := Monoid(t, structure, g, op, identity)
        cyclicSemiGroup := CyclicSemiGroup(t, structure, g, op)
        return Union(t, monoid, cyclicSemiGroup)
}</span>

func Group[S algebra.Group[E], E algebra.GroupElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E], op *BinaryOperator[E],
        identity *Constant[E], inv *UnaryOperator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        monoid := Monoid(t, structure, g, op, identity)
        return &amp;Model[S, E]{
                Carrier: monoid.Carrier,
                Theory: append(monoid.Theory,
                        GroupInverseProperty(t, monoid.Carrier, op, identity, inv),
                ),
        }
}</span>

func AdditiveGroup[S algebra.AdditiveGroup[E], E algebra.AdditiveGroupElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        group := Group(t, structure, g, Addition[E](), AdditiveIdentity(structure), Negation[E]())
        additiveMonoid := AdditiveMonoid(t, structure, g)
        out := Union(t, group, additiveMonoid)
        out.Theory = append(group.Theory,
                CanTrySub(t, group.Carrier),
                CanTryNeg(t, group.Carrier),
        )
        return out
}</span>

func MultiplicativeGroup[S algebra.MultiplicativeGroup[E], E algebra.MultiplicativeGroupElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        group := Group(t, structure, g, Multiplication[E](), MultiplicativeIdentity(structure), Inversion[E]())
        multiplicativeMonoid := MultiplicativeMonoid(t, structure, g)
        out := Union(t, group, multiplicativeMonoid)
        out.Theory = append(group.Theory,
                CanTryDiv(t, group.Carrier),
                CanTryInv(t, group.Carrier),
        )
        return out
}</span>

func CyclicGroup[S algebra.CyclicGroup[E], E algebra.CyclicGroupElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E], op *BinaryOperator[E],
        identity *Constant[E], inv *UnaryOperator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        group := Group(t, structure, g, op, identity, inv)
        cyclicMonoid := CyclicMonoid(t, structure, g, op, identity)
        return Union(t, group, cyclicMonoid)
}</span>

func DoubleMagma[S algebra.DoubleMagma[E], E algebra.DoubleMagmaElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
        op1, op2 *BinaryOperator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        magma1 := Magma(t, structure, g, op1)
        magma2 := Magma(t, structure, g, op2)
        return Union(t, magma1, magma2)
}</span>

func HemiRing[S algebra.HemiRing[E], E algebra.HemiRingElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        additiveSemiGroup := AdditiveSemiGroup(t, structure, g)
        multiplicativeSemiGroup := MultiplicativeSemiGroup(t, structure, g)
        out := Union(t, additiveSemiGroup, multiplicativeSemiGroup)
        out.Theory = append(out.Theory,
                HemiRingIsStandardProperty(t, out.Carrier),
                DistributivityOfMulOverAddProperty(t, out.Carrier),
        )
        return out
}</span>

func SemiRing[S algebra.SemiRing[E], E algebra.SemiRingElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        hemiRing := HemiRing(t, structure, g)
        multiplicativeMonoid := MultiplicativeMonoid(t, structure, g)
        out := Union(t, hemiRing, multiplicativeMonoid)
        return out
}</span>

func Rig[S algebra.Rig[E], E algebra.RigElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        semiRing := SemiRing(t, structure, g)
        additiveMonoid := AdditiveMonoid(t, structure, g)
        out := Union(t, semiRing, additiveMonoid)
        return out
}</span>

func EuclideanSemiDomain[S algebra.EuclideanSemiDomain[E], E algebra.EuclideanSemiDomainElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        ring := Rig(t, structure, g)
        out := &amp;Model[S, E]{
                Carrier: ring.Carrier,
                Theory: append(ring.Theory,
                        EuclideanDivisionProperty(t, ring.Carrier),
                ),
        }
        return out
}</span>

func Rng[S algebra.Rng[E], E algebra.RngElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        hemiRing := HemiRing(t, structure, g)
        additiveGroup := AdditiveGroup(t, structure, g)
        out := Union(t, hemiRing, additiveGroup)
        return out
}</span>

func Ring[S algebra.Ring[E], E algebra.RingElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        rng := Rng(t, structure, g)
        rig := Rig(t, structure, g)
        out := Union(t, rng, rig)
        return out
}</span>

func EuclideanDomain[S algebra.EuclideanDomain[E], E algebra.EuclideanDomainElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        ring := Ring(t, structure, g)
        euclideanSemiDomain := EuclideanSemiDomain(t, structure, g)
        return Union(t, ring, euclideanSemiDomain)
}</span>

func Field[S algebra.Field[E], E algebra.FieldElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        require.Positive(t, structure.ExtensionDegree())
        require.False(t, structure.Zero().Equal(structure.One())) // Requirement to rule out trivial rings.
        out := EuclideanDomain(t, structure, g)
        out.Theory = append(out.Theory,
                EveryNonZeroElementHasMultiplicativeInverseProperty(t, out.Carrier),
                CommutativityProperty(t, out.Carrier, Addition[E]()),
                CommutativityProperty(t, out.Carrier, Multiplication[E]()),
        )
        return out
}</span>

func FieldExtension[S algebra.FieldExtension[E], E algebra.FieldExtensionElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        out := Field(t, structure, g)
        out.Theory = append(out.Theory,
                FieldExtensionComponentBytesRoundTripProperty(t, out.Carrier),
        )
        return out
}</span>

func FiniteField[S algebra.FiniteField[E], E algebra.FiniteFieldElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        return Field(t, structure, g)
}</span>

func SemiModule[S algebra.SemiModule[E, RE], R algebra.SemiRing[RE], E algebra.SemiModuleElement[E, RE], RE algebra.SemiRingElement[RE]](
        t *testing.T, structure S, scalarRing R, g *rapid.Generator[E], gb *rapid.Generator[RE],
        op *BinaryOperator[E], identity *Constant[E],
        scalarOp *Action[RE, E],
) *TwoSortedModel[S, R, E, RE] <span class="cov0" title="0">{
        t.Helper()
        monoid := Monoid(t, structure, g, op, identity)
        baseSemiRing := SemiRing(t, scalarRing, gb)
        out := PairWithAction(t, monoid, baseSemiRing, scalarOp)
        out.Theory = append(out.Theory,
                CommutativityProperty(t, out.First, op),
                CommutativityProperty(t, out.Second, Addition[RE]()),
                CommutativityProperty(t, out.Second, Multiplication[RE]()),
                LeftDistributivityOfActionOverSemiModuleOperationProperty(t, out.Carrier2),
                RightDistributivityOfSemiModuleOperationOverBaseSemiRingAdditionProperty(t, out.Carrier2),
                AssociativityOfScalarsWRTRingMultiplicationProperty(t, out.Carrier2),
        )
        return out
}</span>

func AdditiveSemiModule[S algebra.AdditiveSemiModule[E, RE], R algebra.SemiRing[RE], E algebra.AdditiveSemiModuleElement[E, RE], RE algebra.SemiRingElement[RE]](
        t *testing.T, structure S, scalarRing R, g *rapid.Generator[E], gb *rapid.Generator[RE],
) *TwoSortedModel[S, R, E, RE] <span class="cov0" title="0">{
        t.Helper()
        semiModule := SemiModule(t, structure, scalarRing, g, gb, Addition[E](), AdditiveIdentity(structure), ScalarMultiplication[E]())
        additiveMonoid := AdditiveMonoid(t, structure, g)
        out := UnionAlongFirst(t, semiModule, additiveMonoid)
        out.Theory = append(out.Theory,
                ScalarOpIsScalarMultiplicationProperty(t, out.Carrier2),
        )
        return out
}</span>

func MultiplicativeSemiModule[S algebra.MultiplicativeSemiModule[E, RE], R algebra.SemiRing[RE], E algebra.MultiplicativeSemiModuleElement[E, RE], RE algebra.SemiRingElement[RE]](
        t *testing.T, structure S, scalarRing R, g *rapid.Generator[E], gb *rapid.Generator[RE],
) *TwoSortedModel[S, R, E, RE] <span class="cov0" title="0">{
        t.Helper()
        semiModule := SemiModule(t, structure, scalarRing, g, gb, Multiplication[E](), MultiplicativeIdentity(structure), ScalarExponentiation[E]())
        multiplicativeMonoid := MultiplicativeMonoid(t, structure, g)
        out := UnionAlongFirst(t, semiModule, multiplicativeMonoid)
        out.Theory = append(out.Theory,
                ScalarOpIsScalarExponentiationProperty(t, out.Carrier2),
        )
        return out
}</span>

func Module[S algebra.Module[E, RE], R algebra.Ring[RE], E algebra.ModuleElement[E, RE], RE algebra.RingElement[RE]](
        t *testing.T, structure S, scalarRing R, g *rapid.Generator[E], gb *rapid.Generator[RE],
        op *BinaryOperator[E], identity *Constant[E], inv *UnaryOperator[E],
        scalarOp *Action[RE, E],
) *TwoSortedModel[S, R, E, RE] <span class="cov0" title="0">{
        t.Helper()
        semiModule := SemiModule(t, structure, scalarRing, g, gb, op, identity, scalarOp)
        group := Group(t, structure, g, op, identity, inv)
        out := UnionAlongFirst(t, semiModule, group)
        out.Theory = append(out.Theory,
                BaseRingIdentityActsAsModuleIdentityProperty(t, out.Carrier2),
        )
        return out
}</span>

func AdditiveModule[S algebra.AdditiveModule[E, RE], R algebra.Ring[RE], E algebra.AdditiveModuleElement[E, RE], RE algebra.RingElement[RE]](
        t *testing.T, structure S, scalarRing R, g *rapid.Generator[E], gb *rapid.Generator[RE],
) *TwoSortedModel[S, R, E, RE] <span class="cov0" title="0">{
        t.Helper()
        module := Module(t, structure, scalarRing, g, gb, Addition[E](), AdditiveIdentity(structure), Negation[E](), ScalarMultiplication[E]())
        additiveSemiModule := AdditiveSemiModule(t, structure, scalarRing, g, gb)
        additiveGroup := AdditiveGroup(t, structure, g)
        out := UnionAlongFirst(t, Union2(t, module, additiveSemiModule), additiveGroup)
        out.Theory = append(out.Theory,
                ScalarOpIsScalarMultiplicationProperty(t, out.Carrier2),
        )
        return out
}</span>

func MultiplicativeModule[S algebra.MultiplicativeModule[E, RE], R algebra.Ring[RE], E algebra.MultiplicativeModuleElement[E, RE], RE algebra.RingElement[RE]](
        t *testing.T, structure S, scalarRing R, g *rapid.Generator[E], gb *rapid.Generator[RE],
) *TwoSortedModel[S, R, E, RE] <span class="cov0" title="0">{
        t.Helper()
        module := Module(t, structure, scalarRing, g, gb, Multiplication[E](), MultiplicativeIdentity(structure), Inversion[E](), ScalarExponentiation[E]())
        multiplicativeSemiModule := MultiplicativeSemiModule(t, structure, scalarRing, g, gb)
        multiplicativeGroup := MultiplicativeGroup(t, structure, g)
        out := UnionAlongFirst(t, Union2(t, module, multiplicativeSemiModule), multiplicativeGroup)
        out.Theory = append(out.Theory,
                ScalarOpIsScalarExponentiationProperty(t, out.Carrier2),
        )
        return out
}</span>

func VectorSpace[
        S algebra.VectorSpace[E, FE], F algebra.Field[FE],
        E algebra.Vector[E, FE], FE algebra.FieldElement[FE],
](
        t *testing.T, structure S, scalarField F, g *rapid.Generator[E], gb *rapid.Generator[FE],
        op *BinaryOperator[E], identity *Constant[E], inv *UnaryOperator[E],
        scalarOp *Action[FE, E],
) *TwoSortedModel[S, F, E, FE] <span class="cov0" title="0">{
        t.Helper()
        module := Module(t, structure, scalarField, g, gb, op, identity, inv, scalarOp)
        field := Field(t, scalarField, gb)
        return UnionAlongSecond(t, module, field)
}</span>

func Algebra[S algebra.Algebra[AE, RE], R algebra.Ring[RE], AE algebra.AlgebraElement[AE, RE], RE algebra.RingElement[RE]](
        t *testing.T, structure S, scalarRing R, g *rapid.Generator[AE], gb *rapid.Generator[RE],
) *TwoSortedModel[S, R, AE, RE] <span class="cov0" title="0">{
        t.Helper()
        module := AdditiveModule(t, structure, scalarRing, g, gb)
        ring := Ring(t, structure, g)
        out := UnionAlongFirst(t, module, ring)
        return out
}</span>

func PolynomialRing[
        PS algebra.PolynomialRing[P, S], SS algebra.Ring[S],
        P algebra.Polynomial[P, S], S algebra.RingElement[S],
](
        t *testing.T, structure PS, coeffRing SS, g *rapid.Generator[P], gb *rapid.Generator[S],
) *TwoSortedModel[PS, SS, P, S] <span class="cov0" title="0">{
        t.Helper()
        alg := Algebra(t, structure, coeffRing, g, gb)
        euclideanDomain := EuclideanDomain(t, structure, g)
        out := UnionAlongFirst(t, alg, euclideanDomain)
        out.Theory = append(out.Theory,
                PolynomialLikeConstantTermProperty[PS, SS, SS](t, out.First),
                PolynomialLikeIsConstantProperty[PS, SS, SS](t, out.First),
                PolynomialLikeDegreeProperty[PS, SS, SS](t, out.First),
                PolynomialLikeDerivativeDegreeDeclinesProperty[PS, SS, SS](t, out.First),
                PolynomialLikeDerivativeOfConstantIsZeroProperty[PS, SS, SS](t, out.First),
                UnivariatePolynomialLikeFromCoefficientsRoundTripProperty(t, out.First),
                PolynomialLeadingCoefficientProperty(t, out.First),
                PolynomialEvalAtZeroProperty(t, out.First, coeffRing),
                PolynomialEvalConstantProperty(t, out.First, gb),
        )
        return out
}</span>

func PolynomialModule[
        PM algebra.PolynomialModule[MP, P, C, S],
        CS algebra.Module[C, S],
        SS algebra.Ring[S],
        MP algebra.ModuleValuedPolynomial[MP, P, C, S],
        P algebra.Polynomial[P, S],
        C algebra.ModuleElement[C, S],
        S algebra.RingElement[S],
](
        t *testing.T, structure PM, scalars SS, g *rapid.Generator[MP], gs *rapid.Generator[S],
        op *BinaryOperator[MP], identity *Constant[MP], inv *UnaryOperator[MP],
        scalarOp *Action[S, MP],
) *TwoSortedModel[PM, SS, MP, S] <span class="cov0" title="0">{
        t.Helper()
        module := Module(t, structure, scalars, g, gs, op, identity, inv, scalarOp)
        module.Theory = append(module.Theory,
                PolynomialLikeConstantTermProperty[PM, SS, CS](t, module.First),
                PolynomialLikeIsConstantProperty[PM, SS, CS](t, module.First),
                PolynomialLikeDegreeProperty[PM, SS, CS](t, module.First),
                PolynomialLikeDerivativeDegreeDeclinesProperty[PM, SS, CS](t, module.First),
                PolynomialLikeDerivativeOfConstantIsZeroProperty[PM, SS, CS](t, module.First),
        )
        return module
}</span>

func NumericStructure[S interface {
        Structure
        algebra.NumericStructure[E]
}, E interface {
        algebra.Numeric
        base.Equatable[E]
}](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        out := Set(t, structure, g)
        out.Theory = append(out.Theory,
                NumericStructureFromBytesBERoundTripProperty(t, out.Carrier),
        )
        return out
}</span>

func NPlusLike[S algebra.NPlusLike[E], E algebra.NatPlusLike[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        numericStructure := NumericStructure(t, structure, g)
        out := &amp;Model[S, E]{
                Carrier: numericStructure.Carrier,
                Theory: append(numericStructure.Theory,
                        FromCardinalRoundTripProperty(t, numericStructure.Carrier),
                        AnyNumberIsEitherOddOrEvenProperty(t, numericStructure.Carrier),
                ),
        }
        return out
}</span>

func NLike[S algebra.NLike[E], E algebra.NatLike[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        nPlusLike := NPlusLike(t, structure, g)
        euclideanSemiDomain := EuclideanSemiDomain(t, structure, g)
        out := Union(t, nPlusLike, euclideanSemiDomain)
        out.Theory = append(nPlusLike.Theory,
                AnyNaturalNumberIsEitherZeroOrPositiveProperty(t, out.Carrier),
        )
        return out
}</span>

func ZLike[S algebra.ZLike[E], E algebra.IntLike[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        out := EuclideanDomain(t, structure, g)
        out.Theory = append(out.Theory,
                AnyNumberIsEitherOddOrEvenProperty(t, out.Carrier),
                AnyIntegerIsEitherPositiveOrNegativeOrZero(t, out.Carrier),
        )
        return out
}</span>

func ZModLike[S algebra.ZModLike[E], E algebra.UintLike[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        nLike := NLike(t, structure, g)
        ring := Ring(t, structure, g)
        out := Union(t, ring, nLike)
        out.Theory = append(out.Theory,
                ZModFromBytesBEReduceRoundTripProperty(t, out.Carrier),
        )
        return out
}</span>

func PrimeField[S algebra.PrimeField[E], E algebra.PrimeFieldElement[E]](
        t *testing.T, structure S, g *rapid.Generator[E],
) *Model[S, E] <span class="cov0" title="0">{
        t.Helper()
        require.Greater(t, structure.BitLen(), 1)
        require.True(t, structure.Characteristic().IsProbablyPrime())
        field := Field(t, structure, g)
        zModLike := ZModLike(t, structure, g)
        out := Union(t, field, zModLike)
        out.Theory = append(field.Theory,
                FromWideBytesRoundTripProperty(t, out.Carrier),
        )
        return out
}</span>

func AbelianGroup[S algebra.AbelianGroup[E, RE], R algebra.Ring[RE], E algebra.AbelianGroupElement[E, RE], RE algebra.RingElement[RE]](
        t *testing.T, structure S, scalarRing R, g *rapid.Generator[E], gb *rapid.Generator[RE],
        op *BinaryOperator[E], identity *Constant[E], inv *UnaryOperator[E],
        scalarOp *Action[RE, E],
) *TwoSortedModel[S, R, E, RE] <span class="cov0" title="0">{
        t.Helper()
        return Module(t, structure, scalarRing, g, gb, op, identity, inv, scalarOp)
}</span>

func PrimeGroup[
        S algebra.PrimeGroup[E, FE], F algebra.PrimeField[FE],
        E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE],
](
        t *testing.T, structure S, scalarField F, g *rapid.Generator[E], gb *rapid.Generator[FE],
        op *BinaryOperator[E], scalarOp *Action[FE, E],
        identity *Constant[E], inv *UnaryOperator[E],
) *TwoSortedModel[S, F, E, FE] <span class="cov0" title="0">{
        t.Helper()
        abelianGroup := AbelianGroup(t, structure, scalarField, g, gb, op, identity, inv, scalarOp)
        vectorSpace := VectorSpace(t, structure, scalarField, g, gb, op, identity, inv, scalarOp)
        cyclicSemiGroup := CyclicSemiGroup(t, structure, g, op)
        primeField := PrimeField(t, scalarField, gb)
        out := UnionAlongSecond(
                t,
                UnionAlongFirst(
                        t,
                        Union2(t, abelianGroup, vectorSpace),
                        cyclicSemiGroup,
                ),
                primeField,
        )
        out.Theory = append(out.Theory,
                CanScalarBaseOp(t, out.Carrier2),
        )
        require.True(t, out.First.Value.Order().Equal(out.Second.Value.Characteristic()), "prime group order must match base field characteristic")
        return out
}</span>

func AdditivePrimeGroup[
        S algebra.AdditivePrimeGroup[E, FE], F algebra.PrimeField[FE],
        E algebra.AdditivePrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE],
](
        t *testing.T, structure S, scalarField F, g *rapid.Generator[E], gb *rapid.Generator[FE],
) *TwoSortedModel[S, F, E, FE] <span class="cov0" title="0">{
        t.Helper()
        out := PrimeGroup(t, structure, scalarField, g, gb, Addition[E](), ScalarMultiplication[E](), AdditiveIdentity(structure), Negation[E]())
        out.Theory = append(out.Theory,
                CanScalarBaseMul(t, out.Carrier2),
        )
        return out
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package properties

import "github.com/bronlabs/bron-crypto/pkg/base/algebra"

type Action[SC, E Element] struct {
        Name string
        Func func(SC, E) E
}

type Constant[E Element] struct {
        Name  string
        Value func() E
}

type UnaryOperator[E Element] struct {
        Name string
        Func func(E) E
}

type BinaryOperator[E Element] struct {
        Name string
        Func func(E, E) E
}

type Predicate[E Element] struct {
        Name string
        Func func(E) bool
}

type Relation[E Element] struct {
        Name string
        Func func(E, E) bool
}

func Addition[E interface {
        algebra.Element[E]
        algebra.Summand[E]
}]() *BinaryOperator[E] <span class="cov0" title="0">{
        return &amp;BinaryOperator[E]{
                Name: "Addition",
                Func: func(a, b E) E </span><span class="cov0" title="0">{
                        return a.Add(b)
                }</span>,
        }
}

func Multiplication[E interface {
        algebra.Element[E]
        algebra.Multiplicand[E]
}]() *BinaryOperator[E] <span class="cov0" title="0">{
        return &amp;BinaryOperator[E]{
                Name: "Multiplication",
                Func: func(a, b E) E </span><span class="cov0" title="0">{
                        return a.Mul(b)
                }</span>,
        }
}

func Equality[E algebra.Element[E]]() *Relation[E] <span class="cov0" title="0">{
        return &amp;Relation[E]{
                Name: "Equality",
                Func: func(a, b E) bool </span><span class="cov0" title="0">{
                        return a.Equal(b)
                }</span>,
        }
}

func ScalarMultiplication[
        E algebra.AdditiveSemiModuleElement[E, RE], RE algebra.SemiRingElement[RE],
]() *Action[RE, E] <span class="cov0" title="0">{
        return &amp;Action[RE, E]{
                Name: "Scalar Multiplication",
                Func: func(s RE, r E) E </span><span class="cov0" title="0">{
                        return r.ScalarMul(s)
                }</span>,
        }
}

func ScalarExponentiation[
        E algebra.MultiplicativeSemiModuleElement[E, RE], RE algebra.SemiRingElement[RE],
]() *Action[RE, E] <span class="cov0" title="0">{
        return &amp;Action[RE, E]{
                Name: "Scalar Exponentiation",
                Func: func(s RE, r E) E </span><span class="cov0" title="0">{
                        return r.ScalarExp(s)
                }</span>,
        }
}

func AdditiveIdentity[S algebra.AdditiveMonoid[E], E algebra.AdditiveMonoidElement[E]](structure S) *Constant[E] <span class="cov0" title="0">{
        return &amp;Constant[E]{
                Name:  "Additive Identity (Zero)",
                Value: structure.Zero,
        }
}</span>

func MultiplicativeIdentity[S algebra.MultiplicativeMonoid[E], E algebra.MultiplicativeMonoidElement[E]](structure S) *Constant[E] <span class="cov0" title="0">{
        return &amp;Constant[E]{
                Name:  "Multiplicative Identity (One)",
                Value: structure.One,
        }
}</span>

func Negation[E algebra.AdditiveGroupElement[E]]() *UnaryOperator[E] <span class="cov0" title="0">{
        return &amp;UnaryOperator[E]{
                Name: "Additive Inverse (Negation)",
                Func: func(a E) E </span><span class="cov0" title="0">{
                        return a.Neg()
                }</span>,
        }
}

func Inversion[E algebra.MultiplicativeGroupElement[E]]() *UnaryOperator[E] <span class="cov0" title="0">{
        return &amp;UnaryOperator[E]{
                Name: "Multiplicative Inverse (Inversion)",
                Func: func(a E) E </span><span class="cov0" title="0">{
                        return a.Inv()
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package properties

import (
        "testing"

        "github.com/stretchr/testify/require"
        "pgregory.net/rapid"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

type Axiom struct {
        Name      string
        CheckFunc func(t *testing.T)
}

// ReflexivityProperty verifies that aRa is always true.
func ReflexivityProperty[S algebra.Structure[E], E algebra.Element[E]](
        t *testing.T, c *Carrier[S, E], R *Relation[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Reflexivity",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                require.True(t, R.Func(a, a), "reflexivity failed: aRa should be true")
                        }</span>)
                },
        }
}

func SymmetryProperty[S algebra.Structure[E], E algebra.Element[E]](
        t *testing.T, c *Carrier[S, E], R *Relation[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Symmetry",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                if R.Func(a, b) </span><span class="cov0" title="0">{
                                        require.True(t, R.Func(b, a), "symmetry failed: aRb but not bRa")
                                }</span>
                        })
                },
        }
}

func TransitiveProperty[S algebra.Structure[E], E algebra.Element[E]](
        t *testing.T, c *Carrier[S, E], R *Relation[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Transitivity",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                c := c.Dist.Draw(rt, "c")
                                if R.Func(a, b) &amp;&amp; R.Func(b, c) </span><span class="cov0" title="0">{
                                        require.True(t, R.Func(a, c), "transitivity failed: aRb &amp;&amp; bRc but not aRc")
                                }</span>
                        })
                },
        }
}

func EqualityProperties[S algebra.Structure[E], E algebra.Element[E]](
        t *testing.T, c *Carrier[S, E], R *Relation[E],
) []Axiom <span class="cov0" title="0">{
        t.Helper()
        return []Axiom{
                ReflexivityProperty(t, c, R),
                SymmetryProperty(t, c, R),
                TransitiveProperty(t, c, R),
        }
}</span>

func ClosureProperty[S algebra.Magma[E], E algebra.MagmaElement[E]](
        t *testing.T, c *Carrier[S, E], op *BinaryOperator[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: op.Name + "_Closure",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                c := op.Func(a, b)
                                require.NotNil(t, c, "closure failed: operation should return non-nil result")
                        }</span>)
                },
        }
}

func AssociativityProperty[S algebra.SemiGroup[E], E algebra.SemiGroupElement[E]](
        t *testing.T, c *Carrier[S, E], op *BinaryOperator[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: op.Name + "_Associativity",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                c := c.Dist.Draw(rt, "c")
                                left := op.Func(op.Func(a, b), c)
                                right := op.Func(a, op.Func(b, c))
                                require.True(t, left.Equal(right), "associativity failed: (a op b) op c != a op (b op c)")
                        }</span>)
                },
        }
}

func CommutativityProperty[S algebra.Magma[E], E algebra.MagmaElement[E]](
        t *testing.T, c *Carrier[S, E], op *BinaryOperator[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: op.Name + "_Commutativity",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                left := op.Func(a, b)
                                right := op.Func(b, a)
                                require.True(t, left.Equal(right), "commutativity failed: a op b != b op a")
                        }</span>)
                },
        }
}

func CyclicProperty[S algebra.CyclicSemiGroup[E], E algebra.CyclicSemiGroupElement[E]](
        t *testing.T, c *Carrier[S, E], op *BinaryOperator[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: op.Name + "_Cyclic",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                g := c.Value.Generator()
                                require.NotNil(t, g, "cyclic property failed: generator is nil")
                                require.True(t, g.IsDesignatedGenerator(), "cyclic property failed: generator is not designated")
                                x := c.Dist.Draw(rt, "x")
                                require.Equal(t, x.Equal(g), x.IsDesignatedGenerator(), "cyclic property failed: more than one designated generator found")
                        }</span>)
                },
        }
}

func IdentityProperty[S algebra.Monoid[E], E algebra.MonoidElement[E]](
        t *testing.T, c *Carrier[S, E], op *BinaryOperator[E], identity *Constant[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: identity.Name,
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")

                                // Left identity: identity op a = a
                                left := op.Func(identity.Value(), a)
                                require.True(t, left.Equal(a), "left identity failed: identity op a != a")

                                // Right identity: a op identity = a
                                right := op.Func(a, identity.Value())
                                require.True(t, right.Equal(a), "right identity failed: a op identity != a")
                        }</span>)
                },
        }
}

func CanDoubleProperty[S algebra.AdditiveSemiGroup[E], E algebra.AdditiveSemiGroupElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanDouble",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                expected := a.Add(a)
                                actual := a.Double()
                                require.True(t, actual.Equal(expected), "can double failed: a + a != Double(a)")
                        }</span>)
                },
        }
}

func CanSquareProperty[S algebra.MultiplicativeSemiGroup[E], E algebra.MultiplicativeSemiGroupElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanSquare",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                expected := a.Mul(a)
                                actual := a.Square()
                                require.True(t, actual.Equal(expected), "can square failed: a * a != Square(a)")
                        }</span>)
                },
        }
}

func CanDistinguishAdditiveIdentity[S algebra.AdditiveMonoid[E], E algebra.AdditiveMonoidElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanDistinguishZeroElement",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                zero := c.Value.Zero()
                                require.True(t, zero.IsZero(), "zero element is not marked as identity")
                                x := c.Dist.Draw(rt, "x")
                                require.Equal(t, x.Equal(zero), x.IsOpIdentity(), "can distinguish zero failed: more than one zero element found")
                        }</span>)
                },
        }
}

func CanDistinguishMultiplicativeIdentity[S algebra.MultiplicativeMonoid[E], E algebra.MultiplicativeMonoidElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanDistinguishOneElement",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                one := c.Value.One()
                                require.True(t, one.IsOne(), "one element is not marked as identity")
                                x := c.Dist.Draw(rt, "x")
                                require.Equal(t, x.Equal(one), x.IsOpIdentity(), "can distinguish one failed: more than one one element found")
                        }</span>)
                },
        }
}

func CanTrySub[S algebra.AdditiveMonoid[E], E algebra.AdditiveMonoidElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanTrySub",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                diff, err := a.TrySub(b)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Verify that a = b + diff
                                        sum := b.Add(diff)
                                        require.True(t, sum.Equal(a), "can try sub failed: a != b + (a - b)")
                                }</span> else<span class="cov0" title="0"> {
                                        require.Nil(t, diff)
                                }</span>
                        })
                },
        }
}

func CanTryNeg[S algebra.AdditiveMonoid[E], E algebra.AdditiveMonoidElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanTryNeg",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                neg, err := a.TryNeg()
                                if err == nil </span><span class="cov0" title="0">{
                                        // Verify that a + (-a) = 0
                                        sum := a.Add(neg)
                                        zero := c.Value.Zero()
                                        require.True(t, sum.Equal(zero), "can try neg failed: a + (-a) != 0")
                                }</span> else<span class="cov0" title="0"> {
                                        require.Nil(t, neg)
                                }</span>
                        })
                },
        }
}

func CanTryDiv[S algebra.MultiplicativeMonoid[E], E algebra.MultiplicativeMonoidElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanTryDiv",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                quotient, err := a.TryDiv(b)
                                if err == nil </span><span class="cov0" title="0">{
                                        // Verify that a = b * quotient
                                        product := b.Mul(quotient)
                                        require.True(t, product.Equal(a), "can try div failed: a != b * (a / b)")
                                }</span> else<span class="cov0" title="0"> {
                                        require.Nil(t, quotient)
                                }</span>
                        })
                },
        }
}

func CanTryInv[S algebra.MultiplicativeMonoid[E], E algebra.MultiplicativeMonoidElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanTryInv",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                inv, err := a.TryInv()
                                if err == nil </span><span class="cov0" title="0">{
                                        // Verify that a * a^-1 = 1
                                        product := a.Mul(inv)
                                        one := c.Value.One()
                                        require.True(t, product.Equal(one), "can try inv failed: a * a^-1 != 1")
                                }</span> else<span class="cov0" title="0"> {
                                        require.Nil(t, inv)
                                }</span>
                        })
                },
        }
}

func GroupInverseProperty[S algebra.Group[E], E algebra.GroupElement[E]](
        t *testing.T, c *Carrier[S, E], op *BinaryOperator[E],
        identity *Constant[E], inv *UnaryOperator[E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: inv.Name,
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                invA := inv.Func(a)

                                // Right inverse: a op inv(a) = identity
                                right := op.Func(a, invA)
                                require.True(t, right.Equal(identity.Value()), "right inverse failed: a op inv(a) != identity")
                                // Left inverse: inv(a) op a = identity
                                left := op.Func(invA, a)
                                require.True(t, left.Equal(identity.Value()), "left inverse failed: inv(a) op a != identity")
                        }</span>)
                },
        }
}

func GroupInverseIsNeg[S algebra.AdditiveGroup[E], E algebra.AdditiveGroupElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "InverseIsNeg",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                invA := a.OpInv()
                                negA := a.Neg()
                                require.True(t, invA.Equal(negA), "inverse is neg failed: inv(a) != -a")
                        }</span>)
                },
        }
}

func CanSub[S algebra.AdditiveGroup[E], E algebra.AdditiveGroupElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanSub",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                diff := a.Sub(b)
                                // Verify that a = b + diff
                                sum := b.Add(diff)
                                require.True(t, sum.Equal(a), "can sub failed: a != b + (a - b)")
                        }</span>)
                },
        }
}

func GroupInverseIsInv[S algebra.MultiplicativeGroup[E], E algebra.MultiplicativeGroupElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "InverseIsInv",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                invA := a.OpInv()
                                invFuncA := a.Inv()
                                require.True(t, invA.Equal(invFuncA), "inverse is inv failed: inv(a) != a^-1")
                        }</span>)
                },
        }
}

func CanDiv[S algebra.MultiplicativeGroup[E], E algebra.MultiplicativeGroupElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanDiv",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                quotient := a.Div(b)
                                // Verify that a = b * quotient
                                product := b.Mul(quotient)
                                require.True(t, product.Equal(a), "can div failed: a != b * (a / b)")
                        }</span>)
                },
        }
}

func HemiRingIsStandardProperty[S algebra.HemiRing[E], E algebra.HemiRingElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "HemiRingIsStandard",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")

                                aOpB := a.Op(b)
                                aAddB := a.Add(b)

                                require.True(t, aOpB.Equal(aAddB), "hemi-ring is standard failed: a.Op(b) != a.Add(b)")

                                aOtherOpB := a.OtherOp(b)
                                aMulB := a.Mul(b)

                                require.True(t, aOtherOpB.Equal(aMulB), "hemi-ring is standard failed: a.OtherOp(b) != a.Mul(b)")
                        }</span>)
                },
        }
}

func DistributivityOfMulOverAddProperty[S algebra.HemiRing[E], E algebra.HemiRingElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Mul_DistributesOver_Add",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                d := c.Dist.Draw(rt, "c")

                                // a * (b + c)
                                left1 := a.Mul(b.Add(d))
                                // (a * b) + (a * c)
                                right1 := a.Mul(b).Add(a.Mul(d))

                                require.True(t, left1.Equal(right1), "distributivity failed: a * (b + c) != (a * b) + (a * c)")

                                // (a + b) * c
                                left2 := a.Add(b).Mul(d)
                                // (a * c) + (b * c)
                                right2 := a.Mul(d).Add(b.Mul(d))

                                require.True(t, left2.Equal(right2), "distributivity failed: (a + b) * c != (a * c) + (b * c)")
                        }</span>)
                },
        }
}

func EuclideanDivisionProperty[S algebra.EuclideanSemiDomain[E], E algebra.EuclideanSemiDomainElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Euclidean_Division",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := c.Dist.Draw(rt, "b")
                                for b.IsZero() </span><span class="cov0" title="0">{
                                        b = c.Dist.Draw(rt, "b")
                                }</span>

                                <span class="cov0" title="0">q, r, err := a.EuclideanDiv(b)
                                require.NoError(t, err)

                                // Verify a = q*b + r
                                qb := q.Mul(b)
                                reconstructed := qb.Add(r)
                                require.True(t, a.Equal(reconstructed), "Euclidean division failed: a != q*b + r")

                                if !r.IsZero() </span><span class="cov0" title="0">{
                                        require.True(
                                                t,
                                                base.Compare(r.EuclideanValuation(), b.EuclideanValuation()).IsLessThan() &amp;&amp;
                                                        !base.Compare(r.EuclideanValuation(), b.EuclideanValuation()).IsEqual(),
                                                "Euclidean division failed: r &gt;= |b|")
                                }</span>
                        })
                },
        }
}

func EveryNonZeroElementHasMultiplicativeInverseProperty[S algebra.Field[E], E algebra.FieldElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "EveryNonZeroElementHasMultiplicativeInverse",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Filter(func(x E) bool </span><span class="cov0" title="0">{ return !x.IsZero() }</span>).Draw(rt, "a")
                                <span class="cov0" title="0">aInv, err := a.TryInv()
                                require.NoError(t, err, "multiplicative inverse failed: TryInv returned error for non-zero element")
                                require.True(t, a.Mul(aInv).IsOne(), "multiplicative inverse failed: a * a^-1 != 1")</span>
                        })
                },
        }
}

func FieldExtensionComponentBytesRoundTripProperty[S algebra.FieldExtension[E], E algebra.FieldExtensionElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "FieldExtension_ComponentBytes_RoundTrip",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")
                                b := a.ComponentsBytes()
                                require.NotEmpty(t, b, "Field extension component bytes round-trip failed: ComponentsBytes returned empty byte slice")

                                aReconstructed, err := c.Value.FromComponentsBytes(b)
                                require.NoError(t, err, "ElementFromComponentBytes returned error")

                                require.True(t, a.Equal(aReconstructed), "Field extension component bytes round-trip failed: reconstructed element does not equal original")
                        }</span>)
                },
        }
}

func LeftDistributivityOfActionOverSemiModuleOperationProperty[S algebra.SemiModule[E, RE], R algebra.SemiRing[RE], E algebra.SemiModuleElement[E, RE], RE algebra.SemiRingElement[RE]](
        t *testing.T, c *Carrier2[S, R, E, RE],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: c.Action.Name + "_DistributesOver_Op",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.First.Dist.Draw(rt, "a")
                                b := c.First.Dist.Draw(rt, "b")
                                sc := c.Second.Dist.Draw(rt, "sc")

                                // sc * (a + b)
                                left1 := a.Op(b).ScalarOp(sc)
                                // (sc * a) + (sc * b)
                                right1 := a.ScalarOp(sc).Op(b.ScalarOp(sc))

                                require.True(t, left1.Equal(right1), "distributivity of scalar multiplication over addition failed: sc * (a + b) != (sc * a) + (sc * b)")
                        }</span>)
                },
        }
}

func RightDistributivityOfSemiModuleOperationOverBaseSemiRingAdditionProperty[S algebra.SemiModule[E, RE], R algebra.SemiRing[RE], E algebra.SemiModuleElement[E, RE], RE algebra.SemiRingElement[RE]](
        t *testing.T, c *Carrier2[S, R, E, RE],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Op_DistributesOver_" + c.Action.Name,
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.First.Dist.Draw(rt, "a")
                                sc1 := c.Second.Dist.Draw(rt, "sc1")
                                sc2 := c.Second.Dist.Draw(rt, "sc2")

                                // (sc1 + sc2) (*) a
                                left1 := a.ScalarOp(sc1.Add(sc2))
                                // (sc1 (*) a) + (sc2 (*) a)
                                right1 := a.ScalarOp(sc1).Op(a.ScalarOp(sc2))

                                require.True(t, left1.Equal(right1), "distributivity of addition over scalar multiplication failed: (sc1 + sc2) (*) a != (sc1 (*) a) + (sc2 (*) a)")
                        }</span>)
                },
        }
}

func AssociativityOfScalarsWRTRingMultiplicationProperty[S algebra.SemiModule[E, RE], R algebra.SemiRing[RE], E algebra.SemiModuleElement[E, RE], RE algebra.SemiRingElement[RE]](
        t *testing.T, c *Carrier2[S, R, E, RE],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: c.Action.Name + "_Associativity_WRT_Ring_Multiplication",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.First.Dist.Draw(rt, "a")
                                sc1 := c.Second.Dist.Draw(rt, "sc1")
                                sc2 := c.Second.Dist.Draw(rt, "sc2")

                                // (sc1 * sc2) (*) a
                                left1 := a.ScalarOp(sc1.Mul(sc2))
                                // sc1 (*) (sc2 (*) a)
                                right1 := a.ScalarOp(sc2).ScalarOp(sc1)

                                require.True(t, left1.Equal(right1), "associativity of scalars wrt ring multiplication failed: (sc1 * sc2) (*) a != sc1 (*) (sc2 (*) a)")
                        }</span>)
                },
        }
}

func ScalarOpIsScalarMultiplicationProperty[S algebra.AdditiveSemiModule[E, RE], R algebra.SemiRing[RE], E algebra.AdditiveSemiModuleElement[E, RE], RE algebra.SemiRingElement[RE]](
        t *testing.T, c *Carrier2[S, R, E, RE],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "ScalarOp_Is_ScalarMultiplication",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.First.Dist.Draw(rt, "a")
                                sc := c.Second.Dist.Draw(rt, "sc")

                                expected := a.ScalarMul(sc)
                                actual := a.ScalarOp(sc)

                                require.True(t, actual.Equal(expected), "scalar op is scalar multiplication failed: ScalarOp(sc) != ScalarMul(sc)")
                        }</span>)
                },
        }
}

func ScalarOpIsScalarExponentiationProperty[S algebra.MultiplicativeSemiModule[E, RE], R algebra.SemiRing[RE], E algebra.MultiplicativeSemiModuleElement[E, RE], RE algebra.SemiRingElement[RE]](
        t *testing.T, c *Carrier2[S, R, E, RE],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "ScalarOp_Is_ScalarExponentiation",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.First.Dist.Draw(rt, "a")
                                sc := c.Second.Dist.Draw(rt, "sc")

                                expected := a.ScalarExp(sc)
                                actual := a.ScalarOp(sc)

                                require.True(t, actual.Equal(expected), "scalar op is scalar exponentiation failed: ScalarOp(sc) != ScalarExp(sc)")
                        }</span>)
                },
        }
}

func BaseRingIdentityActsAsModuleIdentityProperty[S algebra.Module[E, RE], R algebra.Ring[RE], E algebra.ModuleElement[E, RE], RE algebra.RingElement[RE]](
        t *testing.T, c *Carrier2[S, R, E, RE],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "BaseRingIdentity_ActsAs_ModuleIdentity",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.First.Dist.Draw(rt, "a")
                                one := c.Second.Value.One()

                                result := a.ScalarOp(one)

                                require.True(t, result.Equal(a), "base ring identity does not act as module identity: 1 (*) a != a")
                        }</span>)
                },
        }
}

func NumericStructureFromBytesBERoundTripProperty[S interface {
        algebra.NumericStructure[E]
        Structure
}, E interface {
        algebra.Numeric
        base.Equatable[E]
}](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "NumericSerialisationRoundTrip",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                value := c.Dist.Draw(rt, "value")

                                serialised := value.BytesBE()
                                deserialised, err := c.Value.FromBytesBE(serialised)
                                require.NoError(t, err, "numeric serialisation round trip failed: FromBytesBE returned error")

                                require.True(t, value.Equal(deserialised), "numeric serialisation round trip failed: value != Deserialize(Serialise(value))")
                        }</span>)
                },
        }
}

func FromCardinalRoundTripProperty[S algebra.NPlusLike[E], E algebra.NatPlusLike[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "FromCardinal_RoundTrip",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                original := c.Dist.Draw(rt, "original")

                                card := original.Cardinal()
                                reconstructed, err := c.Value.FromCardinal(card)
                                require.NoError(t, err, "FromCardinal returned error")

                                require.True(t, original.Equal(reconstructed), "FromCardinal round trip failed: original != FromCardinal(ToCardinal(original))")
                        }</span>)
                },
        }
}

func AnyNumberIsEitherOddOrEvenProperty[S algebra.Structure[E], E interface {
        algebra.Element[E]
        IsOdd() bool
        IsEven() bool
}](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "AnyNumberIsEitherOddOrEven",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")

                                isOdd := a.IsOdd()
                                isEven := a.IsEven()

                                require.True(t, isOdd || isEven, "any number is either odd or even failed: number is neither odd nor even")
                                require.False(t, isOdd &amp;&amp; isEven, "any number is either odd or even failed: number is both odd and even")
                        }</span>)
                },
        }
}

func AnyNaturalNumberIsEitherZeroOrPositiveProperty[S algebra.NLike[E], E algebra.NatLike[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "AnyNaturalNumberIsEitherZeroOrPositive",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")

                                isZero := a.IsZero()
                                isPositive := a.IsPositive()

                                require.True(t, isZero || isPositive, "any natural number is either zero or positive failed: number is neither zero nor positive")
                                require.False(t, isZero &amp;&amp; isPositive, "any natural number is either zero or positive failed: number is both zero and positive")
                        }</span>)
                },
        }
}

func AnyIntegerIsEitherPositiveOrNegativeOrZero[S algebra.ZLike[E], E algebra.IntLike[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "AnyIntegerIsEitherPositiveOrNegativeOrZero",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                a := c.Dist.Draw(rt, "a")

                                isPositive := a.IsPositive()
                                isNegative := a.IsNegative()
                                isZero := a.IsZero()

                                require.True(t, isPositive || isNegative || isZero, "any integer is either positive, negative, or zero failed: number is neither positive, negative, nor zero")
                                require.False(t, (isPositive &amp;&amp; isNegative) || (isPositive &amp;&amp; isZero) || (isNegative &amp;&amp; isZero), "any integer is either positive, negative, or zero failed: number is more than one of positive, negative, or zero")
                        }</span>)
                },
        }
}

func ZModFromBytesBEReduceRoundTripProperty[S algebra.ZModLike[E], E algebra.UintLike[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "ZModFromBytesBE_Reduce_RoundTrip",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                modulus := c.Value.Characteristic()
                                extraCardinal := cardinal.New(rapid.Uint64Range(0, modulus.Uint64()-1).Draw(rt, "extra"))
                                extra, err := c.Value.FromBytes(extraCardinal.Bytes())
                                require.NoError(t, err)

                                modulusWithExtra := modulus.Add(extraCardinal)
                                reduced, err := c.Value.FromBytesBEReduce(modulusWithExtra.Bytes())
                                require.NoError(t, err, "ZMod FromBytesBE Reduce returned error")

                                require.True(t, extra.Equal(reduced), "ZMod FromBytesBE Reduce round trip failed: original != FromBytesBEReduce(BytesBE(original))")
                        }</span>)
                },
        }
}

func FromWideBytesRoundTripProperty[S algebra.PrimeField[E], E algebra.PrimeFieldElement[E]](
        t *testing.T, c *Carrier[S, E],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "FromWideBytes_RoundTrip",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                original := c.Dist.Draw(rt, "original")

                                serialised := original.Bytes()
                                require.Len(t, serialised, c.Value.ElementSize(), "FromWideBytes round trip failed: Bytes() returned byte slice of incorrect length")
                                reconstructed, err := c.Value.FromWideBytes(serialised)
                                require.NoError(t, err, "FromWideBytes returned error")
                                require.True(t, original.Equal(reconstructed), "FromWideBytes round trip failed: original != FromWideBytes(WideBytes(original))")

                                padded := sliceutils.PadToLeft(serialised, c.Value.WideElementSize()-len(serialised))
                                _, err = c.Value.FromWideBytes(padded)
                                require.Error(t, err, "FromWideBytes should return error for too big input")
                        }</span>)
                },
        }
}

func CanScalarBaseOp[S algebra.PrimeGroup[E, FE], F algebra.PrimeField[FE], E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]](
        t *testing.T, c *Carrier2[S, F, E, FE],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanScalarBaseOp",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                sc := c.Second.Dist.Draw(rt, "sc")
                                result := c.First.Value.ScalarBaseOp(sc)
                                expected := c.First.Value.Generator().ScalarOp(sc)
                                require.True(t, result.Equal(expected), "can scalar base op failed: ScalarBaseOp(sc) != ScalarOp(FromBytesBE(sc))")
                        }</span>)
                },
        }
}

func CanScalarBaseMul[S algebra.AdditivePrimeGroup[E, FE], F algebra.PrimeField[FE], E algebra.AdditivePrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]](
        t *testing.T, c *Carrier2[S, F, E, FE],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "CanScalarBaseMul",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                sc := c.Second.Dist.Draw(rt, "sc")
                                result := c.First.Value.ScalarBaseMul(sc)
                                expected := c.First.Value.Generator().ScalarMul(sc)
                                require.True(t, result.Equal(expected), "can scalar base mul failed: ScalarBaseMul(sc) != ScalarMul(FromBytesBE(sc))")
                        }</span>)
                },
        }
}

func PolynomialLikeConstantTermProperty[
        PS algebra.PolynomialLikeStructure[P, S, C], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.PolynomialLike[P, S, C], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "PolynomialLike_ConstantTerm",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                constantTerm := p.ConstantTerm()
                                coeffs := p.Coefficients()
                                require.True(t, constantTerm.Equal(coeffs[0]), "polynomial-like constant term failed: ConstantTerm() != Coefficients()[0]")
                        }</span>)
                },
        }
}

func PolynomialLikeIsConstantProperty[
        PS algebra.PolynomialLikeStructure[P, S, C], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.PolynomialLike[P, S, C], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "PolynomialLike_IsConstant",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                coeffs := p.Coefficients()
                                isConstant := true
                                for i := 1; i &lt; len(coeffs); i++ </span><span class="cov0" title="0">{
                                        if !coeffs[i].IsOpIdentity() </span><span class="cov0" title="0">{
                                                isConstant = false
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">require.Equal(t, p.IsConstant(), isConstant, "polynomial-like is constant failed: IsConstant() does not match coefficients")</span>
                        })
                },
        }
}

func UnivariatePolynomialLikeFromCoefficientsRoundTripProperty[
        PS algebra.UnivariatePolynomialLikeStructure[P, S, C, SS, CS], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.UnivariatePolynomialLike[P, S, C, SS, CS], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "PolynomialLike_FromCoefficients_RoundTrip",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                coeffs := p.Coefficients()
                                reconstructed, err := c.Value.New(coeffs...)
                                require.NoError(t, err, "FromCoefficients returned error")

                                require.True(t, p.Equal(reconstructed), "polynomial-like from coefficients round trip failed: original != FromCoefficients(Coefficients(original))")
                        }</span>)
                },
        }
}

func PolynomialLikeDegreeProperty[
        PS algebra.PolynomialLikeStructure[P, S, C], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.PolynomialLike[P, S, C], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "PolynomialLike_Degree",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                coeffs := p.Coefficients()
                                expectedDegree := -1
                                for i := len(coeffs) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                                        if !coeffs[i].IsOpIdentity() </span><span class="cov0" title="0">{
                                                expectedDegree = i
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">require.Equal(t, expectedDegree, p.Degree(), "polynomial-like degree failed: Degree() does not match highest non-zero coefficient index")</span>
                        })
                },
        }
}

func PolynomialLikeDerivativeDegreeDeclinesProperty[
        PS algebra.PolynomialLikeStructure[P, S, C], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.PolynomialLike[P, S, C], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "PolynomialLike_Derivative_DegreeDeclines",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                deg := p.Degree()
                                deriv := p.Derivative()
                                derivDeg := deriv.Degree()
                                if deg &lt;= 0 </span><span class="cov0" title="0">{
                                        require.Equal(t, -1, derivDeg, "polynomial-like derivative degree failed: derivative of constant should have degree -1")
                                }</span> else<span class="cov0" title="0"> {
                                        require.LessOrEqual(t, derivDeg, deg-1, "polynomial-like derivative degree failed: derivative degree should be at most deg-1")
                                }</span>
                        })
                },
        }
}

func PolynomialLikeDerivativeOfConstantIsZeroProperty[
        PS algebra.PolynomialLikeStructure[P, S, C], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.PolynomialLike[P, S, C], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "PolynomialLike_Derivative_ConstantIsZero",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                if p.IsConstant() </span><span class="cov0" title="0">{
                                        deriv := p.Derivative()
                                        require.True(t, deriv.IsOpIdentity(), "polynomial-like derivative failed: derivative of constant should be zero")
                                }</span>
                        })
                },
        }
}

func UnivariatePolynomialLikeLeadingCoefficientProperty[
        PS algebra.UnivariatePolynomialLikeStructure[P, S, C, SS, CS], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.UnivariatePolynomialLike[P, S, C, SS, CS], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "UnivariatePolynomialLike_LeadingCoefficient",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                deg := p.Degree()
                                lc := p.LeadingCoefficient()
                                if deg &gt;= 0 </span><span class="cov0" title="0">{
                                        coeffs := p.Coefficients()
                                        require.True(t, lc.Equal(coeffs[deg]), "univariate polynomial-like leading coefficient failed: LeadingCoefficient() != Coefficients()[Degree()]")
                                }</span> else<span class="cov0" title="0"> {
                                        require.True(t, lc.IsOpIdentity(), "univariate polynomial-like leading coefficient failed: zero polynomial should have zero leading coefficient")
                                }</span>
                        })
                },
        }
}

func UnivariatePolynomialLikeEvalAtZeroProperty[
        PS algebra.UnivariatePolynomialLikeStructure[P, S, C, SS, CS], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.UnivariatePolynomialLike[P, S, C, SS, CS], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P], scalarStructure SS,
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "UnivariatePolynomialLike_EvalAtZero",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                zero := scalarStructure.Zero()
                                evalAtZero := p.Eval(zero)
                                constantTerm := p.ConstantTerm()
                                require.True(t, evalAtZero.Equal(constantTerm), "univariate polynomial-like eval at zero failed: Eval(0) != ConstantTerm()")
                        }</span>)
                },
        }
}

func UnivariatePolynomialLikeEvalConstantProperty[
        PS algebra.UnivariatePolynomialLikeStructure[P, S, C, SS, CS], SS algebra.Ring[S], CS algebra.Group[C],
        P algebra.UnivariatePolynomialLike[P, S, C, SS, CS], S algebra.RingElement[S], C algebra.GroupElement[C],
](
        t *testing.T, c *Carrier[PS, P], scalarDist *rapid.Generator[S],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "UnivariatePolynomialLike_EvalConstant",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                if p.IsConstant() </span><span class="cov0" title="0">{
                                        x := scalarDist.Draw(rt, "x")
                                        evalAtX := p.Eval(x)
                                        constantTerm := p.ConstantTerm()
                                        require.True(t, evalAtX.Equal(constantTerm), "univariate polynomial-like eval constant failed: constant polynomial should evaluate to its constant term at any point")
                                }</span>
                        })
                },
        }
}

func PolynomialLeadingCoefficientProperty[
        PS algebra.PolynomialRing[P, S],
        P algebra.Polynomial[P, S], S algebra.RingElement[S],
](
        t *testing.T, c *Carrier[PS, P],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Polynomial_LeadingCoefficient",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                deg := p.Degree()
                                lc := p.LeadingCoefficient()
                                if deg &gt;= 0 </span><span class="cov0" title="0">{
                                        coeffs := p.Coefficients()
                                        require.True(t, lc.Equal(coeffs[deg]), "polynomial leading coefficient failed: LeadingCoefficient() != Coefficients()[Degree()]")
                                }</span> else<span class="cov0" title="0"> {
                                        require.True(t, lc.IsOpIdentity(), "polynomial leading coefficient failed: zero polynomial should have zero leading coefficient")
                                }</span>
                        })
                },
        }
}

func PolynomialEvalAtZeroProperty[
        PS algebra.PolynomialRing[P, S],
        P algebra.Polynomial[P, S], S algebra.RingElement[S],
](
        t *testing.T, c *Carrier[PS, P], scalarStructure algebra.Ring[S],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Polynomial_EvalAtZero",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                zero := scalarStructure.Zero()
                                evalAtZero := p.Eval(zero)
                                constantTerm := p.ConstantTerm()
                                require.True(t, evalAtZero.Equal(constantTerm), "polynomial eval at zero failed: Eval(0) != ConstantTerm()")
                        }</span>)
                },
        }
}

func PolynomialEvalConstantProperty[
        PS algebra.PolynomialRing[P, S],
        P algebra.Polynomial[P, S], S algebra.RingElement[S],
](
        t *testing.T, c *Carrier[PS, P], scalarDist *rapid.Generator[S],
) Axiom <span class="cov0" title="0">{
        t.Helper()
        return Axiom{
                Name: "Polynomial_EvalConstant",
                CheckFunc: func(t *testing.T) </span><span class="cov0" title="0">{
                        t.Helper()
                        rapid.Check(t, func(rt *rapid.T) </span><span class="cov0" title="0">{
                                p := c.Dist.Draw(rt, "p")
                                if p.IsConstant() </span><span class="cov0" title="0">{
                                        x := scalarDist.Draw(rt, "x")
                                        evalAtX := p.Eval(x)
                                        constantTerm := p.ConstantTerm()
                                        require.True(t, evalAtX.Equal(constantTerm), "polynomial eval constant failed: constant polynomial should evaluate to its constant term at any point")
                                }</span>
                        })
                },
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package base58

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

const (
        Alphabet     string = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
        alphabetIdx0 byte   = '1'
)

type Base58 string

func (b Base58) Equal(other Base58) bool <span class="cov0" title="0">{
        return ct.SliceEqual([]byte(b), []byte(other)) == 1
}</span>

var (
        radix58 = num.N().FromUint64(58)
        zero    = num.N().FromUint64(0)
        one     = num.N().FromUint64(1)
        // Pre-computed table: ASCII  057 (invalid = 0xFF)
        // Initialise once in init().
        b58 [256]byte
)

func init() <span class="cov8" title="1">{ //nolint:gochecknoinits // initialises base58 decoding table
        for i := range b58 </span><span class="cov8" title="1">{
                b58[i] = 0xFF
        }</span>
        <span class="cov8" title="1">for i, char := range Alphabet </span><span class="cov8" title="1">{
                b58[char] = byte(i)
        }</span>
        <span class="cov8" title="1">if alphabetIdx0 != Alphabet[0] </span><span class="cov0" title="0">{
                panic(errs2.New("alphabetIdx0 must be the first character of the alphabet"))</span>
        }
}

func Encode(data []byte) Base58 <span class="cov8" title="1">{
        x, err := num.N().FromBytes(data)
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err).WithMessage("failed to convert bytes to Nat"))</span>
        }
        <span class="cov8" title="1">answer := make([]byte, 0, len(data)*136/100)
        var rem *num.Nat
        for x.Compare(zero).Is(base.GreaterThan) </span><span class="cov8" title="1">{
                x, rem, err = x.EuclideanDiv(radix58)
                if err != nil </span><span class="cov0" title="0">{
                        panic(errs2.Wrap(err).WithMessage("failed to perform division"))</span>
                }
                <span class="cov8" title="1">answer = append(answer, Alphabet[rem.Uint64()])</span>
        }
        <span class="cov8" title="1">for range utils.LeadingZeroBytes(data) </span><span class="cov8" title="1">{
                answer = append(answer, alphabetIdx0)
        }</span>
        <span class="cov8" title="1">sliceutils.Reverse(answer)
        return Base58(string(answer))</span>
}

func Decode(s Base58) []byte <span class="cov8" title="1">{
        answer := zero
        j := one

        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                tmp := b58[s[i]]
                if tmp == 0xFF </span><span class="cov8" title="1">{
                        return []byte("")
                }</span>
                <span class="cov8" title="1">scratch := num.N().FromUint64(uint64(tmp)).Mul(j)
                answer = answer.Add(scratch)
                j = j.Mul(radix58)</span>
        }

        <span class="cov8" title="1">tmpval := answer.Big().Bytes()

        var leadingZerosCount int
        for leadingZerosCount = 0; leadingZerosCount &lt; len(s) &amp;&amp; s[leadingZerosCount] == alphabetIdx0; leadingZerosCount++ </span>{<span class="cov0" title="0"> //nolint:revive // empty block is intentional.
                // count leading zeros
        }</span>
        <span class="cov8" title="1">flen := leadingZerosCount + len(tmpval)
        val := make([]byte, flen)
        copy(val[leadingZerosCount:], tmpval)
        return val</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package base58

import (
        "crypto/sha256"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

const (
        ChecksumLen          int = 4
        VersionLen           int = 1
        minimumDecodedLength     = VersionLen + ChecksumLen
)

var (
        ErrChecksumMismatch = errs2.New("checksum mismatch")
        ErrInvalidLength    = errs2.New("decoded input too short for Base58")
)

type (
        VersionPrefix byte
        Checksum      [ChecksumLen]byte
)

func (c Checksum) Equal(other Checksum) bool <span class="cov8" title="1">{
        return ct.SliceEqual(c[:], other[:]) == 1
}</span>

func DeriveChecksum(input []byte) (cksum Checksum) <span class="cov8" title="1">{
        h := sha256.Sum256(input)
        h2 := sha256.Sum256(h[:])
        copy(cksum[:], h2[:ChecksumLen])
        return cksum
}</span>

func CheckEncode(input []byte, version VersionPrefix) Base58 <span class="cov8" title="1">{
        b := make([]byte, 0, VersionLen+len(input)+ChecksumLen)
        b = append(b, byte(version))
        b = append(b, input...)
        cksum := DeriveChecksum(b)
        b = append(b, cksum[:]...)
        return Encode(b)
}</span>

func CheckDecode(input Base58) (result []byte, version VersionPrefix, err error) <span class="cov8" title="1">{
        decoded := Decode(input)
        if len(decoded) &lt; minimumDecodedLength </span><span class="cov8" title="1">{
                return nil, 0, ErrInvalidLength.WithStackFrame()
        }</span>
        <span class="cov8" title="1">version = VersionPrefix(decoded[0])

        var decodedChecksum [ChecksumLen]byte
        copy(decodedChecksum[:], decoded[len(decoded)-ChecksumLen:])

        versionAndPayload := decoded[:len(decoded)-ChecksumLen]
        recomputedChecksum := DeriveChecksum(versionAndPayload)

        if !recomputedChecksum.Equal(decodedChecksum) </span><span class="cov8" title="1">{
                return nil, 0, ErrChecksumMismatch.WithStackFrame()
        }</span>
        <span class="cov8" title="1">result = versionAndPayload[VersionLen:]
        return result, version, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package bf128

import (
        "encoding/binary"
        "fmt"
        "io"
        "math/big"
        "math/bits"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        Name              = "F_{2^128}"
        FieldElementSize  = 16
        FieldElementLimbs = 2
)

var (
        instance = &amp;Field{}

        _ algebra.FieldExtension[*FieldElement]        = (*Field)(nil)
        _ algebra.FiniteField[*FieldElement]           = (*Field)(nil)
        _ algebra.FieldExtensionElement[*FieldElement] = (*FieldElement)(nil)
        _ algebra.FiniteFieldElement[*FieldElement]    = (*FieldElement)(nil)
)

type Field struct{}

func NewField() *Field <span class="cov8" title="1">{
        return instance
}</span>

func (f *Field) Random(prng io.Reader) (*FieldElement, error) <span class="cov8" title="1">{
        var data [16]byte
        _, err := io.ReadFull(prng, data[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to read random bytes")
        }</span>
        <span class="cov8" title="1">return f.FromBytes(data[:])</span>
}

func (f *Field) RandomNonZero(prng io.Reader) (*FieldElement, error) <span class="cov8" title="1">{
        e, err := f.Random(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to generate random element")
        }</span>
        <span class="cov8" title="1">for e.IsZero() </span><span class="cov0" title="0">{
                e, err = f.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to generate random element")
                }</span>
        }
        <span class="cov8" title="1">return e, nil</span>
}

func (f *Field) Hash(data []byte) (*FieldElement, error) <span class="cov0" title="0">{
        h, err := blake2b.New(FieldElementSize, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create hasher")
        }</span>
        <span class="cov0" title="0">_, err = h.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to write to hasher")
        }</span>
        <span class="cov0" title="0">return f.FromBytes(h.Sum(nil))</span>
}

func (*Field) Name() string <span class="cov0" title="0">{
        return Name
}</span>

func (*Field) Order() cardinal.Cardinal <span class="cov0" title="0">{
        orderBig := new(big.Int)
        orderBig.SetBit(orderBig, 128, 1)
        return cardinal.NewFromBig(orderBig)
}</span>

func (*Field) ElementSize() int <span class="cov0" title="0">{
        return FieldElementSize
}</span>

func (*Field) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(2)
}</span>

func (f *Field) OpIdentity() *FieldElement <span class="cov0" title="0">{
        return f.Zero()
}</span>

func (*Field) One() *FieldElement <span class="cov8" title="1">{
        return &amp;FieldElement{1, 0}
}</span>

func (*Field) Zero() *FieldElement <span class="cov8" title="1">{
        return &amp;FieldElement{0, 0}
}</span>

func (*Field) IsDomain() bool <span class="cov0" title="0">{
        return true
}</span>

func (*Field) ExtensionDegree() uint <span class="cov0" title="0">{
        return 128
}</span>

func (f *Field) FromComponentsBytes(data [][]byte) (*FieldElement, error) <span class="cov0" title="0">{
        if len(data) != 1 </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid number of components for F2e128 element (is %d, should be 1)", len(data))
        }</span>
        <span class="cov0" title="0">return f.FromBytes(data[0])</span>
}

func (*Field) FromBytes(buf []byte) (*FieldElement, error) <span class="cov8" title="1">{
        el := &amp;FieldElement{}
        if len(buf) != FieldElementSize </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid length of bytes for F2e128 element (is %d, should be %d)", len(buf), 16)
        }</span>
        <span class="cov8" title="1">el[0] = binary.BigEndian.Uint64(buf[8:16])
        el[1] = binary.BigEndian.Uint64(buf[:8])
        return el, nil</span>
}

func (*Field) Select(choice uint64, x, y *FieldElement) *FieldElement <span class="cov0" title="0">{
        zSlice := ct.CSelectInts(ct.Choice(choice), x[:], y[:])
        return &amp;FieldElement{
                zSlice[0],
                zSlice[1],
        }
}</span>

type FieldElement [2]uint64

func (*FieldElement) Structure() algebra.Structure[*FieldElement] <span class="cov0" title="0">{
        return NewField()
}</span>

func (el *FieldElement) Clone() *FieldElement <span class="cov8" title="1">{
        var clone FieldElement
        copy(clone[:], el[:])
        return &amp;clone
}</span>

func (el *FieldElement) HashCode() base.HashCode <span class="cov0" title="0">{
        return base.HashCode(el[0] ^ el[1])
}</span>

func (el *FieldElement) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("F2e128(%08x%08x)", el[1], el[0])
}</span>

func (el *FieldElement) Op(e *FieldElement) *FieldElement <span class="cov0" title="0">{
        return el.Add(e)
}</span>

func (el *FieldElement) OtherOp(e *FieldElement) *FieldElement <span class="cov0" title="0">{
        return el.Mul(e)
}</span>

func (*FieldElement) Double() *FieldElement <span class="cov0" title="0">{
        return NewField().Zero()
}</span>

func (el *FieldElement) Square() *FieldElement <span class="cov0" title="0">{
        return el.Mul(el)
}</span>

func (el *FieldElement) IsOpIdentity() bool <span class="cov0" title="0">{
        return el.IsZero()
}</span>

func (el *FieldElement) TryOpInv() (*FieldElement, error) <span class="cov0" title="0">{
        x := el.Neg()
        return x, nil
}</span>

func (el *FieldElement) IsOne() bool <span class="cov8" title="1">{
        return (el[1] | (el[0] ^ 1)) == 0
}</span>

func (el *FieldElement) TryInv() (*FieldElement, error) <span class="cov8" title="1">{
        if el.IsZero() </span><span class="cov8" title="1">{
                return nil, ErrDivisionByZero
        }</span>

        <span class="cov8" title="1">b := NewField().Zero()
        c := NewField().One()
        u := &amp;FieldElement{(1 &lt;&lt; 7) | (1 &lt;&lt; 2) | (1 &lt;&lt; 1) | (1 &lt;&lt; 0), 0}
        v := el.Clone()
        j := 128 - v.degree()
        u = u.Sub(v.shiftLeft(j))
        b = b.Sub(c.shiftLeft(j))

        for u.degree() &gt; 0 </span><span class="cov8" title="1">{
                if u.degree() &lt; v.degree() </span><span class="cov8" title="1">{
                        u, v = v, u
                        b, c = c, b
                }</span>
                <span class="cov8" title="1">j = u.degree() - v.degree()
                u = u.Sub(v.shiftLeft(j))
                b = b.Sub(c.shiftLeft(j))</span>
        }

        <span class="cov8" title="1">return b, nil</span>
}

func (el *FieldElement) TryDiv(e *FieldElement) (*FieldElement, error) <span class="cov8" title="1">{
        eInv, err := e.TryInv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot invert element")
        }</span>
        <span class="cov8" title="1">return el.Mul(eInv), nil</span>
}

func (el *FieldElement) IsZero() bool <span class="cov8" title="1">{
        return (el[1] | el[0]) == 0
}</span>

func (el *FieldElement) TryNeg() (*FieldElement, error) <span class="cov0" title="0">{
        return el.Neg(), nil
}</span>

func (el *FieldElement) TrySub(e *FieldElement) (*FieldElement, error) <span class="cov0" title="0">{
        return el.Sub(e), nil
}</span>

func (el *FieldElement) OpInv() *FieldElement <span class="cov0" title="0">{
        return el.Neg()
}</span>

func (el *FieldElement) Neg() *FieldElement <span class="cov8" title="1">{
        return el.Clone()
}</span>

func (el *FieldElement) Sub(e *FieldElement) *FieldElement <span class="cov8" title="1">{
        return el.Add(e)
}</span>

func (*FieldElement) IsProbablyPrime() bool <span class="cov0" title="0">{
        return false
}</span>

func (el *FieldElement) EuclideanDiv(rhs *FieldElement) (quot, rem *FieldElement, err error) <span class="cov0" title="0">{
        quot, err = el.TryDiv(rhs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("division by zero")
        }</span>
        <span class="cov0" title="0">return quot, NewField().Zero(), nil</span>
}

func (el *FieldElement) EuclideanValuation() cardinal.Cardinal <span class="cov0" title="0">{
        if el.IsZero() </span><span class="cov0" title="0">{
                return cardinal.New(0)
        }</span> else<span class="cov0" title="0"> {
                return cardinal.New(1)
        }</span>
}

func (*FieldElement) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (el *FieldElement) Add(y *FieldElement) *FieldElement <span class="cov8" title="1">{
        return &amp;FieldElement{el[0] ^ y[0], el[1] ^ y[1]}
}</span>

func (el *FieldElement) Mul(rhs *FieldElement) *FieldElement <span class="cov8" title="1">{
        // From section 2.3 of https://link.springer.com/book/10.1007/b97644, employing
        // the irreducible polynomial f(X) = X^128 + X^7 + X^2 + X + 1. (from Table A.1).
        var z [4]uint64
        var b = [3]uint64{rhs[0], rhs[1], 0}
        for k := range 64 </span><span class="cov8" title="1">{
                for j := range FieldElementLimbs </span><span class="cov8" title="1">{
                        // conditionally add a copy of shifted B to C, depending on the appropriate bit of A
                        mask := -(el[j] &gt;&gt; k &amp; 0x01) // if A[j] &gt;&gt; k &amp; 0x01 == 1 then 0xFFF... else 0x000...
                        for i := range FieldElementLimbs + 1 </span><span class="cov8" title="1">{
                                z[j+i] ^= b[i] &amp; mask
                        }</span>
                }
                <span class="cov8" title="1">for i := FieldElementLimbs; i &gt; 0; i-- </span><span class="cov8" title="1">{
                        b[i] = b[i]&lt;&lt;1 | b[i-1]&gt;&gt;63
                }</span>
                <span class="cov8" title="1">b[0] &lt;&lt;= 1</span>
        }
        // Modular reduction (stacked precomputation of Algorithm 2.40 in t, see Figure 2.9)
        <span class="cov8" title="1">for i := 2*FieldElementLimbs - 1; i &gt;= FieldElementLimbs; i-- </span><span class="cov8" title="1">{
                z[i-2] ^= z[i] &lt;&lt; 7
                z[i-1] ^= z[i] &gt;&gt; 57
                z[i-2] ^= z[i] &lt;&lt; 2
                z[i-1] ^= z[i] &gt;&gt; 62
                z[i-2] ^= z[i] &lt;&lt; 1
                z[i-1] ^= z[i] &gt;&gt; 63
                z[i-2] ^= z[i]
        }</span>

        <span class="cov8" title="1">return (*FieldElement)(&amp;[FieldElementLimbs]uint64{z[0], z[1]})</span>
}

func (el *FieldElement) Bytes() []byte <span class="cov0" title="0">{
        buf := make([]byte, FieldElementSize)
        binary.BigEndian.PutUint64(buf[:8], el[1])
        binary.BigEndian.PutUint64(buf[8:16], el[0])
        return buf
}</span>

func (el *FieldElement) Equal(rhs *FieldElement) bool <span class="cov8" title="1">{
        return ((el[0] ^ rhs[0]) | (el[1] ^ rhs[1])) == 0
}</span>

func (el *FieldElement) shiftLeft(k int) *FieldElement <span class="cov8" title="1">{
        if k &lt;= 0 </span><span class="cov8" title="1">{
                return el.Clone()
        }</span>
        <span class="cov8" title="1">if k &gt;= 128 </span><span class="cov0" title="0">{
                return &amp;FieldElement{0, 0}
        }</span>
        <span class="cov8" title="1">if k &gt;= 64 </span><span class="cov0" title="0">{
                return &amp;FieldElement{0, el[0] &lt;&lt; (k - 64)}
        }</span>
        <span class="cov8" title="1">return &amp;FieldElement{el[0] &lt;&lt; k, (el[1] &lt;&lt; k) | (el[0] &gt;&gt; (64 - k))}</span>
}

func (el *FieldElement) degree() int <span class="cov8" title="1">{
        z := bits.LeadingZeros64(el[1])
        if z == 64 </span><span class="cov8" title="1">{
                z += bits.LeadingZeros64(el[0])
        }</span>

        <span class="cov8" title="1">d := 127 - z
        if d &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span> else<span class="cov8" title="1"> {
                return d
        }</span>
}

var (
        ErrDivisionByZero = errs2.New("division by zero")
        ErrInvalidLength  = errs2.New("invalid length")
)
</pre>
		
		<pre class="file" id="file24" style="display: none">//TODO: (Mateusz) Implement this before the audit

// Copyright (c) 2014 Dropbox, Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
// list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its contributors
// may be used to endorse or promote products derived from this software without
// specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package bitvec

// A BitVector is a variable sized vector of bits. It supports
// lookups, sets, appends, insertions, and deletions.
//
// This class is not thread safe.
type BitVector struct {
        data   []byte
        length int
}

// NewBitVector creates and initialises a new bit vector with length
// elements, using data as its initial contents.
func NewBitVector(data []byte, length int) *BitVector <span class="cov0" title="0">{
        return &amp;BitVector{
                data:   data,
                length: length,
        }
}</span>

// Bytes returns a slice of the contents of the bit vector. If the caller changes the returned slice,
// the contents of the bit vector may change.
func (vector *BitVector) Bytes() []byte <span class="cov0" title="0">{
        return vector.data
}</span>

// Length returns the current number of elements in the bit vector.
func (vector *BitVector) Length() int <span class="cov0" title="0">{
        return vector.length
}</span>

// This function shifts a byte slice one bit lower (less significant).
// bit (either 1 or 0) contains the bit to put in the most significant
// position of the last byte in the slice.
// This returns the bit that was shifted off of the last byte.
func shiftLower(bit byte, b []byte) byte <span class="cov0" title="0">{
        bit &lt;&lt;= 7
        for i := len(b) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                newByte := b[i] &gt;&gt; 1
                newByte |= bit
                bit = (b[i] &amp; 1) &lt;&lt; 7
                b[i] = newByte
        }</span>
        <span class="cov0" title="0">return bit &gt;&gt; 7</span>
}

// This function shifts a byte slice one bit higher (more significant).
// bit (either 1 or 0) contains the bit to put in the least significant
// position of the first byte in the slice.
// This returns the bit that was shifted off the last byte.
func shiftHigher(bit byte, b []byte) byte <span class="cov0" title="0">{
        for i := 0; i &lt; len(b); i++ </span><span class="cov0" title="0">{
                newByte := b[i] &lt;&lt; 1
                newByte |= bit
                bit = (b[i] &amp; 0x80) &gt;&gt; 7
                b[i] = newByte
        }</span>
        <span class="cov0" title="0">return bit</span>
}

// Returns the minimum number of bytes needed for storing the bit vector.
func (vector *BitVector) bytesLength() int <span class="cov0" title="0">{
        lastBitIndex := vector.length - 1
        lastByteIndex := lastBitIndex &gt;&gt; 3
        return lastByteIndex + 1
}</span>

// Panics if the given index is not within the bounds of the bit vector.
func (vector *BitVector) indexAssert(i int) <span class="cov0" title="0">{
        if i &lt; 0 || i &gt;= vector.length </span><span class="cov0" title="0">{
                panic("Attempted to access element outside buffer")</span>
        }
}

// Append adds a bit to the end of a bit vector.
func (vector *BitVector) Append(bit byte) <span class="cov0" title="0">{
        index := uint32(vector.length)
        vector.length++

        if vector.bytesLength() &gt; len(vector.data) </span><span class="cov0" title="0">{
                vector.data = append(vector.data, 0)
        }</span>

        <span class="cov0" title="0">byteIndex := index &gt;&gt; 3
        byteOffset := index % 8
        oldByte := vector.data[byteIndex]
        var newByte byte
        if bit == 1 </span><span class="cov0" title="0">{
                newByte = oldByte | 1&lt;&lt;byteOffset
        }</span> else<span class="cov0" title="0"> {
                // Set all bits except the byteOffset
                mask := byte(^(1 &lt;&lt; byteOffset))
                newByte = oldByte &amp; mask
        }</span>

        <span class="cov0" title="0">vector.data[byteIndex] = newByte</span>
}

// Element returns the bit in the ith index of the bit vector.
// Returned value is either 1 or 0.
func (vector *BitVector) Element(i int) byte <span class="cov0" title="0">{
        vector.indexAssert(i)
        byteIndex := i &gt;&gt; 3
        byteOffset := uint32(i % 8)
        b := vector.data[byteIndex]
        // Check the offset bit
        return (b &gt;&gt; byteOffset) &amp; 1
}</span>

// Set changes the bit in the ith index of the bit vector to the value specified in
// bit.
func (vector *BitVector) Set(bit byte, index int) <span class="cov0" title="0">{
        vector.indexAssert(index)
        byteIndex := uint32(index &gt;&gt; 3)
        byteOffset := uint32(index % 8)

        oldByte := vector.data[byteIndex]

        var newByte byte
        if bit == 1 </span><span class="cov0" title="0">{
                // turn on the byteOffset'th bit
                newByte = oldByte | 1&lt;&lt;byteOffset
        }</span> else<span class="cov0" title="0"> {
                // turn off the byteOffset'th bit
                removeMask := byte(^(1 &lt;&lt; byteOffset))
                newByte = oldByte &amp; removeMask
        }</span>
        <span class="cov0" title="0">vector.data[byteIndex] = newByte</span>
}

// Insert inserts bit into the supplied index of the bit vector. All
// bits in positions greater than or equal to index before the call will
// be shifted up by one.
func (vector *BitVector) Insert(bit byte, index int) <span class="cov0" title="0">{
        vector.indexAssert(index)
        vector.length++

        // Append an additional byte if necessary.
        if vector.bytesLength() &gt; len(vector.data) </span><span class="cov0" title="0">{
                vector.data = append(vector.data, 0)
        }</span>

        <span class="cov0" title="0">byteIndex := uint32(index &gt;&gt; 3)
        byteOffset := uint32(index % 8)
        var bitToInsert byte
        if bit == 1 </span><span class="cov0" title="0">{
                bitToInsert = 1 &lt;&lt; byteOffset
        }</span>

        <span class="cov0" title="0">oldByte := vector.data[byteIndex]
        // This bit will need to be shifted into the next byte
        leftoverBit := (oldByte &amp; 0x80) &gt;&gt; 7
        // Make masks to pull off the bits below and above byteOffset
        // This mask has the byteOffset lowest bits set.
        bottomMask := byte((1 &lt;&lt; byteOffset) - 1)
        // This mask has the 8 - byteOffset top bits set.
        topMask := ^bottomMask
        top := (oldByte &amp; topMask) &lt;&lt; 1
        newByte := bitToInsert | (oldByte &amp; bottomMask) | top

        vector.data[byteIndex] = newByte
        // Shift the rest of the bytes in the slice one higher, append
        // the leftoverBit obtained above.
        shiftHigher(leftoverBit, vector.data[byteIndex+1:])</span>
}

// Delete removes the bit in the supplied index of the bit vector. All
// bits in positions greater than or equal to index before the call will
// be shifted down by one.
func (vector *BitVector) Delete(index int) <span class="cov0" title="0">{
        vector.indexAssert(index)
        vector.length--
        byteIndex := uint32(index &gt;&gt; 3)
        byteOffset := uint32(index % 8)

        oldByte := vector.data[byteIndex]

        // Shift all the bytes above the byte we're modifying, return the
        // leftover bit to include in the byte we're modifying.
        bit := shiftLower(0, vector.data[byteIndex+1:])

        // Modify oldByte.
        // At a high level, we want to select the bits above byteOffset,
        // and shift them down by one, removing the bit at byteOffset.

        // This selects the bottom bits
        bottomMask := byte((1 &lt;&lt; byteOffset) - 1)
        // This selects the top (8 - byteOffset - 1) bits
        topMask := byte(^((1 &lt;&lt; (byteOffset + 1)) - 1))
        // newTop is the top bits, shifted down one, combined with the leftover bit from shifting
        // the other bytes.
        newTop := (oldByte&amp;topMask)&gt;&gt;1 | (bit &lt;&lt; 7)
        // newByte takes the bottom bits and combines with the new top.
        newByte := (bottomMask &amp; oldByte) | newTop
        vector.data[byteIndex] = newByte

        // The desired length is the byte index of the last element plus one,
        // where the byte index of the last element is the bit index of the last
        // element divided by 8.
        byteLength := vector.bytesLength()
        if byteLength &lt; len(vector.data) </span><span class="cov0" title="0">{
                vector.data = vector.data[:byteLength]
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">//go:build !purego &amp;&amp; !nobignum

package boring

// #include "openssl/bn.h"
import (
        "C"
)

import (
        "runtime"
        "unsafe"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/nocopy"
)

type nativeBigNum = C.BIGNUM

type BigNum struct {
        nativeBigNum

        noCopy      nocopy.NoCopy
        copyChecker nocopy.CopyChecker
}

var (
        oneLimbs = []C.BN_ULONG{1}
        One      = &amp;BigNum{}
)

//nolint:gochecknoinits // allow initialization of native values
func init() <span class="cov8" title="1">{
        One.nativeBigNum.d = &amp;oneLimbs[0]
        One.nativeBigNum.width = 1
        One.nativeBigNum.dmax = 1
        One.nativeBigNum.neg = 0
        One.nativeBigNum.flags = C.BN_FLG_STATIC_DATA
}</span>

// NewBigNum creates a new BigNum and initialises it.
func NewBigNum() *BigNum <span class="cov8" title="1">{
        bn := &amp;BigNum{}
        C.BN_init(&amp;bn.nativeBigNum)

        runtime.SetFinalizer(bn, func(bn *BigNum) </span><span class="cov8" title="1">{
                C.BN_clear_free(&amp;bn.nativeBigNum)
                runtime.KeepAlive(bn)
        }</span>)

        <span class="cov8" title="1">bn.copyChecker.Check()
        return bn</span>
}

// GenPrime sets bn to a prime number of bits length.
// If safe is true then the prime will be such that (bn-1)/2 is also a prime.
// (This is needed for Diffie-Hellman groups to ensure that the only subgroups are of size 2 and (p-1)/2.)
// Beware: this function is rather slow for safe primes. Use dedicated DiffieHellmanGroup.GenerateParameters instead.
func (bn *BigNum) GenPrime(bits int, safe ct.Bool) (*BigNum, error) <span class="cov0" title="0">{
        bn.copyChecker.Check()

        lockOSThread()
        ret := C.BN_generate_prime_ex(&amp;bn.nativeBigNum, (C.int)(bits), (C.int)(safe), nil, nil, nil)
        if ret != 1 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        return bn, nil</span>
}

// Gcd sets bn = gcd(a, b). Internally, BoringSSL's GCD's output is an odd number plus a leftShift
// to make it even (corresponding to `bn_rshift_secret_shift`), if needed. Therefore:
// - Algorithm is constant time ONLY IF at least one argument is odd.
func (bn *BigNum) Gcd(a, b *BigNum, bnCtx *BigNumCtx) (*BigNum, error) <span class="cov0" title="0">{
        bn.copyChecker.Check()
        a.copyChecker.Check()
        b.copyChecker.Check()
        bnCtx.copyChecker.Check()

        lockOSThread()
        ret := C.BN_gcd(&amp;bn.nativeBigNum, &amp;a.nativeBigNum, &amp;b.nativeBigNum, bnCtx.nativeBnCtx)
        if ret != 1 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        runtime.KeepAlive(a)
        runtime.KeepAlive(b)
        runtime.KeepAlive(bnCtx)
        return bn, nil</span>
}

// Inv sets bn = a^{-1} mod n using BoringSSL's constant-time, blinded
// modular inverse. The modulus n is taken from the provided Montgomery context
// (montCtx). It returns the receiver (bn), a boolean noInverse which is true
// iff a has no inverse modulo n, and an error for other failures.
//
// Requirements:
//   - 0 &lt;= a &lt; n (callers should reduce a beforehand).
//   - n &gt; 1. The function is intended for moduli with few noninvertible
//     residues (e.g., RSA moduli). See bn.h for details.
//   - montCtx must be initialised for n. If n is secret, use a consttime
//     Montgomery context.
func (bn *BigNum) Inv(a *BigNum, montCtx *BigNumMontCtx, bnCtx *BigNumCtx) (*BigNum, int32, error) <span class="cov0" title="0">{
        bn.copyChecker.Check()
        a.copyChecker.Check()
        montCtx.copyChecker.Check()
        bnCtx.copyChecker.Check()

        // Lock OS thread to ensure error queue is on the same thread as the CGO call
        lockOSThread()
        var noInv C.int
        ret := C.BN_mod_inverse_blinded(&amp;bn.nativeBigNum, &amp;noInv, &amp;a.nativeBigNum, montCtx.nativeBnMontCtx, bnCtx.nativeBnCtx)
        if ret != 1 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, int32(noInv), err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        runtime.KeepAlive(a)
        runtime.KeepAlive(montCtx)
        runtime.KeepAlive(bnCtx)
        return bn, int32(noInv), nil</span>
}

// Bytes serialises the value of bn as a big-endian integer.
func (bn *BigNum) Bytes() ([]byte, error) <span class="cov8" title="1">{
        bn.copyChecker.Check()

        announcedLen := ((C.BN_BITS2 * bn.nativeBigNum.width) + 7) / 8
        buffer := make([]byte, announcedLen)
        if announcedLen &gt; 0 </span><span class="cov8" title="1">{
                lockOSThread()
                ret := C.BN_bn2bin_padded((*C.uint8_t)(&amp;buffer[0]), (C.size_t)(announcedLen), &amp;bn.nativeBigNum)
                if ret != 1 </span><span class="cov0" title="0">{
                        err := lastError()
                        unlockOSThread()
                        return nil, err
                }</span>
                <span class="cov8" title="1">unlockOSThread()</span>
        }

        <span class="cov8" title="1">runtime.KeepAlive(bn)
        return buffer, nil</span>
}

// Exp sets bn equal to a^p mod m.
// It treats a, p, and m as secrets and requires 0 &lt;= a &lt; m.
func (bn *BigNum) Exp(a, p, m *BigNum, montCtx *BigNumMontCtx, bnCtx *BigNumCtx) (*BigNum, error) <span class="cov8" title="1">{
        bn.copyChecker.Check()
        a.copyChecker.Check()
        p.copyChecker.Check()
        m.copyChecker.Check()
        montCtx.copyChecker.Check()
        bnCtx.copyChecker.Check()

        lockOSThread()
        ret := C.BN_mod_exp_mont_consttime(&amp;bn.nativeBigNum, &amp;a.nativeBigNum, &amp;p.nativeBigNum, &amp;m.nativeBigNum, bnCtx.nativeBnCtx, montCtx.nativeBnMontCtx)
        if ret != 1 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        runtime.KeepAlive(a)
        runtime.KeepAlive(p)
        runtime.KeepAlive(m)
        runtime.KeepAlive(montCtx)
        runtime.KeepAlive(bnCtx)
        return bn, nil</span>
}

// ModMul sets bn = a*b mod m.
func (bn *BigNum) ModMul(l, r, m *BigNum, bnCtx *BigNumCtx) (*BigNum, error) <span class="cov0" title="0">{
        bn.copyChecker.Check()
        l.copyChecker.Check()
        r.copyChecker.Check()
        m.copyChecker.Check()
        bnCtx.copyChecker.Check()

        lockOSThread()
        ret := C.BN_mod_mul(&amp;bn.nativeBigNum, &amp;l.nativeBigNum, &amp;r.nativeBigNum, &amp;m.nativeBigNum, bnCtx.nativeBnCtx)
        if ret != 1 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        runtime.KeepAlive(l)
        runtime.KeepAlive(r)
        runtime.KeepAlive(m)
        runtime.KeepAlive(bnCtx)
        return bn, nil</span>
}

// ModSub sets bn = l - r mod m
// It requires that l and r be less than m.
func (bn *BigNum) ModSub(l, r, m *BigNum) (*BigNum, error) <span class="cov0" title="0">{
        bn.copyChecker.Check()
        l.copyChecker.Check()
        r.copyChecker.Check()
        m.copyChecker.Check()

        lockOSThread()
        ret := C.BN_mod_sub_quick(&amp;bn.nativeBigNum, &amp;l.nativeBigNum, &amp;r.nativeBigNum, &amp;m.nativeBigNum)
        if ret != 1 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        runtime.KeepAlive(l)
        runtime.KeepAlive(r)
        runtime.KeepAlive(m)
        return bn, nil</span>
}

// ModAdd sets bn = l + r mod m.
// It requires that l and r be less than m.
func (bn *BigNum) ModAdd(l, r, m *BigNum) (*BigNum, error) <span class="cov0" title="0">{
        bn.copyChecker.Check()
        l.copyChecker.Check()
        r.copyChecker.Check()
        m.copyChecker.Check()

        lockOSThread()
        ret := C.BN_mod_add_quick(&amp;bn.nativeBigNum, &amp;l.nativeBigNum, &amp;r.nativeBigNum, &amp;m.nativeBigNum)
        if ret != 1 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        runtime.KeepAlive(l)
        runtime.KeepAlive(r)
        runtime.KeepAlive(m)
        return bn, nil</span>
}

// Mod sets bn = x mod m.
func (bn *BigNum) Mod(x, m *BigNum, bnCtx *BigNumCtx) (*BigNum, error) <span class="cov8" title="1">{
        bn.copyChecker.Check()
        x.copyChecker.Check()
        m.copyChecker.Check()
        bnCtx.copyChecker.Check()

        lockOSThread()
        r := C.BN_nnmod(&amp;bn.nativeBigNum, &amp;x.nativeBigNum, &amp;m.nativeBigNum, bnCtx.nativeBnCtx)
        if r != 1 </span><span class="cov8" title="1">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        runtime.KeepAlive(x)
        runtime.KeepAlive(m)
        runtime.KeepAlive(bnCtx)

        return bn, nil</span>
}

// SetBytes sets bn to the value of bytes from data, interpreted as a big-endian number.
func (bn *BigNum) SetBytes(data []byte) (*BigNum, error) <span class="cov8" title="1">{
        bn.copyChecker.Check()

        if len(data) == 0 </span><span class="cov0" title="0">{
                C.BN_clear_free(&amp;bn.nativeBigNum)
                C.BN_init(&amp;bn.nativeBigNum)
                return bn, nil
        }</span>

        <span class="cov8" title="1">lockOSThread()
        rawData := (*C.uint8_t)(unsafe.Pointer(&amp;data[0]))
        r := C.BN_bin2bn(rawData, C.size_t(len(data)), &amp;bn.nativeBigNum)
        if r == nil </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov8" title="1">unlockOSThread()

        runtime.KeepAlive(data)
        return bn, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">//go:build !purego &amp;&amp; !nobignum

package boring

// #include "openssl/bn.h"
import "C"
import (
        "runtime"

        "github.com/bronlabs/bron-crypto/pkg/base/utils/nocopy"
)

type nativeBnCtx = *C.BN_CTX

type BigNumCtx struct {
        nativeBnCtx

        noCopy      nocopy.NoCopy
        copyChecker nocopy.CopyChecker
}

func NewBigNumCtx() *BigNumCtx <span class="cov8" title="1">{
        bnCtx := C.BN_CTX_new()
        if bnCtx == nil </span><span class="cov0" title="0">{
                panic("BN_CTX_new")</span>
        }
        <span class="cov8" title="1">ctx := &amp;BigNumCtx{
                nativeBnCtx: bnCtx,
        }
        runtime.SetFinalizer(ctx, func(ctx *BigNumCtx) </span><span class="cov8" title="1">{
                C.BN_CTX_free(ctx.nativeBnCtx)
                ctx.nativeBnCtx = nil
                runtime.KeepAlive(ctx)
        }</span>)

        <span class="cov8" title="1">ctx.copyChecker.Check()
        return ctx</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">//go:build !purego &amp;&amp; !nobignum

package boring

// #include "openssl/bn.h"
import "C"
import (
        "runtime"

        "github.com/bronlabs/bron-crypto/pkg/base/utils/nocopy"
)

type nativeBnMontCtx = *C.BN_MONT_CTX

type BigNumMontCtx struct {
        nativeBnMontCtx

        noCopy      nocopy.NoCopy
        copyChecker nocopy.CopyChecker
}

func NewBigNumMontCtx(m *BigNum, bigNumCtx *BigNumCtx) (*BigNumMontCtx, error) <span class="cov8" title="1">{
        m.copyChecker.Check()
        bigNumCtx.copyChecker.Check()

        lockOSThread()
        nativeCtx := C.BN_MONT_CTX_new_consttime(&amp;m.nativeBigNum, bigNumCtx.nativeBnCtx)
        if nativeCtx == nil </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov8" title="1">unlockOSThread()

        ctx := &amp;BigNumMontCtx{
                nativeBnMontCtx: nativeCtx,
        }

        runtime.SetFinalizer(ctx, func(montCtx *BigNumMontCtx) </span><span class="cov8" title="1">{
                C.BN_MONT_CTX_free(montCtx.nativeBnMontCtx)
                montCtx.nativeBnMontCtx = nil
                runtime.KeepAlive(montCtx)
        }</span>)

        <span class="cov8" title="1">ctx.copyChecker.Check()
        runtime.KeepAlive(m)
        runtime.KeepAlive(bigNumCtx)
        return ctx, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">//go:build !purego &amp;&amp; !nobignum

package boring

// #include "openssl/dh.h"
// #include "openssl/bn.h"
import "C"
import (
        "runtime"

        "github.com/bronlabs/bron-crypto/pkg/base/utils/nocopy"
)

type nativeDh = *C.DH

type DiffieHellmanGroup struct {
        nativeDh

        nocopy.NoCopy
        copyChecker nocopy.CopyChecker
}

func NewDiffieHellmanGroup() *DiffieHellmanGroup <span class="cov8" title="1">{
        dh := C.DH_new()
        if dh == nil </span><span class="cov0" title="0">{
                panic("DH_new")</span>
        }
        <span class="cov8" title="1">dhGroup := &amp;DiffieHellmanGroup{
                nativeDh: dh,
        }
        runtime.SetFinalizer(dhGroup, func(dhGroup *DiffieHellmanGroup) </span><span class="cov8" title="1">{
                C.DH_free(dhGroup.nativeDh)
                dhGroup.nativeDh = nil
                runtime.KeepAlive(dhGroup)
        }</span>)

        <span class="cov8" title="1">dhGroup.copyChecker.Check()
        return dhGroup</span>
}

func (dh *DiffieHellmanGroup) GenerateParameters(primeBits int) *DiffieHellmanGroup <span class="cov8" title="1">{
        dh.copyChecker.Check()

        ret := C.DH_generate_parameters_ex(dh.nativeDh, C.int(primeBits), C.DH_GENERATOR_2, nil)
        if ret != 1 </span><span class="cov0" title="0">{
                panic("DH_generate_parameters_ex")</span>
        }

        <span class="cov8" title="1">return dh</span>
}

func (dh *DiffieHellmanGroup) GetP() *BigNum <span class="cov8" title="1">{
        dh.copyChecker.Check()

        nativeP := C.DH_get0_p(dh.nativeDh)
        if nativeP == nil </span><span class="cov0" title="0">{
                panic("DH_get0_p")</span>
        }
        <span class="cov8" title="1">p := NewBigNum()
        ret := C.BN_copy(&amp;p.nativeBigNum, nativeP)
        if ret == nil </span><span class="cov0" title="0">{
                panic("DH_get0_p")</span>
        }

        <span class="cov8" title="1">runtime.KeepAlive(dh)
        return p</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">//go:build !purego &amp;&amp; !nobignum

package boring

import "C"
import (
        "bytes"
        "runtime"
        "unsafe"
)

// #include "openssl/bn.h"
// #include "openssl/err.h"
//
// extern int bn_jacobi(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
// extern int bn_lcm_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
// OPENSSL_EXPORT int BN_jacobi(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
// OPENSSL_EXPORT int BN_lcm_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
//
// int BN_jacobi(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx) {
//     return bn_jacobi(a, b, ctx);
// }
//
// int BN_lcm_consttime(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx) {
//     return bn_lcm_consttime(r, a, b, ctx);
// }
import (
        "C"
)

import (
        "errors"
)

func (bn *BigNum) Jacobi(b *BigNum, bnCtx *BigNumCtx) (int, error) <span class="cov8" title="1">{
        bn.copyChecker.Check()
        b.copyChecker.Check()
        bnCtx.copyChecker.Check()

        lockOSThread()
        ret := C.BN_jacobi(&amp;bn.nativeBigNum, &amp;b.nativeBigNum, bnCtx.nativeBnCtx)
        if ret == -2 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return 0, err
        }</span>
        <span class="cov8" title="1">unlockOSThread()

        runtime.KeepAlive(bn)
        runtime.KeepAlive(b)
        runtime.KeepAlive(bnCtx)
        return int(ret), nil</span>
}

func (bn *BigNum) Lcm(a, b *BigNum, bnCtx *BigNumCtx) (*BigNum, error) <span class="cov0" title="0">{
        bn.copyChecker.Check()
        a.copyChecker.Check()
        b.copyChecker.Check()
        bnCtx.copyChecker.Check()

        lockOSThread()
        ret := C.BN_lcm_consttime(&amp;bn.nativeBigNum, &amp;a.nativeBigNum, &amp;b.nativeBigNum, bnCtx.nativeBnCtx)
        if ret != 1 </span><span class="cov0" title="0">{
                err := lastError()
                unlockOSThread()
                return nil, err
        }</span>
        <span class="cov0" title="0">unlockOSThread()

        runtime.KeepAlive(a)
        runtime.KeepAlive(b)
        runtime.KeepAlive(bnCtx)
        return bn, nil</span>
}

// lastError retrieves the most recent error from BoringSSL's thread-local error queue.
// IMPORTANT: This must be called on the same OS thread as the CGO call that failed.
// Use lockOSThread/unlockOSThread around CGO calls that may fail to ensure thread affinity.
func lastError() error <span class="cov8" title="1">{
        errno := C.ERR_get_error()
        if errno == 0 </span><span class="cov0" title="0">{
                // No error on this thread's queue - this can happen if the goroutine
                // migrated to a different OS thread between the CGO call and this call.
                // Return a generic error instead of panicking.
                return errors.New("boringssl: operation failed (error queue empty)")
        }</span>

        <span class="cov8" title="1">var errBytes [128]byte
        ret := C.ERR_error_string_n(errno, (*C.char)(unsafe.Pointer(&amp;errBytes[0])), C.size_t(len(errBytes)))
        if ret == nil </span><span class="cov0" title="0">{
                panic("ERR_error_string_n")</span>
        }

        <span class="cov8" title="1">n := bytes.IndexByte(errBytes[:], 0)
        errString := string(errBytes[:n])
        err := errors.New(errString) //nolint:goerr113 // dynamic error from native

        return err</span> //nolint:wrapcheck // false positive
}

// lockOSThread pins the current goroutine to its OS thread.
// This MUST be called before any CGO operation that may fail and require error retrieval.
// Call unlockOSThread when done with the CGO operation and error handling.
func lockOSThread() <span class="cov8" title="1">{
        runtime.LockOSThread()
}</span>

// unlockOSThread unpins the current goroutine from its OS thread.
// This should be called after CGO operations and error handling are complete.
func unlockOSThread() <span class="cov8" title="1">{
        runtime.UnlockOSThread()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package ct

import "crypto/subtle"

// CompareBytes is the constant-time counterpart of bytes.Compare.
// Lexicographic: first differing byte decides; if one is a prefix,
// the shorter slice is smaller.
func CompareBytes[T ~[]byte](x, y T) (lt, eq, gt Bool) <span class="cov8" title="1">{
        lenX := len(x)
        lenY := len(y)
        minLen := Min(lenX, lenY)
        maxLen := Max(lenX, lenY)

        // Pad both slices to maxLen for constant-time access
        px := make([]byte, maxLen)
        py := make([]byte, maxLen)
        copy(px, x)
        copy(py, y)

        // Compare byte by byte up to minLen
        var done Choice // becomes 1 after the first difference
        for i := range minLen </span><span class="cov8" title="1">{
                bx := px[i]
                by := py[i]

                less := LessU64(uint64(bx), uint64(by))
                greater := LessU64(uint64(by), uint64(bx))

                mask := done ^ 1
                lt |= less &amp; mask
                gt |= greater &amp; mask
                done |= less | greater
        }</span>

        // If all bytes up to minLen are equal, the shorter slice is less
        // Check lengths in constant time
        <span class="cov8" title="1">xShorter := Less(lenX, lenY)
        yShorter := Less(lenY, lenX)
        allEqual := done ^ 1

        lt |= xShorter &amp; allEqual
        gt |= yShorter &amp; allEqual
        eq = Equal(lenX, lenY) &amp; allEqual

        return lt, eq, gt</span>
}

// XorBytes computes the bitwise XOR of two byte slices and stores the result in dst.
// panics if dst is smaller than either x or y.
func XorBytes[T ~[]byte](dst, x, y T) int <span class="cov0" title="0">{
        return subtle.XORBytes(dst, x, y)
}</span>

// AndBytes computes the bitwise AND of two byte slices and stores the result in dst.
// panics if dst is smaller than either x or y.
func AndBytes[T ~[]byte](dst, x, y T) int <span class="cov8" title="1">{
        n := min(len(x), len(y))
        if n == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if n &gt; len(dst) </span><span class="cov0" title="0">{
                panic("dst too short")</span>
        }
        <span class="cov8" title="1">for i := range n </span><span class="cov8" title="1">{
                dst[i] = x[i] &amp; y[i]
        }</span>
        <span class="cov8" title="1">return n</span>
}

// OrBytes computes the bitwise OR of two byte slices and stores the result in dst.
// panics if dst is smaller than either x or y.
func OrBytes[T ~[]byte](dst, x, y T) int <span class="cov8" title="1">{
        n := min(len(x), len(y))
        if n == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if n &gt; len(dst) </span><span class="cov0" title="0">{
                panic("dst too short")</span>
        }
        <span class="cov8" title="1">for i := range n </span><span class="cov8" title="1">{
                dst[i] = x[i] | y[i]
        }</span>
        <span class="cov8" title="1">return n</span>
}

// NotBytes computes the bitwise NOT of a byte slice and stores the result in dst.
// panics if dst is smaller than x.
func NotBytes[T ~[]byte](dst, x T) int <span class="cov8" title="1">{
        n := len(x)
        if n == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if n &gt; len(dst) </span><span class="cov0" title="0">{
                panic("dst too short")</span>
        }
        <span class="cov8" title="1">for i := range n </span><span class="cov8" title="1">{
                dst[i] = ^x[i]
        }</span>
        <span class="cov8" title="1">return n</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package ct

type (
        // Choice represents a constant-time boolean choice.
        Choice uint64
        Bool   = Choice // TODO: remove
)

const (
        Zero Choice = 0
        One  Choice = 1

        False Bool = 0
        True  Bool = 1
)

// Not returns the negation of the Choice.
func (c Choice) Not() Choice <span class="cov8" title="1">{
        return c ^ One
}</span>

// Comparable represents types that can be compared in constant time.
type Comparable[E any] interface {
        // Compare compares the receiver with rhs and returns gt, eq, lt as Bool values.
        Compare(rhs E) (gt, eq, lt Bool)
}

// Equatable represents types that can be checked for equality in constant time.
type Equatable[E any] interface {
        // Equal checks if the receiver is equal to rhs and returns the result as a Bool value.
        Equal(rhs E) Bool
}

// ConditionallySelectable represents types that can be conditionally selected in constant time.
type ConditionallySelectable[E any] interface {
        // Select selects between x0 and x1 based on the Choice value.
        Select(choice Choice, x0, x1 E)
}

// ConditionallyAssignable represents types that can be conditionally assigned in constant time.
type ConditionallyAssignable[E any] interface {
        // CondAssign conditionally assigns rhs to the receiver based on the Choice value.
        CondAssign(Choice, E)
}

// ConditionallyNegatable represents types that can be conditionally negated in constant time.
type ConditionallyNegatable[E any] interface {
        // CondNeg conditionally negates the receiver based on the Choice value.
        CondNeg(Choice)
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package ct

import (
        "reflect"

        "golang.org/x/exp/constraints"
)

// IsZero returns 1 if x == 0 and 0 otherwise.
func IsZero[I constraints.Integer](x I) Choice <span class="cov8" title="1">{
        // Handle all integer sizes properly
        xx := uint64(x)
        // For unsigned types, -xx wraps around; for signed types it negates
        // The bitwise OR with its negation sets the MSB if x != 0
        return Choice(((xx | -xx) &gt;&gt; 63) ^ 1)
}</span>

// Equal returns 1 if x == y and 0 otherwise.
func Equal[I constraints.Integer](x, y I) Choice <span class="cov8" title="1">{
        return IsZero(x ^ y)
}</span>

// Greater returns 1 iff x &gt; y, using the natural order of I.
func Greater[I constraints.Integer](x, y I) Choice <span class="cov8" title="1">{
        return Less(y, x)
}</span>

// Less returns 1 iff x &lt; y.
func Less[I constraints.Integer](x, y I) Choice <span class="cov8" title="1">{
        if isSigned[I]() </span><span class="cov8" title="1">{
                return LessI64(int64(x), int64(y))
        }</span>
        <span class="cov8" title="1">return LessU64(uint64(x), uint64(y))</span>
}

// LessOrEqual returns 1 iff x &lt;= y.
func LessOrEqual[I constraints.Integer](x, y I) Choice <span class="cov8" title="1">{
        return Greater(x, y) ^ 1
}</span>

// GreaterOrEqual returns 1 iff x &gt;= y.
func GreaterOrEqual[I constraints.Integer](x, y I) Choice <span class="cov8" title="1">{
        return Less(x, y) ^ 1
}</span>

// CompareInt compares x and y and returns (gt, eq, lt) where each is 1 or 0.
func CompareInt[I constraints.Integer](x, y I) (gt, eq, lt Bool) <span class="cov8" title="1">{
        // Equal: 1 if x == y, else 0
        eq = Equal(x, y)

        // Greater: 1 if x &gt; y, else 0
        gt = Greater(x, y)

        // Less: 1 if x &lt; y, else 0
        lt = Less(x, y)
        return gt, eq, lt
}</span>

// CSelectInt returns x0 if choice == 0 and x1 if choice == 1. Undefined for other values of choice.
// It supports both signed and unsigned integer types.
func CSelectInt[I constraints.Integer](choice Choice, x0, x1 I) I <span class="cov8" title="1">{
        mask := I(-int64(choice)) // 0 if choice == 0, -1 (all bits 1) if choice == 1
        return (x0 &amp;^ mask) | (x1 &amp; mask)
}</span>

// CMOVInt sets *dst = *src iff yes==1; otherwise leaves *dst unchanged.
func CMOVInt[I constraints.Integer](dst *I, yes Choice, src *I) <span class="cov8" title="1">{
        // mask = 0 if yes==0, all-ones if yes==1
        mask := I(-int64(yes &amp; 1))
        *dst = (*dst &amp;^ mask) | (*src &amp; mask)
}</span>

// CSwapInt swaps *x and *y iff yes==1; otherwise leaves them unchanged.
func CSwapInt[I constraints.Integer](x, y *I, yes Choice) <span class="cov8" title="1">{
        mask := I(-int64(yes &amp; 1))
        d := (*x ^ *y) &amp; mask
        *x ^= d
        *y ^= d
}</span>

// Min returns the smaller of a and b in constant time.
func Min[T constraints.Integer](a, b T) T <span class="cov8" title="1">{
        // Select(choice, x0, x1): if choice=0 return x0, if choice=1 return x1
        // Less(a, b) returns 1 if a &lt; b, 0 otherwise
        // If a &lt; b (Less=1), we want a
        // If a &gt;= b (Less=0), we want b
        return CSelectInt(Less(a, b), b, a)
}</span>

// Max returns the larger of a and b in constant time.
func Max[T constraints.Integer](a, b T) T <span class="cov8" title="1">{
        // Select(choice, x0, x1): if choice=0 return x0, if choice=1 return x1
        // Greater(a, b) returns 1 if a &gt; b, 0 otherwise
        // If a &gt; b (Greater=1), we want a
        // If a &lt;= b (Greater=0), we want b
        return CSelectInt(Greater(a, b), b, a)
}</span>

// Isqrt64 computes floor(sqrt(n)) for a 64-bit n in constant time.
// Uses binary search with 32 iterations to ensure constant time execution.
func Isqrt64(n uint64) uint64 <span class="cov8" title="1">{
        var result uint64
        var bit uint64 = 1 &lt;&lt; 31 // Start with highest bit for 32-bit result

        // Binary search: test each bit from high to low
        for range 32 </span><span class="cov8" title="1">{
                temp := result + bit
                square := temp * temp
                // Keep the bit if temp^2 &lt;= n (no overflow for temp &lt; 2^32)
                le := LessOrEqual(square, n)
                result = CSelectInt(le, result, temp)
                bit &gt;&gt;= 1
        }</span>
        <span class="cov8" title="1">return result</span>
}

func isSigned[I constraints.Integer]() bool <span class="cov8" title="1">{
        var zero I
        switch reflect.TypeOf(zero).Kind() </span>{ //nolint:exhaustive // we only care about integer kinds here
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return true</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov8" title="1">
                return false</span>
        default:<span class="cov0" title="0">
                panic("not an integer type")</span>
        }
}

// LessU64 returns 1 iff x &lt; y for uint64 values.
func LessU64(x, y uint64) Choice <span class="cov8" title="1">{
        // Use borrow: x &lt; y iff x - y borrows (sets MSB)
        // But we need to check for borrow, not just MSB of result
        // x &lt; y iff (x ^ ((x ^ y) | ((x - y) ^ y))) has MSB set
        return Choice((x ^ ((x ^ y) | ((x - y) ^ y))) &gt;&gt; 63)
}</span>

// LessI64 returns 1 iff x &lt; y for int64 values.
func LessI64(x, y int64) Choice <span class="cov8" title="1">{
        // Convert to unsigned by flipping sign bit, then compare as unsigned
        ux := uint64(x) ^ (1 &lt;&lt; 63)
        uy := uint64(y) ^ (1 &lt;&lt; 63)
        return LessU64(ux, uy)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package ct

import (
        "golang.org/x/exp/constraints"
)

// SliceEachEqual returns 1 if all values of s are equal to e and returns 0 otherwise. Based on the subtle package.
func SliceEachEqual[S ~[]I, I constraints.Integer](s S, e I) Choice <span class="cov8" title="1">{
        v := I(0)
        for i := range s </span><span class="cov8" title="1">{
                v |= s[i] ^ e
        }</span>
        <span class="cov8" title="1">return IsZero(v)</span>
}

// SliceEqual returns 1 if x == y.
func SliceEqual[S ~[]I, I constraints.Integer](x, y S) Choice <span class="cov8" title="1">{
        if len(x) != len(y) </span><span class="cov8" title="1">{
                panic("ct: slices have different lengths")</span>
        }

        <span class="cov8" title="1">v := I(0)
        for i := range x </span><span class="cov8" title="1">{
                v |= x[i] ^ y[i]
        }</span>
        <span class="cov8" title="1">return IsZero(v)</span>
}

// SliceIsZero returns 1 if all values of s are equal to 0 and returns 0 otherwise. Based on the subtle package.
func SliceIsZero[S ~[]E, E constraints.Integer](s S) Choice <span class="cov8" title="1">{
        v := E(0)
        for _, e := range s </span><span class="cov8" title="1">{
                v |= e
        }</span>
        <span class="cov8" title="1">return IsZero(v)</span>
}

// CSelectInts yields x1 if choice == 1, x0 if choice == 0.
// Its behaviour is undefined if choice takes any other value.
func CSelectInts[S ~[]E, E constraints.Integer](choice Choice, x0, x1 S) S <span class="cov8" title="1">{
        if len(x0) != len(x1) </span><span class="cov8" title="1">{
                panic("ct: slices have different lengths")</span>
        }

        <span class="cov8" title="1">out := make(S, len(x0))
        for i := range out </span><span class="cov8" title="1">{
                out[i] = CSelectInt(choice, x0[i], x1[i])
        }</span>
        <span class="cov8" title="1">return out</span>
}

// CMOVInts does: dst[i] = src[i] iff yes==1; otherwise dst[i] unchanged.
// Panics if lengths differ.
func CMOVInts[S ~[]I, I constraints.Integer](dst, src S, yes Choice) <span class="cov8" title="1">{
        if len(dst) != len(src) </span><span class="cov8" title="1">{
                panic("ct: slices have different lengths")</span>
        }
        <span class="cov8" title="1">mask := I(-int64(yes &amp; 1))
        for i := range dst </span><span class="cov8" title="1">{
                dst[i] = (dst[i] &amp;^ mask) | (src[i] &amp; mask)
        }</span>
}

// CSwapInts swaps x[i] and y[i] iff yes==1; otherwise unchanged.
// Panics if lengths differ.
func CSwapInts[S ~[]I, I constraints.Integer](x, y S, yes Choice) <span class="cov8" title="1">{
        if len(x) != len(y) </span><span class="cov8" title="1">{
                panic("ct: slices have different lengths")</span>
        }
        <span class="cov8" title="1">mask := I(-int64(yes &amp; 1))
        for i := range x </span><span class="cov8" title="1">{
                d := (x[i] ^ y[i]) &amp; mask
                x[i] ^= d
                y[i] ^= d
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package curve25519

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Unmarshaler = (*Scalar)(nil)
        _ cbor.Marshaler   = (*Point)(nil)
        _ cbor.Unmarshaler = (*Point)(nil)
        _ cbor.Marshaler   = (*PrimeSubGroupPoint)(nil)
        _ cbor.Unmarshaler = (*PrimeSubGroupPoint)(nil)
)

type pointDTO struct {
        AffineUnompressedBytes []byte `cbor:"compressedBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (p *Point) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;pointDTO{AffineUnompressedBytes: p.ToUncompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *Point) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*pointDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pp, err := NewCurve().FromUncompressed(dto.AffineUnompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}

// MarshalCBOR implements cbor.Marshaler.
func (p *PrimeSubGroupPoint) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;pointDTO{AffineUnompressedBytes: p.ToUncompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *PrimeSubGroupPoint) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*pointDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pp, err := NewPrimeSubGroup().FromUncompressed(dto.AffineUnompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package curve25519

import (
        "fmt"
        "hash/fnv"
        "math/big"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        edwards25519Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

const (
        // CurveName is the curve name.
        CurveName = "curve25519"
        // Hash2CurveSuite is the hash-to-curve suite string.
        Hash2CurveSuite = "curve25519_XMD:SHA-512_ELL2_NU_"
)

var (
        _ curves.EllipticCurve[*Point, *BaseFieldElement, *Scalar] = (*Curve)(nil)
        _ curves.ECPoint[*Point, *BaseFieldElement, *Scalar]       = (*Point)(nil)

        curveInstance *Curve
        curveInitOnce sync.Once

        c edwards25519Impl.Fp
)

//nolint:gochecknoinits // init c
func init() <span class="cov8" title="1">{
        c.MustSetHex("0f26edf460a006bbd27b08dc03fc4f7ec5a1d3d14b7d1a82cc6e04aaff457e06")
}</span>

// Curve represents the elliptic curve group.
type Curve struct {
        traits.CurveTrait[*edwards25519Impl.Fp, *edwards25519Impl.Point, *Point, Point]
}

// NewCurve returns the curve instance.
func NewCurve() *Curve <span class="cov8" title="1">{
        curveInitOnce.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for a trait
                curveInstance = &amp;Curve{}
        }</span>)

        <span class="cov8" title="1">return curveInstance</span>
}

// Name returns the name of the structure.
func (*Curve) Name() string <span class="cov0" title="0">{
        return CurveName
}</span>

// Cofactor returns the curve cofactor.
func (*Curve) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(8)
}</span>

// Order returns the group or field order.
func (*Curve) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewScalarField().Order()
}</span>

// ElementSize returns the element size in bytes.
func (*Curve) ElementSize() int <span class="cov0" title="0">{
        return edwards25519Impl.FpBytes
}</span>

// FromCompressed decodes a compressed point.
func (c *Curve) FromCompressed(data []byte) (*Point, error) <span class="cov8" title="1">{
        if len(data) != 32 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid byte sequence")
        }</span>
        <span class="cov8" title="1">if sliceutils.All(data, func(b byte) bool </span><span class="cov8" title="1">{ return b == 0 }</span>) <span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov8" title="1">var one, u edwards25519Impl.Fp
        one.SetOne()
        ok := u.SetBytes(data)
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid compressed point")
        }</span>

        <span class="cov8" title="1">var n, d, dInv, y edwards25519Impl.Fp
        n.Sub(&amp;u, &amp;one)
        d.Add(&amp;u, &amp;one)
        ok = dInv.Inv(&amp;d)
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid compressed point")
        }</span>
        <span class="cov8" title="1">y.Mul(&amp;n, &amp;dInv)

        var p Point
        ok = p.V.SetFromAffineY(&amp;y)
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid compressed point")
        }</span>
        <span class="cov8" title="1">return &amp;p, nil</span>
}

// FromBytes decodes an element from bytes.
func (c *Curve) FromBytes(input []byte) (*Point, error) <span class="cov0" title="0">{
        return c.FromCompressed(input)
}</span>

// FromUncompressed decodes an uncompressed point.
func (c *Curve) FromUncompressed(data []byte) (*Point, error) <span class="cov8" title="1">{
        if len(data) != 64 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid byte sequence")
        }</span>
        <span class="cov8" title="1">if sliceutils.All(data, func(b byte) bool </span><span class="cov8" title="1">{ return b == 0 }</span>) <span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov8" title="1">xBytes := data[:32]
        yBytes := data[32:]
        var x, y BaseFieldElement
        ok := x.V.SetBytes(xBytes)
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid uncompressed point")
        }</span>
        <span class="cov8" title="1">ok = y.V.SetBytes(yBytes)
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid uncompressed point")
        }</span>
        <span class="cov8" title="1">return c.FromAffine(&amp;x, &amp;y)</span>
}

// FromAffine builds a point from affine coordinates.
func (c *Curve) FromAffine(x, y *BaseFieldElement) (*Point, error) <span class="cov8" title="1">{
        p, err := c.FromCompressed(x.V.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>

        <span class="cov8" title="1">y2, err := p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov8" title="1">if y.Equal(y2) </span><span class="cov8" title="1">{
                return p, nil
        }</span>

        <span class="cov8" title="1">p = p.Neg()
        y2, err = p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov8" title="1">if y.Equal(y2) </span><span class="cov8" title="1">{
                return p, nil
        }</span>

        <span class="cov0" title="0">return nil, curves.ErrFailed.WithMessage("cannot deserialize point")</span>
}

// Hash maps input bytes to an element or point.
func (c *Curve) Hash(bytes []byte) (*Point, error) <span class="cov0" title="0">{
        return c.HashWithDst(base.Hash2CurveAppTag+Hash2CurveSuite, bytes)
}</span>

// HashWithDst maps input bytes to a point with a custom DST.
func (*Curve) HashWithDst(dst string, bytes []byte) (*Point, error) <span class="cov8" title="1">{
        var p Point
        p.V.Hash(dst, bytes)
        return &amp;p, nil
}</span>

// ScalarStructure returns the scalar structure.
func (*Curve) ScalarStructure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarRing returns the scalar ring.
func (*Curve) ScalarRing() algebra.ZModLike[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseStructure returns the base field structure.
func (*Curve) BaseStructure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// BaseField returns the base field.
func (*Curve) BaseField() algebra.FiniteField[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *Curve) MultiScalarOp(scalars []*Scalar, points []*Point) (*Point, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*Curve) MultiScalarMul(scalars []*Scalar, points []*Point) (*Point, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result Point
        scs := make([][]byte, len(scalars))
        pts := make([]*edwards25519Impl.Point, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// Point represents a curve point.
type Point struct {
        traits.PointTrait[*edwards25519Impl.Fp, *edwards25519Impl.Point, edwards25519Impl.Point, *Point, Point]
}

// AffineX returns the affine x-coordinate.
func (p *Point) AffineX() (*BaseFieldElement, error) <span class="cov8" title="1">{
        var u, w, wInv edwards25519Impl.Fp
        u.Add(&amp;p.V.Z, &amp;p.V.Y)
        w.Sub(&amp;p.V.Z, &amp;p.V.Y)
        ok := wInv.Inv(&amp;w)
        if ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("cannot get affine x")
        }</span>

        <span class="cov8" title="1">var bfe BaseFieldElement
        bfe.V.Mul(&amp;u, &amp;wInv)
        return &amp;bfe, nil</span>
}

// AffineY returns the affine y-coordinate.
func (p *Point) AffineY() (*BaseFieldElement, error) <span class="cov8" title="1">{
        var u, w, wInv edwards25519Impl.Fp
        u.Add(&amp;p.V.Z, &amp;p.V.Y)
        w.Sub(&amp;p.V.X, &amp;p.V.T)
        ok := wInv.Inv(&amp;w)
        if ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("cannot get affine y")
        }</span>

        <span class="cov8" title="1">var bfe BaseFieldElement
        bfe.V.Mul(&amp;u, &amp;wInv)
        bfe.V.Mul(&amp;bfe.V, &amp;c)
        return &amp;bfe, nil</span>
}

// ToCompressed encodes the point in compressed form.
func (p *Point) ToCompressed() []byte <span class="cov8" title="1">{
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                return make([]byte, 32)
        }</span>

        <span class="cov8" title="1">x, err := p.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err).WithMessage("this should never happen"))</span>
        }

        <span class="cov8" title="1">return x.V.Bytes()</span>
}

// HashCode returns a hash code for the receiver.
func (p *Point) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(p.ToCompressed())
        return base.HashCode(h.Sum64())
}</span>

// Structure returns the algebraic structure for the receiver.
func (*Point) Structure() algebra.Structure[*Point] <span class="cov0" title="0">{
        return NewCurve()
}</span>

// ToUncompressed encodes the point in uncompressed form.
func (p *Point) ToUncompressed() []byte <span class="cov8" title="1">{
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                return make([]byte, 64)
        }</span>

        <span class="cov8" title="1">x, err := p.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err).WithMessage("this should never happen"))</span>
        }
        <span class="cov8" title="1">y, err := p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err).WithMessage("this should never happen"))</span>
        }

        <span class="cov8" title="1">return append(x.V.Bytes(), y.V.Bytes()...)</span>
}

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *Point) ScalarOp(sc *Scalar) *Point <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *Point) ScalarMul(actor *Scalar) *Point <span class="cov8" title="1">{
        var result Point
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (p *Point) IsTorsionFree() bool <span class="cov0" title="0">{
        primeOrderBytes := NewScalarField().Order().Bytes()
        slices.Reverse(primeOrderBytes)
        var e edwards25519Impl.Point
        aimpl.ScalarMulLowLevel(&amp;e, &amp;p.V, primeOrderBytes)
        return e.IsZero() != ct.False
}</span>

// Bytes returns the canonical byte encoding.
func (p *Point) Bytes() []byte <span class="cov0" title="0">{
        return p.ToCompressed()
}</span>

// String returns the string form of the receiver.
func (p *Point) String() string <span class="cov0" title="0">{
        xBytes := p.ToCompressed()
        slices.Reverse(xBytes)
        xInt := new(big.Int).SetBytes(xBytes)

        return fmt.Sprintf("(%s)", xInt.Text(10))
}</span>

// AsPrimeSubGroupPoint converts to a prime subgroup point if torsion-free.
func (p *Point) AsPrimeSubGroupPoint() (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        if !p.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not in the prime subgroup")
        }</span>

        <span class="cov0" title="0">var pp PrimeSubGroupPoint
        pp.V.Set(&amp;p.V)
        return &amp;pp, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package curve25519

import (
        "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519"
)

const (
        // BaseFieldName is the base field name.
        BaseFieldName = edwards25519.BaseFieldName
)

type (
        BaseField        = edwards25519.BaseField
        BaseFieldElement = edwards25519.BaseFieldElement
)

// NewBaseField returns the base field instance.
func NewBaseField() *BaseField <span class="cov0" title="0">{
        return edwards25519.NewBaseField()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package curve25519

import "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519"

const (
        // ScalarFieldName is the scalar field name.
        ScalarFieldName = edwards25519.ScalarFieldName
)

type (
        ScalarField = edwards25519.ScalarField
        Scalar      = edwards25519.Scalar
)

// NewScalarField returns the scalar field instance.
func NewScalarField() *ScalarField <span class="cov8" title="1">{
        return edwards25519.NewScalarField()
}</span>

// NewScalar returns a new scalar.
func NewScalar(v uint64) *Scalar <span class="cov0" title="0">{
        return edwards25519.NewScalar(v)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package curve25519

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        edwards25519Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // PrimeCurveName is the prime subgroup curve name.
        PrimeCurveName = CurveName + "(PrimeSubGroup)"
)

var (
        _ curves.Curve[*PrimeSubGroupPoint, *BaseFieldElement, *Scalar] = (*PrimeSubGroup)(nil)
        _ curves.Point[*PrimeSubGroupPoint, *BaseFieldElement, *Scalar] = (*PrimeSubGroupPoint)(nil)

        primeSubGroupInstance *PrimeSubGroup
        primeSubGroupInitOnce sync.Once
)

// NewPrimeSubGroup returns the prime subgroup instance.
func NewPrimeSubGroup() *PrimeSubGroup <span class="cov0" title="0">{
        primeSubGroupInitOnce.Do(func() </span><span class="cov0" title="0">{
                //nolint:exhaustruct // no need for a trait
                primeSubGroupInstance = &amp;PrimeSubGroup{}
        }</span>)

        <span class="cov0" title="0">return primeSubGroupInstance</span>
}

// PrimeSubGroup represents the prime-order subgroup.
type PrimeSubGroup struct {
        traits.PrimeCurveTrait[*edwards25519Impl.Fp, *edwards25519Impl.Point, *PrimeSubGroupPoint, PrimeSubGroupPoint]
}

// Name returns the name of the structure.
func (*PrimeSubGroup) Name() string <span class="cov0" title="0">{
        return PrimeCurveName
}</span>

// ElementSize returns the element size in bytes.
func (*PrimeSubGroup) ElementSize() int <span class="cov0" title="0">{
        return 32
}</span>

// Cofactor returns the curve cofactor.
func (*PrimeSubGroup) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(8)
}</span>

// Order returns the group or field order.
func (*PrimeSubGroup) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewScalarField().Order()
}</span>

// FromCompressed decodes a compressed point.
func (*PrimeSubGroup) FromCompressed(data []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().FromCompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// FromBytes decodes an element from bytes.
func (*PrimeSubGroup) FromBytes(data []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().FromBytes(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// FromUncompressed decodes an uncompressed point.
func (*PrimeSubGroup) FromUncompressed(data []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().FromUncompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// FromAffine builds a point from affine coordinates.
func (*PrimeSubGroup) FromAffine(x, y *BaseFieldElement) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().FromAffine(x, y)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot set coordinates")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// Hash maps input bytes to an element or point.
func (*PrimeSubGroup) Hash(bytes []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().Hash(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash to curve")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// HashWithDst maps input bytes to a point with a custom DST.
func (*PrimeSubGroup) HashWithDst(dst string, bytes []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().HashWithDst(dst, bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash to curve")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// ScalarStructure returns the scalar structure.
func (*PrimeSubGroup) ScalarStructure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarRing returns the scalar ring.
func (*PrimeSubGroup) ScalarRing() algebra.ZModLike[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarField returns the scalar field.
func (*PrimeSubGroup) ScalarField() algebra.PrimeField[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseField returns the base field.
func (*PrimeSubGroup) BaseField() algebra.FiniteField[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// BaseStructure returns the base field structure.
func (*PrimeSubGroup) BaseStructure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// ScalarBaseOp adds a scalar multiple of the generator.
func (c *PrimeSubGroup) ScalarBaseOp(sc *Scalar) *PrimeSubGroupPoint <span class="cov0" title="0">{
        return c.ScalarBaseMul(sc)
}</span>

// ScalarBaseMul multiplies the generator by a scalar.
func (c *PrimeSubGroup) ScalarBaseMul(sc *Scalar) *PrimeSubGroupPoint <span class="cov0" title="0">{
        return c.Generator().ScalarMul(sc)
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *PrimeSubGroup) MultiScalarOp(scalars []*Scalar, points []*PrimeSubGroupPoint) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*PrimeSubGroup) MultiScalarMul(scalars []*Scalar, points []*PrimeSubGroupPoint) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result PrimeSubGroupPoint
        scs := make([][]byte, len(scalars))
        pts := make([]*edwards25519Impl.Point, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// PrimeSubGroupPoint represents a point in the prime-order subgroup.
type PrimeSubGroupPoint struct {
        traits.PrimePointTrait[*edwards25519Impl.Fp, *edwards25519Impl.Point, edwards25519Impl.Point, *PrimeSubGroupPoint, PrimeSubGroupPoint]
}

// HashCode returns a hash code for the receiver.
func (p *PrimeSubGroupPoint) HashCode() base.HashCode <span class="cov0" title="0">{
        return p.AsPoint().HashCode()
}</span>

// Structure returns the algebraic structure for the receiver.
func (*PrimeSubGroupPoint) Structure() algebra.Structure[*PrimeSubGroupPoint] <span class="cov0" title="0">{
        return NewPrimeSubGroup()
}</span>

// ToCompressed encodes the point in compressed form.
func (p *PrimeSubGroupPoint) ToCompressed() []byte <span class="cov0" title="0">{
        return p.AsPoint().ToCompressed()
}</span>

// ToUncompressed encodes the point in uncompressed form.
func (p *PrimeSubGroupPoint) ToUncompressed() []byte <span class="cov0" title="0">{
        return p.AsPoint().ToUncompressed()
}</span>

// AffineX returns the affine x-coordinate.
func (p *PrimeSubGroupPoint) AffineX() (*BaseFieldElement, error) <span class="cov0" title="0">{
        return p.AsPoint().AffineX()
}</span>

// AffineY returns the affine y-coordinate.
func (p *PrimeSubGroupPoint) AffineY() (*BaseFieldElement, error) <span class="cov0" title="0">{
        return p.AsPoint().AffineY()
}</span>

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *PrimeSubGroupPoint) ScalarOp(sc *Scalar) *PrimeSubGroupPoint <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *PrimeSubGroupPoint) ScalarMul(actor *Scalar) *PrimeSubGroupPoint <span class="cov0" title="0">{
        var result PrimeSubGroupPoint
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (*PrimeSubGroupPoint) IsTorsionFree() bool <span class="cov0" title="0">{
        return true
}</span>

// Bytes returns the canonical byte encoding.
func (p *PrimeSubGroupPoint) Bytes() []byte <span class="cov0" title="0">{
        return p.AsPoint().ToCompressed()
}</span>

// String returns the string form of the receiver.
func (p *PrimeSubGroupPoint) String() string <span class="cov0" title="0">{
        return p.AsPoint().String()
}</span>

// AsPoint converts the prime subgroup point to a curve point.
func (p *PrimeSubGroupPoint) AsPoint() *Point <span class="cov0" title="0">{
        var pp Point
        pp.V.Set(&amp;p.V)
        return &amp;pp
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package edwards25519

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*BaseFieldElement)(nil)
        _ cbor.Unmarshaler = (*BaseFieldElement)(nil)
        _ cbor.Marshaler   = (*Scalar)(nil)
        _ cbor.Unmarshaler = (*Scalar)(nil)
        _ cbor.Marshaler   = (*Point)(nil)
        _ cbor.Unmarshaler = (*Point)(nil)
        _ cbor.Marshaler   = (*PrimeSubGroupPoint)(nil)
        _ cbor.Unmarshaler = (*PrimeSubGroupPoint)(nil)
)

type baseFieldDTO struct {
        BaseFieldBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *BaseFieldElement) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;baseFieldDTO{BaseFieldBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *BaseFieldElement) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*baseFieldDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">bfe, err := NewBaseField().FromBytes(dto.BaseFieldBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize base field element")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;bfe.V)
        return nil</span>
}

type scalarDTO struct {
        ScalarBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *Scalar) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;scalarDTO{ScalarBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *Scalar) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*scalarDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s, err := NewScalarField().FromBytes(dto.ScalarBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize scalar")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;s.V)
        return nil</span>
}

type pointDTO struct {
        AffineCompressedBytes []byte `cbor:"compressedBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (p *Point) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;pointDTO{AffineCompressedBytes: p.ToCompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *Point) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*pointDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pp, err := NewCurve().FromCompressed(dto.AffineCompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov8" title="1">p.V.Set(&amp;pp.V)
        return nil</span>
}

// MarshalCBOR implements cbor.Marshaler.
func (p *PrimeSubGroupPoint) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;pointDTO{AffineCompressedBytes: p.ToCompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *PrimeSubGroupPoint) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*pointDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pp, err := NewPrimeSubGroup().FromCompressed(dto.AffineCompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package edwards25519

import (
        "encoding"
        "fmt"
        "hash/fnv"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        edwards25519Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // CurveName is the curve name.
        CurveName = "edwards25519"
        // Hash2CurveSuite is the hash-to-curve suite string.
        Hash2CurveSuite = "edwards25519_XMD:SHA-512_ELL2_NU_"
        // Hash2CurveScalarSuite is the hash-to-curve scalar suite string.
        Hash2CurveScalarSuite = "edwards25519_XMD:SHA-512_ELL2_NU_SC_"
        compressedPointBytes  = edwards25519Impl.FpBytes
)

var (
        _ curves.EllipticCurve[*Point, *BaseFieldElement, *Scalar] = (*Curve)(nil)
        _ curves.ECPoint[*Point, *BaseFieldElement, *Scalar]       = (*Point)(nil)
        _ encoding.BinaryMarshaler                                 = (*Point)(nil)
        _ encoding.BinaryUnmarshaler                               = (*Point)(nil)

        curveInstance *Curve
        curveInitOnce sync.Once
)

// Curve represents the elliptic curve group.
type Curve struct {
        traits.CurveTrait[*edwards25519Impl.Fp, *edwards25519Impl.Point, *Point, Point]
}

// NewCurve returns the curve instance.
func NewCurve() *Curve <span class="cov8" title="1">{
        curveInitOnce.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for a trait
                curveInstance = &amp;Curve{}
        }</span>)

        <span class="cov8" title="1">return curveInstance</span>
}

// Name returns the name of the structure.
func (*Curve) Name() string <span class="cov0" title="0">{
        return CurveName
}</span>

// ElementSize returns the element size in bytes.
func (*Curve) ElementSize() int <span class="cov0" title="0">{
        return compressedPointBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*Curve) WideElementSize() int <span class="cov0" title="0">{
        return int(^uint(0) &gt;&gt; 1)
}</span>

// FromWideBytes decodes an element from wide bytes.
func (c *Curve) FromWideBytes(input []byte) (*Point, error) <span class="cov0" title="0">{
        return c.Hash(input)
}</span>

// Cofactor returns the curve cofactor.
func (*Curve) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(8)
}</span>

// Order returns the group or field order.
func (*Curve) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewScalarField().Order()
}</span>

// FromCompressed decodes a compressed point.
func (*Curve) FromCompressed(inBytes []byte) (*Point, error) <span class="cov8" title="1">{
        if len(inBytes) != int(compressedPointBytes) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("input must be 32 bytes long")
        }</span>

        <span class="cov8" title="1">var yBytes [32]byte
        copy(yBytes[:], inBytes)
        var y BaseFieldElement
        yBytes[31] &amp;= 0x7f
        ok := y.V.SetBytes(yBytes[:])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid point")
        }</span>

        <span class="cov8" title="1">var x BaseFieldElement
        result := new(Point)
        ok = result.V.SetFromAffineY(&amp;y.V)
        _ = result.V.ToAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid point")
        }</span>

        <span class="cov8" title="1">isOdd := ct.Bool(inBytes[31] &gt;&gt; 7)
        if fieldsImpl.IsOdd(&amp;x.V) != isOdd </span><span class="cov0" title="0">{
                result = result.Neg()
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// FromBytes decodes an element from bytes.
func (c *Curve) FromBytes(input []byte) (*Point, error) <span class="cov0" title="0">{
        return c.FromCompressed(input)
}</span>

// FromUncompressed decodes an uncompressed point.
func (*Curve) FromUncompressed(inBytes []byte) (*Point, error) <span class="cov0" title="0">{
        if len(inBytes) != 2*32 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid byte sequence")
        }</span>
        <span class="cov0" title="0">yBytes := inBytes[:32]
        xBytes := inBytes[32:]

        var x, y BaseFieldElement
        ok := x.V.SetBytes(xBytes)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov0" title="0">ok = y.V.SetBytes(yBytes)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("y")
        }</span>

        <span class="cov0" title="0">result := new(Point)
        ok = result.V.SetAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// FromAffine builds a point from affine coordinates.
func (*Curve) FromAffine(x, y *BaseFieldElement) (*Point, error) <span class="cov0" title="0">{
        var p Point
        ok := p.V.SetAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

// Hash maps input bytes to an element or point.
func (c *Curve) Hash(bytes []byte) (*Point, error) <span class="cov0" title="0">{
        return c.HashWithDst(base.Hash2CurveAppTag+Hash2CurveSuite, bytes)
}</span>

// HashWithDst maps input bytes to a point with a custom DST.
func (*Curve) HashWithDst(dst string, bytes []byte) (*Point, error) <span class="cov0" title="0">{
        var p Point
        p.V.Hash(dst, bytes)
        return &amp;p, nil
}</span>

// ScalarRing returns the scalar ring.
func (*Curve) ScalarRing() algebra.ZModLike[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarStructure returns the scalar structure.
func (*Curve) ScalarStructure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseStructure returns the base field structure.
func (*Curve) BaseStructure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// BaseField returns the base field.
func (*Curve) BaseField() algebra.FiniteField[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *Curve) MultiScalarOp(scalars []*Scalar, points []*Point) (*Point, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*Curve) MultiScalarMul(scalars []*Scalar, points []*Point) (*Point, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result Point
        scs := make([][]byte, len(scalars))
        pts := make([]*edwards25519Impl.Point, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// Point represents a curve point.
type Point struct {
        traits.PointTrait[*edwards25519Impl.Fp, *edwards25519Impl.Point, edwards25519Impl.Point, *Point, Point]
}

// HashCode returns a hash code for the receiver.
func (p *Point) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(p.ToCompressed())
        return base.HashCode(h.Sum64())
}</span>

// Structure returns the algebraic structure for the receiver.
func (*Point) Structure() algebra.Structure[*Point] <span class="cov0" title="0">{
        return NewCurve()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (p *Point) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return p.ToCompressed(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (p *Point) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        pp, err := NewCurve().FromCompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>

        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}

// ToCompressed encodes the point in compressed form.
func (p *Point) ToCompressed() []byte <span class="cov8" title="1">{
        var x, y BaseFieldElement
        _ = p.V.ToAffine(&amp;x.V, &amp;y.V)
        yBytes := y.V.Bytes()
        yBytes[31] |= byte(fieldsImpl.IsOdd(&amp;x.V) &lt;&lt; 7)
        return yBytes
}</span>

// ToUncompressed encodes the point in uncompressed form.
func (p *Point) ToUncompressed() []byte <span class="cov0" title="0">{
        var x, y BaseFieldElement
        _ = p.V.ToAffine(&amp;x.V, &amp;y.V)

        return slices.Concat(y.V.Bytes(), x.V.Bytes())
}</span>

// AffineX returns the affine x-coordinate.
func (p *Point) AffineX() (*BaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>
        <span class="cov0" title="0">var x, y BaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;x, nil</span>
}

// AffineY returns the affine y-coordinate.
func (p *Point) AffineY() (*BaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;y, nil</span>
}

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *Point) ScalarOp(sc *Scalar) *Point <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *Point) ScalarMul(actor *Scalar) *Point <span class="cov0" title="0">{
        var result Point
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (p *Point) IsTorsionFree() bool <span class="cov0" title="0">{
        primeOrderBytes := NewScalarField().Order().Bytes()
        slices.Reverse(primeOrderBytes)
        var e edwards25519Impl.Point
        aimpl.ScalarMulLowLevel(&amp;e, &amp;p.V, primeOrderBytes)
        return e.IsZero() == 1
}</span>

// Bytes returns the canonical byte encoding.
func (p *Point) Bytes() []byte <span class="cov0" title="0">{
        return p.ToCompressed()
}</span>

// String returns the string form of the receiver.
func (p *Point) String() string <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return "(0, 1, 0, 1)"
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("(%s, %s, %s, %s)", p.V.X.String(), p.V.Y.String(), p.V.T.String(), p.V.Z.String())
        }</span>
}

// AsPrimeSubGroupPoint converts to a prime subgroup point if torsion-free.
func (p *Point) AsPrimeSubGroupPoint() (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        if !p.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not in the prime subgroup")
        }</span>

        <span class="cov0" title="0">var pp PrimeSubGroupPoint
        pp.V.Set(&amp;p.V)
        return &amp;pp, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package edwards25519

import (
        "encoding"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        edwards25519Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

const (
        // BaseFieldName is the base field name.
        BaseFieldName = "curve25519Fp"
)

var (
        _ algebra.PrimeField[*BaseFieldElement]        = (*BaseField)(nil)
        _ algebra.PrimeFieldElement[*BaseFieldElement] = (*BaseFieldElement)(nil)
        _ encoding.BinaryMarshaler                     = (*BaseFieldElement)(nil)
        _ encoding.BinaryUnmarshaler                   = (*BaseFieldElement)(nil)

        baseFieldInstance *BaseField
        baseFieldInitOnce sync.Once
        baseFieldOrder    *numct.Modulus
)

// BaseField represents the curve base field.
type BaseField struct {
        traits.PrimeFieldTrait[*edwards25519Impl.Fp, *BaseFieldElement, BaseFieldElement]
}

// NewBaseField returns the base field instance.
func NewBaseField() *BaseField <span class="cov8" title="1">{
        baseFieldInitOnce.Do(func() </span><span class="cov8" title="1">{
                baseFieldOrder, _ = numct.NewModulusFromBytesBE(sliceutils.Reversed(edwards25519Impl.FpModulus[:]))
                //nolint:exhaustruct // no need for a trait
                baseFieldInstance = &amp;BaseField{}
        }</span>)

        <span class="cov8" title="1">return baseFieldInstance</span>
}

// Name returns the name of the structure.
func (*BaseField) Name() string <span class="cov0" title="0">{
        return BaseFieldName
}</span>

// Order returns the group or field order.
func (*BaseField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(baseFieldOrder.Nat())
}</span>

// Characteristic returns the field characteristic.
func (*BaseField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(baseFieldOrder.Nat())
}</span>

// Hash maps input bytes to an element or point.
func (*BaseField) Hash(bytes []byte) (*BaseFieldElement, error) <span class="cov0" title="0">{
        var e [1]edwards25519Impl.Fp
        h2c.HashToField(e[:], edwards25519Impl.CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveSuite, bytes)

        var s BaseFieldElement
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// ElementSize returns the element size in bytes.
func (*BaseField) ElementSize() int <span class="cov0" title="0">{
        return int(edwards25519Impl.FpBytes)
}</span>

// WideElementSize returns the wide element size in bytes.
func (*BaseField) WideElementSize() int <span class="cov0" title="0">{
        return int(edwards25519Impl.FpWideBytes)
}</span>

// BitLen returns the field modulus bit length.
func (*BaseField) BitLen() int <span class="cov0" title="0">{
        return int(edwards25519Impl.FpBits)
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *BaseField) FromBytesBEReduce(input []byte) (*BaseFieldElement, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        baseFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// BaseFieldElement represents an element of the base field.
type BaseFieldElement struct {
        traits.PrimeFieldElementTrait[*edwards25519Impl.Fp, edwards25519Impl.Fp, *BaseFieldElement, BaseFieldElement]
}

// Structure returns the algebraic structure for the receiver.
func (*BaseFieldElement) Structure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *BaseFieldElement) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *BaseFieldElement) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("failed to unmarshal field element")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' unsaturated-solinas --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fp 64 '(auto)' '2^255 - 19'
//
// curve description: Fp
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// n = 5 (from "(auto)")
//
// s-c = 2^255 - [(1, 19)] (from "2^255 - 19")
//
// tight_bounds_multiplier = 1 (from "")
//
//
//
// Computed values:
//
//   carry_chain = [0, 1, 2, 3, 4, 0, 1]
//
//   eval z = z[0] + (z[1] &lt;&lt; 51) + (z[2] &lt;&lt; 102) + (z[3] &lt;&lt; 153) + (z[4] &lt;&lt; 204)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   balance = [0xfffffffffffda, 0xffffffffffffe, 0xffffffffffffe, 0xffffffffffffe, 0xffffffffffffe]
package impl

import "math/bits"

type fiatFpUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFpInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFpLooseFieldElement is a field element with loose bounds.
//
// Bounds:
//
//   [[0x0 ~&gt; 0x18000000000000], [0x0 ~&gt; 0x18000000000000], [0x0 ~&gt; 0x18000000000000], [0x0 ~&gt; 0x18000000000000], [0x0 ~&gt; 0x18000000000000]]
type fiatFpLooseFieldElement [5]uint64

// fiatFpTightFieldElement is a field element with tight bounds.
//
// Bounds:
//
//   [[0x0 ~&gt; 0x8000000000000], [0x0 ~&gt; 0x8000000000000], [0x0 ~&gt; 0x8000000000000], [0x0 ~&gt; 0x8000000000000], [0x0 ~&gt; 0x8000000000000]]
type fiatFpTightFieldElement [5]uint64

// fiatFpAddcarryxU51 is an addition with carry.
//
// Postconditions:
//   out1 = (arg1 + arg2 + arg3) mod 2^51
//   out2 = (arg1 + arg2 + arg3) / 2^51
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0x7ffffffffffff]
//   arg3: [0x0 ~&gt; 0x7ffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0x7ffffffffffff]
//   out2: [0x0 ~&gt; 0x1]
func fiatFpAddcarryxU51(out1 *uint64, out2 *fiatFpUint1, arg1 fiatFpUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := ((uint64(arg1) + arg2) + arg3)
        x2 := (x1 &amp; 0x7ffffffffffff)
        x3 := fiatFpUint1((x1 &gt;&gt; 51))
        *out1 = x2
        *out2 = x3
}</span>

// fiatFpSubborrowxU51 is a subtraction with borrow.
//
// Postconditions:
//   out1 = (-arg1 + arg2 + -arg3) mod 2^51
//   out2 = -(-arg1 + arg2 + -arg3) / 2^51
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0x7ffffffffffff]
//   arg3: [0x0 ~&gt; 0x7ffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0x7ffffffffffff]
//   out2: [0x0 ~&gt; 0x1]
func fiatFpSubborrowxU51(out1 *uint64, out2 *fiatFpUint1, arg1 fiatFpUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := ((int64(arg2) - int64(arg1)) - int64(arg3))
        x2 := fiatFpInt1((x1 &gt;&gt; 51))
        x3 := (uint64(x1) &amp; 0x7ffffffffffff)
        *out1 = x3
        *out2 = (0x0 - fiatFpUint1(x2))
}</span>

// fiatFpCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpCmovznzU64(out1 *uint64, arg1 fiatFpUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFpCarryMul multiplies two field elements and reduces the result.
//
// Postconditions:
//   eval out1 mod m = (eval arg1 * eval arg2) mod m
//
func fiatFpCarryMul(out1 *fiatFpTightFieldElement, arg1 *fiatFpLooseFieldElement, arg2 *fiatFpLooseFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x2, x1 = bits.Mul64(arg1[4], (arg2[4] * 0x13))
        var x3 uint64
        var x4 uint64
        x4, x3 = bits.Mul64(arg1[4], (arg2[3] * 0x13))
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(arg1[4], (arg2[2] * 0x13))
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(arg1[4], (arg2[1] * 0x13))
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(arg1[3], (arg2[4] * 0x13))
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(arg1[3], (arg2[3] * 0x13))
        var x13 uint64
        var x14 uint64
        x14, x13 = bits.Mul64(arg1[3], (arg2[2] * 0x13))
        var x15 uint64
        var x16 uint64
        x16, x15 = bits.Mul64(arg1[2], (arg2[4] * 0x13))
        var x17 uint64
        var x18 uint64
        x18, x17 = bits.Mul64(arg1[2], (arg2[3] * 0x13))
        var x19 uint64
        var x20 uint64
        x20, x19 = bits.Mul64(arg1[1], (arg2[4] * 0x13))
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(arg1[4], arg2[0])
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(arg1[3], arg2[1])
        var x25 uint64
        var x26 uint64
        x26, x25 = bits.Mul64(arg1[3], arg2[0])
        var x27 uint64
        var x28 uint64
        x28, x27 = bits.Mul64(arg1[2], arg2[2])
        var x29 uint64
        var x30 uint64
        x30, x29 = bits.Mul64(arg1[2], arg2[1])
        var x31 uint64
        var x32 uint64
        x32, x31 = bits.Mul64(arg1[2], arg2[0])
        var x33 uint64
        var x34 uint64
        x34, x33 = bits.Mul64(arg1[1], arg2[3])
        var x35 uint64
        var x36 uint64
        x36, x35 = bits.Mul64(arg1[1], arg2[2])
        var x37 uint64
        var x38 uint64
        x38, x37 = bits.Mul64(arg1[1], arg2[1])
        var x39 uint64
        var x40 uint64
        x40, x39 = bits.Mul64(arg1[1], arg2[0])
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(arg1[0], arg2[4])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(arg1[0], arg2[3])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(arg1[0], arg2[2])
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(arg1[0], arg2[1])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(arg1[0], arg2[0])
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x13, x7, uint64(0x0))
        var x53 uint64
        x53, _ = bits.Add64(x14, x8, uint64(fiatFpUint1(x52)))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x17, x51, uint64(0x0))
        var x57 uint64
        x57, _ = bits.Add64(x18, x53, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x19, x55, uint64(0x0))
        var x61 uint64
        x61, _ = bits.Add64(x20, x57, uint64(fiatFpUint1(x60)))
        var x63 uint64
        var x64 uint64
        x63, x64 = bits.Add64(x49, x59, uint64(0x0))
        var x65 uint64
        x65, _ = bits.Add64(x50, x61, uint64(fiatFpUint1(x64)))
        x67 := ((x63 &gt;&gt; 51) | ((x65 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x68 := (x63 &amp; 0x7ffffffffffff)
        var x69 uint64
        var x70 uint64
        x69, x70 = bits.Add64(x23, x21, uint64(0x0))
        var x71 uint64
        x71, _ = bits.Add64(x24, x22, uint64(fiatFpUint1(x70)))
        var x73 uint64
        var x74 uint64
        x73, x74 = bits.Add64(x27, x69, uint64(0x0))
        var x75 uint64
        x75, _ = bits.Add64(x28, x71, uint64(fiatFpUint1(x74)))
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x33, x73, uint64(0x0))
        var x79 uint64
        x79, _ = bits.Add64(x34, x75, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x41, x77, uint64(0x0))
        var x83 uint64
        x83, _ = bits.Add64(x42, x79, uint64(fiatFpUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x25, x1, uint64(0x0))
        var x87 uint64
        x87, _ = bits.Add64(x26, x2, uint64(fiatFpUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x29, x85, uint64(0x0))
        var x91 uint64
        x91, _ = bits.Add64(x30, x87, uint64(fiatFpUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x35, x89, uint64(0x0))
        var x95 uint64
        x95, _ = bits.Add64(x36, x91, uint64(fiatFpUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x43, x93, uint64(0x0))
        var x99 uint64
        x99, _ = bits.Add64(x44, x95, uint64(fiatFpUint1(x98)))
        var x101 uint64
        var x102 uint64
        x101, x102 = bits.Add64(x9, x3, uint64(0x0))
        var x103 uint64
        x103, _ = bits.Add64(x10, x4, uint64(fiatFpUint1(x102)))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x31, x101, uint64(0x0))
        var x107 uint64
        x107, _ = bits.Add64(x32, x103, uint64(fiatFpUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x37, x105, uint64(0x0))
        var x111 uint64
        x111, _ = bits.Add64(x38, x107, uint64(fiatFpUint1(x110)))
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x45, x109, uint64(0x0))
        var x115 uint64
        x115, _ = bits.Add64(x46, x111, uint64(fiatFpUint1(x114)))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x11, x5, uint64(0x0))
        var x119 uint64
        x119, _ = bits.Add64(x12, x6, uint64(fiatFpUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x15, x117, uint64(0x0))
        var x123 uint64
        x123, _ = bits.Add64(x16, x119, uint64(fiatFpUint1(x122)))
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x39, x121, uint64(0x0))
        var x127 uint64
        x127, _ = bits.Add64(x40, x123, uint64(fiatFpUint1(x126)))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x47, x125, uint64(0x0))
        var x131 uint64
        x131, _ = bits.Add64(x48, x127, uint64(fiatFpUint1(x130)))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x67, x129, uint64(0x0))
        x135 := (uint64(fiatFpUint1(x134)) + x131)
        x136 := ((x133 &gt;&gt; 51) | ((x135 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x137 := (x133 &amp; 0x7ffffffffffff)
        var x138 uint64
        var x139 uint64
        x138, x139 = bits.Add64(x136, x113, uint64(0x0))
        x140 := (uint64(fiatFpUint1(x139)) + x115)
        x141 := ((x138 &gt;&gt; 51) | ((x140 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x142 := (x138 &amp; 0x7ffffffffffff)
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x141, x97, uint64(0x0))
        x145 := (uint64(fiatFpUint1(x144)) + x99)
        x146 := ((x143 &gt;&gt; 51) | ((x145 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x147 := (x143 &amp; 0x7ffffffffffff)
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x146, x81, uint64(0x0))
        x150 := (uint64(fiatFpUint1(x149)) + x83)
        x151 := ((x148 &gt;&gt; 51) | ((x150 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x152 := (x148 &amp; 0x7ffffffffffff)
        x153 := (x151 * 0x13)
        x154 := (x68 + x153)
        x155 := (x154 &gt;&gt; 51)
        x156 := (x154 &amp; 0x7ffffffffffff)
        x157 := (x155 + x137)
        x158 := fiatFpUint1((x157 &gt;&gt; 51))
        x159 := (x157 &amp; 0x7ffffffffffff)
        x160 := (uint64(x158) + x142)
        out1[0] = x156
        out1[1] = x159
        out1[2] = x160
        out1[3] = x147
        out1[4] = x152
}</span>

// fiatFpCarrySquare squares a field element and reduces the result.
//
// Postconditions:
//   eval out1 mod m = (eval arg1 * eval arg1) mod m
//
func fiatFpCarrySquare(out1 *fiatFpTightFieldElement, arg1 *fiatFpLooseFieldElement) <span class="cov8" title="1">{
        x1 := (arg1[4] * 0x13)
        x2 := (x1 * 0x2)
        x3 := (arg1[4] * 0x2)
        x4 := (arg1[3] * 0x13)
        x5 := (x4 * 0x2)
        x6 := (arg1[3] * 0x2)
        x7 := (arg1[2] * 0x2)
        x8 := (arg1[1] * 0x2)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(arg1[4], x1)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(arg1[3], x2)
        var x13 uint64
        var x14 uint64
        x14, x13 = bits.Mul64(arg1[3], x4)
        var x15 uint64
        var x16 uint64
        x16, x15 = bits.Mul64(arg1[2], x2)
        var x17 uint64
        var x18 uint64
        x18, x17 = bits.Mul64(arg1[2], x5)
        var x19 uint64
        var x20 uint64
        x20, x19 = bits.Mul64(arg1[2], arg1[2])
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(arg1[1], x2)
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(arg1[1], x6)
        var x25 uint64
        var x26 uint64
        x26, x25 = bits.Mul64(arg1[1], x7)
        var x27 uint64
        var x28 uint64
        x28, x27 = bits.Mul64(arg1[1], arg1[1])
        var x29 uint64
        var x30 uint64
        x30, x29 = bits.Mul64(arg1[0], x3)
        var x31 uint64
        var x32 uint64
        x32, x31 = bits.Mul64(arg1[0], x6)
        var x33 uint64
        var x34 uint64
        x34, x33 = bits.Mul64(arg1[0], x7)
        var x35 uint64
        var x36 uint64
        x36, x35 = bits.Mul64(arg1[0], x8)
        var x37 uint64
        var x38 uint64
        x38, x37 = bits.Mul64(arg1[0], arg1[0])
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x21, x17, uint64(0x0))
        var x41 uint64
        x41, _ = bits.Add64(x22, x18, uint64(fiatFpUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x37, x39, uint64(0x0))
        var x45 uint64
        x45, _ = bits.Add64(x38, x41, uint64(fiatFpUint1(x44)))
        x47 := ((x43 &gt;&gt; 51) | ((x45 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x48 := (x43 &amp; 0x7ffffffffffff)
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x23, x19, uint64(0x0))
        var x51 uint64
        x51, _ = bits.Add64(x24, x20, uint64(fiatFpUint1(x50)))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x29, x49, uint64(0x0))
        var x55 uint64
        x55, _ = bits.Add64(x30, x51, uint64(fiatFpUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x25, x9, uint64(0x0))
        var x59 uint64
        x59, _ = bits.Add64(x26, x10, uint64(fiatFpUint1(x58)))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Add64(x31, x57, uint64(0x0))
        var x63 uint64
        x63, _ = bits.Add64(x32, x59, uint64(fiatFpUint1(x62)))
        var x65 uint64
        var x66 uint64
        x65, x66 = bits.Add64(x27, x11, uint64(0x0))
        var x67 uint64
        x67, _ = bits.Add64(x28, x12, uint64(fiatFpUint1(x66)))
        var x69 uint64
        var x70 uint64
        x69, x70 = bits.Add64(x33, x65, uint64(0x0))
        var x71 uint64
        x71, _ = bits.Add64(x34, x67, uint64(fiatFpUint1(x70)))
        var x73 uint64
        var x74 uint64
        x73, x74 = bits.Add64(x15, x13, uint64(0x0))
        var x75 uint64
        x75, _ = bits.Add64(x16, x14, uint64(fiatFpUint1(x74)))
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x35, x73, uint64(0x0))
        var x79 uint64
        x79, _ = bits.Add64(x36, x75, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x47, x77, uint64(0x0))
        x83 := (uint64(fiatFpUint1(x82)) + x79)
        x84 := ((x81 &gt;&gt; 51) | ((x83 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x85 := (x81 &amp; 0x7ffffffffffff)
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x84, x69, uint64(0x0))
        x88 := (uint64(fiatFpUint1(x87)) + x71)
        x89 := ((x86 &gt;&gt; 51) | ((x88 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x90 := (x86 &amp; 0x7ffffffffffff)
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x89, x61, uint64(0x0))
        x93 := (uint64(fiatFpUint1(x92)) + x63)
        x94 := ((x91 &gt;&gt; 51) | ((x93 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x95 := (x91 &amp; 0x7ffffffffffff)
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x94, x53, uint64(0x0))
        x98 := (uint64(fiatFpUint1(x97)) + x55)
        x99 := ((x96 &gt;&gt; 51) | ((x98 &lt;&lt; 13) &amp; 0xffffffffffffffff))
        x100 := (x96 &amp; 0x7ffffffffffff)
        x101 := (x99 * 0x13)
        x102 := (x48 + x101)
        x103 := (x102 &gt;&gt; 51)
        x104 := (x102 &amp; 0x7ffffffffffff)
        x105 := (x103 + x85)
        x106 := fiatFpUint1((x105 &gt;&gt; 51))
        x107 := (x105 &amp; 0x7ffffffffffff)
        x108 := (uint64(x106) + x90)
        out1[0] = x104
        out1[1] = x107
        out1[2] = x108
        out1[3] = x95
        out1[4] = x100
}</span>

// fiatFpCarry reduces a field element.
//
// Postconditions:
//   eval out1 mod m = eval arg1 mod m
//
func fiatFpCarry(out1 *fiatFpTightFieldElement, arg1 *fiatFpLooseFieldElement) <span class="cov0" title="0">{
        x1 := arg1[0]
        x2 := ((x1 &gt;&gt; 51) + arg1[1])
        x3 := ((x2 &gt;&gt; 51) + arg1[2])
        x4 := ((x3 &gt;&gt; 51) + arg1[3])
        x5 := ((x4 &gt;&gt; 51) + arg1[4])
        x6 := ((x1 &amp; 0x7ffffffffffff) + ((x5 &gt;&gt; 51) * 0x13))
        x7 := (uint64(fiatFpUint1((x6 &gt;&gt; 51))) + (x2 &amp; 0x7ffffffffffff))
        x8 := (x6 &amp; 0x7ffffffffffff)
        x9 := (x7 &amp; 0x7ffffffffffff)
        x10 := (uint64(fiatFpUint1((x7 &gt;&gt; 51))) + (x3 &amp; 0x7ffffffffffff))
        x11 := (x4 &amp; 0x7ffffffffffff)
        x12 := (x5 &amp; 0x7ffffffffffff)
        out1[0] = x8
        out1[1] = x9
        out1[2] = x10
        out1[3] = x11
        out1[4] = x12
}</span>

// fiatFpAdd adds two field elements.
//
// Postconditions:
//   eval out1 mod m = (eval arg1 + eval arg2) mod m
//
func fiatFpAdd(out1 *fiatFpLooseFieldElement, arg1 *fiatFpTightFieldElement, arg2 *fiatFpTightFieldElement) <span class="cov0" title="0">{
        x1 := (arg1[0] + arg2[0])
        x2 := (arg1[1] + arg2[1])
        x3 := (arg1[2] + arg2[2])
        x4 := (arg1[3] + arg2[3])
        x5 := (arg1[4] + arg2[4])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
        out1[4] = x5
}</span>

// fiatFpSub subtracts two field elements.
//
// Postconditions:
//   eval out1 mod m = (eval arg1 - eval arg2) mod m
//
func fiatFpSub(out1 *fiatFpLooseFieldElement, arg1 *fiatFpTightFieldElement, arg2 *fiatFpTightFieldElement) <span class="cov0" title="0">{
        x1 := ((0xfffffffffffda + arg1[0]) - arg2[0])
        x2 := ((0xffffffffffffe + arg1[1]) - arg2[1])
        x3 := ((0xffffffffffffe + arg1[2]) - arg2[2])
        x4 := ((0xffffffffffffe + arg1[3]) - arg2[3])
        x5 := ((0xffffffffffffe + arg1[4]) - arg2[4])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
        out1[4] = x5
}</span>

// fiatFpOpp negates a field element.
//
// Postconditions:
//   eval out1 mod m = -eval arg1 mod m
//
func fiatFpOpp(out1 *fiatFpLooseFieldElement, arg1 *fiatFpTightFieldElement) <span class="cov0" title="0">{
        x1 := (0xfffffffffffda - arg1[0])
        x2 := (0xffffffffffffe - arg1[1])
        x3 := (0xffffffffffffe - arg1[2])
        x4 := (0xffffffffffffe - arg1[3])
        x5 := (0xffffffffffffe - arg1[4])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
        out1[4] = x5
}</span>

// fiatFpCarryAdd adds two field elements.
//
// Postconditions:
//   eval out1 mod m = (eval arg1 + eval arg2) mod m
//
func fiatFpCarryAdd(out1 *fiatFpTightFieldElement, arg1 *fiatFpTightFieldElement, arg2 *fiatFpTightFieldElement) <span class="cov8" title="1">{
        x1 := (arg1[0] + arg2[0])
        x2 := ((x1 &gt;&gt; 51) + (arg1[1] + arg2[1]))
        x3 := ((x2 &gt;&gt; 51) + (arg1[2] + arg2[2]))
        x4 := ((x3 &gt;&gt; 51) + (arg1[3] + arg2[3]))
        x5 := ((x4 &gt;&gt; 51) + (arg1[4] + arg2[4]))
        x6 := ((x1 &amp; 0x7ffffffffffff) + ((x5 &gt;&gt; 51) * 0x13))
        x7 := (uint64(fiatFpUint1((x6 &gt;&gt; 51))) + (x2 &amp; 0x7ffffffffffff))
        x8 := (x6 &amp; 0x7ffffffffffff)
        x9 := (x7 &amp; 0x7ffffffffffff)
        x10 := (uint64(fiatFpUint1((x7 &gt;&gt; 51))) + (x3 &amp; 0x7ffffffffffff))
        x11 := (x4 &amp; 0x7ffffffffffff)
        x12 := (x5 &amp; 0x7ffffffffffff)
        out1[0] = x8
        out1[1] = x9
        out1[2] = x10
        out1[3] = x11
        out1[4] = x12
}</span>

// fiatFpCarrySub subtracts two field elements.
//
// Postconditions:
//   eval out1 mod m = (eval arg1 - eval arg2) mod m
//
func fiatFpCarrySub(out1 *fiatFpTightFieldElement, arg1 *fiatFpTightFieldElement, arg2 *fiatFpTightFieldElement) <span class="cov8" title="1">{
        x1 := ((0xfffffffffffda + arg1[0]) - arg2[0])
        x2 := ((x1 &gt;&gt; 51) + ((0xffffffffffffe + arg1[1]) - arg2[1]))
        x3 := ((x2 &gt;&gt; 51) + ((0xffffffffffffe + arg1[2]) - arg2[2]))
        x4 := ((x3 &gt;&gt; 51) + ((0xffffffffffffe + arg1[3]) - arg2[3]))
        x5 := ((x4 &gt;&gt; 51) + ((0xffffffffffffe + arg1[4]) - arg2[4]))
        x6 := ((x1 &amp; 0x7ffffffffffff) + ((x5 &gt;&gt; 51) * 0x13))
        x7 := (uint64(fiatFpUint1((x6 &gt;&gt; 51))) + (x2 &amp; 0x7ffffffffffff))
        x8 := (x6 &amp; 0x7ffffffffffff)
        x9 := (x7 &amp; 0x7ffffffffffff)
        x10 := (uint64(fiatFpUint1((x7 &gt;&gt; 51))) + (x3 &amp; 0x7ffffffffffff))
        x11 := (x4 &amp; 0x7ffffffffffff)
        x12 := (x5 &amp; 0x7ffffffffffff)
        out1[0] = x8
        out1[1] = x9
        out1[2] = x10
        out1[3] = x11
        out1[4] = x12
}</span>

// fiatFpCarryOpp negates a field element.
//
// Postconditions:
//   eval out1 mod m = -eval arg1 mod m
//
func fiatFpCarryOpp(out1 *fiatFpTightFieldElement, arg1 *fiatFpTightFieldElement) <span class="cov8" title="1">{
        x1 := (0xfffffffffffda - arg1[0])
        x2 := (uint64(fiatFpUint1((x1 &gt;&gt; 51))) + (0xffffffffffffe - arg1[1]))
        x3 := (uint64(fiatFpUint1((x2 &gt;&gt; 51))) + (0xffffffffffffe - arg1[2]))
        x4 := (uint64(fiatFpUint1((x3 &gt;&gt; 51))) + (0xffffffffffffe - arg1[3]))
        x5 := (uint64(fiatFpUint1((x4 &gt;&gt; 51))) + (0xffffffffffffe - arg1[4]))
        x6 := ((x1 &amp; 0x7ffffffffffff) + (uint64(fiatFpUint1((x5 &gt;&gt; 51))) * 0x13))
        x7 := (uint64(fiatFpUint1((x6 &gt;&gt; 51))) + (x2 &amp; 0x7ffffffffffff))
        x8 := (x6 &amp; 0x7ffffffffffff)
        x9 := (x7 &amp; 0x7ffffffffffff)
        x10 := (uint64(fiatFpUint1((x7 &gt;&gt; 51))) + (x3 &amp; 0x7ffffffffffff))
        x11 := (x4 &amp; 0x7ffffffffffff)
        x12 := (x5 &amp; 0x7ffffffffffff)
        out1[0] = x8
        out1[1] = x9
        out1[2] = x10
        out1[3] = x11
        out1[4] = x12
}</span>

// fiatFpRelax is the identity function converting from tight field elements to loose field elements.
//
// Postconditions:
//   out1 = arg1
//
func fiatFpRelax(out1 *fiatFpLooseFieldElement, arg1 *fiatFpTightFieldElement) <span class="cov0" title="0">{
        x1 := arg1[0]
        x2 := arg1[1]
        x3 := arg1[2]
        x4 := arg1[3]
        x5 := arg1[4]
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
        out1[4] = x5
}</span>

// fiatFpSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpSelectznz(out1 *[5]uint64, arg1 fiatFpUint1, arg2 *[5]uint64, arg3 *[5]uint64) <span class="cov8" title="1">{
        var x1 uint64
        fiatFpCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFpCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFpCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFpCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        var x5 uint64
        fiatFpCmovznzU64(&amp;x5, arg1, arg2[4], arg3[4])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
        out1[4] = x5
}</span>

// fiatFpToBytes serializes a field element to bytes in little-endian order.
//
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x7f]]
func fiatFpToBytes(out1 *[32]uint8, arg1 *fiatFpTightFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 fiatFpUint1
        fiatFpSubborrowxU51(&amp;x1, &amp;x2, 0x0, arg1[0], 0x7ffffffffffed)
        var x3 uint64
        var x4 fiatFpUint1
        fiatFpSubborrowxU51(&amp;x3, &amp;x4, x2, arg1[1], 0x7ffffffffffff)
        var x5 uint64
        var x6 fiatFpUint1
        fiatFpSubborrowxU51(&amp;x5, &amp;x6, x4, arg1[2], 0x7ffffffffffff)
        var x7 uint64
        var x8 fiatFpUint1
        fiatFpSubborrowxU51(&amp;x7, &amp;x8, x6, arg1[3], 0x7ffffffffffff)
        var x9 uint64
        var x10 fiatFpUint1
        fiatFpSubborrowxU51(&amp;x9, &amp;x10, x8, arg1[4], 0x7ffffffffffff)
        var x11 uint64
        fiatFpCmovznzU64(&amp;x11, x10, uint64(0x0), 0xffffffffffffffff)
        var x12 uint64
        var x13 fiatFpUint1
        fiatFpAddcarryxU51(&amp;x12, &amp;x13, 0x0, x1, (x11 &amp; 0x7ffffffffffed))
        var x14 uint64
        var x15 fiatFpUint1
        fiatFpAddcarryxU51(&amp;x14, &amp;x15, x13, x3, (x11 &amp; 0x7ffffffffffff))
        var x16 uint64
        var x17 fiatFpUint1
        fiatFpAddcarryxU51(&amp;x16, &amp;x17, x15, x5, (x11 &amp; 0x7ffffffffffff))
        var x18 uint64
        var x19 fiatFpUint1
        fiatFpAddcarryxU51(&amp;x18, &amp;x19, x17, x7, (x11 &amp; 0x7ffffffffffff))
        var x20 uint64
        var x21 fiatFpUint1
        fiatFpAddcarryxU51(&amp;x20, &amp;x21, x19, x9, (x11 &amp; 0x7ffffffffffff))
        x22 := (x20 &lt;&lt; 4)
        x23 := (x18 * uint64(0x2))
        x24 := (x16 &lt;&lt; 6)
        x25 := (x14 &lt;&lt; 3)
        x26 := (uint8(x12) &amp; 0xff)
        x27 := (x12 &gt;&gt; 8)
        x28 := (uint8(x27) &amp; 0xff)
        x29 := (x27 &gt;&gt; 8)
        x30 := (uint8(x29) &amp; 0xff)
        x31 := (x29 &gt;&gt; 8)
        x32 := (uint8(x31) &amp; 0xff)
        x33 := (x31 &gt;&gt; 8)
        x34 := (uint8(x33) &amp; 0xff)
        x35 := (x33 &gt;&gt; 8)
        x36 := (uint8(x35) &amp; 0xff)
        x37 := uint8((x35 &gt;&gt; 8))
        x38 := (x25 + uint64(x37))
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := (x44 &gt;&gt; 8)
        x47 := (uint8(x46) &amp; 0xff)
        x48 := (x46 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := uint8((x48 &gt;&gt; 8))
        x51 := (x24 + uint64(x50))
        x52 := (uint8(x51) &amp; 0xff)
        x53 := (x51 &gt;&gt; 8)
        x54 := (uint8(x53) &amp; 0xff)
        x55 := (x53 &gt;&gt; 8)
        x56 := (uint8(x55) &amp; 0xff)
        x57 := (x55 &gt;&gt; 8)
        x58 := (uint8(x57) &amp; 0xff)
        x59 := (x57 &gt;&gt; 8)
        x60 := (uint8(x59) &amp; 0xff)
        x61 := (x59 &gt;&gt; 8)
        x62 := (uint8(x61) &amp; 0xff)
        x63 := (x61 &gt;&gt; 8)
        x64 := (uint8(x63) &amp; 0xff)
        x65 := fiatFpUint1((x63 &gt;&gt; 8))
        x66 := (x23 + uint64(x65))
        x67 := (uint8(x66) &amp; 0xff)
        x68 := (x66 &gt;&gt; 8)
        x69 := (uint8(x68) &amp; 0xff)
        x70 := (x68 &gt;&gt; 8)
        x71 := (uint8(x70) &amp; 0xff)
        x72 := (x70 &gt;&gt; 8)
        x73 := (uint8(x72) &amp; 0xff)
        x74 := (x72 &gt;&gt; 8)
        x75 := (uint8(x74) &amp; 0xff)
        x76 := (x74 &gt;&gt; 8)
        x77 := (uint8(x76) &amp; 0xff)
        x78 := uint8((x76 &gt;&gt; 8))
        x79 := (x22 + uint64(x78))
        x80 := (uint8(x79) &amp; 0xff)
        x81 := (x79 &gt;&gt; 8)
        x82 := (uint8(x81) &amp; 0xff)
        x83 := (x81 &gt;&gt; 8)
        x84 := (uint8(x83) &amp; 0xff)
        x85 := (x83 &gt;&gt; 8)
        x86 := (uint8(x85) &amp; 0xff)
        x87 := (x85 &gt;&gt; 8)
        x88 := (uint8(x87) &amp; 0xff)
        x89 := (x87 &gt;&gt; 8)
        x90 := (uint8(x89) &amp; 0xff)
        x91 := uint8((x89 &gt;&gt; 8))
        out1[0] = x26
        out1[1] = x28
        out1[2] = x30
        out1[3] = x32
        out1[4] = x34
        out1[5] = x36
        out1[6] = x39
        out1[7] = x41
        out1[8] = x43
        out1[9] = x45
        out1[10] = x47
        out1[11] = x49
        out1[12] = x52
        out1[13] = x54
        out1[14] = x56
        out1[15] = x58
        out1[16] = x60
        out1[17] = x62
        out1[18] = x64
        out1[19] = x67
        out1[20] = x69
        out1[21] = x71
        out1[22] = x73
        out1[23] = x75
        out1[24] = x77
        out1[25] = x80
        out1[26] = x82
        out1[27] = x84
        out1[28] = x86
        out1[29] = x88
        out1[30] = x90
        out1[31] = x91
}</span>

// fiatFpFromBytes deserializes a field element from bytes in little-endian order.
//
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x7f]]
func fiatFpFromBytes(out1 *fiatFpTightFieldElement, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 44)
        x2 := (uint64(arg1[30]) &lt;&lt; 36)
        x3 := (uint64(arg1[29]) &lt;&lt; 28)
        x4 := (uint64(arg1[28]) &lt;&lt; 20)
        x5 := (uint64(arg1[27]) &lt;&lt; 12)
        x6 := (uint64(arg1[26]) &lt;&lt; 4)
        x7 := (uint64(arg1[25]) &lt;&lt; 47)
        x8 := (uint64(arg1[24]) &lt;&lt; 39)
        x9 := (uint64(arg1[23]) &lt;&lt; 31)
        x10 := (uint64(arg1[22]) &lt;&lt; 23)
        x11 := (uint64(arg1[21]) &lt;&lt; 15)
        x12 := (uint64(arg1[20]) &lt;&lt; 7)
        x13 := (uint64(arg1[19]) &lt;&lt; 50)
        x14 := (uint64(arg1[18]) &lt;&lt; 42)
        x15 := (uint64(arg1[17]) &lt;&lt; 34)
        x16 := (uint64(arg1[16]) &lt;&lt; 26)
        x17 := (uint64(arg1[15]) &lt;&lt; 18)
        x18 := (uint64(arg1[14]) &lt;&lt; 10)
        x19 := (uint64(arg1[13]) &lt;&lt; 2)
        x20 := (uint64(arg1[12]) &lt;&lt; 45)
        x21 := (uint64(arg1[11]) &lt;&lt; 37)
        x22 := (uint64(arg1[10]) &lt;&lt; 29)
        x23 := (uint64(arg1[9]) &lt;&lt; 21)
        x24 := (uint64(arg1[8]) &lt;&lt; 13)
        x25 := (uint64(arg1[7]) &lt;&lt; 5)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x38 &amp; 0x7ffffffffffff)
        x40 := uint8((x38 &gt;&gt; 51))
        x41 := (x25 + uint64(x40))
        x42 := (x24 + x41)
        x43 := (x23 + x42)
        x44 := (x22 + x43)
        x45 := (x21 + x44)
        x46 := (x20 + x45)
        x47 := (x46 &amp; 0x7ffffffffffff)
        x48 := uint8((x46 &gt;&gt; 51))
        x49 := (x19 + uint64(x48))
        x50 := (x18 + x49)
        x51 := (x17 + x50)
        x52 := (x16 + x51)
        x53 := (x15 + x52)
        x54 := (x14 + x53)
        x55 := (x13 + x54)
        x56 := (x55 &amp; 0x7ffffffffffff)
        x57 := uint8((x55 &gt;&gt; 51))
        x58 := (x12 + uint64(x57))
        x59 := (x11 + x58)
        x60 := (x10 + x59)
        x61 := (x9 + x60)
        x62 := (x8 + x61)
        x63 := (x7 + x62)
        x64 := (x63 &amp; 0x7ffffffffffff)
        x65 := uint8((x63 &gt;&gt; 51))
        x66 := (x6 + uint64(x65))
        x67 := (x5 + x66)
        x68 := (x4 + x67)
        x69 := (x3 + x68)
        x70 := (x2 + x69)
        x71 := (x1 + x70)
        out1[0] = x39
        out1[1] = x47
        out1[2] = x56
        out1[3] = x64
        out1[4] = x71
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fq 64 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed
//
// curve description: Fq
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed (from "0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) in
//
//                            if x1 &amp; (2^256-1) &lt; 2^255 then x1 &amp; (2^256-1) else (x1 &amp; (2^256-1)) - 2^256
package impl

import "math/bits"

type fiatFqUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFqInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFqMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqMontgomeryDomainFieldElement [4]uint64

// fiatFqNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqNonMontgomeryDomainFieldElement [4]uint64

// fiatFqCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqCmovznzU64(out1 *uint64, arg1 fiatFqUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFqMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqMul(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg2[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg2[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg2[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg2[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0xd2b51da312547e1b)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0x1000000000000000)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0x14def9dea2f79cd6)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0x5812631a5cf5d3ed)
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x27, x24, uint64(0x0))
        x30 := (uint64(fiatFqUint1(x29)) + x25)
        var x32 uint64
        _, x32 = bits.Add64(x11, x26, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x13, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x15, x30, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x17, x22, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x19, x23, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, arg2[3])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, arg2[2])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, arg2[1])
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg2[0])
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x48, x45, uint64(0x0))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x46, x43, uint64(fiatFqUint1(x50)))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x44, x41, uint64(fiatFqUint1(x52)))
        x55 := (uint64(fiatFqUint1(x54)) + x42)
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x33, x47, uint64(0x0))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x35, x49, uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x37, x51, uint64(fiatFqUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(fiatFqUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(uint64(fiatFqUint1(x40)), x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x56, 0xd2b51da312547e1b)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x1000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x14def9dea2f79cd6)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x5812631a5cf5d3ed)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        x76 := (uint64(fiatFqUint1(x75)) + x71)
        var x78 uint64
        _, x78 = bits.Add64(x56, x72, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x58, x74, uint64(fiatFqUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x60, x76, uint64(fiatFqUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x62, x68, uint64(fiatFqUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x64, x69, uint64(fiatFqUint1(x84)))
        x87 := (uint64(fiatFqUint1(x86)) + uint64(fiatFqUint1(x65)))
        var x88 uint64
        var x89 uint64
        x89, x88 = bits.Mul64(x2, arg2[3])
        var x90 uint64
        var x91 uint64
        x91, x90 = bits.Mul64(x2, arg2[2])
        var x92 uint64
        var x93 uint64
        x93, x92 = bits.Mul64(x2, arg2[1])
        var x94 uint64
        var x95 uint64
        x95, x94 = bits.Mul64(x2, arg2[0])
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x95, x92, uint64(0x0))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x93, x90, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x91, x88, uint64(fiatFqUint1(x99)))
        x102 := (uint64(fiatFqUint1(x101)) + x89)
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x94, uint64(0x0))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x96, uint64(fiatFqUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x98, uint64(fiatFqUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x85, x100, uint64(fiatFqUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x87, x102, uint64(fiatFqUint1(x110)))
        var x113 uint64
        _, x113 = bits.Mul64(x103, 0xd2b51da312547e1b)
        var x115 uint64
        var x116 uint64
        x116, x115 = bits.Mul64(x113, 0x1000000000000000)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x113, 0x14def9dea2f79cd6)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x113, 0x5812631a5cf5d3ed)
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x120, x117, uint64(0x0))
        x123 := (uint64(fiatFqUint1(x122)) + x118)
        var x125 uint64
        _, x125 = bits.Add64(x103, x119, uint64(0x0))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x105, x121, uint64(fiatFqUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64(x107, x123, uint64(fiatFqUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Add64(x109, x115, uint64(fiatFqUint1(x129)))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Add64(x111, x116, uint64(fiatFqUint1(x131)))
        x134 := (uint64(fiatFqUint1(x133)) + uint64(fiatFqUint1(x112)))
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, arg2[3])
        var x137 uint64
        var x138 uint64
        x138, x137 = bits.Mul64(x3, arg2[2])
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x3, arg2[1])
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, arg2[0])
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x142, x139, uint64(0x0))
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x140, x137, uint64(fiatFqUint1(x144)))
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x138, x135, uint64(fiatFqUint1(x146)))
        x149 := (uint64(fiatFqUint1(x148)) + x136)
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x126, x141, uint64(0x0))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Add64(x128, x143, uint64(fiatFqUint1(x151)))
        var x154 uint64
        var x155 uint64
        x154, x155 = bits.Add64(x130, x145, uint64(fiatFqUint1(x153)))
        var x156 uint64
        var x157 uint64
        x156, x157 = bits.Add64(x132, x147, uint64(fiatFqUint1(x155)))
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x134, x149, uint64(fiatFqUint1(x157)))
        var x160 uint64
        _, x160 = bits.Mul64(x150, 0xd2b51da312547e1b)
        var x162 uint64
        var x163 uint64
        x163, x162 = bits.Mul64(x160, 0x1000000000000000)
        var x164 uint64
        var x165 uint64
        x165, x164 = bits.Mul64(x160, 0x14def9dea2f79cd6)
        var x166 uint64
        var x167 uint64
        x167, x166 = bits.Mul64(x160, 0x5812631a5cf5d3ed)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x167, x164, uint64(0x0))
        x170 := (uint64(fiatFqUint1(x169)) + x165)
        var x172 uint64
        _, x172 = bits.Add64(x150, x166, uint64(0x0))
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x152, x168, uint64(fiatFqUint1(x172)))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x154, x170, uint64(fiatFqUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x156, x162, uint64(fiatFqUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x158, x163, uint64(fiatFqUint1(x178)))
        x181 := (uint64(fiatFqUint1(x180)) + uint64(fiatFqUint1(x159)))
        var x182 uint64
        var x183 uint64
        x182, x183 = bits.Sub64(x173, 0x5812631a5cf5d3ed, uint64(0x0))
        var x184 uint64
        var x185 uint64
        x184, x185 = bits.Sub64(x175, 0x14def9dea2f79cd6, uint64(fiatFqUint1(x183)))
        var x186 uint64
        var x187 uint64
        x186, x187 = bits.Sub64(x177, uint64(0x0), uint64(fiatFqUint1(x185)))
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Sub64(x179, 0x1000000000000000, uint64(fiatFqUint1(x187)))
        var x191 uint64
        _, x191 = bits.Sub64(x181, uint64(0x0), uint64(fiatFqUint1(x189)))
        var x192 uint64
        fiatFqCmovznzU64(&amp;x192, fiatFqUint1(x191), x182, x173)
        var x193 uint64
        fiatFqCmovznzU64(&amp;x193, fiatFqUint1(x191), x184, x175)
        var x194 uint64
        fiatFqCmovznzU64(&amp;x194, fiatFqUint1(x191), x186, x177)
        var x195 uint64
        fiatFqCmovznzU64(&amp;x195, fiatFqUint1(x191), x188, x179)
        out1[0] = x192
        out1[1] = x193
        out1[2] = x194
        out1[3] = x195
}</span>

// fiatFqSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSquare(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg1[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg1[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg1[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg1[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0xd2b51da312547e1b)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0x1000000000000000)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0x14def9dea2f79cd6)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0x5812631a5cf5d3ed)
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x27, x24, uint64(0x0))
        x30 := (uint64(fiatFqUint1(x29)) + x25)
        var x32 uint64
        _, x32 = bits.Add64(x11, x26, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x13, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x15, x30, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x17, x22, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x19, x23, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, arg1[3])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, arg1[2])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, arg1[1])
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg1[0])
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x48, x45, uint64(0x0))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x46, x43, uint64(fiatFqUint1(x50)))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x44, x41, uint64(fiatFqUint1(x52)))
        x55 := (uint64(fiatFqUint1(x54)) + x42)
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x33, x47, uint64(0x0))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x35, x49, uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x37, x51, uint64(fiatFqUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(fiatFqUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(uint64(fiatFqUint1(x40)), x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x56, 0xd2b51da312547e1b)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x1000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x14def9dea2f79cd6)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x5812631a5cf5d3ed)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        x76 := (uint64(fiatFqUint1(x75)) + x71)
        var x78 uint64
        _, x78 = bits.Add64(x56, x72, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x58, x74, uint64(fiatFqUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x60, x76, uint64(fiatFqUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x62, x68, uint64(fiatFqUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x64, x69, uint64(fiatFqUint1(x84)))
        x87 := (uint64(fiatFqUint1(x86)) + uint64(fiatFqUint1(x65)))
        var x88 uint64
        var x89 uint64
        x89, x88 = bits.Mul64(x2, arg1[3])
        var x90 uint64
        var x91 uint64
        x91, x90 = bits.Mul64(x2, arg1[2])
        var x92 uint64
        var x93 uint64
        x93, x92 = bits.Mul64(x2, arg1[1])
        var x94 uint64
        var x95 uint64
        x95, x94 = bits.Mul64(x2, arg1[0])
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x95, x92, uint64(0x0))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x93, x90, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x91, x88, uint64(fiatFqUint1(x99)))
        x102 := (uint64(fiatFqUint1(x101)) + x89)
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x94, uint64(0x0))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x96, uint64(fiatFqUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x98, uint64(fiatFqUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x85, x100, uint64(fiatFqUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x87, x102, uint64(fiatFqUint1(x110)))
        var x113 uint64
        _, x113 = bits.Mul64(x103, 0xd2b51da312547e1b)
        var x115 uint64
        var x116 uint64
        x116, x115 = bits.Mul64(x113, 0x1000000000000000)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x113, 0x14def9dea2f79cd6)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x113, 0x5812631a5cf5d3ed)
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x120, x117, uint64(0x0))
        x123 := (uint64(fiatFqUint1(x122)) + x118)
        var x125 uint64
        _, x125 = bits.Add64(x103, x119, uint64(0x0))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x105, x121, uint64(fiatFqUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64(x107, x123, uint64(fiatFqUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Add64(x109, x115, uint64(fiatFqUint1(x129)))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Add64(x111, x116, uint64(fiatFqUint1(x131)))
        x134 := (uint64(fiatFqUint1(x133)) + uint64(fiatFqUint1(x112)))
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, arg1[3])
        var x137 uint64
        var x138 uint64
        x138, x137 = bits.Mul64(x3, arg1[2])
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x3, arg1[1])
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, arg1[0])
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x142, x139, uint64(0x0))
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x140, x137, uint64(fiatFqUint1(x144)))
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x138, x135, uint64(fiatFqUint1(x146)))
        x149 := (uint64(fiatFqUint1(x148)) + x136)
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x126, x141, uint64(0x0))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Add64(x128, x143, uint64(fiatFqUint1(x151)))
        var x154 uint64
        var x155 uint64
        x154, x155 = bits.Add64(x130, x145, uint64(fiatFqUint1(x153)))
        var x156 uint64
        var x157 uint64
        x156, x157 = bits.Add64(x132, x147, uint64(fiatFqUint1(x155)))
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x134, x149, uint64(fiatFqUint1(x157)))
        var x160 uint64
        _, x160 = bits.Mul64(x150, 0xd2b51da312547e1b)
        var x162 uint64
        var x163 uint64
        x163, x162 = bits.Mul64(x160, 0x1000000000000000)
        var x164 uint64
        var x165 uint64
        x165, x164 = bits.Mul64(x160, 0x14def9dea2f79cd6)
        var x166 uint64
        var x167 uint64
        x167, x166 = bits.Mul64(x160, 0x5812631a5cf5d3ed)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x167, x164, uint64(0x0))
        x170 := (uint64(fiatFqUint1(x169)) + x165)
        var x172 uint64
        _, x172 = bits.Add64(x150, x166, uint64(0x0))
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x152, x168, uint64(fiatFqUint1(x172)))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x154, x170, uint64(fiatFqUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x156, x162, uint64(fiatFqUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x158, x163, uint64(fiatFqUint1(x178)))
        x181 := (uint64(fiatFqUint1(x180)) + uint64(fiatFqUint1(x159)))
        var x182 uint64
        var x183 uint64
        x182, x183 = bits.Sub64(x173, 0x5812631a5cf5d3ed, uint64(0x0))
        var x184 uint64
        var x185 uint64
        x184, x185 = bits.Sub64(x175, 0x14def9dea2f79cd6, uint64(fiatFqUint1(x183)))
        var x186 uint64
        var x187 uint64
        x186, x187 = bits.Sub64(x177, uint64(0x0), uint64(fiatFqUint1(x185)))
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Sub64(x179, 0x1000000000000000, uint64(fiatFqUint1(x187)))
        var x191 uint64
        _, x191 = bits.Sub64(x181, uint64(0x0), uint64(fiatFqUint1(x189)))
        var x192 uint64
        fiatFqCmovznzU64(&amp;x192, fiatFqUint1(x191), x182, x173)
        var x193 uint64
        fiatFqCmovznzU64(&amp;x193, fiatFqUint1(x191), x184, x175)
        var x194 uint64
        fiatFqCmovznzU64(&amp;x194, fiatFqUint1(x191), x186, x177)
        var x195 uint64
        fiatFqCmovznzU64(&amp;x195, fiatFqUint1(x191), x188, x179)
        out1[0] = x192
        out1[1] = x193
        out1[2] = x194
        out1[3] = x195
}</span>

// fiatFqAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqAdd(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(x1, 0x5812631a5cf5d3ed, uint64(0x0))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(x3, 0x14def9dea2f79cd6, uint64(fiatFqUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x5, uint64(0x0), uint64(fiatFqUint1(x12)))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x7, 0x1000000000000000, uint64(fiatFqUint1(x14)))
        var x18 uint64
        _, x18 = bits.Sub64(uint64(fiatFqUint1(x8)), uint64(0x0), uint64(fiatFqUint1(x16)))
        var x19 uint64
        fiatFqCmovznzU64(&amp;x19, fiatFqUint1(x18), x9, x1)
        var x20 uint64
        fiatFqCmovznzU64(&amp;x20, fiatFqUint1(x18), x11, x3)
        var x21 uint64
        fiatFqCmovznzU64(&amp;x21, fiatFqUint1(x18), x13, x5)
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, fiatFqUint1(x18), x15, x7)
        out1[0] = x19
        out1[1] = x20
        out1[2] = x21
        out1[3] = x22
}</span>

// fiatFqSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSub(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0x5812631a5cf5d3ed), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0x14def9dea2f79cd6), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, uint64(0x0), uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0x1000000000000000), uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFqOpp(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0x5812631a5cf5d3ed), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0x14def9dea2f79cd6), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, uint64(0x0), uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0x1000000000000000), uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^4) mod m
//   0  eval out1 &lt; m
//
func fiatFqFromMontgomery(out1 *fiatFqNonMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[0]
        var x2 uint64
        _, x2 = bits.Mul64(x1, 0xd2b51da312547e1b)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x2, 0x1000000000000000)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x2, 0x14def9dea2f79cd6)
        var x8 uint64
        var x9 uint64
        x9, x8 = bits.Mul64(x2, 0x5812631a5cf5d3ed)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x9, x6, uint64(0x0))
        var x13 uint64
        _, x13 = bits.Add64(x1, x8, uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), x10, uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x14, arg1[1], uint64(0x0))
        var x18 uint64
        _, x18 = bits.Mul64(x16, 0xd2b51da312547e1b)
        var x20 uint64
        var x21 uint64
        x21, x20 = bits.Mul64(x18, 0x1000000000000000)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x18, 0x14def9dea2f79cd6)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x18, 0x5812631a5cf5d3ed)
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(x25, x22, uint64(0x0))
        var x29 uint64
        _, x29 = bits.Add64(x16, x24, uint64(0x0))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64((uint64(fiatFqUint1(x17)) + (uint64(fiatFqUint1(x15)) + (uint64(fiatFqUint1(x11)) + x7))), x26, uint64(fiatFqUint1(x29)))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x4, (uint64(fiatFqUint1(x27)) + x23), uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x5, x20, uint64(fiatFqUint1(x33)))
        var x36 uint64
        var x37 uint64
        x36, x37 = bits.Add64(x30, arg1[2], uint64(0x0))
        var x38 uint64
        var x39 uint64
        x38, x39 = bits.Add64(x32, uint64(0x0), uint64(fiatFqUint1(x37)))
        var x40 uint64
        var x41 uint64
        x40, x41 = bits.Add64(x34, uint64(0x0), uint64(fiatFqUint1(x39)))
        var x42 uint64
        _, x42 = bits.Mul64(x36, 0xd2b51da312547e1b)
        var x44 uint64
        var x45 uint64
        x45, x44 = bits.Mul64(x42, 0x1000000000000000)
        var x46 uint64
        var x47 uint64
        x47, x46 = bits.Mul64(x42, 0x14def9dea2f79cd6)
        var x48 uint64
        var x49 uint64
        x49, x48 = bits.Mul64(x42, 0x5812631a5cf5d3ed)
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x49, x46, uint64(0x0))
        var x53 uint64
        _, x53 = bits.Add64(x36, x48, uint64(0x0))
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64(x38, x50, uint64(fiatFqUint1(x53)))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x40, (uint64(fiatFqUint1(x51)) + x47), uint64(fiatFqUint1(x55)))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64((uint64(fiatFqUint1(x41)) + (uint64(fiatFqUint1(x35)) + x21)), x44, uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x54, arg1[3], uint64(0x0))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x56, uint64(0x0), uint64(fiatFqUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x58, uint64(0x0), uint64(fiatFqUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x60, 0xd2b51da312547e1b)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x1000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x14def9dea2f79cd6)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x5812631a5cf5d3ed)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        var x77 uint64
        _, x77 = bits.Add64(x60, x72, uint64(0x0))
        var x78 uint64
        var x79 uint64
        x78, x79 = bits.Add64(x62, x74, uint64(fiatFqUint1(x77)))
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x64, (uint64(fiatFqUint1(x75)) + x71), uint64(fiatFqUint1(x79)))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64((uint64(fiatFqUint1(x65)) + (uint64(fiatFqUint1(x59)) + x45)), x68, uint64(fiatFqUint1(x81)))
        x84 := (uint64(fiatFqUint1(x83)) + x69)
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Sub64(x78, 0x5812631a5cf5d3ed, uint64(0x0))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Sub64(x80, 0x14def9dea2f79cd6, uint64(fiatFqUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Sub64(x82, uint64(0x0), uint64(fiatFqUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Sub64(x84, 0x1000000000000000, uint64(fiatFqUint1(x90)))
        var x94 uint64
        _, x94 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFqUint1(x92)))
        var x95 uint64
        fiatFqCmovznzU64(&amp;x95, fiatFqUint1(x94), x85, x78)
        var x96 uint64
        fiatFqCmovznzU64(&amp;x96, fiatFqUint1(x94), x87, x80)
        var x97 uint64
        fiatFqCmovznzU64(&amp;x97, fiatFqUint1(x94), x89, x82)
        var x98 uint64
        fiatFqCmovznzU64(&amp;x98, fiatFqUint1(x94), x91, x84)
        out1[0] = x95
        out1[1] = x96
        out1[2] = x97
        out1[3] = x98
}</span>

// fiatFqToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFqToMontgomery(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, 0x399411b7c309a3d)
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, 0xceec73d217f5be65)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, 0xd00e1ba768859347)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, 0xa40611e3449c0f01)
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        var x19 uint64
        _, x19 = bits.Mul64(x11, 0xd2b51da312547e1b)
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(x19, 0x1000000000000000)
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(x19, 0x14def9dea2f79cd6)
        var x25 uint64
        var x26 uint64
        x26, x25 = bits.Mul64(x19, 0x5812631a5cf5d3ed)
        var x27 uint64
        var x28 uint64
        x27, x28 = bits.Add64(x26, x23, uint64(0x0))
        var x30 uint64
        _, x30 = bits.Add64(x11, x25, uint64(0x0))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x13, x27, uint64(fiatFqUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x15, (uint64(fiatFqUint1(x28)) + x24), uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x17, x21, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x38, x37 = bits.Mul64(x1, 0x399411b7c309a3d)
        var x39 uint64
        var x40 uint64
        x40, x39 = bits.Mul64(x1, 0xceec73d217f5be65)
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, 0xd00e1ba768859347)
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, 0xa40611e3449c0f01)
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x44, x41, uint64(0x0))
        var x47 uint64
        var x48 uint64
        x47, x48 = bits.Add64(x42, x39, uint64(fiatFqUint1(x46)))
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x40, x37, uint64(fiatFqUint1(x48)))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x31, x43, uint64(0x0))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x33, x45, uint64(fiatFqUint1(x52)))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x35, x47, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(((uint64(fiatFqUint1(x36)) + (uint64(fiatFqUint1(x18)) + x6)) + x22), x49, uint64(fiatFqUint1(x56)))
        var x59 uint64
        _, x59 = bits.Mul64(x51, 0xd2b51da312547e1b)
        var x61 uint64
        var x62 uint64
        x62, x61 = bits.Mul64(x59, 0x1000000000000000)
        var x63 uint64
        var x64 uint64
        x64, x63 = bits.Mul64(x59, 0x14def9dea2f79cd6)
        var x65 uint64
        var x66 uint64
        x66, x65 = bits.Mul64(x59, 0x5812631a5cf5d3ed)
        var x67 uint64
        var x68 uint64
        x67, x68 = bits.Add64(x66, x63, uint64(0x0))
        var x70 uint64
        _, x70 = bits.Add64(x51, x65, uint64(0x0))
        var x71 uint64
        var x72 uint64
        x71, x72 = bits.Add64(x53, x67, uint64(fiatFqUint1(x70)))
        var x73 uint64
        var x74 uint64
        x73, x74 = bits.Add64(x55, (uint64(fiatFqUint1(x68)) + x64), uint64(fiatFqUint1(x72)))
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Add64(x57, x61, uint64(fiatFqUint1(x74)))
        var x77 uint64
        var x78 uint64
        x78, x77 = bits.Mul64(x2, 0x399411b7c309a3d)
        var x79 uint64
        var x80 uint64
        x80, x79 = bits.Mul64(x2, 0xceec73d217f5be65)
        var x81 uint64
        var x82 uint64
        x82, x81 = bits.Mul64(x2, 0xd00e1ba768859347)
        var x83 uint64
        var x84 uint64
        x84, x83 = bits.Mul64(x2, 0xa40611e3449c0f01)
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x84, x81, uint64(0x0))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x82, x79, uint64(fiatFqUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x80, x77, uint64(fiatFqUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x71, x83, uint64(0x0))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x73, x85, uint64(fiatFqUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x75, x87, uint64(fiatFqUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(((uint64(fiatFqUint1(x76)) + (uint64(fiatFqUint1(x58)) + (uint64(fiatFqUint1(x50)) + x38))) + x62), x89, uint64(fiatFqUint1(x96)))
        var x99 uint64
        _, x99 = bits.Mul64(x91, 0xd2b51da312547e1b)
        var x101 uint64
        var x102 uint64
        x102, x101 = bits.Mul64(x99, 0x1000000000000000)
        var x103 uint64
        var x104 uint64
        x104, x103 = bits.Mul64(x99, 0x14def9dea2f79cd6)
        var x105 uint64
        var x106 uint64
        x106, x105 = bits.Mul64(x99, 0x5812631a5cf5d3ed)
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x106, x103, uint64(0x0))
        var x110 uint64
        _, x110 = bits.Add64(x91, x105, uint64(0x0))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x93, x107, uint64(fiatFqUint1(x110)))
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x95, (uint64(fiatFqUint1(x108)) + x104), uint64(fiatFqUint1(x112)))
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x97, x101, uint64(fiatFqUint1(x114)))
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x3, 0x399411b7c309a3d)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x3, 0xceec73d217f5be65)
        var x121 uint64
        var x122 uint64
        x122, x121 = bits.Mul64(x3, 0xd00e1ba768859347)
        var x123 uint64
        var x124 uint64
        x124, x123 = bits.Mul64(x3, 0xa40611e3449c0f01)
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x124, x121, uint64(0x0))
        var x127 uint64
        var x128 uint64
        x127, x128 = bits.Add64(x122, x119, uint64(fiatFqUint1(x126)))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x120, x117, uint64(fiatFqUint1(x128)))
        var x131 uint64
        var x132 uint64
        x131, x132 = bits.Add64(x111, x123, uint64(0x0))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x113, x125, uint64(fiatFqUint1(x132)))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x115, x127, uint64(fiatFqUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(((uint64(fiatFqUint1(x116)) + (uint64(fiatFqUint1(x98)) + (uint64(fiatFqUint1(x90)) + x78))) + x102), x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        _, x139 = bits.Mul64(x131, 0xd2b51da312547e1b)
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x139, 0x1000000000000000)
        var x143 uint64
        var x144 uint64
        x144, x143 = bits.Mul64(x139, 0x14def9dea2f79cd6)
        var x145 uint64
        var x146 uint64
        x146, x145 = bits.Mul64(x139, 0x5812631a5cf5d3ed)
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x146, x143, uint64(0x0))
        var x150 uint64
        _, x150 = bits.Add64(x131, x145, uint64(0x0))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Add64(x133, x147, uint64(fiatFqUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Add64(x135, (uint64(fiatFqUint1(x148)) + x144), uint64(fiatFqUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Add64(x137, x141, uint64(fiatFqUint1(x154)))
        x157 := ((uint64(fiatFqUint1(x156)) + (uint64(fiatFqUint1(x138)) + (uint64(fiatFqUint1(x130)) + x118))) + x142)
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Sub64(x151, 0x5812631a5cf5d3ed, uint64(0x0))
        var x160 uint64
        var x161 uint64
        x160, x161 = bits.Sub64(x153, 0x14def9dea2f79cd6, uint64(fiatFqUint1(x159)))
        var x162 uint64
        var x163 uint64
        x162, x163 = bits.Sub64(x155, uint64(0x0), uint64(fiatFqUint1(x161)))
        var x164 uint64
        var x165 uint64
        x164, x165 = bits.Sub64(x157, 0x1000000000000000, uint64(fiatFqUint1(x163)))
        var x167 uint64
        _, x167 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFqUint1(x165)))
        var x168 uint64
        fiatFqCmovznzU64(&amp;x168, fiatFqUint1(x167), x158, x151)
        var x169 uint64
        fiatFqCmovznzU64(&amp;x169, fiatFqUint1(x167), x160, x153)
        var x170 uint64
        fiatFqCmovznzU64(&amp;x170, fiatFqUint1(x167), x162, x155)
        var x171 uint64
        fiatFqCmovznzU64(&amp;x171, fiatFqUint1(x167), x164, x157)
        out1[0] = x168
        out1[1] = x169
        out1[2] = x170
        out1[3] = x171
}</span>

// fiatFqNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqNonzero(out1 *uint64, arg1 *[4]uint64) <span class="cov0" title="0">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | arg1[3])))
        *out1 = x1
}</span>

// fiatFqSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqSelectznz(out1 *[4]uint64, arg1 fiatFqUint1, arg2 *[4]uint64, arg3 *[4]uint64) <span class="cov0" title="0">{
        var x1 uint64
        fiatFqCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFqCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFqCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFqCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
}</span>

// fiatFqToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x1fffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x1f]]
func fiatFqToBytes(out1 *[32]uint8, arg1 *[4]uint64) <span class="cov0" title="0">{
        x1 := arg1[3]
        x2 := arg1[2]
        x3 := arg1[1]
        x4 := arg1[0]
        x5 := (uint8(x4) &amp; 0xff)
        x6 := (x4 &gt;&gt; 8)
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := uint8((x16 &gt;&gt; 8))
        x19 := (uint8(x3) &amp; 0xff)
        x20 := (x3 &gt;&gt; 8)
        x21 := (uint8(x20) &amp; 0xff)
        x22 := (x20 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := uint8((x30 &gt;&gt; 8))
        x33 := (uint8(x2) &amp; 0xff)
        x34 := (x2 &gt;&gt; 8)
        x35 := (uint8(x34) &amp; 0xff)
        x36 := (x34 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := uint8((x44 &gt;&gt; 8))
        x47 := (uint8(x1) &amp; 0xff)
        x48 := (x1 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := (x48 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := uint8((x58 &gt;&gt; 8))
        out1[0] = x5
        out1[1] = x7
        out1[2] = x9
        out1[3] = x11
        out1[4] = x13
        out1[5] = x15
        out1[6] = x17
        out1[7] = x18
        out1[8] = x19
        out1[9] = x21
        out1[10] = x23
        out1[11] = x25
        out1[12] = x27
        out1[13] = x29
        out1[14] = x31
        out1[15] = x32
        out1[16] = x33
        out1[17] = x35
        out1[18] = x37
        out1[19] = x39
        out1[20] = x41
        out1[21] = x43
        out1[22] = x45
        out1[23] = x46
        out1[24] = x47
        out1[25] = x49
        out1[26] = x51
        out1[27] = x53
        out1[28] = x55
        out1[29] = x57
        out1[30] = x59
        out1[31] = x60
}</span>

// fiatFqFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x1f]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x1fffffffffffffff]]
func fiatFqFromBytes(out1 *[4]uint64, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 56)
        x2 := (uint64(arg1[30]) &lt;&lt; 48)
        x3 := (uint64(arg1[29]) &lt;&lt; 40)
        x4 := (uint64(arg1[28]) &lt;&lt; 32)
        x5 := (uint64(arg1[27]) &lt;&lt; 24)
        x6 := (uint64(arg1[26]) &lt;&lt; 16)
        x7 := (uint64(arg1[25]) &lt;&lt; 8)
        x8 := arg1[24]
        x9 := (uint64(arg1[23]) &lt;&lt; 56)
        x10 := (uint64(arg1[22]) &lt;&lt; 48)
        x11 := (uint64(arg1[21]) &lt;&lt; 40)
        x12 := (uint64(arg1[20]) &lt;&lt; 32)
        x13 := (uint64(arg1[19]) &lt;&lt; 24)
        x14 := (uint64(arg1[18]) &lt;&lt; 16)
        x15 := (uint64(arg1[17]) &lt;&lt; 8)
        x16 := arg1[16]
        x17 := (uint64(arg1[15]) &lt;&lt; 56)
        x18 := (uint64(arg1[14]) &lt;&lt; 48)
        x19 := (uint64(arg1[13]) &lt;&lt; 40)
        x20 := (uint64(arg1[12]) &lt;&lt; 32)
        x21 := (uint64(arg1[11]) &lt;&lt; 24)
        x22 := (uint64(arg1[10]) &lt;&lt; 16)
        x23 := (uint64(arg1[9]) &lt;&lt; 8)
        x24 := arg1[8]
        x25 := (uint64(arg1[7]) &lt;&lt; 56)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x25 + x38)
        x40 := (x23 + uint64(x24))
        x41 := (x22 + x40)
        x42 := (x21 + x41)
        x43 := (x20 + x42)
        x44 := (x19 + x43)
        x45 := (x18 + x44)
        x46 := (x17 + x45)
        x47 := (x15 + uint64(x16))
        x48 := (x14 + x47)
        x49 := (x13 + x48)
        x50 := (x12 + x49)
        x51 := (x11 + x50)
        x52 := (x10 + x51)
        x53 := (x9 + x52)
        x54 := (x7 + uint64(x8))
        x55 := (x6 + x54)
        x56 := (x5 + x55)
        x57 := (x4 + x56)
        x58 := (x3 + x57)
        x59 := (x2 + x58)
        x60 := (x1 + x59)
        out1[0] = x39
        out1[1] = x46
        out1[2] = x53
        out1[3] = x60
}</span>

// fiatFqSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFqSetOne(out1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        out1[0] = 0xd6ec31748d98951d
        out1[1] = 0xc6ef5bf4737dcf70
        out1[2] = 0xfffffffffffffffe
        out1[3] = 0xfffffffffffffff
}</span>

// fiatFqMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqMsat(out1 *[5]uint64) <span class="cov0" title="0">{
        out1[0] = 0x5812631a5cf5d3ed
        out1[1] = 0x14def9dea2f79cd6
        out1[2] = uint64(0x0)
        out1[3] = 0x1000000000000000
        out1[4] = uint64(0x0)
}</span>

// fiatFqDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstepPrecomp(out1 *[4]uint64) <span class="cov0" title="0">{
        out1[0] = 0xd70af84436a7cb92
        out1[1] = 0x5f71c978b0b8b159
        out1[2] = 0xe76d816974947f1a
        out1[3] = 0x19a2d36f193e4ff
}</span>

// fiatFqDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstep(out1 *uint64, out2 *[5]uint64, out3 *[5]uint64, out4 *[4]uint64, out5 *[4]uint64, arg1 uint64, arg2 *[5]uint64, arg3 *[5]uint64, arg4 *[4]uint64, arg5 *[4]uint64) <span class="cov0" title="0">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFqUint1((x1 &gt;&gt; 63)) &amp; (fiatFqUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFqCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFqCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFqCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFqCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFqCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFqUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFqUint1(x17)))
        var x20 uint64
        x20, _ = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFqUint1(x19)))
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, x3, arg3[0], x12)
        var x23 uint64
        fiatFqCmovznzU64(&amp;x23, x3, arg3[1], x14)
        var x24 uint64
        fiatFqCmovznzU64(&amp;x24, x3, arg3[2], x16)
        var x25 uint64
        fiatFqCmovznzU64(&amp;x25, x3, arg3[3], x18)
        var x26 uint64
        fiatFqCmovznzU64(&amp;x26, x3, arg3[4], x20)
        var x27 uint64
        fiatFqCmovznzU64(&amp;x27, x3, arg4[0], arg5[0])
        var x28 uint64
        fiatFqCmovznzU64(&amp;x28, x3, arg4[1], arg5[1])
        var x29 uint64
        fiatFqCmovznzU64(&amp;x29, x3, arg4[2], arg5[2])
        var x30 uint64
        fiatFqCmovznzU64(&amp;x30, x3, arg4[3], arg5[3])
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x27, x27, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x28, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x29, x29, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x30, x30, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Sub64(x31, 0x5812631a5cf5d3ed, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Sub64(x33, 0x14def9dea2f79cd6, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Sub64(x35, uint64(0x0), uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Sub64(x37, 0x1000000000000000, uint64(fiatFqUint1(x44)))
        var x48 uint64
        _, x48 = bits.Sub64(uint64(fiatFqUint1(x38)), uint64(0x0), uint64(fiatFqUint1(x46)))
        x49 := arg4[3]
        x50 := arg4[2]
        x51 := arg4[1]
        x52 := arg4[0]
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(uint64(0x0), x52, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(uint64(0x0), x51, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(uint64(0x0), x50, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(uint64(0x0), x49, uint64(fiatFqUint1(x58)))
        var x61 uint64
        fiatFqCmovznzU64(&amp;x61, fiatFqUint1(x60), uint64(0x0), 0xffffffffffffffff)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x53, (x61 &amp; 0x5812631a5cf5d3ed), uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x55, (x61 &amp; 0x14def9dea2f79cd6), uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, uint64(0x0), uint64(fiatFqUint1(x65)))
        var x68 uint64
        x68, _ = bits.Add64(x59, (x61 &amp; 0x1000000000000000), uint64(fiatFqUint1(x67)))
        var x70 uint64
        fiatFqCmovznzU64(&amp;x70, x3, arg5[0], x62)
        var x71 uint64
        fiatFqCmovznzU64(&amp;x71, x3, arg5[1], x64)
        var x72 uint64
        fiatFqCmovznzU64(&amp;x72, x3, arg5[2], x66)
        var x73 uint64
        fiatFqCmovznzU64(&amp;x73, x3, arg5[3], x68)
        x74 := (fiatFqUint1(x22) &amp; 0x1)
        var x75 uint64
        fiatFqCmovznzU64(&amp;x75, x74, uint64(0x0), x7)
        var x76 uint64
        fiatFqCmovznzU64(&amp;x76, x74, uint64(0x0), x8)
        var x77 uint64
        fiatFqCmovznzU64(&amp;x77, x74, uint64(0x0), x9)
        var x78 uint64
        fiatFqCmovznzU64(&amp;x78, x74, uint64(0x0), x10)
        var x79 uint64
        fiatFqCmovznzU64(&amp;x79, x74, uint64(0x0), x11)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x22, x75, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x23, x76, uint64(fiatFqUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x24, x77, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x25, x78, uint64(fiatFqUint1(x85)))
        var x88 uint64
        x88, _ = bits.Add64(x26, x79, uint64(fiatFqUint1(x87)))
        var x90 uint64
        fiatFqCmovznzU64(&amp;x90, x74, uint64(0x0), x27)
        var x91 uint64
        fiatFqCmovznzU64(&amp;x91, x74, uint64(0x0), x28)
        var x92 uint64
        fiatFqCmovznzU64(&amp;x92, x74, uint64(0x0), x29)
        var x93 uint64
        fiatFqCmovznzU64(&amp;x93, x74, uint64(0x0), x30)
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x70, x90, uint64(0x0))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x71, x91, uint64(fiatFqUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x72, x92, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x73, x93, uint64(fiatFqUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Sub64(x94, 0x5812631a5cf5d3ed, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Sub64(x96, 0x14def9dea2f79cd6, uint64(fiatFqUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Sub64(x98, uint64(0x0), uint64(fiatFqUint1(x105)))
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Sub64(x100, 0x1000000000000000, uint64(fiatFqUint1(x107)))
        var x111 uint64
        _, x111 = bits.Sub64(uint64(fiatFqUint1(x101)), uint64(0x0), uint64(fiatFqUint1(x109)))
        var x112 uint64
        x112, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x114 := ((x80 &gt;&gt; 1) | ((x82 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x115 := ((x82 &gt;&gt; 1) | ((x84 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x116 := ((x84 &gt;&gt; 1) | ((x86 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x117 := ((x86 &gt;&gt; 1) | ((x88 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x118 := ((x88 &amp; 0x8000000000000000) | (x88 &gt;&gt; 1))
        var x119 uint64
        fiatFqCmovznzU64(&amp;x119, fiatFqUint1(x48), x39, x31)
        var x120 uint64
        fiatFqCmovznzU64(&amp;x120, fiatFqUint1(x48), x41, x33)
        var x121 uint64
        fiatFqCmovznzU64(&amp;x121, fiatFqUint1(x48), x43, x35)
        var x122 uint64
        fiatFqCmovznzU64(&amp;x122, fiatFqUint1(x48), x45, x37)
        var x123 uint64
        fiatFqCmovznzU64(&amp;x123, fiatFqUint1(x111), x102, x94)
        var x124 uint64
        fiatFqCmovznzU64(&amp;x124, fiatFqUint1(x111), x104, x96)
        var x125 uint64
        fiatFqCmovznzU64(&amp;x125, fiatFqUint1(x111), x106, x98)
        var x126 uint64
        fiatFqCmovznzU64(&amp;x126, fiatFqUint1(x111), x108, x100)
        *out1 = x112
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out3[0] = x114
        out3[1] = x115
        out3[2] = x116
        out3[3] = x117
        out3[4] = x118
        out4[0] = x119
        out4[1] = x120
        out4[2] = x121
        out4[3] = x122
        out5[0] = x123
        out5[1] = x124
        out5[2] = x125
        out5[3] = x126
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode unsaturated-solinas --fiat-only --modulus "2^255 - 19" --type Fp
//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed" --type Fq --sqrt fqSqrt
package impl

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func fqSqrt(out, x, rootOfUnity *Fq, e uint64, progenitorExp []uint8) (ok ct.Bool) <span class="cov0" title="0">{
        return fieldsImpl.TonelliShanks(out, x, rootOfUnity, e, progenitorExp)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package impl

import (
        "encoding/binary"
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        // FpE is the exponent parameter for square roots.
        FpE = 2
        // FpBits is the field modulus bit length.
        FpBits = 255
        // FpBytes is the size of an Fp element in bytes.
        FpBytes = 32
        // FpWideBytes is the size of a wide Fp element in bytes.
        FpWideBytes = 64
)

var (
        // FpModulus is the field modulus in little-endian bytes.
        FpModulus     = [...]uint8{0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f}
        FpRootOfUnity Fp
        // FpProgenitorExp is the exponent for the progenitor element.
        FpProgenitorExp = [...]uint8{0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f}
)

//nolint:gochecknoinits // parameters initialization
func init() <span class="cov8" title="1">{
        FpRootOfUnity.MustSetHex("2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0")
}</span>

var _ fieldsImpl.PrimeFieldElement[*Fp] = (*Fp)(nil)

// Fp represents a prime field element.
type Fp struct {
        v fiatFpTightFieldElement
}

// Set sets the receiver to v.
func (f *Fp) Set(v *Fp) <span class="cov8" title="1">{
        f.v = v.v
}</span>

// SetZero sets the receiver to zero.
func (f *Fp) SetZero() <span class="cov8" title="1">{
        f.v = fiatFpTightFieldElement{}
}</span>

// SetOne sets the receiver to one.
func (f *Fp) SetOne() <span class="cov8" title="1">{
        f.v = fiatFpTightFieldElement{1}
}</span>

// SetUint64 sets the receiver from v.
func (f *Fp) SetUint64(u uint64) <span class="cov8" title="1">{
        f.v = fiatFpTightFieldElement{u &amp; ((1 &lt;&lt; 51) - 1), u &gt;&gt; 51}
}</span>

// Select conditionally assigns z or nz into the receiver.
func (f *Fp) Select(choice ct.Choice, z, nz *Fp) <span class="cov8" title="1">{
        fiatFpSelectznz((*[5]uint64)(&amp;f.v), fiatFpUint1(choice), (*[5]uint64)(&amp;z.v), (*[5]uint64)(&amp;nz.v))
}</span>

// Add sets the receiver to lhs + rhs.
func (f *Fp) Add(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpCarryAdd(&amp;f.v, &amp;lhs.v, &amp;rhs.v)
}</span>

// Double sets the receiver to 2*x.
func (f *Fp) Double(x *Fp) <span class="cov0" title="0">{
        fiatFpCarryAdd(&amp;f.v, &amp;x.v, &amp;x.v)
}</span>

// Sub sets the receiver to lhs - rhs.
func (f *Fp) Sub(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpCarrySub(&amp;f.v, &amp;lhs.v, &amp;rhs.v)
}</span>

// Neg sets the receiver to -v.
func (f *Fp) Neg(v *Fp) <span class="cov8" title="1">{
        fiatFpCarryOpp(&amp;f.v, &amp;v.v)
}</span>

// Mul sets the receiver to lhs * rhs.
func (f *Fp) Mul(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpCarryMul(&amp;f.v, (*fiatFpLooseFieldElement)(&amp;lhs.v), (*fiatFpLooseFieldElement)(&amp;rhs.v))
}</span>

// Square sets the receiver to v^2.
func (f *Fp) Square(v *Fp) <span class="cov8" title="1">{
        fiatFpCarrySquare(&amp;f.v, (*fiatFpLooseFieldElement)(&amp;v.v))
}</span>

// Inv sets the receiver to the inverse of a, if it exists.
func (f *Fp) Inv(a *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var _10, _11, _1100, _1111, _11110000, _11111111, x10, x20, x30, x60, x120, x240, x250, out Fp

        // _10       = 2*1
        _10.Square(a)
        // _11       = 1 + _10
        _11.Mul(a, &amp;_10)
        // _1100     = _11 &lt;&lt; 2
        _1100.Square(&amp;_11)
        _1100.Square(&amp;_1100)
        // _1111     = _11 + _1100
        _1111.Mul(&amp;_11, &amp;_1100)
        // _11110000 = _1111 &lt;&lt; 4
        _11110000.Square(&amp;_1111)
        _11110000.Square(&amp;_11110000)
        _11110000.Square(&amp;_11110000)
        _11110000.Square(&amp;_11110000)
        // _11111111 = _1111 + _11110000
        _11111111.Mul(&amp;_1111, &amp;_11110000)
        // x10       = _11111111 &lt;&lt; 2 + _11
        x10.Square(&amp;_11111111)
        x10.Square(&amp;x10)
        x10.Mul(&amp;x10, &amp;_11)
        // x20       = x10 &lt;&lt; 10 + x10
        x20.Set(&amp;x10)
        for range 10 </span><span class="cov8" title="1">{
                x20.Square(&amp;x20)
        }</span>
        <span class="cov8" title="1">x20.Mul(&amp;x20, &amp;x10)
        // x30       = x20 &lt;&lt; 10 + x10
        x30.Set(&amp;x20)
        for range 10 </span><span class="cov8" title="1">{
                x30.Square(&amp;x30)
        }</span>
        <span class="cov8" title="1">x30.Mul(&amp;x30, &amp;x10)
        // x60       = x30 &lt;&lt; 30 + x30
        x60.Set(&amp;x30)
        for range 30 </span><span class="cov8" title="1">{
                x60.Square(&amp;x60)
        }</span>
        <span class="cov8" title="1">x60.Mul(&amp;x60, &amp;x30)
        // x120      = x60 &lt;&lt; 60 + x60
        x120.Set(&amp;x60)
        for range 60 </span><span class="cov8" title="1">{
                x120.Square(&amp;x120)
        }</span>
        <span class="cov8" title="1">x120.Mul(&amp;x120, &amp;x60)
        // x240      = x120 &lt;&lt; 120 + x120
        x240.Set(&amp;x120)
        for range 120 </span><span class="cov8" title="1">{
                x240.Square(&amp;x240)
        }</span>
        <span class="cov8" title="1">x240.Mul(&amp;x240, &amp;x120)
        // x250      = x240 &lt;&lt; 10 + x10
        x250.Set(&amp;x240)
        for range 10 </span><span class="cov8" title="1">{
                x250.Square(&amp;x250)
        }</span>
        <span class="cov8" title="1">x250.Mul(&amp;x250, &amp;x10)
        // return      (x250 &lt;&lt; 2 + 1) &lt;&lt; 3 + _11
        out.Square(&amp;x250)
        out.Square(&amp;out)
        out.Mul(&amp;out, a)
        out.Square(&amp;out)
        out.Square(&amp;out)
        out.Square(&amp;out)
        out.Mul(&amp;out, &amp;_11)

        ok = a.IsNonZero()
        f.Select(ok, f, &amp;out)
        return ok</span>
}

// Div sets the receiver to lhs / rhs, if rhs is nonzero.
func (f *Fp) Div(lhs, rhs *Fp) (ok ct.Bool) <span class="cov0" title="0">{
        var rhsInv Fp
        ok = rhsInv.Inv(rhs)
        var out Fp
        out.Mul(lhs, &amp;rhsInv)

        f.Select(ok, f, &amp;out)
        return ok
}</span>

// Sqrt sets the receiver to sqrt(x) if it exists.
func (f *Fp) Sqrt(v *Fp) (ok ct.Bool) <span class="cov0" title="0">{
        return fieldsImpl.TonelliShanks(f, v, &amp;FpRootOfUnity, FpE, FpProgenitorExp[:])
}</span>

// Equal reports whether the receiver equals v.
func (f *Fp) Equal(rhs *Fp) ct.Bool <span class="cov8" title="1">{
        var diff Fp
        diff.Sub(f, rhs)
        return diff.IsZero()
}</span>

// IsNonZero reports whether the receiver is nonzero.
func (f *Fp) IsNonZero() ct.Bool <span class="cov8" title="1">{
        var data [FpBytes]byte
        fiatFpToBytes(&amp;data, &amp;f.v)
        return anyNonZero(&amp;data)
}</span>

// IsZero reports whether the receiver is zero.
func (f *Fp) IsZero() ct.Bool <span class="cov8" title="1">{
        return f.IsNonZero() ^ 1
}</span>

// IsOne reports whether the receiver is one.
func (f *Fp) IsOne() ct.Bool <span class="cov0" title="0">{
        var one Fp
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

// SetUniformBytes sets the receiver from uniform bytes.
func (f *Fp) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return f.SetBytesWide(componentsData[0])</span>
}

// SetRandom sets the receiver from a random source.
func (f *Fp) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var data [FpWideBytes]byte
        _, err := io.ReadFull(prng, data[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return f.SetBytesWide(data[:])</span>
}

// ComponentsBytes returns component byte slices.
func (f *Fp) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

// Degree returns the extension degree.
func (*Fp) Degree() uint64 <span class="cov8" title="1">{
        return 1
}</span>

// SetLimbs sets the receiver from limbs.
func (f *Fp) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != 4 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var byteData [FpBytes]byte
        binary.LittleEndian.PutUint64(byteData[:8], data[0])
        binary.LittleEndian.PutUint64(byteData[8:16], data[1])
        binary.LittleEndian.PutUint64(byteData[16:24], data[2])
        binary.LittleEndian.PutUint64(byteData[24:], data[3])

        return f.SetBytes(byteData[:])</span>
}

// SetBytes sets the receiver from bytes.
func (f *Fp) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != int(FpBytes) || (data[FpBytes-1]&amp;0x80 != 0) </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">fiatFpFromBytes(&amp;f.v, (*[FpBytes]uint8)(data))
        return 1</span>
}

// SetBytesWide sets the receiver from wide bytes.
func (f *Fp) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) &gt; FpWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var wideData [FpWideBytes]byte
        copy(wideData[:], data[:])
        p255 := ct.Choice(wideData[FpBytes-1] &gt;&gt; 7)
        wideData[FpBytes-1] &amp;= 0x7f
        p511 := ct.Choice(wideData[FpWideBytes-1] &gt;&gt; 7)
        wideData[FpWideBytes-1] &amp;= 0x7f

        var zero, lo, hi, twoTo256, pLo, pHi Fp
        zero.SetZero()
        twoTo256.SetUint64(19 * 2)
        okLo := lo.SetBytes(wideData[:FpBytes])
        okHi := hi.SetBytes(wideData[FpBytes:])
        hi.Mul(&amp;hi, &amp;twoTo256)
        ok = okLo &amp; okHi
        pLo.SetUint64(19)
        pLo.Select(p255, &amp;zero, &amp;pLo)
        lo.Add(&amp;lo, &amp;pLo)
        pHi.SetUint64(19 * 19 * 2)
        pHi.Select(p511, &amp;zero, &amp;pHi)
        hi.Add(&amp;hi, &amp;pHi)

        var out Fp
        out.Add(&amp;lo, &amp;hi)
        f.Select(ok, f, &amp;out)
        return ok</span>
}

// Bytes returns the canonical byte encoding.
func (f *Fp) Bytes() []byte <span class="cov8" title="1">{
        var data [FpBytes]byte
        fiatFpToBytes(&amp;data, &amp;f.v)
        return data[:]
}</span>

// Limbs returns the little-endian limb representation.
func (f *Fp) Limbs() []uint64 <span class="cov0" title="0">{
        var limbs [4]uint64
        data := f.Bytes()
        limbs[0] = binary.LittleEndian.Uint64(data[0:8])
        limbs[1] = binary.LittleEndian.Uint64(data[8:16])
        limbs[2] = binary.LittleEndian.Uint64(data[16:24])
        limbs[3] = binary.LittleEndian.Uint64(data[24:32])
        return limbs[:]
}</span>

// MustSetHex sets the receiver from a hex string, panicking on failure.
func (f *Fp) MustSetHex(data string) <span class="cov8" title="1">{
        dataBytes, err := hex.DecodeString(data)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(dataBytes)

        ok := f.SetBytes(dataBytes)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("cannot set bytes")</span>
        }
}

// String returns the string form of the receiver.
func (f *Fp) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

// GoString returns the Go-syntax representation of the receiver.
func (f *Fp) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>

func anyNonZero(data *[FpBytes]byte) (ok ct.Bool) <span class="cov8" title="1">{
        v := uint64(
                data[0] | data[1] | data[2] | data[3] | data[4] | data[5] | data[6] | data[7] |
                        data[8] | data[9] | data[10] | data[11] | data[12] | data[13] | data[14] | data[15] |
                        data[16] | data[17] | data[18] | data[19] | data[20] | data[21] | data[22] | data[23] |
                        data[24] | data[25] | data[26] | data[27] | data[28] | data[29] | data[30] | data[31])

        return ct.Bool((v | -v) &gt;&gt; 63)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FqLimbs     = 4
        FqSatLimbs  = FqLimbs + 1
        FqBits      = 253
        FqBytes     = 8 * (((FqBits - 1) / 64) + 1)
        FqWideBytes = 2 * FqBytes
        FqDivSteps  = ((49 * FqBits) + 57) / 17
        FqE         = 2
)

var (
        FqProgenitorExp = [...]byte{0x7d, 0xba, 0x9e, 0x4b, 0x63, 0x4c, 0x02, 0xcb, 0x9a, 0xf3, 0x5e, 0xd4, 0x3b, 0xdf, 0x9b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02}
        FqModulus       = [...]byte{0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10}
        FqRootOfUnity   Fq
)

func init() <span class="cov8" title="1">{
        FqRootOfUnity.MustSetHex("094a7310e07981e77d3d6d60abc1c27a0ef0565342ce83febe8775dfebbe07d4")
}</span>

type Fq struct {
        fiatFqMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fq) Set(v *Fq) <span class="cov0" title="0">{
        *f = *v
}</span>

func (f *Fq) SetZero() <span class="cov0" title="0">{
        *f = Fq{}
}</span>

func (f *Fq) SetOne() <span class="cov0" title="0">{
        fiatFqSetOne(&amp;f.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FqLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fq) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fq) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FqBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromBytes((*[FqLimbs]uint64)(&amp;nonMonty), (*[FqBytes]uint8)(data))
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fq) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(data) &gt; FqWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var wideData [FqWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FqLimbs]uint64
        fiatFqFromBytes(&amp;d0, (*[FqBytes]uint8)(wideData[:FqBytes]))
        fiatFqFromBytes(&amp;d1, (*[FqBytes]uint8)(wideData[FqBytes:]))

        // d0*r2 + d1*r3
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fq) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fq) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FqBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fq) Select(choice ct.Choice, z, nz *Fq) <span class="cov0" title="0">{
        fiatFqSelectznz((*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement),fiatFqUint1(choice), (*[FqLimbs]uint64)(&amp;z.fiatFqMontgomeryDomainFieldElement), (*[FqLimbs]uint64)(&amp;nz.fiatFqMontgomeryDomainFieldElement))
}</span>

func (f *Fq) Add(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Double(x *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Sub(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqSub(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Neg(v *Fq) <span class="cov0" title="0">{
        fiatFqOpp(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Mul(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Square(v *Fq) <span class="cov0" title="0">{
        fiatFqSquare(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Inv(a *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        var precomp, h, v, r, out4, out5 [FqLimbs]uint64
        var ff, g, out2, out3 [FqSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFqDivstepPrecomp(&amp;precomp)
        fiatFqFromMontgomery((*fiatFqNonMontgomeryDomainFieldElement)(g[:FqLimbs]), &amp;a.fiatFqMontgomeryDomainFieldElement)
        fiatFqMsat(&amp;ff)
        fiatFqSetOne((*fiatFqMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FqDivSteps-(FqDivSteps%2); i += 2 </span><span class="cov0" title="0">{
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFqDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov0" title="0">if (FqDivSteps % 2) != 0 </span><span class="cov0" title="0">{ // compile time if - always true
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov0" title="0">fiatFqOpp((*fiatFqMontgomeryDomainFieldElement)(&amp;h), (*fiatFqMontgomeryDomainFieldElement)(&amp;v))
        fiatFqSelectznz(&amp;v, fiatFqUint1(ff[FqLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;v), (*fiatFqMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFqNonzero(&amp;inverted, (*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fq) Div(lhs, rhs *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        var rhsInv Fq
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fq) Sqrt(x *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(fqSqrt(f, x, &amp;FqRootOfUnity, FqE, FqProgenitorExp[:]))
}</span>

func (f *Fq) IsNonZero() ct.Bool <span class="cov0" title="0">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFqNonzero(&amp;nonZero, (*[FqLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fq) IsZero() ct.Bool <span class="cov0" title="0">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fq) IsOne() ct.Bool <span class="cov0" title="0">{
        var one Fq
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fq) Equal(v *Fq) ct.Bool <span class="cov0" title="0">{
        var diff Fq
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fq) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fq) Bytes() []byte <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        var data [FqBytes]byte
        fiatFqToBytes(&amp;data, (*[FqLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fq) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fq) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fq) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fq) Degree() uint64 <span class="cov0" title="0">{
        return 1
}</span>

func (f *Fq) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fq) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package impl

import (
        "crypto/sha512"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/elligator2"
)

var (
        _ points.TwistedEdwardsCurveParams[*Fp] = curveParams{}
        _ h2c.HasherParams                      = CurveHasherParams{}
        _ h2c.PointMapper[*Fp]                  = curveMapper{}

        curveA               Fp
        curveD               Fp
        curveD2              Fp
        curveGx              Fp
        curveGy              Fp
        curveGxy             Fp
        curveMessageExpander = h2c.NewXMDMessageExpander(sha512.New)
)

//nolint:gochecknoinits // parameters initialization
func init() <span class="cov8" title="1">{
        curveA.MustSetHex("7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec")
        curveD.MustSetHex("52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3")
        curveD2.MustSetHex("2406d9dc56dffce7198e80f2eef3d13000e0149a8283b156ebd69b9426b2f159")
        curveGx.MustSetHex("216936D3CD6E53FEC0A4E231FDD6DC5C692CC7609525A7B2C9562D608F25D51A")
        curveGy.MustSetHex("6666666666666666666666666666666666666666666666666666666666666658")
        curveGxy.Mul(&amp;curveGx, &amp;curveGy)
}</span>

type curveParams struct{}

// CurveHasherParams defines hash-to-curve parameters.
type CurveHasherParams struct{}

type curveMapper = elligator2.Edwards25519PointMapper[*Fp, Fp]

// SetGenerator sets generator coordinates.
func (curveParams) SetGenerator(xOut, yOut, tOut, zOut *Fp) <span class="cov0" title="0">{
        xOut.Set(&amp;curveGx)
        yOut.Set(&amp;curveGy)
        tOut.Set(&amp;curveGxy)
        zOut.SetOne()
}</span>

// ClearCofactor clears the cofactor of the input point.
func (curveParams) ClearCofactor(xOut, yOut, tOut, zOut, xIn, yIn, tIn, zIn *Fp) <span class="cov8" title="1">{
        var out Point
        out.X.Set(xIn)
        out.Y.Set(yIn)
        out.T.Set(tIn)
        out.Z.Set(zIn)
        out.Double(&amp;out)
        out.Double(&amp;out)
        out.Double(&amp;out)

        xOut.Set(&amp;out.X)
        yOut.Set(&amp;out.Y)
        tOut.Set(&amp;out.T)
        zOut.Set(&amp;out.Z)
}</span>

// SetA sets the curve A parameter.
func (curveParams) SetA(out *Fp) <span class="cov0" title="0">{
        out.Set(&amp;curveA)
}</span>

// MulByA multiplies by the curve A parameter.
func (curveParams) MulByA(out, in *Fp) <span class="cov8" title="1">{
        out.Neg(in)
}</span>

// MulByD multiplies by the curve D parameter.
func (curveParams) MulByD(out, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;curveD)
}</span>

// MulBy2D multiplies by 2*D.
func (curveParams) MulBy2D(out, in *Fp) <span class="cov0" title="0">{
        out.Mul(in, &amp;curveD2)
}</span>

// L returns the hash-to-field length in bytes.
func (CurveHasherParams) L() uint64 <span class="cov8" title="1">{
        return 48
}</span>

// MessageExpander returns the RFC 9380 message expander.
func (CurveHasherParams) MessageExpander() h2c.MessageExpander <span class="cov8" title="1">{
        return curveMessageExpander
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package edwards25519

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        edwards25519Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // PrimeCurveName is the prime subgroup curve name.
        PrimeCurveName = CurveName + "(PrimeSubGroup)"
)

var (
        _ curves.Curve[*PrimeSubGroupPoint, *BaseFieldElement, *Scalar] = (*PrimeSubGroup)(nil)
        _ curves.Point[*PrimeSubGroupPoint, *BaseFieldElement, *Scalar] = (*PrimeSubGroupPoint)(nil)

        primeSubGroupInstance *PrimeSubGroup
        primeSubGroupInitOnce sync.Once
)

// NewPrimeSubGroup returns the prime subgroup instance.
func NewPrimeSubGroup() *PrimeSubGroup <span class="cov0" title="0">{
        primeSubGroupInitOnce.Do(func() </span><span class="cov0" title="0">{
                //nolint:exhaustruct // no need for a trait
                primeSubGroupInstance = &amp;PrimeSubGroup{}
        }</span>)

        <span class="cov0" title="0">return primeSubGroupInstance</span>
}

// PrimeSubGroup represents the prime-order subgroup.
type PrimeSubGroup struct {
        traits.PrimeCurveTrait[*edwards25519Impl.Fp, *edwards25519Impl.Point, *PrimeSubGroupPoint, PrimeSubGroupPoint]
}

// Name returns the name of the structure.
func (*PrimeSubGroup) Name() string <span class="cov0" title="0">{
        return PrimeCurveName
}</span>

// ElementSize returns the element size in bytes.
func (*PrimeSubGroup) ElementSize() int <span class="cov0" title="0">{
        return compressedPointBytes
}</span>

// Cofactor returns the curve cofactor.
func (*PrimeSubGroup) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(8)
}</span>

// Order returns the group or field order.
func (*PrimeSubGroup) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewScalarField().Order()
}</span>

// FromCompressed decodes a compressed point.
func (*PrimeSubGroup) FromCompressed(inBytes []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().FromCompressed(inBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// FromBytes decodes an element from bytes.
func (*PrimeSubGroup) FromBytes(inBytes []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().FromBytes(inBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// FromUncompressed decodes an uncompressed point.
func (*PrimeSubGroup) FromUncompressed(inBytes []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().FromUncompressed(inBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// FromAffine builds a point from affine coordinates.
func (*PrimeSubGroup) FromAffine(x, y *BaseFieldElement) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().FromAffine(x, y)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot set coordinates")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// Hash maps input bytes to an element or point.
func (*PrimeSubGroup) Hash(bytes []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().Hash(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash to curve")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// HashWithDst maps input bytes to a point with a custom DST.
func (*PrimeSubGroup) HashWithDst(dst string, bytes []byte) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        p, err := NewCurve().HashWithDst(dst, bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash to curve")
        }</span>
        <span class="cov0" title="0">return p.AsPrimeSubGroupPoint()</span>
}

// ScalarStructure returns the scalar structure.
func (*PrimeSubGroup) ScalarStructure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarRing returns the scalar ring.
func (*PrimeSubGroup) ScalarRing() algebra.ZModLike[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarField returns the scalar field.
func (*PrimeSubGroup) ScalarField() algebra.PrimeField[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseField returns the base field.
func (*PrimeSubGroup) BaseField() algebra.FiniteField[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// BaseStructure returns the base field structure.
func (*PrimeSubGroup) BaseStructure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// ScalarBaseOp adds a scalar multiple of the generator.
func (c *PrimeSubGroup) ScalarBaseOp(sc *Scalar) *PrimeSubGroupPoint <span class="cov0" title="0">{
        if sc.IsZero() </span><span class="cov0" title="0">{
                return c.OpIdentity()
        }</span>
        <span class="cov0" title="0">return c.ScalarBaseMul(sc)</span>
}

// ScalarBaseMul multiplies the generator by a scalar.
func (c *PrimeSubGroup) ScalarBaseMul(sc *Scalar) *PrimeSubGroupPoint <span class="cov0" title="0">{
        return c.Generator().ScalarMul(sc)
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *PrimeSubGroup) MultiScalarOp(scalars []*Scalar, points []*PrimeSubGroupPoint) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*PrimeSubGroup) MultiScalarMul(scalars []*Scalar, points []*PrimeSubGroupPoint) (*PrimeSubGroupPoint, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result PrimeSubGroupPoint
        scs := make([][]byte, len(scalars))
        pts := make([]*edwards25519Impl.Point, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// PrimeSubGroupPoint represents a point in the prime-order subgroup.
type PrimeSubGroupPoint struct {
        traits.PrimePointTrait[*edwards25519Impl.Fp, *edwards25519Impl.Point, edwards25519Impl.Point, *PrimeSubGroupPoint, PrimeSubGroupPoint]
}

// HashCode returns a hash code for the receiver.
func (p *PrimeSubGroupPoint) HashCode() base.HashCode <span class="cov0" title="0">{
        return p.AsPoint().HashCode()
}</span>

// Structure returns the algebraic structure for the receiver.
func (*PrimeSubGroupPoint) Structure() algebra.Structure[*PrimeSubGroupPoint] <span class="cov0" title="0">{
        return NewPrimeSubGroup()
}</span>

// ToCompressed encodes the point in compressed form.
func (p *PrimeSubGroupPoint) ToCompressed() []byte <span class="cov0" title="0">{
        return p.AsPoint().ToCompressed()
}</span>

// ToUncompressed encodes the point in uncompressed form.
func (p *PrimeSubGroupPoint) ToUncompressed() []byte <span class="cov0" title="0">{
        return p.AsPoint().ToUncompressed()
}</span>

// AffineX returns the affine x-coordinate.
func (p *PrimeSubGroupPoint) AffineX() (*BaseFieldElement, error) <span class="cov0" title="0">{
        return p.AsPoint().AffineX()
}</span>

// AffineY returns the affine y-coordinate.
func (p *PrimeSubGroupPoint) AffineY() (*BaseFieldElement, error) <span class="cov0" title="0">{
        return p.AsPoint().AffineY()
}</span>

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *PrimeSubGroupPoint) ScalarOp(sc *Scalar) *PrimeSubGroupPoint <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *PrimeSubGroupPoint) ScalarMul(actor *Scalar) *PrimeSubGroupPoint <span class="cov0" title="0">{
        var result PrimeSubGroupPoint
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (*PrimeSubGroupPoint) IsTorsionFree() bool <span class="cov0" title="0">{
        return true
}</span>

// Bytes returns the canonical byte encoding.
func (p *PrimeSubGroupPoint) Bytes() []byte <span class="cov0" title="0">{
        return p.AsPoint().Bytes()
}</span>

// String returns the string form of the receiver.
func (p *PrimeSubGroupPoint) String() string <span class="cov0" title="0">{
        return p.AsPoint().String()
}</span>

// AsPoint converts the prime subgroup point to a curve point.
func (p *PrimeSubGroupPoint) AsPoint() *Point <span class="cov0" title="0">{
        var pp Point
        pp.V.Set(&amp;p.V)
        return &amp;pp
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package edwards25519

import (
        "encoding"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        edwards25519Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519/impl"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

const (
        // ScalarFieldName is the scalar field name.
        ScalarFieldName = "curve25519Fq"
)

var (
        _ algebra.PrimeField[*Scalar]        = (*ScalarField)(nil)
        _ algebra.PrimeFieldElement[*Scalar] = (*Scalar)(nil)
        _ encoding.BinaryMarshaler           = (*Scalar)(nil)
        _ encoding.BinaryUnmarshaler         = (*Scalar)(nil)

        scalarFieldInitOnce sync.Once
        scalarFieldInstance *ScalarField
        scalarFieldOrder    *numct.Modulus
)

func scalarFieldInit() <span class="cov8" title="1">{
        scalarFieldOrder, _ = numct.NewModulusFromBytesBE(sliceutils.Reversed(edwards25519Impl.FqModulus[:]))
        //nolint:exhaustruct // no need for a trait
        scalarFieldInstance = &amp;ScalarField{}
}</span>

// ScalarField represents the scalar field.
type ScalarField struct {
        traits.PrimeFieldTrait[*edwards25519Impl.Fq, *Scalar, Scalar]
}

// NewScalarField returns the scalar field instance.
func NewScalarField() *ScalarField <span class="cov8" title="1">{
        scalarFieldInitOnce.Do(scalarFieldInit)
        return scalarFieldInstance
}</span>

// Name returns the name of the structure.
func (*ScalarField) Name() string <span class="cov0" title="0">{
        return ScalarFieldName
}</span>

// Order returns the group or field order.
func (*ScalarField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder.Nat())
}</span>

// Characteristic returns the field characteristic.
func (*ScalarField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder.Nat())
}</span>

// Hash maps input bytes to an element or point.
func (*ScalarField) Hash(bytes []byte) (*Scalar, error) <span class="cov0" title="0">{
        var e [1]edwards25519Impl.Fq
        h2c.HashToField(e[:], edwards25519Impl.CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveScalarSuite, bytes)

        var s Scalar
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *ScalarField) FromBytesBEReduce(input []byte) (*Scalar, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        scalarFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ElementSize returns the element size in bytes.
func (*ScalarField) ElementSize() int <span class="cov0" title="0">{
        return edwards25519Impl.FqBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*ScalarField) WideElementSize() int <span class="cov0" title="0">{
        return edwards25519Impl.FqWideBytes
}</span>

// BitLen returns the field modulus bit length.
func (*ScalarField) BitLen() int <span class="cov0" title="0">{
        return edwards25519Impl.FqBits
}</span>

// FromClampedBytes decodes a clamped scalar from bytes.
func (*ScalarField) FromClampedBytes(data []byte) (*Scalar, error) <span class="cov0" title="0">{
        if len(data) != edwards25519Impl.FqBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov0" title="0">var clone [32]byte
        copy(clone[:], data)
        clone[0] &amp;= 248
        clone[31] &amp;= 127
        clone[31] |= 64

        var s Scalar
        if ok := s.V.SetBytesWide(clone[:]); ok == ct.False </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("failed to set scalar from bytes")
        }</span>
        <span class="cov0" title="0">return &amp;s, nil</span>
}

// Scalar represents a scalar field element.
type Scalar struct {
        traits.PrimeFieldElementTrait[*edwards25519Impl.Fq, edwards25519Impl.Fq, *Scalar, Scalar]
}

// NewScalar returns a new scalar.
func NewScalar(v uint64) *Scalar <span class="cov0" title="0">{
        var s Scalar
        s.V.SetUint64(v)
        return &amp;s
}</span>

// Structure returns the algebraic structure for the receiver.
func (*Scalar) Structure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *Scalar) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *Scalar) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("failed to unmarshal field element")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package points

import (
        "fmt"
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
)

// TwistedEdwardsCurveParams exposes curve constants and helpers for Edwards arithmetic.
type TwistedEdwardsCurveParams[FP fields.FiniteFieldElement[FP]] interface {
        // SetGenerator sets generator coordinates.
        SetGenerator(xOut, yOut, tOut, zOut FP)

        // ClearCofactor clears cofactor (must comply with RFC9380).
        ClearCofactor(xOut, yOut, tOut, zOut, xIn, yIn, tIn, zIn FP)

        // SetA sets the curve A parameter.
        SetA(out FP)
        // MulByA multiplies by the curve A parameter.
        MulByA(out, in FP)
        // MulByD multiplies by the curve D parameter.
        MulByD(out, in FP)
        // MulBy2D multiplies by 2*D.
        MulBy2D(out, in FP)
}

// TwistedEdwardsPointImpl implements extended coordinates for Twisted Edwards curves.
type TwistedEdwardsPointImpl[FP fields.FiniteFieldElementPtr[FP, F], C TwistedEdwardsCurveParams[FP], H h2c.HasherParams, M h2c.PointMapper[FP], F any] struct {
        X F
        Y F
        T F
        Z F
}

// Add sets p = lhs + rhs.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Add(lhs, rhs *TwistedEdwardsPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        var params C
        var a, b, c, d, e, f, g, h, t0, t1, t2 F

        //  A = X1 * X2
        FP(&amp;a).Mul(&amp;lhs.X, &amp;rhs.X)
        //  B = Y1 * Y2
        FP(&amp;b).Mul(&amp;lhs.Y, &amp;rhs.Y)
        //  C = T1 * d * T2
        FP(&amp;t0).Mul(&amp;lhs.T, &amp;rhs.T)
        params.MulByD(&amp;c, &amp;t0)
        //  D = Z1 * Z2
        FP(&amp;d).Mul(&amp;lhs.Z, &amp;rhs.Z)
        //E = (X1+Y1)*(X2+Y2) - A - B
        FP(&amp;t0).Add(&amp;lhs.X, &amp;lhs.Y)
        FP(&amp;t1).Add(&amp;rhs.X, &amp;rhs.Y)
        FP(&amp;t2).Mul(&amp;t0, &amp;t1)
        FP(&amp;t0).Add(&amp;a, &amp;b)
        FP(&amp;e).Sub(&amp;t2, &amp;t0)
        //  F = D - C
        FP(&amp;f).Sub(&amp;d, &amp;c)
        //  G = D + C
        FP(&amp;g).Add(&amp;d, &amp;c)
        //  H = B - a*A
        params.MulByA(&amp;t0, &amp;a)
        FP(&amp;h).Sub(&amp;b, &amp;t0)
        // X3 = E * F
        FP(&amp;p.X).Mul(&amp;e, &amp;f)
        // Y3 = G * H
        FP(&amp;p.Y).Mul(&amp;g, &amp;h)
        // T3 = E * H
        FP(&amp;p.T).Mul(&amp;e, &amp;h)
        // Z3 = F * G
        FP(&amp;p.Z).Mul(&amp;f, &amp;g)
}</span>

// Double sets p = 2*v.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Double(v *TwistedEdwardsPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        var params C
        var a, b, c, d, e, f, g, h, t0, t1 F

        //  A = X1^2
        FP(&amp;a).Square(&amp;v.X)
        //  B = Y1^2
        FP(&amp;b).Square(&amp;v.Y)
        //  C = 2*Z1^2
        FP(&amp;t0).Square(&amp;v.Z)
        FP(&amp;c).Add(&amp;t0, &amp;t0)
        //  D = a*A
        params.MulByA(&amp;d, &amp;a)
        //  E = (X1+Y1)^2-A-B
        FP(&amp;t0).Add(&amp;v.X, &amp;v.Y)
        FP(&amp;t1).Square(&amp;t0)
        FP(&amp;t0).Add(&amp;a, &amp;b)
        FP(&amp;e).Sub(&amp;t1, &amp;t0)
        //  G = D+B
        FP(&amp;g).Add(&amp;d, &amp;b)
        //  F = G-C
        FP(&amp;f).Sub(&amp;g, &amp;c)
        //  H = D-B
        FP(&amp;h).Sub(&amp;d, &amp;b)
        // X3 = E*F
        FP(&amp;p.X).Mul(&amp;e, &amp;f)
        // Y3 = G*H
        FP(&amp;p.Y).Mul(&amp;g, &amp;h)
        // T3 = E*H
        FP(&amp;p.T).Mul(&amp;e, &amp;h)
        // Z3 = F*G
        FP(&amp;p.Z).Mul(&amp;f, &amp;g)
}</span>

// Encode hashes a message to a curve point with one hash-to-field element.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Encode(dstPrefix string, message []byte) <span class="cov0" title="0">{
        var curveParams C
        var hasherParams H
        var mapper M

        var u [1]F
        h2c.HashToField[FP](u[:], hasherParams, dstPrefix, message)

        var xn, xd, yn, yd F
        mapper.Map(&amp;xn, &amp;xd, &amp;yn, &amp;yd, &amp;u[0])

        var q TwistedEdwardsPointImpl[FP, C, H, M, F]
        q.setFractions(&amp;xn, &amp;xd, &amp;yn, &amp;yd)

        curveParams.ClearCofactor(&amp;p.X, &amp;p.Y, &amp;p.T, &amp;p.Z, &amp;q.X, &amp;q.Y, &amp;q.T, &amp;q.Z)
}</span>

// Hash hashes a message to a curve point with two hash-to-field elements.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Hash(dst string, message []byte) <span class="cov0" title="0">{
        var curveParams C
        var hasherParams H
        var mapper M

        var u [2]F
        h2c.HashToField[FP](u[:], hasherParams, dst, message)

        var xn0, xd0, yn0, yd0, xn1, xd1, yn1, yd1 F
        mapper.Map(&amp;xn0, &amp;xd0, &amp;yn0, &amp;yd0, &amp;u[0])
        mapper.Map(&amp;xn1, &amp;xd1, &amp;yn1, &amp;yd1, &amp;u[1])

        var q0, q1 TwistedEdwardsPointImpl[FP, C, H, M, F]
        q0.setFractions(&amp;xn0, &amp;xd0, &amp;yn0, &amp;yd0)
        q1.setFractions(&amp;xn1, &amp;xd1, &amp;yn1, &amp;yd1)

        var q TwistedEdwardsPointImpl[FP, C, H, M, F]
        q.Add(&amp;q0, &amp;q1)

        curveParams.ClearCofactor(&amp;p.X, &amp;p.Y, &amp;p.T, &amp;p.Z, &amp;q.X, &amp;q.Y, &amp;q.T, &amp;q.Z)
}</span>

// Set sets p to v.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Set(v *TwistedEdwardsPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        FP(&amp;p.X).Set(&amp;v.X)
        FP(&amp;p.Y).Set(&amp;v.Y)
        FP(&amp;p.Z).Set(&amp;v.Z)
        FP(&amp;p.T).Set(&amp;v.T)
}</span>

// SetRandom maps random field elements to a curve point and clears the cofactor.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var curveParams C
        var mapper M

        var u [2]F
        ok0 := FP(&amp;u[0]).SetRandom(prng)
        ok1 := FP(&amp;u[1]).SetRandom(prng)
        ok = ok0 &amp; ok1

        var xn0, xd0, yn0, yd0, xn1, xd1, yn1, yd1 F
        mapper.Map(&amp;xn0, &amp;xd0, &amp;yn0, &amp;yd0, &amp;u[0])
        mapper.Map(&amp;xn1, &amp;xd1, &amp;yn1, &amp;yd1, &amp;u[1])

        var q0, q1 TwistedEdwardsPointImpl[FP, C, H, M, F]
        q0.setFractions(&amp;xn0, &amp;xd0, &amp;yn0, &amp;yd0)
        q1.setFractions(&amp;xn1, &amp;xd1, &amp;yn1, &amp;yd1)

        var q TwistedEdwardsPointImpl[FP, C, H, M, F]
        q.Add(&amp;q0, &amp;q1)
        curveParams.ClearCofactor(&amp;q.X, &amp;q.Y, &amp;q.T, &amp;q.Z, &amp;q.X, &amp;q.Y, &amp;q.T, &amp;q.Z)

        p.Select(ok, p, &amp;q)
        return ok
}</span>

// SetZero sets p to the identity point.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) SetZero() <span class="cov0" title="0">{
        FP(&amp;p.X).SetZero()
        FP(&amp;p.Y).SetOne()
        FP(&amp;p.Z).SetOne()
        FP(&amp;p.T).SetZero()
}</span>

// SetGenerator sets p to the curve generator.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) SetGenerator() <span class="cov0" title="0">{
        var params C
        params.SetGenerator(&amp;p.X, &amp;p.Y, &amp;p.T, &amp;p.Z)
        FP(&amp;p.Z).SetOne()
}</span>

// SetAffine sets p from affine coordinates if they satisfy the curve equation.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) SetAffine(x, y FP) (ok ct.Bool) <span class="cov0" title="0">{
        var params C
        var out TwistedEdwardsPointImpl[FP, C, H, M, F]
        FP(&amp;out.X).Set(x)
        FP(&amp;out.Y).Set(y)
        FP(&amp;out.Z).SetOne()
        FP(&amp;out.T).Mul(x, y)

        var one, xx, yy, l, r F
        FP(&amp;one).SetOne()
        FP(&amp;xx).Square(x)
        FP(&amp;yy).Square(y)
        params.MulByA(&amp;l, &amp;xx)
        FP(&amp;l).Add(&amp;l, &amp;yy)
        FP(&amp;r).Mul(&amp;xx, &amp;yy)
        params.MulByD(&amp;r, &amp;r)
        FP(&amp;r).Add(&amp;r, &amp;one)
        ok = FP(&amp;l).Equal(&amp;r)

        p.Select(ok, p, &amp;out)
        return ok
}</span>

// SetFromAffineY sets p from an affine y-coordinate, choosing a square root for x.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) SetFromAffineY(y FP) (ok ct.Bool) <span class="cov0" title="0">{
        var params C
        var one, a, x, yy, num, den F
        var out TwistedEdwardsPointImpl[FP, C, H, M, F]

        FP(&amp;one).SetOne()
        params.SetA(&amp;a)
        FP(&amp;yy).Square(y)
        FP(&amp;num).Sub(&amp;one, &amp;yy)
        params.MulByD(&amp;den, &amp;yy)
        FP(&amp;den).Sub(&amp;a, &amp;den)
        ok1 := FP(&amp;den).Inv(&amp;den)
        FP(&amp;x).Mul(&amp;num, &amp;den)
        ok2 := FP(&amp;x).Sqrt(&amp;x)
        FP(&amp;out.X).Set(&amp;x)
        FP(&amp;out.Y).Set(y)
        FP(&amp;out.T).Mul(&amp;x, y)
        FP(&amp;out.Z).SetOne()

        ok = ok1 &amp; ok2
        p.Select(ok, p, &amp;out)
        return ok
}</span>

// Select conditionally assigns z or nz into p based on choice.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Select(choice ct.Choice, z, nz *TwistedEdwardsPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        FP(&amp;p.X).Select(choice, &amp;z.X, &amp;nz.X)
        FP(&amp;p.Y).Select(choice, &amp;z.Y, &amp;nz.Y)
        FP(&amp;p.Z).Select(choice, &amp;z.Z, &amp;nz.Z)
        FP(&amp;p.T).Select(choice, &amp;z.T, &amp;nz.T)
}</span>

// ClearCofactor clears the curve cofactor on input.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) ClearCofactor(in *TwistedEdwardsPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        var params C

        params.ClearCofactor(&amp;p.X, &amp;p.Y, &amp;p.T, &amp;p.Z, &amp;in.X, &amp;in.Y, &amp;in.T, &amp;in.Z)
}</span>

// Sub sets p = lhs - rhs.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Sub(lhs, rhs *TwistedEdwardsPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        var rhsNeg TwistedEdwardsPointImpl[FP, C, H, M, F]
        rhsNeg.Neg(rhs)
        p.Add(lhs, &amp;rhsNeg)
}</span>

// Neg sets p to the negation of v.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Neg(v *TwistedEdwardsPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        FP(&amp;p.X).Neg(&amp;v.X)
        FP(&amp;p.Y).Set(&amp;v.Y)
        FP(&amp;p.Z).Set(&amp;v.Z)
        FP(&amp;p.T).Neg(&amp;v.T)
}</span>

// IsZero reports whether p is the identity point.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) IsZero() ct.Bool <span class="cov0" title="0">{
        return FP(&amp;p.X).IsZero() &amp; (FP(&amp;p.Y).Equal(&amp;p.Z))
}</span>

// IsNonZero reports whether p is not the identity point.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) IsNonZero() ct.Bool <span class="cov0" title="0">{
        return FP(&amp;p.X).IsNonZero()
}</span>

// Equal reports whether p and v represent the same point.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Equal(v *TwistedEdwardsPointImpl[FP, C, H, M, F]) ct.Bool <span class="cov0" title="0">{
        var x1z2, x2z1, y1z2, y2z1 F
        FP(&amp;x1z2).Mul(&amp;p.X, &amp;v.Z)
        FP(&amp;x2z1).Mul(&amp;v.X, &amp;p.Z)
        FP(&amp;y1z2).Mul(&amp;p.Y, &amp;v.Z)
        FP(&amp;y2z1).Mul(&amp;v.Y, &amp;p.Z)

        return FP(&amp;x1z2).Equal(&amp;x2z1) &amp; FP(&amp;y1z2).Equal(&amp;y2z1)
}</span>

// ToAffine converts p to affine coordinates if possible.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) ToAffine(x, y FP) (ok ct.Bool) <span class="cov0" title="0">{
        var xx, yy, zInv F
        zInvPtr := FP(&amp;zInv)
        ok = zInvPtr.Inv(&amp;p.Z)

        FP(&amp;xx).Mul(&amp;p.X, zInvPtr)
        FP(&amp;yy).Mul(&amp;p.Y, zInvPtr)

        x.Select(ok, x, &amp;xx)
        y.Select(ok, y, &amp;yy)
        return ok
}</span>

// Bytes returns the concatenated byte encoding of extended coordinates.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(FP(&amp;p.X).Bytes(), FP(&amp;p.Y).Bytes(), FP(&amp;p.Z).Bytes(), FP(&amp;p.T).Bytes())
}</span>

// SetBytes decodes extended coordinates from input.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) SetBytes(input []byte) (ok ct.Bool) <span class="cov0" title="0">{
        coordinateLen := len(input) / 4
        x := input[:coordinateLen]
        y := input[coordinateLen : 2*coordinateLen]
        z := input[2*coordinateLen : 3*coordinateLen]
        t := input[3*coordinateLen:]
        var tmpX, tmpY, tmpZ, tmpT F
        okX := FP(&amp;tmpX).SetBytes(x)
        okY := FP(&amp;tmpY).SetBytes(y)
        okZ := FP(&amp;tmpZ).SetBytes(z)
        okT := FP(&amp;tmpT).SetBytes(t)
        ok = okX &amp; okY &amp; okZ &amp; okT

        FP(&amp;p.X).Select(ok, &amp;p.X, &amp;tmpX)
        FP(&amp;p.Y).Select(ok, &amp;p.Y, &amp;tmpY)
        FP(&amp;p.Z).Select(ok, &amp;p.Z, &amp;tmpZ)
        FP(&amp;p.T).Select(ok, &amp;p.T, &amp;tmpT)
        return ok
}</span>

// String formats the point in projective coordinates.
func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) String() string <span class="cov0" title="0">{
        var one, x, y, z F
        FP(&amp;one).SetOne()

        ok := p.ToAffine(&amp;x, &amp;y)
        FP(&amp;x).Select(ok, &amp;p.X, &amp;x)
        FP(&amp;y).Select(ok, &amp;p.Y, &amp;y)
        FP(&amp;z).Select(ok, &amp;p.Z, &amp;one)

        return fmt.Sprintf("(%s : %s : %s)", FP(&amp;x), FP(&amp;y), FP(&amp;z))
}</span>

func (p *TwistedEdwardsPointImpl[FP, C, H, M, F]) setFractions(xn, xd, yn, yd FP) <span class="cov0" title="0">{
        FP(&amp;p.X).Mul(xn, yd)
        FP(&amp;p.Y).Mul(yn, xd)
        FP(&amp;p.Z).Mul(xd, yd)
        FP(&amp;p.T).Mul(xn, yn)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package testutils

import (
        "encoding/json"
        "fmt"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        fieldsTu "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields/testutils"
        pointsImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
)

type PointJSON[FP fields.FiniteFieldElementPtr[FP, F], PP pointsImpl.PointPtr[FP, PP, P], F, P any] struct {
        V P
}

func (p *PointJSON[FP, PP, F, P]) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type innerType struct {
                X fieldsTu.FiniteFieldElementJSON[FP, F] `json:"x"`
                Y fieldsTu.FiniteFieldElementJSON[FP, F] `json:"y"`
        }
        var innerData innerType
        err := json.Unmarshal(data, &amp;innerData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ok := PP(&amp;p.V).SetAffine(FP(&amp;innerData.X.V), FP(&amp;innerData.Y.V))
        if ok != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid point")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package points

import (
        "fmt"
        "io"
        "slices"

        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
)

// ShortWeierstrassCurveParams exposes curve constants and helpers for Weierstrass arithmetic.
type ShortWeierstrassCurveParams[FP fieldsImpl.FiniteFieldElement[FP]] interface {
        // SetGenerator sets generator coordinates.
        SetGenerator(xOut, yOut, zOut FP)

        // ClearCofactor clears cofactor (must comply with RFC9380).
        ClearCofactor(xOut, yOut, zOut, xIn, yIn, zIn FP)

        // AddA computes out = in + A, where A is the A in the curve equation y^2 = x^3 + Ax + B
        AddA(out FP, in FP)

        // AddB computes out = in + B, where B is the B in the curve equation y^2 = x^3 + Ax + B
        AddB(out FP, in FP)

        // MulByA computes out = in * A, where A is the A in the curve equation y^2 = x^3 + Ax + B
        MulByA(out FP, in FP)

        // MulBy3B computes out = in * 3 * B, where B is the B in the curve equation y^2 = x^3 + Ax + B
        MulBy3B(out FP, in FP)
}

// ShortWeierstrassPointImpl implements Jacobian coordinates for short Weierstrass curves.
type ShortWeierstrassPointImpl[FP fieldsImpl.FiniteFieldElementPtr[FP, F], C ShortWeierstrassCurveParams[FP], H h2c.HasherParams, M h2c.PointMapper[FP], F any] struct {
        X F
        Y F
        Z F
}

// Encode hashes a message to a curve point with one hash-to-field element.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Encode(dstPrefix string, message []byte) <span class="cov0" title="0">{
        var curveParams C
        var hasherParams H
        var mapper M

        var u [1]F
        h2c.HashToField[FP](u[:], hasherParams, dstPrefix, message)

        var xn, xd, yn, yd F
        mapper.Map(&amp;xn, &amp;xd, &amp;yn, &amp;yd, &amp;u[0])

        var q ShortWeierstrassPointImpl[FP, C, H, M, F]
        q.setFractions(&amp;xn, &amp;xd, &amp;yn, &amp;yd)

        curveParams.ClearCofactor(&amp;p.X, &amp;p.Y, &amp;p.Z, &amp;q.X, &amp;q.Y, &amp;q.Z)
}</span>

// Hash hashes a message to a curve point with two hash-to-field elements.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Hash(dst string, message []byte) <span class="cov0" title="0">{
        var curveParams C
        var hasherParams H
        var mapper M

        var u [2]F
        h2c.HashToField[FP](u[:], hasherParams, dst, message)

        var xn0, xd0, yn0, yd0, xn1, xd1, yn1, yd1 F
        mapper.Map(&amp;xn0, &amp;xd0, &amp;yn0, &amp;yd0, &amp;u[0])
        mapper.Map(&amp;xn1, &amp;xd1, &amp;yn1, &amp;yd1, &amp;u[1])

        var q0, q1 ShortWeierstrassPointImpl[FP, C, H, M, F]
        q0.setFractions(&amp;xn0, &amp;xd0, &amp;yn0, &amp;yd0)
        q1.setFractions(&amp;xn1, &amp;xd1, &amp;yn1, &amp;yd1)

        var q ShortWeierstrassPointImpl[FP, C, H, M, F]
        q.Add(&amp;q0, &amp;q1)

        curveParams.ClearCofactor(&amp;p.X, &amp;p.Y, &amp;p.Z, &amp;q.X, &amp;q.Y, &amp;q.Z)
}</span>

// Set sets p to v.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Set(v *ShortWeierstrassPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        FP(&amp;p.X).Set(&amp;v.X)
        FP(&amp;p.Y).Set(&amp;v.Y)
        FP(&amp;p.Z).Set(&amp;v.Z)
}</span>

// SetZero sets p to the identity point.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) SetZero() <span class="cov0" title="0">{
        FP(&amp;p.X).SetZero()
        FP(&amp;p.Y).SetOne()
        FP(&amp;p.Z).SetZero()
}</span>

// SetGenerator sets p to the curve generator.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) SetGenerator() <span class="cov0" title="0">{
        var params C

        params.SetGenerator(&amp;p.X, &amp;p.Y, &amp;p.Z)
}</span>

// SetRandom maps random field elements to a curve point and clears the cofactor.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var curveParams C
        var mapper M

        var u [2]F
        ok0 := FP(&amp;u[0]).SetRandom(prng)
        ok1 := FP(&amp;u[1]).SetRandom(prng)
        ok = ok0 &amp; ok1

        var xn0, xd0, yn0, yd0, xn1, xd1, yn1, yd1 F
        mapper.Map(&amp;xn0, &amp;xd0, &amp;yn0, &amp;yd0, &amp;u[0])
        mapper.Map(&amp;xn1, &amp;xd1, &amp;yn1, &amp;yd1, &amp;u[1])

        var q0, q1 ShortWeierstrassPointImpl[FP, C, H, M, F]
        q0.setFractions(&amp;xn0, &amp;xd0, &amp;yn0, &amp;yd0)
        q1.setFractions(&amp;xn1, &amp;xd1, &amp;yn1, &amp;yd1)

        var q ShortWeierstrassPointImpl[FP, C, H, M, F]
        q.Add(&amp;q0, &amp;q1)
        curveParams.ClearCofactor(&amp;q.X, &amp;q.Y, &amp;q.Z, &amp;q.X, &amp;q.Y, &amp;q.Z)

        p.Select(ok, p, &amp;q)
        return ok
}</span>

// SetAffine sets p from affine coordinates if they satisfy the curve equation.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) SetAffine(x, y FP) (ok ct.Bool) <span class="cov0" title="0">{
        var params C
        var one, eql, eqr F
        FP(&amp;one).SetOne()

        FP(&amp;eqr).Square(x)
        params.AddA(&amp;eqr, &amp;eqr)
        FP(&amp;eqr).Mul(&amp;eqr, x)
        params.AddB(&amp;eqr, &amp;eqr)

        FP(&amp;eql).Square(y)
        ok = FP(&amp;eql).Equal(&amp;eqr)

        FP(&amp;p.X).Select(ok, &amp;p.X, x)
        FP(&amp;p.Y).Select(ok, &amp;p.Y, y)
        FP(&amp;p.Z).Select(ok, &amp;p.Z, &amp;one)
        return ok
}</span>

func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) setFractions(xn, xd, yn, yd FP) <span class="cov0" title="0">{
        FP(&amp;p.X).Mul(xn, yd)
        FP(&amp;p.Y).Mul(yn, xd)
        FP(&amp;p.Z).Mul(xd, yd)
}</span>

// SetFromAffineX sets p from an affine x-coordinate, choosing a square root for y.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) SetFromAffineX(x FP) (ok ct.Bool) <span class="cov0" title="0">{
        var params C
        var one, yy, y F
        FP(&amp;one).SetOne()

        FP(&amp;yy).Square(x)
        params.AddA(&amp;yy, &amp;yy)
        FP(&amp;yy).Mul(&amp;yy, x)
        params.AddB(&amp;yy, &amp;yy)
        ok = FP(&amp;y).Sqrt(&amp;yy)

        FP(&amp;p.X).Select(ok, &amp;p.X, x)
        FP(&amp;p.Y).Select(ok, &amp;p.Y, &amp;y)
        FP(&amp;p.Z).Select(ok, &amp;p.Z, &amp;one)
        return ok
}</span>

// Select conditionally assigns z or nz into p based on choice.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Select(choice ct.Choice, z, nz *ShortWeierstrassPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        FP(&amp;p.X).Select(choice, &amp;z.X, &amp;nz.X)
        FP(&amp;p.Y).Select(choice, &amp;z.Y, &amp;nz.Y)
        FP(&amp;p.Z).Select(choice, &amp;z.Z, &amp;nz.Z)
}</span>

// ClearCofactor clears the curve cofactor on input.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) ClearCofactor(in *ShortWeierstrassPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        var params C

        params.ClearCofactor(&amp;p.X, &amp;p.Y, &amp;p.Z, &amp;in.Z, &amp;in.Y, &amp;in.Z)
}</span>

// Add computes p = lhs + rhs
// Source: 2015 RenesCostelloBatina "Complete addition formulas for prime order elliptic curves", Appendix A.1.
// Add sets the receiver to lhs + rhs.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Add(lhs, rhs *ShortWeierstrassPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        var arith C
        var t0f, t1f, t2f, t3f, t4f, t5f F
        var x3f, y3f, z3f F

        t0 := FP(&amp;t0f)
        t1 := FP(&amp;t1f)
        t2 := FP(&amp;t2f)
        t3 := FP(&amp;t3f)
        t4 := FP(&amp;t4f)
        t5 := FP(&amp;t5f)
        x1 := FP(&amp;lhs.X)
        y1 := FP(&amp;lhs.Y)
        z1 := FP(&amp;lhs.Z)
        x2 := FP(&amp;rhs.X)
        y2 := FP(&amp;rhs.Y)
        z2 := FP(&amp;rhs.Z)
        x3 := FP(&amp;x3f)
        y3 := FP(&amp;y3f)
        z3 := FP(&amp;z3f)

        t0.Mul(x1, x2)
        t1.Mul(y1, y2)
        t2.Mul(z1, z2)
        t3.Add(x1, y1)
        t4.Add(x2, y2)
        t3.Mul(t3, t4)
        t4.Add(t0, t1)
        t3.Sub(t3, t4)
        t4.Add(x1, z1)
        t5.Add(x2, z2)
        t4.Mul(t4, t5)
        t5.Add(t0, t2)
        t4.Sub(t4, t5)
        t5.Add(y1, z1)
        x3.Add(y2, z2)
        t5.Mul(t5, x3)
        x3.Add(t1, t2)
        t5.Sub(t5, x3)
        arith.MulByA(z3, t4)
        arith.MulBy3B(x3, t2)
        z3.Add(x3, z3)
        x3.Sub(t1, z3)
        z3.Add(t1, z3)
        y3.Mul(x3, z3)
        t1.Add(t0, t0)
        t1.Add(t1, t0)
        arith.MulByA(t2, t2)
        arith.MulBy3B(t4, t4)
        t1.Add(t1, t2)
        t2.Sub(t0, t2)
        arith.MulByA(t2, t2)
        t4.Add(t4, t2)
        t0.Mul(t1, t4)
        y3.Add(y3, t0)
        t0.Mul(t5, t4)
        x3.Mul(t3, x3)
        x3.Sub(x3, t0)
        t0.Mul(t3, t1)
        z3.Mul(t5, z3)
        z3.Add(z3, t0)

        FP(&amp;p.X).Set(x3)
        FP(&amp;p.Y).Set(y3)
        FP(&amp;p.Z).Set(z3)
}</span>

// Sub sets p = lhs - rhs.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Sub(lhs, rhs *ShortWeierstrassPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        var rhsNeg ShortWeierstrassPointImpl[FP, C, H, M, F]
        rhsNeg.Neg(rhs)
        p.Add(lhs, &amp;rhsNeg)
}</span>

// Double computes p = v + v
// Source: 2015 RenesCostelloBatina "Complete addition formulas for prime order elliptic curves", Appendix A.1.
// The BernsteinLange doubling might be slightly faster, but these are highly unified.
// Double sets the receiver to 2*x.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Double(v *ShortWeierstrassPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        var arith C
        var t0f, t1f, t2f, t3f F
        var x3f, y3f, z3f F

        t0 := FP(&amp;t0f)
        t1 := FP(&amp;t1f)
        t2 := FP(&amp;t2f)
        t3 := FP(&amp;t3f)
        x1 := FP(&amp;v.X)
        y1 := FP(&amp;v.Y)
        z1 := FP(&amp;v.Z)
        x3 := FP(&amp;x3f)
        y3 := FP(&amp;y3f)
        z3 := FP(&amp;z3f)

        t0.Square(x1)
        t1.Square(y1)
        t2.Square(z1)
        t3.Mul(x1, y1)
        t3.Add(t3, t3)
        z3.Mul(x1, z1)
        z3.Add(z3, z3)
        arith.MulByA(x3, z3)
        arith.MulBy3B(y3, t2)
        y3.Add(x3, y3)
        x3.Sub(t1, y3)
        y3.Add(t1, y3)
        y3.Mul(x3, y3)
        x3.Mul(t3, x3)
        arith.MulBy3B(z3, z3)
        arith.MulByA(t2, t2)
        t3.Sub(t0, t2)
        arith.MulByA(t3, t3)
        t3.Add(t3, z3)
        z3.Add(t0, t0)
        t0.Add(z3, t0)
        t0.Add(t0, t2)
        t0.Mul(t0, t3)
        y3.Add(y3, t0)
        t2.Mul(y1, z1)
        t2.Add(t2, t2)
        t0.Mul(t2, t3)
        x3.Sub(x3, t0)
        z3.Mul(t2, t1)
        z3.Add(z3, z3)
        z3.Add(z3, z3)

        p.X = *x3
        p.Y = *y3
        p.Z = *z3
}</span>

// Neg sets p to the negation of v.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Neg(v *ShortWeierstrassPointImpl[FP, C, H, M, F]) <span class="cov0" title="0">{
        FP(&amp;p.X).Set(&amp;v.X)
        FP(&amp;p.Y).Neg(&amp;v.Y)
        FP(&amp;p.Z).Set(&amp;v.Z)
}</span>

// IsZero reports whether p is the identity point.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) IsZero() ct.Bool <span class="cov0" title="0">{
        return FP(&amp;p.Z).IsZero()
}</span>

// IsNonZero reports whether p is not the identity point.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) IsNonZero() ct.Bool <span class="cov0" title="0">{
        return FP(&amp;p.Z).IsNonZero()
}</span>

// Equal reports whether p and rhs represent the same point.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Equal(rhs *ShortWeierstrassPointImpl[FP, C, H, M, F]) ct.Bool <span class="cov0" title="0">{
        var x1z2f, y1z2f, x2z1f, y2z1f F
        x1z2 := FP(&amp;x1z2f)
        y1z2 := FP(&amp;y1z2f)
        x2z1 := FP(&amp;x2z1f)
        y2z1 := FP(&amp;y2z1f)

        x1 := FP(&amp;p.X)
        y1 := FP(&amp;p.Y)
        z1 := FP(&amp;p.Z)
        x2 := FP(&amp;rhs.X)
        y2 := FP(&amp;rhs.Y)
        z2 := FP(&amp;rhs.Z)

        x1z2.Mul(x1, z2)
        y1z2.Mul(y1, z2)
        x2z1.Mul(x2, z1)
        y2z1.Mul(y2, z1)

        return x1z2.Equal(x2z1) &amp; y1z2.Equal(y2z1)
}</span>

// ToAffine converts p to affine coordinates if possible.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) ToAffine(xOut, yOut FP) (ok ct.Bool) <span class="cov0" title="0">{
        var x, y, zInv F
        zInvPtr := FP(&amp;zInv)
        ok = zInvPtr.Inv(&amp;p.Z)

        FP(&amp;x).Mul(&amp;p.X, zInvPtr)
        FP(&amp;y).Mul(&amp;p.Y, zInvPtr)

        xOut.Select(ok, xOut, &amp;x)
        yOut.Select(ok, yOut, &amp;y)
        return ok
}</span>

// String formats the point in projective coordinates.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) String() string <span class="cov0" title="0">{
        var one, x, y, z F
        FP(&amp;one).SetOne()

        ok := p.ToAffine(&amp;x, &amp;y)
        FP(&amp;x).Select(ok, &amp;p.X, &amp;x)
        FP(&amp;y).Select(ok, &amp;p.Y, &amp;y)
        FP(&amp;z).Select(ok, &amp;p.Z, &amp;one)

        return fmt.Sprintf("(%s : %s : %s)", FP(&amp;x), FP(&amp;y), FP(&amp;z))
}</span>

// Bytes returns the concatenated byte encoding of projective coordinates.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(FP(&amp;p.X).Bytes(), FP(&amp;p.Y).Bytes(), FP(&amp;p.Z).Bytes())
}</span>

// SetBytes decodes projective coordinates from input.
func (p *ShortWeierstrassPointImpl[FP, C, H, M, F]) SetBytes(input []byte) (ok ct.Bool) <span class="cov0" title="0">{
        coordinateLen := len(input) / 3
        x := input[:coordinateLen]
        y := input[coordinateLen : 2*coordinateLen]
        z := input[2*coordinateLen:]

        var tmpX, tmpY, tmpZ F
        okX := FP(&amp;tmpX).SetBytes(x)
        okY := FP(&amp;tmpY).SetBytes(y)
        okZ := FP(&amp;tmpZ).SetBytes(z)
        ok = okX &amp; okY &amp; okZ

        // Conditionally assign: keep current if failed
        FP(&amp;p.X).Select(ok, &amp;p.X, &amp;tmpX)
        FP(&amp;p.Y).Select(ok, &amp;p.Y, &amp;tmpY)
        FP(&amp;p.Z).Select(ok, &amp;p.Z, &amp;tmpZ)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package rfc9380

import (
        "hash"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/expanders"
)

// MessageExpander expands messages per RFC 9380 hash-to-curve.
type MessageExpander interface {
        // ExpandMessage expands msg to outLen using dst.
        ExpandMessage(dst, msg []byte, outLen uint) []byte
}

// NewXMDMessageExpander returns an XMD expander for the given hash.
func NewXMDMessageExpander[H hash.Hash](hashFunc func() H) MessageExpander <span class="cov0" title="0">{
        return &amp;expanders.Xmd{HashFunc: func() hash.Hash </span><span class="cov0" title="0">{ return hashFunc() }</span>}
}

// NewXOFMessageExpander returns an XOF expander for the given XOF hash and security parameter k.
func NewXOFMessageExpander(shakeHash hash.XOF, k uint) MessageExpander <span class="cov0" title="0">{
        return &amp;expanders.Xof{
                XofHash: shakeHash,
                K:       k,
        }
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package expanders

import (
        "crypto/subtle"
        "encoding/binary"
        "hash"
        "slices"
)

// Xmd implements expand_message_xmd from RFC 9380.
type Xmd struct {
        HashFunc func() hash.Hash
}

// ExpandMessage expands msg to lenInBytes using XMD and dst.
func (e *Xmd) ExpandMessage(dst, msg []byte, lenInBytes uint) []byte <span class="cov8" title="1">{
        h := e.HashFunc()
        sInBytes := h.BlockSize()

        // 0. if len(DST) &gt; 255: DST = H("H2C-OVERSIZE-DST-" || a_very_long_DST)
        if len(dst) &gt; 255 </span><span class="cov8" title="1">{
                h.Reset()
                h.Write(slices.Concat([]byte("H2C-OVERSIZE-DST-"), dst))
                dst = h.Sum(nil)
        }</span>
        //  1. ell = ceil(len_in_bytes / b_in_bytes)
        <span class="cov8" title="1">ell := (lenInBytes + 7) / 8
        //  2.  ABORT if ell &gt; 255 or len_in_bytes &gt; 65535
        if ell &gt; 255 || lenInBytes &gt; 65535 </span><span class="cov0" title="0">{
                panic("invalid length")</span>
        }
        //  3.  DST_prime = DST || I2OSP(len(DST), 1)
        <span class="cov8" title="1">dstPrime := append(dst, i2osp(uint64(len(dst)), 1)...)
        //  4.  Z_pad = I2OSP(0, s_in_bytes)
        zPad := i2osp(0, uint(sInBytes))
        //  5.  l_i_b_str = I2OSP(len_in_bytes, 2)
        libStr := i2osp(uint64(lenInBytes), 2)
        //  6.  msg_prime = Z_pad || msg || l_i_b_str || I2OSP(0, 1) || DST_prime
        msgPrime := slices.Concat(zPad, msg, libStr, i2osp(0, 1), dstPrime)
        //  7.  b_0 = H(msg_prime)
        b := make([][]byte, ell+1)
        h.Reset()
        h.Write(msgPrime)
        b[0] = h.Sum(nil)
        //  8.  b_1 = H(b_0 || I2OSP(1, 1) || DST_prime)
        h.Reset()
        h.Write(slices.Concat(b[0], i2osp(1, 1), dstPrime))
        b[1] = h.Sum(nil)
        //  9.  for i in (2, ..., ell):
        for i := uint(2); i &lt;= ell; i++ </span><span class="cov8" title="1">{
                // 10. b_i = H(strxor(b_0, b_(i - 1)) || I2OSP(i, 1) || DST_prime)
                b0XorBi := make([]byte, h.Size())
                subtle.XORBytes(b0XorBi, b[0], b[i-1])
                h.Reset()
                h.Write(slices.Concat(b0XorBi, i2osp(uint64(i), 1), dstPrime))
                b[i] = h.Sum(nil)
        }</span>
        // 11. uniform_bytes = b_1 || ... || b_ell
        <span class="cov8" title="1">uniformBytes := slices.Concat(b[1:]...)
        // 12. return substr(uniform_bytes, 0, len_in_bytes)
        return uniformBytes[:lenInBytes]</span>
}

func i2osp(in uint64, length uint) []byte <span class="cov8" title="1">{
        data := make([]byte, length)
        copy(data, binary.LittleEndian.AppendUint64(nil, in))
        slices.Reverse(data)
        return data
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package expanders

import (
        "hash"
        "slices"
)

// Xof implements expand_message_xof from RFC 9380.
type Xof struct {
        XofHash hash.XOF
        K       uint
}

// ExpandMessage expands msg to lenInBytes using XOF and dst.
func (e *Xof) ExpandMessage(dst, msg []byte, lenInBytes uint) []byte <span class="cov8" title="1">{
        h := e.XofHash

        if len(dst) &gt; 255 </span><span class="cov8" title="1">{
                // 0. DST = H("H2C-OVERSIZE-DST-" || a_very_long_DST, ceil(2 * k / 8))
                h.Reset()
                h.Write(slices.Concat([]byte("H2C-OVERSIZE-DST-"), dst))
                dst = make([]byte, (2*e.K+7)/8)
                h.Read(dst)
        }</span>

        // 1. ABORT if len_in_bytes &gt; 65535
        <span class="cov8" title="1">if lenInBytes &gt; 65535 </span><span class="cov0" title="0">{
                panic("invalid length")</span>
        }
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        <span class="cov8" title="1">dstPrime := slices.Concat(dst, i2osp(uint64(len(dst)), 1))
        // 3. msg_prime = msg || I2OSP(len_in_bytes, 2) || DST_prime
        msgPrime := slices.Concat(msg, i2osp(uint64(lenInBytes), 2), dstPrime)
        // 4. uniform_bytes = H(msg_prime, len_in_bytes)
        h.Reset()
        h.Write(msgPrime)
        uniformBytes := make([]byte, lenInBytes)
        h.Read(uniformBytes)
        // 5. return uniform_bytes
        return uniformBytes[:lenInBytes]</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package rfc9380

import (
        "slices"

        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
)

// HasherParams exposes parameters for hash-to-field expansion.
type HasherParams interface {
        // L returns the hash-to-field length in bytes.
        L() uint64
        // MessageExpander returns the RFC 9380 message expander.
        MessageExpander() MessageExpander
}

// HashToField expands msg into field elements as specified by RFC 9380.
func HashToField[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any](out []F, params HasherParams, dstStr string, msg []byte) <span class="cov0" title="0">{
        m := fieldsImpl.Degree[FP]()
        l := params.L()
        expander := params.MessageExpander()
        dst := []byte(dstStr)
        count := len(out)

        //  1. len_in_bytes = count * m * L
        lenInBytes := uint64(count) * m * l
        //  2. uniform_bytes = expand_message(msg, DST, len_in_bytes)
        uniformBytes := expander.ExpandMessage(dst, msg, uint(lenInBytes))
        //  3. for i in (0, ..., count - 1):
        for i := range uint64(len(out)) </span><span class="cov0" title="0">{
                e := make([][]byte, m)
                //  4.   for j in (0, ..., m - 1):
                for j := range m </span><span class="cov0" title="0">{
                        //  5.     elm_offset = L * (j + i * m)
                        elmOffset := l * (j + i*m)
                        //  6.     tv = substr(uniform_bytes, elm_offset, L)
                        tv := uniformBytes[elmOffset : elmOffset+l]
                        //  7.     e_j = OS2IP(tv) mod p
                        slices.Reverse(tv)
                        e[j] = tv
                }</span>
                //  8.   u_i = (e_0, ..., e_(m - 1))
                <span class="cov0" title="0">FP(&amp;out[i]).SetUniformBytes(e...)</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package elligator2

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

var (
        curve25519Elligator2JLimbs  = [...]uint64{0x0000000000076d06, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000}
        curve25519Elligator2C2Limbs = [...]uint64{0xc4ee1b274a0ea0b1, 0x2f431806ad2fe478, 0x2b4d00993dfbd7a7, 0x2b8324804fc1df0b}
        curve25519Elligator2C3Limbs = [...]uint64{0xc4ee1b274a0ea0b0, 0x2f431806ad2fe478, 0x2b4d00993dfbd7a7, 0x2b8324804fc1df0b}
        curve25519Elligator2C4      = [...]uint8{0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f}
)

func mapToCurveElligator2Curve25519[FP fieldsImpl.PrimeFieldElementPtr[FP, F], F any](xnOut, xdOut, ynOut, ydOut, u *F) <span class="cov0" title="0">{
        var one, j, c2, c3, tv1, tv2, tv3, xd, xn, x1n, x2n, gxd, gx1, gx2, y, yn, y1, y11, y12, y2, y21, y22 F
        FP(&amp;one).SetOne()
        FP(&amp;j).SetLimbs(curve25519Elligator2JLimbs[:])
        FP(&amp;c2).SetLimbs(curve25519Elligator2C2Limbs[:])
        FP(&amp;c3).SetLimbs(curve25519Elligator2C3Limbs[:])

        //  1.  tv1 = u^2
        FP(&amp;tv1).Square(u)
        //  2.  tv1 = 2 * tv1
        FP(&amp;tv1).Add(&amp;tv1, &amp;tv1)
        //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
        FP(&amp;xd).Add(&amp;tv1, &amp;one)
        //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
        FP(&amp;x1n).Neg(&amp;j)
        //  5.  tv2 = xd^2
        FP(&amp;tv2).Square(&amp;xd)
        //  6.  gxd = tv2 * xd        # gxd = xd^3
        FP(&amp;gxd).Mul(&amp;tv2, &amp;xd)
        //  7.  gx1 = J * tv1         # x1n + J * xd
        FP(&amp;gx1).Mul(&amp;j, &amp;tv1)
        //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
        FP(&amp;gx1).Mul(&amp;gx1, &amp;x1n)
        //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
        FP(&amp;gx1).Add(&amp;gx1, &amp;tv2)
        // 10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
        FP(&amp;gx1).Mul(&amp;gx1, &amp;x1n)
        // 11. tv3 = gxd^2
        FP(&amp;tv3).Square(&amp;gxd)
        // 12. tv2 = tv3^2           # gxd^4
        FP(&amp;tv2).Square(&amp;tv3)
        // 13. tv3 = tv3 * gxd       # gxd^3
        FP(&amp;tv3).Mul(&amp;tv3, &amp;gxd)
        // 14. tv3 = tv3 * gx1       # gx1 * gxd^3
        FP(&amp;tv3).Mul(&amp;tv3, &amp;gx1)
        // 15. tv2 = tv2 * tv3       # gx1 * gxd^7
        FP(&amp;tv2).Mul(&amp;tv2, &amp;tv3)
        // 16. y11 = tv2^c4          # (gx1 * gxd^7)^((p - 5) / 8)
        fieldsImpl.Pow[FP](&amp;y11, &amp;tv2, curve25519Elligator2C4[:])
        // 17. y11 = y11 * tv3       # gx1 * gxd^3 * (gx1 * gxd^7)^((p - 5) / 8)
        FP(&amp;y11).Mul(&amp;y11, &amp;tv3)
        // 18. y12 = y11 * c3
        FP(&amp;y12).Mul(&amp;y11, &amp;c3)
        // 19. tv2 = y11^2
        FP(&amp;tv2).Square(&amp;y11)
        // 20. tv2 = tv2 * gxd
        FP(&amp;tv2).Mul(&amp;tv2, &amp;gxd)
        // 21.  e1 = tv2 == gx1
        e1 := FP(&amp;tv2).Equal(&amp;gx1)
        // 22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
        FP(&amp;y1).Select(e1, &amp;y12, &amp;y11)
        // 23. x2n = x1n * tv1           # x2 = x2n / xd = 2 * u^2 * x1n / xd
        FP(&amp;x2n).Mul(&amp;x1n, &amp;tv1)
        // 24. y21 = y11 * u
        FP(&amp;y21).Mul(&amp;y11, u)
        // 25. y21 = y21 * c2
        FP(&amp;y21).Mul(&amp;y21, &amp;c2)
        // 26. y22 = y21 * c3
        FP(&amp;y22).Mul(&amp;y21, &amp;c3)
        // 27. gx2 = gx1 * tv1           # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
        FP(&amp;gx2).Mul(&amp;gx1, &amp;tv1)
        // 28. tv2 = y21^2
        FP(&amp;tv2).Square(&amp;y21)
        // 29. tv2 = tv2 * gxd
        FP(&amp;tv2).Mul(&amp;tv2, &amp;gxd)
        // 30.  e2 = tv2 == gx2
        e2 := FP(&amp;tv2).Equal(&amp;gx2)
        // 31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
        FP(&amp;y2).Select(e2, &amp;y22, &amp;y21)
        // 32. tv2 = y1^2
        FP(&amp;tv2).Square(&amp;y1)
        // 33. tv2 = tv2 * gxd
        FP(&amp;tv2).Mul(&amp;tv2, &amp;gxd)
        // 34.  e3 = tv2 == gx1
        e3 := FP(&amp;tv2).Equal(&amp;gx1)
        // 35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
        FP(&amp;xn).Select(e3, &amp;x2n, &amp;x1n)
        // 36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
        FP(&amp;y).Select(e3, &amp;y2, &amp;y1)
        // 37.  e4 = sgn0(y) == 1        # Fix sign of y
        e4 := sgn0(FP(&amp;y))
        // 38.   y = CMOV(y, -y, e3 XOR e4)
        FP(&amp;yn).Neg(&amp;y)
        FP(&amp;y).Select(e3^e4, &amp;y, &amp;yn)
        // 39. return (xn, xd, y, 1)
        FP(xnOut).Set(&amp;xn)
        FP(xdOut).Set(&amp;xd)
        FP(ynOut).Set(&amp;y)
        FP(ydOut).SetOne()
}</span>

func sgn0[FP fieldsImpl.PrimeFieldElement[FP]](in FP) ct.Bool <span class="cov0" title="0">{
        inBytes := in.Bytes()
        return ct.Bool(uint64(inBytes[0] &amp; 0b1))
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package elligator2

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
)

var (
        edwards25519Elligator2C1Limbs = [...]uint64{0xcc6e04aaff457e06, 0xc5a1d3d14b7d1a82, 0xd27b08dc03fc4f7e, 0x0f26edf460a006bb}
)

// Edwards25519PointMapper maps field elements to Edwards25519 using Elligator 2.
type Edwards25519PointMapper[FP fieldsImpl.PrimeFieldElementPtr[FP, F], F any] struct{}

// Map maps u to a curve point represented by rational coordinates.
func (Edwards25519PointMapper[FP, F]) Map(xn, xd, yn, yd, u FP) <span class="cov0" title="0">{
        mapToCurveElligator2Edwards25519[FP](xn, xd, yn, yd, u)
}</span>

func mapToCurveElligator2Edwards25519[FP fieldsImpl.PrimeFieldElementPtr[FP, F], F any](xnOut, xdOut, ynOut, ydOut, u *F) <span class="cov0" title="0">{
        var zero, one, c1, xMn, xMd, yMn, yMd, tv1, xn, xd, yn, yd F
        FP(&amp;zero).SetZero()
        FP(&amp;one).SetOne()
        FP(&amp;c1).SetLimbs(edwards25519Elligator2C1Limbs[:])

        //  1.  (xMn, xMd, yMn, yMd) = map_to_curve_elligator2_curve25519(u)
        mapToCurveElligator2Curve25519[FP](&amp;xMn, &amp;xMd, &amp;yMn, &amp;yMd, u)
        //  2.  xn = xMn * yMd
        FP(&amp;xn).Mul(&amp;xMn, &amp;yMd)
        //  3.  xn = xn * c1
        FP(&amp;xn).Mul(&amp;xn, &amp;c1)
        //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
        FP(&amp;xd).Mul(&amp;xMd, &amp;yMn)
        //  5.  yn = xMn - xMd
        FP(&amp;yn).Sub(&amp;xMn, &amp;xMd)
        //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
        FP(&amp;yd).Add(&amp;xMn, &amp;xMd)
        //  7. tv1 = xd * yd
        FP(&amp;tv1).Mul(&amp;xd, &amp;yd)
        //  8.   e = tv1 == 0
        e := FP(&amp;tv1).IsZero()
        //  9.  xn = CMOV(xn, 0, e)
        FP(&amp;xn).Select(e, &amp;xn, &amp;zero)
        // 10. xd = CMOV(xd, 1, e)
        FP(&amp;xd).Select(e, &amp;xd, &amp;one)
        // 11. yn = CMOV(yn, 1, e)
        FP(&amp;yn).Select(e, &amp;yn, &amp;one)
        // 12. yd = CMOV(yd, 1, e)
        FP(&amp;yd).Select(e, &amp;yd, &amp;one)
        // 13. return (xn, xd, yn, yd)
        FP(xnOut).Set(&amp;xn)
        FP(xdOut).Set(&amp;xd)
        FP(ynOut).Set(&amp;yn)
        FP(ydOut).Set(&amp;yd)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package sswu

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
)

func mapIso[FP fieldsImpl.FiniteFieldElementPtr[FP, F], P ZeroPointMapperParams[FP, F], F any](xnOut, xdOut, ynOut, ydOut *F, params P, xIn, yIn *F) <span class="cov0" title="0">{
        var xNum, xDen, yNum, yDen F

        polyEval[FP](&amp;xNum, params.XNum(), xIn)
        polyEval[FP](&amp;xDen, params.XDen(), xIn)
        polyEval[FP](&amp;yNum, params.YNum(), xIn)
        polyEval[FP](&amp;yDen, params.YDen(), xIn)
        FP(&amp;yNum).Mul(&amp;yNum, yIn)

        FP(xnOut).Set(&amp;xNum)
        FP(xdOut).Set(&amp;xDen)
        FP(ynOut).Set(&amp;yNum)
        FP(ydOut).Set(&amp;yDen)
}</span>

func polyEval[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any](result *F, coefficients []F, at *F) <span class="cov0" title="0">{
        FP(result).Set(&amp;coefficients[len(coefficients)-1])
        for i := len(coefficients) - 2; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                FP(result).Mul(result, at)
                FP(result).Add(result, &amp;coefficients[i])
        }</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package sswu

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

// NonZeroPointMapperParams provides curve-specific helpers for SSWU.
type NonZeroPointMapperParams[FP fieldsImpl.FiniteFieldElement[FP]] interface {
        // MulByA multiplies by the curve A parameter.
        MulByA(out, in FP)
        // MulByB multiplies by the curve B parameter.
        MulByB(out, in FP)
        // SetZ sets the SSWU Z parameter.
        SetZ(out FP)
        // SqrtRatio computes sqrt(u/v) with curve-specific parameters.
        SqrtRatio(out, u, v FP) (ok ct.Bool)
        // Sgn0 returns the sign bit per RFC 9380.
        Sgn0(v FP) ct.Bool
}

// NonZeroPointMapper maps field elements using SSWU without an isogeny.
type NonZeroPointMapper[FP fieldsImpl.FiniteFieldElementPtr[FP, F], P NonZeroPointMapperParams[FP], F any] struct{}

// Map maps u to a curve point represented by rational coordinates.
func (NonZeroPointMapper[FP, P, F]) Map(xnOut, xdOut, ynOut, ydOut, u FP) <span class="cov0" title="0">{
        var params P
        sswu[FP](xnOut, ynOut, params, u)
        xdOut.SetOne()
        ydOut.SetOne()
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package sswu

import (
        "encoding/binary"

        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

// SqrtRatio computes sqrt(u/v) using constant-time steps from RFC 9380.
func SqrtRatio[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any](yOut *F, c1 uint64, c3 []uint8, c4, c5 uint64, c6, c7, u, v *F) (ok ct.Bool) <span class="cov0" title="0">{
        var one, tv1, tv2, tv3, tv4, tv5 F
        FP(&amp;one).SetOne()

        //  1. tv1 = c6
        FP(&amp;tv1).Set(c6)
        //  2. tv2 = v^c4
        fieldsImpl.Pow[FP](&amp;tv2, v, binary.LittleEndian.AppendUint64(nil, c4))
        //  3. tv3 = tv2^2
        FP(&amp;tv3).Square(&amp;tv2)
        //  4. tv3 = tv3 * v
        FP(&amp;tv3).Mul(&amp;tv3, v)
        //  5. tv5 = u * tv3
        FP(&amp;tv5).Mul(u, &amp;tv3)
        //  6. tv5 = tv5^c3
        fieldsImpl.Pow[FP](&amp;tv5, &amp;tv5, c3)
        //  7. tv5 = tv5 * tv2
        FP(&amp;tv5).Mul(&amp;tv5, &amp;tv2)
        //  8. tv2 = tv5 * v
        FP(&amp;tv2).Mul(&amp;tv5, v)
        //  9. tv3 = tv5 * u
        FP(&amp;tv3).Mul(&amp;tv5, u)
        // 10. tv4 = tv3 * tv2
        FP(&amp;tv4).Mul(&amp;tv3, &amp;tv2)
        // 11. tv5 = tv4^c5
        fieldsImpl.Pow[FP](&amp;tv5, &amp;tv4, binary.LittleEndian.AppendUint64(nil, c5))
        // 12. isQR = tv5 == 1
        isQr := FP(&amp;tv5).IsOne()
        // 13. tv2 = tv3 * c7
        FP(&amp;tv2).Mul(&amp;tv3, c7)
        // 14. tv5 = tv4 * tv1
        FP(&amp;tv5).Mul(&amp;tv4, &amp;tv1)
        // 15. tv3 = CMOV(tv2, tv3, isQR)
        FP(&amp;tv3).Select(isQr, &amp;tv2, &amp;tv3)
        // 16. tv4 = CMOV(tv5, tv4, isQR)
        FP(&amp;tv4).Select(isQr, &amp;tv5, &amp;tv4)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for i := c1; i &gt;= 2; i-- </span><span class="cov0" title="0">{
                // 18. tv5 = i - 2
                tv5i := i - 2
                // 19. tv5 = 2 ^ tv5
                tv5i = 1 &lt;&lt; tv5i
                // 20. tv5 = tv4 ^ tv5
                fieldsImpl.Pow[FP](&amp;tv5, &amp;tv4, binary.LittleEndian.AppendUint64(nil, tv5i))
                // 21. e1 = tv5 == 1
                e1 := FP(&amp;tv5).IsOne()
                // 22. tv2 = tv3 * tv1
                FP(&amp;tv2).Mul(&amp;tv3, &amp;tv1)
                // 23. tv1 = tv1 * tv1
                FP(&amp;tv1).Square(&amp;tv1)
                // 24. tv5 = tv4 * tv1
                FP(&amp;tv5).Mul(&amp;tv4, &amp;tv1)
                // 25. tv3 = CMOV(tv2, tv3, e1)
                FP(&amp;tv3).Select(e1, &amp;tv2, &amp;tv3)
                // 26. tv4 = CMOV(tv5, tv4, e1)
                FP(&amp;tv4).Select(e1, &amp;tv5, &amp;tv4)
        }</span>
        // 27. return (isQR, tv3)
        <span class="cov0" title="0">FP(yOut).Set(&amp;tv3)
        return isQr</span>
}

// SqrtRatio3Mod4 computes sqrt(u/v) for fields with p mod 4 == 3.
func SqrtRatio3Mod4[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any](yOut *F, c1 []uint8, c2, u, v *F) (ok ct.Bool) <span class="cov0" title="0">{
        var tv1, tv2, tv3, y1, y2 F

        //  1. tv1 = v^2
        FP(&amp;tv1).Square(v)
        //  2. tv2 = u * v
        FP(&amp;tv2).Mul(u, v)
        //  3. tv1 = tv1 * tv2
        FP(&amp;tv1).Mul(&amp;tv1, &amp;tv2)
        //  4. y1 = tv1^c1
        fieldsImpl.Pow[FP](&amp;y1, &amp;tv1, c1)
        //  5. y1 = y1 * tv2
        FP(&amp;y1).Mul(&amp;y1, &amp;tv2)
        //  6. y2 = y1 * c2
        FP(&amp;y2).Mul(&amp;y1, c2)
        //  7. tv3 = y1^2
        FP(&amp;tv3).Square(&amp;y1)
        //  8. tv3 = tv3 * v
        FP(&amp;tv3).Mul(&amp;tv3, v)
        //  9. isQR = tv3 == u
        isQR := FP(u).Equal(&amp;tv3)
        // 10. y = CMOV(y2, y1, isQR)
        FP(yOut).Select(isQR, &amp;y2, &amp;y1)
        // 11. return (isQR, y)
        return isQR
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package sswu

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
)

func sswu[FP fieldsImpl.FiniteFieldElementPtr[FP, F], P NonZeroPointMapperParams[FP], F any](xOut, yOut *F, params P, u *F) <span class="cov0" title="0">{
        var one, z, tv1, tv2, tv2n, tv3, tv4, tv5, tv6, y1, yn F
        FP(&amp;one).SetOne()
        params.SetZ(&amp;z)

        //  1.  tv1 = u^2
        FP(&amp;tv1).Square(u)
        //  2.  tv1 = Z * tv1
        FP(&amp;tv1).Mul(&amp;z, &amp;tv1)
        //  3.  tv2 = tv1^2
        FP(&amp;tv2).Square(&amp;tv1)
        //  4.  tv2 = tv2 + tv1
        FP(&amp;tv2).Add(&amp;tv2, &amp;tv1)
        //  5.  tv3 = tv2 + 1
        FP(&amp;tv3).Add(&amp;tv2, &amp;one)
        //  6.  tv3 = B * tv3
        params.MulByB(&amp;tv3, &amp;tv3)
        //  7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        FP(&amp;tv2n).Neg(&amp;tv2)
        FP(&amp;tv4).Select(FP(&amp;tv2).IsNonZero(), &amp;z, &amp;tv2n)
        //  8.  tv4 = A * tv4
        params.MulByA(&amp;tv4, &amp;tv4)
        //  9.  tv2 = tv3^2
        FP(&amp;tv2).Square(&amp;tv3)
        // 10. tv6 = tv4^2
        FP(&amp;tv6).Square(&amp;tv4)
        // 11. tv5 = A * tv6
        params.MulByA(&amp;tv5, &amp;tv6)
        // 12. tv2 = tv2 + tv5
        FP(&amp;tv2).Add(&amp;tv2, &amp;tv5)
        // 13. tv2 = tv2 * tv3
        FP(&amp;tv2).Mul(&amp;tv2, &amp;tv3)
        // 14. tv6 = tv6 * tv4
        FP(&amp;tv6).Mul(&amp;tv6, &amp;tv4)
        // 15. tv5 = B * tv6
        params.MulByB(&amp;tv5, &amp;tv6)
        // 16. tv2 = tv2 + tv5
        FP(&amp;tv2).Add(&amp;tv2, &amp;tv5)
        // 17.   x = tv1 * tv3
        FP(xOut).Mul(&amp;tv1, &amp;tv3)
        // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        isGx1Square := params.SqrtRatio(&amp;y1, &amp;tv2, &amp;tv6)
        // 19.   y = tv1 * u
        FP(yOut).Mul(&amp;tv1, u)
        // 20.   y = y * y1
        FP(yOut).Mul(yOut, &amp;y1)
        // 21.   x = CMOV(x, tv3, is_gx1_square)
        FP(xOut).Select(isGx1Square, xOut, &amp;tv3)
        // 22.   y = CMOV(y, y1, is_gx1_square)
        FP(yOut).Select(isGx1Square, yOut, &amp;y1)
        // 23.  e1 = sgn0(u) == sgn0(y)
        e1 := (params.Sgn0(u) ^ params.Sgn0(yOut)) ^ 1
        // 24.   y = CMOV(-y, y, e1)
        FP(&amp;yn).Neg(yOut)

        FP(yOut).Select(e1, &amp;yn, yOut)
        // 25.   x = x / tv4
        _ = FP(xOut).Div(xOut, &amp;tv4)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package sswu

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
)

// ZeroPointMapperParams provides parameters for SSWU mapping with isogenies.
type ZeroPointMapperParams[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any] interface {
        NonZeroPointMapperParams[FP]
        // XNum returns isogeny x numerator coefficients.
        XNum() []F
        // XDen returns isogeny x denominator coefficients.
        XDen() []F
        // YNum returns isogeny y numerator coefficients.
        YNum() []F
        // YDen returns isogeny y denominator coefficients.
        YDen() []F
}

// ZeroPointMapper maps field elements using SSWU and an isogeny.
type ZeroPointMapper[FP fieldsImpl.FiniteFieldElementPtr[FP, F], P ZeroPointMapperParams[FP, F], F any] struct{}

// Map maps u to a curve point represented by rational coordinates.
func (ZeroPointMapper[FP, P, F]) Map(xnOut, xdOut, ynOut, ydOut, u *F) <span class="cov0" title="0">{
        var params P
        var isoX, isoY F
        sswu[FP](&amp;isoX, &amp;isoY, params, u)
        mapIso[FP](xnOut, xdOut, ynOut, ydOut, params, &amp;isoX, &amp;isoY)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package traits

import (
        "io"
        "iter"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
)

// PointWrapper exposes the underlying curve point.
type PointWrapper[FP fields.FiniteFieldElement[FP], P points.Point[FP, P]] interface {
        // P defines the P operation.
        P() P
}

// PointWrapperPtrConstraint restricts wrappers to pointer receivers.
type PointWrapperPtrConstraint[FP fields.FiniteFieldElement[FP], P points.Point[FP, P], WT any] interface {
        *WT
        PointWrapper[FP, P]
}

// CurveTrait provides constructors and iterator helpers for curve points.
type CurveTrait[FP fields.FiniteFieldElement[FP], P points.Point[FP, P], W PointWrapperPtrConstraint[FP, P, WT], WT any] struct {
}

// Zero returns the curve's point at infinity.
func (*CurveTrait[FP, P, W, WT]) Zero() W <span class="cov0" title="0">{
        var zero WT
        W(&amp;zero).P().SetZero()
        return &amp;zero
}</span>

// Random samples a curve point using the provided PRNG.
func (*CurveTrait[FP, P, W, WT]) Random(prng io.Reader) (W, error) <span class="cov0" title="0">{
        var p WT
        if ok := W(&amp;p).P().SetRandom(prng); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrRandomSample.WithMessage("cannot sample point")
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

// Iter returns an iterator over points in the prime subgroup.
func (c *CurveTrait[FP, P, W, WT]) Iter() iter.Seq[W] <span class="cov0" title="0">{
        return func(yield func(W) bool) </span><span class="cov0" title="0">{
                generator := c.PrimeSubGroupGenerator()

                var current WT
                W(&amp;current).P().Set(generator.P())

                for W(&amp;current).P().IsZero() != 1 </span><span class="cov0" title="0">{
                        if !yield(W(&amp;current)) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">W(&amp;current).P().Add(W(&amp;current).P(), generator.P())</span>
                }
        }
}

// OpIdentity returns the group operation identity.
func (c *CurveTrait[FP, P, W, WT]) OpIdentity() W <span class="cov0" title="0">{
        return c.Zero()
}</span>

// PrimeSubGroupGenerator returns the designated prime subgroup generator.
func (*CurveTrait[FP, P, W, WT]) PrimeSubGroupGenerator() W <span class="cov0" title="0">{
        var gen WT
        W(&amp;gen).P().SetGenerator()
        return &amp;gen
}</span>

// PrimeCurveTrait provides helpers for prime-order curves.
type PrimeCurveTrait[FP fields.FiniteFieldElement[FP], P points.Point[FP, P], W PointWrapperPtrConstraint[FP, P, WT], WT any] struct {
        CurveTrait[FP, P, W, WT]
}

// Generator returns the designated generator for the curve.
func (*PrimeCurveTrait[FP, P, W, WT]) Generator() W <span class="cov0" title="0">{
        var gen WT
        W(&amp;gen).P().SetGenerator()
        return &amp;gen
}</span>

// PointTrait implements common group operations for points.
type PointTrait[FP fields.FiniteFieldElement[FP], P points.PointPtr[FP, P, T], T any, W PointWrapperPtrConstraint[FP, P, WT], WT any] struct {
        V T
}

// P returns the underlying point pointer.
func (p *PointTrait[FP, P, T, W, WT]) P() P <span class="cov0" title="0">{
        return &amp;p.V
}</span>

// Clone returns a new point with the same value.
func (p *PointTrait[FP, P, T, W, WT]) Clone() W <span class="cov0" title="0">{
        var clone WT
        W(&amp;clone).P().Set(&amp;p.V)
        return &amp;clone
}</span>

// Add returns the sum of this point and e.
func (p *PointTrait[FP, P, T, W, WT]) Add(e W) W <span class="cov0" title="0">{
        var sum WT
        W(&amp;sum).P().Add(&amp;p.V, e.P())
        return &amp;sum
}</span>

// Double returns the point doubled.
func (p *PointTrait[FP, P, T, W, WT]) Double() W <span class="cov0" title="0">{
        var doubled WT
        W(&amp;doubled).P().Add(&amp;p.V, &amp;p.V)
        return &amp;doubled
}</span>

// TrySub returns the difference between this point and e.
func (p *PointTrait[FP, P, T, W, WT]) TrySub(e W) (W, error) <span class="cov0" title="0">{
        return p.Sub(e), nil
}</span>

// Sub returns the difference between this point and e.
func (p *PointTrait[FP, P, T, W, WT]) Sub(e W) W <span class="cov0" title="0">{
        var diff WT
        W(&amp;diff).P().Sub(&amp;p.V, e.P())
        return &amp;diff
}</span>

// TryNeg returns the negation of this point.
func (p *PointTrait[FP, P, T, W, WT]) TryNeg() (W, error) <span class="cov0" title="0">{
        return p.Neg(), nil
}</span>

// Neg returns the negation of this point.
func (p *PointTrait[FP, P, T, W, WT]) Neg() W <span class="cov0" title="0">{
        var neg WT
        W(&amp;neg).P().Neg(&amp;p.V)
        return &amp;neg
}</span>

// ClearCofactor clears the curve cofactor on this point.
func (p *PointTrait[FP, P, T, W, WT]) ClearCofactor() W <span class="cov0" title="0">{
        var torsionFree WT
        W(&amp;torsionFree).P().ClearCofactor(&amp;p.V)
        return &amp;torsionFree
}</span>

// IsZero reports whether this point is the identity.
func (p *PointTrait[FP, P, T, W, WT]) IsZero() bool <span class="cov0" title="0">{
        return P(&amp;p.V).IsZero() == 1
}</span>

// IsPrimeSubGroupDesignatedGenerator reports whether this point is the prime subgroup generator.
func (p *PointTrait[FP, P, T, W, WT]) IsPrimeSubGroupDesignatedGenerator() bool <span class="cov0" title="0">{
        var generator WT
        W(&amp;generator).P().SetGenerator()
        return p.Equal(&amp;generator)
}</span>

// Equal reports whether this point equals rhs.
func (p *PointTrait[FP, P, T, W, WT]) Equal(rhs W) bool <span class="cov0" title="0">{
        return P(&amp;p.V).Equal(rhs.P()) == 1
}</span>

// Op returns the group operation result (addition).
func (p *PointTrait[FP, P, T, W, WT]) Op(e W) W <span class="cov0" title="0">{
        return p.Add(e)
}</span>

// IsOpIdentity reports whether this point is the group identity.
func (p *PointTrait[FP, P, T, W, WT]) IsOpIdentity() bool <span class="cov0" title="0">{
        return p.IsZero()
}</span>

// OpInv returns the group inverse of this point.
func (p *PointTrait[FP, P, T, W, WT]) OpInv() W <span class="cov0" title="0">{
        return p.Neg()
}</span>

// TryOpInv returns the group inverse of this point.
func (p *PointTrait[FP, P, T, W, WT]) TryOpInv() (W, error) <span class="cov0" title="0">{
        return p.Neg(), nil
}</span>

// PrimePointTrait provides helpers for prime-order points.
type PrimePointTrait[FP fields.FiniteFieldElement[FP], P points.PointPtr[FP, P, T], T any, W PointWrapperPtrConstraint[FP, P, WT], WT any] struct {
        PointTrait[FP, P, T, W, WT]
}

// IsDesignatedGenerator reports whether this point is the curve generator.
func (p *PrimePointTrait[FP, P, T, W, WT]) IsDesignatedGenerator() bool <span class="cov0" title="0">{
        var generator WT
        W(&amp;generator).P().SetGenerator()
        return p.Equal(&amp;generator)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package traits

import (
        "encoding/binary"
        "hash/fnv"
        "io"
        "iter"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

// FiniteFieldElementWrapper exposes the underlying finite field element.
type FiniteFieldElementWrapper[FP fieldsImpl.FiniteFieldElement[FP]] interface {
        // Fp defines the Fp operation.
        Fp() FP
}

// FiniteFieldElementWrapperPtrConstraint restricts wrappers to pointer receivers.
type FiniteFieldElementWrapperPtrConstraint[FP fieldsImpl.FiniteFieldElement[FP], W any] interface {
        *W
        FiniteFieldElementWrapper[FP]
}

// FiniteFieldTrait provides common constructor/iterator helpers for finite fields.
type FiniteFieldTrait[FP fieldsImpl.FiniteFieldElement[FP], WP FiniteFieldElementWrapperPtrConstraint[FP, W], W any] struct{}

// FromComponentsBytes builds an element from big-endian component byte slices.
func (*FiniteFieldTrait[FP, WP, W]) FromComponentsBytes(data [][]byte) (WP, error) <span class="cov0" title="0">{
        leData := make([][]byte, len(data))
        for i, d := range data </span><span class="cov0" title="0">{
                leData[i] = sliceutils.Reversed(d)
        }</span>
        <span class="cov0" title="0">var e W
        if ok := WP(&amp;e).Fp().SetUniformBytes(leData...); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("cannot set byte")
        }</span>
        <span class="cov0" title="0">return &amp;e, nil</span>
}

// Random samples a field element using the provided PRNG.
func (*FiniteFieldTrait[FP, WP, W]) Random(prng io.Reader) (WP, error) <span class="cov0" title="0">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, curves.ErrNil.WithMessage("prng")
        }</span>
        <span class="cov0" title="0">var rand W
        if ok := WP(&amp;rand).Fp().SetRandom(prng); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrRandomSample.WithMessage("cannot sample field element")
        }</span>
        <span class="cov0" title="0">return &amp;rand, nil</span>
}

// Iter returns an iterator over field elements starting at one.
func (f *FiniteFieldTrait[FP, WP, W]) Iter() iter.Seq[WP] <span class="cov0" title="0">{
        return func(yield func(WP) bool) </span><span class="cov0" title="0">{
                generator := f.One()

                var current W
                WP(&amp;current).Fp().Set(generator.Fp())

                for WP(&amp;current).Fp().IsZero() == 0 </span><span class="cov0" title="0">{
                        if !yield(WP(&amp;current)) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">WP(&amp;current).Fp().Add(WP(&amp;current).Fp(), generator.Fp())</span>
                }
        }
}

// One returns the multiplicative identity.
func (*FiniteFieldTrait[FP, WP, W]) One() WP <span class="cov0" title="0">{
        var one W
        WP(&amp;one).Fp().SetOne()
        return &amp;one
}</span>

// Zero returns the additive identity.
func (*FiniteFieldTrait[FP, WP, W]) Zero() WP <span class="cov0" title="0">{
        var zero W
        WP(&amp;zero).Fp().SetZero()
        return &amp;zero
}</span>

// OpIdentity returns the additive identity for the group operation.
func (f *FiniteFieldTrait[FP, WP, W]) OpIdentity() WP <span class="cov0" title="0">{
        return f.Zero()
}</span>

// FiniteFieldElementTrait implements common arithmetic operations for elements.
type FiniteFieldElementTrait[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any, WP FiniteFieldElementWrapperPtrConstraint[FP, W], W any] struct {
        V F
}

// Fp returns the underlying field element pointer.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Fp() FP <span class="cov0" title="0">{
        return &amp;fe.V
}</span>

// Clone returns a new element with the same value.
func (*FiniteFieldElementTrait[FP, F, WP, W]) Clone() WP <span class="cov0" title="0">{
        var clone W
        WP(&amp;clone).Fp()
        return &amp;clone
}</span>

// Add returns the sum of this element and e.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Add(e WP) WP <span class="cov0" title="0">{
        var sum W
        WP(&amp;sum).Fp().Add(&amp;fe.V, e.Fp())
        return &amp;sum
}</span>

// Double returns the element multiplied by two.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Double() WP <span class="cov0" title="0">{
        return fe.Add(fe.Clone())
}</span>

// Sub returns the difference of this element and e.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Sub(e WP) WP <span class="cov0" title="0">{
        var diff W
        WP(&amp;diff).Fp().Sub(&amp;fe.V, e.Fp())
        return &amp;diff
}</span>

// Neg returns the additive inverse of this element.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Neg() WP <span class="cov0" title="0">{
        var neg W
        WP(&amp;neg).Fp().Neg(&amp;fe.V)
        return &amp;neg
}</span>

// Mul returns the product of this element and e.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Mul(e WP) WP <span class="cov0" title="0">{
        var prod W
        WP(&amp;prod).Fp().Mul(&amp;fe.V, e.Fp())
        return &amp;prod
}</span>

// Square returns the square of this element.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Square() WP <span class="cov0" title="0">{
        var square W
        WP(&amp;square).Fp().Square(&amp;fe.V)
        return &amp;square
}</span>

// TryInv computes the multiplicative inverse, or returns an error on zero.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) TryInv() (WP, error) <span class="cov0" title="0">{
        var inv W
        if ok := WP(&amp;inv).Fp().Inv(&amp;fe.V); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("division by zero")
        }</span>
        <span class="cov0" title="0">return &amp;inv, nil</span>
}

// TryDiv divides this element by e, or returns an error on zero divisor.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) TryDiv(e WP) (WP, error) <span class="cov0" title="0">{
        var q W
        if ok := WP(&amp;q).Fp().Div(&amp;fe.V, e.Fp()); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("division by zero")
        }</span>
        <span class="cov0" title="0">return &amp;q, nil</span>
}

// EuclideanDiv returns the quotient and zero remainder for field division.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) EuclideanDiv(rhs WP) (quot, rem WP, err error) <span class="cov0" title="0">{
        q, err := fe.TryDiv(rhs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("division by zero")
        }</span>
        <span class="cov0" title="0">var r W
        WP(&amp;r).Fp().SetZero()
        return q, &amp;r, nil</span>
}

// Equal reports whether this element equals rhs.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Equal(rhs WP) bool <span class="cov0" title="0">{
        return FP(&amp;fe.V).Equal(rhs.Fp()) != 0
}</span>

// HashCode returns a stable hash of the element's components.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        for _, bs := range FP(&amp;fe.V).ComponentsBytes() </span><span class="cov0" title="0">{
                _, _ = h.Write(binary.BigEndian.AppendUint64(nil, uint64(len(bs))))
                _, _ = h.Write(bs)
        }</span>

        <span class="cov0" title="0">return base.HashCode(h.Sum64())</span>
}

// IsOne reports whether the element is one.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) IsOne() bool <span class="cov0" title="0">{
        return FP(&amp;fe.V).IsOne() != 0
}</span>

// IsZero reports whether the element is zero.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) IsZero() bool <span class="cov0" title="0">{
        return FP(&amp;fe.V).IsOne() != 0
}</span>

// Bytes returns the concatenated big-endian component bytes.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(fe.ComponentsBytes()...)
}</span>

// ComponentsBytes returns big-endian component byte slices.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        leData := FP(&amp;fe.V).ComponentsBytes()
        beData := make([][]byte, len(leData))
        for i, d := range leData </span><span class="cov0" title="0">{
                beData[i] = sliceutils.Reverse(d)
        }</span>
        <span class="cov0" title="0">return beData</span>
}

// Op returns the group operation result (addition).
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) Op(e WP) WP <span class="cov0" title="0">{
        return fe.Add(e)
}</span>

// OtherOp returns the secondary operation result (multiplication).
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) OtherOp(e WP) WP <span class="cov0" title="0">{
        return fe.Mul(e)
}</span>

// IsOpIdentity reports whether the element is the additive identity.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) IsOpIdentity() bool <span class="cov0" title="0">{
        return fe.IsZero()
}</span>

// TryOpInv returns the additive inverse for the group operation.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) TryOpInv() (WP, error) <span class="cov0" title="0">{
        return fe.Neg(), nil
}</span>

// TryNeg returns the additive inverse.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) TryNeg() (WP, error) <span class="cov0" title="0">{
        return fe.Neg(), nil
}</span>

// TrySub returns the difference between this element and me.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) TrySub(me WP) (WP, error) <span class="cov0" title="0">{
        return fe.Sub(me), nil
}</span>

// OpInv returns the additive inverse for the group operation.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) OpInv() WP <span class="cov0" title="0">{
        return fe.Neg()
}</span>

// EuclideanValuation returns 0 for zero and 1 otherwise.
func (fe *FiniteFieldElementTrait[FP, F, WP, W]) EuclideanValuation() cardinal.Cardinal <span class="cov0" title="0">{
        if fe.IsZero() </span><span class="cov0" title="0">{
                return cardinal.Zero()
        }</span> else<span class="cov0" title="0"> {
                return cardinal.New(1)
        }</span>
}

// IsProbablyPrime is unimplemented for finite fields.
func (*FiniteFieldElementTrait[FP, F, WP, W]) IsProbablyPrime() bool <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// String is unimplemented for finite fields.
func (*FiniteFieldElementTrait[FP, F, WP, W]) String() string <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package traits

import (
        "hash/fnv"
        "io"
        "iter"
        "math/big"

        "github.com/bronlabs/bron-crypto/pkg/base"
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

// PrimeFieldElementWrapper exposes the underlying prime field element.
type PrimeFieldElementWrapper[FP fieldsImpl.PrimeFieldElement[FP]] interface {
        // Fp defines the Fp operation.
        Fp() FP
}

// PrimeFieldElementWrapperPtrConstraint restricts wrappers to pointer receivers.
type PrimeFieldElementWrapperPtrConstraint[FP fieldsImpl.PrimeFieldElement[FP], W any] interface {
        *W
        PrimeFieldElementWrapper[FP]
}

// PrimeFieldTrait provides constructors and helpers for prime fields.
type PrimeFieldTrait[FP fieldsImpl.PrimeFieldElement[FP], WP PrimeFieldElementWrapperPtrConstraint[FP, W], W any] struct{}

// IsDomain reports whether the field forms an integral domain.
func (*PrimeFieldTrait[FP, WP, W]) IsDomain() bool <span class="cov0" title="0">{
        return true
}</span>

// FromBytes builds an element from big-endian bytes.
func (*PrimeFieldTrait[FP, WP, W]) FromBytes(bytes []byte) (WP, error) <span class="cov0" title="0">{
        leBytes := sliceutils.Reversed(bytes)
        var e W
        if ok := WP(&amp;e).Fp().SetBytes(leBytes); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("cannot set bytes")
        }</span>
        <span class="cov0" title="0">return &amp;e, nil</span>
}

// FromBytesBE builds an element from big-endian bytes.
func (f *PrimeFieldTrait[FP, WP, W]) FromBytesBE(input []byte) (WP, error) <span class="cov0" title="0">{
        return f.FromBytes(input)
}</span>

// FromWideBytes builds an element from wide big-endian bytes.
func (*PrimeFieldTrait[FP, WP, W]) FromWideBytes(bytes []byte) (WP, error) <span class="cov0" title="0">{
        leBytes := sliceutils.Reversed(bytes)
        var e W
        if ok := WP(&amp;e).Fp().SetBytesWide(leBytes); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("cannot set bytes")
        }</span>
        <span class="cov0" title="0">return &amp;e, nil</span>
}

// FromComponentsBytes builds an element from big-endian component byte slices.
func (*PrimeFieldTrait[FP, WP, W]) FromComponentsBytes(data [][]byte) (WP, error) <span class="cov0" title="0">{
        leData := make([][]byte, len(data))
        for i, d := range data </span><span class="cov0" title="0">{
                leData[i] = sliceutils.Reversed(d)
        }</span>
        <span class="cov0" title="0">var e W
        if ok := WP(&amp;e).Fp().SetUniformBytes(leData...); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("cannot set uniform bytes")
        }</span>
        <span class="cov0" title="0">return &amp;e, nil</span>
}

// FromUint64 builds an element from a uint64 value.
func (*PrimeFieldTrait[FP, WP, W]) FromUint64(v uint64) WP <span class="cov0" title="0">{
        var e W
        WP(&amp;e).Fp().SetUint64(v)
        return &amp;e
}</span>

// FromCardinal builds an element from a cardinal value.
func (*PrimeFieldTrait[FP, WP, W]) FromCardinal(card cardinal.Cardinal) (WP, error) <span class="cov0" title="0">{
        leData := sliceutils.Reverse(card.Bytes())
        var e W
        if ok := WP(&amp;e).Fp().SetBytesWide(leData); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("cannot set wide bytes")
        }</span>
        <span class="cov0" title="0">return &amp;e, nil</span>
}

// One returns the multiplicative identity.
func (*PrimeFieldTrait[FP, WP, W]) One() WP <span class="cov0" title="0">{
        var one W
        WP(&amp;one).Fp().SetOne()
        return &amp;one
}</span>

// Zero returns the additive identity.
func (*PrimeFieldTrait[FP, WP, W]) Zero() WP <span class="cov0" title="0">{
        var zero W
        WP(&amp;zero).Fp().SetZero()
        return &amp;zero
}</span>

// Iter returns an iterator over field elements starting at one.
func (f *PrimeFieldTrait[FP, WP, W]) Iter() iter.Seq[WP] <span class="cov0" title="0">{
        return func(yield func(WP) bool) </span><span class="cov0" title="0">{
                generator := f.One()

                var current W
                WP(&amp;current).Fp().Set(generator.Fp())

                for WP(&amp;current).Fp().IsZero() == 0 </span><span class="cov0" title="0">{
                        if !yield(WP(&amp;current)) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">WP(&amp;current).Fp().Add(WP(&amp;current).Fp(), generator.Fp())</span>
                }
        }
}

// Random samples a field element using the provided PRNG.
func (*PrimeFieldTrait[FP, WP, W]) Random(prng io.Reader) (WP, error) <span class="cov0" title="0">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, curves.ErrNil.WithMessage("prng")
        }</span>
        <span class="cov0" title="0">var rand W
        if ok := WP(&amp;rand).Fp().SetRandom(prng); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrRandomSample.WithMessage("cannot sample prime field element")
        }</span>
        <span class="cov0" title="0">return &amp;rand, nil</span>
}

// ExtensionDegree returns the degree of the prime field extension.
func (*PrimeFieldTrait[FP, WP, W]) ExtensionDegree() uint <span class="cov0" title="0">{
        return 1
}</span>

// PartialCompare returns a partial ordering for x and y.
func (f *PrimeFieldTrait[FP, WP, W]) PartialCompare(x, y WP) base.PartialOrdering <span class="cov0" title="0">{
        return base.PartialOrdering(f.Compare(x, y))
}</span>

// Compare returns an ordering for x and y.
func (*PrimeFieldTrait[FP, WP, W]) Compare(x, y WP) base.Ordering <span class="cov0" title="0">{
        out := base.ParseOrderingFromMasks(fieldsImpl.SliceCmpLE(x.Fp().Limbs(), y.Fp().Limbs()))
        if out.IsIncomparable() </span><span class="cov0" title="0">{
                panic("prime field elements cannot be incomparable")</span>
        }
        <span class="cov0" title="0">return base.Ordering(out)</span>
}

// OpIdentity returns the additive identity for the group operation.
func (f *PrimeFieldTrait[FP, WP, W]) OpIdentity() WP <span class="cov0" title="0">{
        return f.Zero()
}</span>

// SubFieldIdentity is unimplemented for prime fields.
func (*PrimeFieldTrait[FP, WP, W]) SubFieldIdentity(i uint) (any, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// PrimeFieldElementTrait implements common arithmetic operations for elements.
type PrimeFieldElementTrait[FP fieldsImpl.PrimeFieldElementPtr[FP, F], F any, WP PrimeFieldElementWrapperPtrConstraint[FP, W], W any] struct {
        V F
}

// Fp returns the underlying field element pointer.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Fp() FP <span class="cov0" title="0">{
        return &amp;fe.V
}</span>

// Clone returns a new element with the same value.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Clone() WP <span class="cov0" title="0">{
        var clone W
        WP(&amp;clone).Fp().Set(&amp;fe.V)
        return &amp;clone
}</span>

// Add returns the sum of this element and e.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Add(e WP) WP <span class="cov0" title="0">{
        var sum W
        WP(&amp;sum).Fp().Add(&amp;fe.V, e.Fp())
        return &amp;sum
}</span>

// Double returns the element multiplied by two.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Double() WP <span class="cov0" title="0">{
        return fe.Add(fe.Clone())
}</span>

// Sub returns the difference of this element and e.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Sub(e WP) WP <span class="cov0" title="0">{
        var diff W
        WP(&amp;diff).Fp().Sub(&amp;fe.V, e.Fp())
        return &amp;diff
}</span>

// Neg returns the additive inverse of this element.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Neg() WP <span class="cov0" title="0">{
        var neg W
        WP(&amp;neg).Fp().Neg(&amp;fe.V)
        return &amp;neg
}</span>

// Mul returns the product of this element and e.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Mul(e WP) WP <span class="cov0" title="0">{
        var prod W
        WP(&amp;prod).Fp().Mul(&amp;fe.V, e.Fp())
        return &amp;prod
}</span>

// Square returns the square of this element.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Square() WP <span class="cov0" title="0">{
        var square W
        WP(&amp;square).Fp().Square(&amp;fe.V)
        return &amp;square
}</span>

// TryInv computes the multiplicative inverse, or returns an error on zero.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) TryInv() (WP, error) <span class="cov0" title="0">{
        var inv W
        if ok := WP(&amp;inv).Fp().Inv(&amp;fe.V); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("division by zero")
        }</span>
        <span class="cov0" title="0">return &amp;inv, nil</span>
}

// TryDiv divides this element by e, or returns an error on zero divisor.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) TryDiv(e WP) (WP, error) <span class="cov0" title="0">{
        var quot W
        if ok := WP(&amp;quot).Fp().Div(&amp;fe.V, e.Fp()); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("division by zero")
        }</span>
        <span class="cov0" title="0">return &amp;quot, nil</span>
}

// EuclideanDiv returns the quotient and zero remainder for field division.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) EuclideanDiv(rhs WP) (quot, rem WP, err error) <span class="cov0" title="0">{
        quot, err = fe.TryDiv(rhs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("division by zero")
        }</span>

        <span class="cov0" title="0">var r W
        WP(&amp;r).Fp().SetZero()
        return quot, &amp;r, nil</span>
}

// IsZero reports whether the element is zero.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsZero() bool <span class="cov0" title="0">{
        return FP(&amp;fe.V).IsZero() != 0
}</span>

// IsOne reports whether the element is one.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsOne() bool <span class="cov0" title="0">{
        return FP(&amp;fe.V).IsOne() != 0
}</span>

// Equal reports whether this element equals rhs.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Equal(rhs WP) bool <span class="cov0" title="0">{
        return FP(&amp;fe.V).Equal(rhs.Fp()) != 0
}</span>

// IsLessThanOrEqual reports whether this element is &lt;= rhs.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsLessThanOrEqual(rhs WP) bool <span class="cov0" title="0">{
        out := base.ParseOrderingFromMasks(fieldsImpl.SliceCmpLE(FP(&amp;fe.V).Limbs(), rhs.Fp().Limbs()))
        if out == base.Incomparable </span><span class="cov0" title="0">{
                panic("prime field elements cannot be incomparable")</span>
        }
        <span class="cov0" title="0">return out.IsLessThan() || out.IsEqual()</span>
}

// IsOdd reports whether the element is odd.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsOdd() bool <span class="cov0" title="0">{
        return fieldsImpl.IsOdd[FP](&amp;fe.V) != 0
}</span>

// IsEven reports whether the element is even.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsEven() bool <span class="cov0" title="0">{
        return !fe.IsOdd()
}</span>

// IsNegative reports whether the element is negative in the field's ordering.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsNegative() bool <span class="cov0" title="0">{
        return fieldsImpl.IsNegative[FP](&amp;fe.V) != 0
}</span>

// IsPositive reports whether the element is non-negative in the field's ordering.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsPositive() bool <span class="cov0" title="0">{
        return !fe.IsNegative()
}</span>

// HashCode returns a stable hash of the element bytes.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(FP(&amp;fe.V).Bytes())
        return base.HashCode(h.Sum64())
}</span>

// Bytes returns the big-endian byte encoding.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Bytes() []byte <span class="cov0" title="0">{
        return sliceutils.Reverse(FP(&amp;fe.V).Bytes())
}</span>

// BytesBE returns the big-endian byte encoding.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) BytesBE() []byte <span class="cov0" title="0">{
        return sliceutils.Reverse(FP(&amp;fe.V).Bytes())
}</span>

// ComponentsBytes returns big-endian component byte slices.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        beBytes := make([][]byte, 1) // not a field extension
        beBytes[0] = fe.BytesBE()
        return beBytes
}</span>

// Cardinal converts the element to a cardinal value.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Cardinal() cardinal.Cardinal <span class="cov0" title="0">{
        data := sliceutils.Reverse(FP(&amp;fe.V).Bytes())
        var nat numct.Nat
        nat.SetBytes(data)
        return cardinal.NewFromNumeric(&amp;nat)
}</span>

// Op returns the group operation result (addition).
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) Op(e WP) WP <span class="cov0" title="0">{
        return fe.Add(e)
}</span>

// OtherOp returns the secondary operation result (multiplication).
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) OtherOp(e WP) WP <span class="cov0" title="0">{
        return fe.Mul(e)
}</span>

// TrySub returns the difference between this element and me.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) TrySub(me WP) (WP, error) <span class="cov0" title="0">{
        return fe.Sub(me), nil
}</span>

// OpInv returns the additive inverse for the group operation.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) OpInv() WP <span class="cov0" title="0">{
        return fe.Neg()
}</span>

// TryNeg returns the additive inverse.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) TryNeg() (WP, error) <span class="cov0" title="0">{
        return fe.Neg(), nil
}</span>

// IsProbablyPrime reports whether the element interpreted as an integer is probably prime.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsProbablyPrime() bool <span class="cov0" title="0">{
        return new(big.Int).SetBytes(fe.Bytes()).ProbablyPrime(0)
}</span>

// IsOpIdentity reports whether the element is the additive identity.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) IsOpIdentity() bool <span class="cov0" title="0">{
        return fe.IsZero()
}</span>

// TryOpInv returns the additive inverse for the group operation.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) TryOpInv() (WP, error) <span class="cov0" title="0">{
        return fe.Neg(), nil
}</span>

// EuclideanValuation returns 0 for zero and 1 otherwise.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) EuclideanValuation() cardinal.Cardinal <span class="cov0" title="0">{
        if fe.IsZero() </span><span class="cov0" title="0">{
                return cardinal.Zero()
        }</span> else<span class="cov0" title="0"> {
                return cardinal.New(1)
        }</span>
}

// String returns the base-10 integer representation of the element.
func (fe *PrimeFieldElementTrait[FP, F, WP, W]) String() string <span class="cov0" title="0">{
        data := sliceutils.Reverse(FP(&amp;fe.V).Bytes())
        return new(big.Int).SetBytes(data).String()
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package k256

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*BaseFieldElement)(nil)
        _ cbor.Unmarshaler = (*BaseFieldElement)(nil)
        _ cbor.Marshaler   = (*Scalar)(nil)
        _ cbor.Unmarshaler = (*Scalar)(nil)
        _ cbor.Marshaler   = (*Point)(nil)
        _ cbor.Unmarshaler = (*Point)(nil)
)

type baseFieldDTO struct {
        BaseFieldBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *BaseFieldElement) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;baseFieldDTO{BaseFieldBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *BaseFieldElement) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*baseFieldDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">bfe, err := NewBaseField().FromBytes(dto.BaseFieldBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize base field element")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;bfe.V)
        return nil</span>
}

type scalarDTO struct {
        ScalarBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *Scalar) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;scalarDTO{ScalarBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *Scalar) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*scalarDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s, err := NewScalarField().FromBytes(dto.ScalarBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize scalar")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;s.V)
        return nil</span>
}

type pointDTO struct {
        AffineCompressedBytes []byte `cbor:"compressedBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (p *Point) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;pointDTO{AffineCompressedBytes: p.ToCompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *Point) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[pointDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pp, err := NewCurve().FromCompressed(dto.AffineCompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov8" title="1">p.V.Set(&amp;pp.V)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package k256

import (
        "crypto/elliptic"
        "encoding"
        "fmt"
        "hash/fnv"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        k256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // CurveName is the curve name.
        CurveName = "secp256k1"
        // Hash2CurveSuite is the hash-to-curve suite string.
        Hash2CurveSuite = "secp256k1_XMD:SHA-256_SSWU_RO_"
        // Hash2CurveScalarSuite is the hash-to-curve scalar suite string.
        Hash2CurveScalarSuite = "secp256k1_XMD:SHA-256_SSWU_RO_SC_"
        compressedPointBytes  = k256Impl.FqBytes + 1
)

var (
        _ curves.Curve[*Point, *BaseFieldElement, *Scalar] = (*Curve)(nil)
        _ curves.Point[*Point, *BaseFieldElement, *Scalar] = (*Point)(nil)
        _ encoding.BinaryMarshaler                         = (*Point)(nil)
        _ encoding.BinaryUnmarshaler                       = (*Point)(nil)

        // compressedPointSize = k256Impl.FqBytes + 1.

        curveInstance *Curve
        curveInitOnce sync.Once
)

// Curve represents the elliptic curve group.
type Curve struct {
        traits.PrimeCurveTrait[*k256Impl.Fp, *k256Impl.Point, *Point, Point]
}

// NewCurve returns the curve instance.
func NewCurve() *Curve <span class="cov8" title="1">{
        curveInitOnce.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for a trait
                curveInstance = &amp;Curve{}
        }</span>)

        <span class="cov8" title="1">return curveInstance</span>
}

// Name returns the name of the structure.
func (*Curve) Name() string <span class="cov0" title="0">{
        return CurveName
}</span>

// Cofactor returns the curve cofactor.
func (*Curve) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(1)
}</span>

// Order returns the group or field order.
func (*Curve) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewScalarField().Order()
}</span>

// ElementSize returns the element size in bytes.
func (*Curve) ElementSize() int <span class="cov0" title="0">{
        return compressedPointBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*Curve) WideElementSize() int <span class="cov0" title="0">{
        return int(^uint(0) &gt;&gt; 1)
}</span>

// FromWideBytes decodes an element from wide bytes.
func (c *Curve) FromWideBytes(input []byte) (*Point, error) <span class="cov0" title="0">{
        return c.Hash(input)
}</span>

// FromCompressed decodes a compressed point.
func (c *Curve) FromCompressed(input []byte) (*Point, error) <span class="cov8" title="1">{
        if len(input) != compressedPointBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid byte sequence")
        }</span>

        <span class="cov8" title="1">sign := input[0]
        if sign != 2 &amp;&amp; sign != 3 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid sign byte")
        }</span>
        <span class="cov8" title="1">sign &amp;= 0x1

        var xBytes [k256Impl.FpBytes]byte
        copy(xBytes[:], input[1:])
        slices.Reverse(xBytes[:])

        var x, y k256Impl.Fp
        ok := x.SetBytes(xBytes[:])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov8" title="1">if x.IsZero() == 1 </span><span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov8" title="1">var result Point
        ok = result.V.SetFromAffineX(&amp;x)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov8" title="1">ok = result.V.ToAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov8" title="1">ySign := result.V.Y.Bytes()[0] &amp; 0b1
        if sign != ySign </span><span class="cov0" title="0">{
                result.V.Neg(&amp;result.V)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// FromUncompressed decodes an uncompressed point.
func (c *Curve) FromUncompressed(input []byte) (*Point, error) <span class="cov0" title="0">{
        if len(input) != 65 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid byte sequence")
        }</span>
        <span class="cov0" title="0">if input[0] != 4 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid sign byte")
        }</span>

        <span class="cov0" title="0">var xBytes, yBytes [32]byte
        copy(xBytes[:], input[1:33])
        copy(yBytes[:], input[33:])
        slices.Reverse(xBytes[:])
        slices.Reverse(yBytes[:])

        var x, y k256Impl.Fp
        okx := x.SetBytes(xBytes[:])
        if okx != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov0" title="0">oky := y.SetBytes(yBytes[:])
        if oky != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("y")
        }</span>
        <span class="cov0" title="0">if x.IsZero() == 1 &amp;&amp; y.IsZero() == 1 </span><span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov0" title="0">var result Point
        ok := result.V.SetAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// FromAffine builds a point from affine coordinates.
func (*Curve) FromAffine(x, y *BaseFieldElement) (*Point, error) <span class="cov0" title="0">{
        var p Point
        ok := p.V.SetAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

// FromAffineX builds a point from an affine x-coordinate.
func (*Curve) FromAffineX(x *BaseFieldElement, b bool) (*Point, error) <span class="cov0" title="0">{
        var p Point
        ok := p.V.SetFromAffineX(&amp;x.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov0" title="0">y, err := p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // should never happen
        }
        <span class="cov0" title="0">if y.IsOdd() != b </span><span class="cov0" title="0">{
                return p.Neg(), nil
        }</span> else<span class="cov0" title="0"> {
                return &amp;p, nil
        }</span>
}

// Hash maps input bytes to an element or point.
func (c *Curve) Hash(bytes []byte) (*Point, error) <span class="cov0" title="0">{
        return c.HashWithDst(base.Hash2CurveAppTag+Hash2CurveSuite, bytes)
}</span>

// HashWithDst maps input bytes to a point with a custom DST.
func (*Curve) HashWithDst(dst string, bytes []byte) (*Point, error) <span class="cov0" title="0">{
        p := Point{}
        p.V.Hash(dst, bytes)
        return &amp;p, nil
}</span>

// ScalarStructure returns the scalar structure.
func (*Curve) ScalarStructure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseStructure returns the base field structure.
func (*Curve) BaseStructure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// ScalarRing returns the scalar ring.
func (*Curve) ScalarRing() algebra.ZModLike[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarField returns the scalar field.
func (*Curve) ScalarField() algebra.PrimeField[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseField returns the base field.
func (*Curve) BaseField() algebra.FiniteField[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// ScalarBaseOp adds a scalar multiple of the generator.
func (c *Curve) ScalarBaseOp(sc *Scalar) *Point <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if sc == nil </span><span class="cov0" title="0">{
                panic("scalar is nil")</span>
        }
        <span class="cov0" title="0">if sc.IsZero() </span><span class="cov0" title="0">{
                return c.OpIdentity()
        }</span>
        <span class="cov0" title="0">return c.ScalarBaseMul(sc)</span>
}

// ScalarBaseMul multiplies the generator by a scalar.
func (c *Curve) ScalarBaseMul(sc *Scalar) *Point <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if sc == nil </span><span class="cov0" title="0">{
                panic("scalar is nil")</span>
        }
        <span class="cov0" title="0">return c.Generator().ScalarMul(sc)</span>
}

// FromBytes decodes an element from bytes.
func (c *Curve) FromBytes(data []byte) (*Point, error) <span class="cov0" title="0">{
        return c.FromCompressed(data)
}</span>

// ToElliptic returns the standard library elliptic.Curve adapter.
func (*Curve) ToElliptic() elliptic.Curve <span class="cov0" title="0">{
        return ellipticK256Instance
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *Curve) MultiScalarOp(scalars []*Scalar, points []*Point) (*Point, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*Curve) MultiScalarMul(scalars []*Scalar, points []*Point) (*Point, error) <span class="cov8" title="1">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov8" title="1">var result Point
        scs := make([][]byte, len(scalars))
        pts := make([]*k256Impl.Point, len(points))
        for i := range points </span><span class="cov8" title="1">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov8" title="1">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// Point represents a curve point.
type Point struct {
        traits.PrimePointTrait[*k256Impl.Fp, *k256Impl.Point, k256Impl.Point, *Point, Point]
}

// HashCode returns a hash code for the receiver.
func (p *Point) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(p.ToCompressed())
        return base.HashCode(h.Sum64())
}</span>

// Structure returns the algebraic structure for the receiver.
func (Point) Structure() algebra.Structure[*Point] <span class="cov0" title="0">{
        return NewCurve()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (p *Point) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return p.ToCompressed(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (p *Point) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        pp, err := NewCurve().FromCompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>

        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}

// Bytes returns the canonical byte encoding.
func (p *Point) Bytes() []byte <span class="cov0" title="0">{
        return p.ToCompressed()
}</span>

// ToCompressed encodes the point in compressed form.
func (p *Point) ToCompressed() []byte <span class="cov8" title="1">{
        var compressedBytes [compressedPointBytes]byte
        compressedBytes[0] = byte(2)
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                return compressedBytes[:]
        }</span>

        <span class="cov8" title="1">var px, py k256Impl.Fp
        ok := p.V.ToAffine(&amp;px, &amp;py)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov8" title="1">compressedBytes[0] |= py.Bytes()[0] &amp; 1
        pxBytes := px.Bytes()
        slices.Reverse(pxBytes)
        copy(compressedBytes[1:], pxBytes)
        return compressedBytes[:]</span>
}

// ToUncompressed encodes the point in uncompressed form.
func (p *Point) ToUncompressed() []byte <span class="cov0" title="0">{
        var out [65]byte
        out[0] = byte(4)
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                return out[:]
        }</span>

        <span class="cov0" title="0">var px, py k256Impl.Fp
        ok := p.V.ToAffine(&amp;px, &amp;py)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov0" title="0">pxBytes := px.Bytes()
        slices.Reverse(pxBytes)
        copy(out[1:33], pxBytes)

        pyBytes := py.Bytes()
        slices.Reverse(pyBytes)
        copy(out[33:], pyBytes)

        return out[:]</span>
}

// AffineX returns the affine x-coordinate.
func (p *Point) AffineX() (*BaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;x, nil</span>
}

// AffineY returns the affine y-coordinate.
func (p *Point) AffineY() (*BaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;y, nil</span>
}

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *Point) ScalarOp(sc *Scalar) *Point <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *Point) ScalarMul(actor *Scalar) *Point <span class="cov8" title="1">{
        var result Point
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (*Point) IsTorsionFree() bool <span class="cov0" title="0">{
        return true
}</span>

// String returns the string form of the receiver.
func (p *Point) String() string <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return "(0, 1, 0)"
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("(%s, %s, %s)", p.V.X.String(), p.V.Y.String(), p.V.Z.String())
        }</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package k256

import (
        "crypto/elliptic"
        "math/big"
        "slices"

        k256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl"
)

var (
        ellipticK256Params = &amp;elliptic.CurveParams{
                P:       mustSetBigIntString("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                N:       mustSetBigIntString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
                B:       mustSetBigIntString("0000000000000000000000000000000000000000000000000000000000000007"),
                Gx:      mustSetBigIntString("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
                Gy:      mustSetBigIntString("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"),
                BitSize: k256Impl.FpBits,
                Name:    CurveName,
        }
        ellipticK256Instance = &amp;ellipticK256{}
)

type ellipticK256 struct {
}

// Params returns the curve parameters.
func (*ellipticK256) Params() *elliptic.CurveParams <span class="cov0" title="0">{
        return ellipticK256Params
}</span>

// IsOnCurve reports whether the point is on the curve.
func (*ellipticK256) IsOnCurve(x, y *big.Int) bool <span class="cov0" title="0">{
        // IsOnCurve is documented to reject (0, 0), the conventional point at infinity.
        if x.Sign() == 0 &amp;&amp; y.Sign() == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, err := fromAffine(x, y)
        return err != nil</span>
}

// Add sets the receiver to lhs + rhs.
func (*ellipticK256) Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int) <span class="cov0" title="0">{
        p1, err := fromAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("Add was called on an invalid point")</span>
        }
        <span class="cov0" title="0">p2, err := fromAffine(x2, y2)
        if err != nil </span><span class="cov0" title="0">{
                panic("Add was called on an invalid point")</span>
        }
        <span class="cov0" title="0">return toAffine(p1.Add(p2))</span>
}

// Double sets the receiver to 2*x.
func (*ellipticK256) Double(x1, y1 *big.Int) (x, y *big.Int) <span class="cov0" title="0">{
        p, err := fromAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("Double was called on an invalid point")</span>
        }
        <span class="cov0" title="0">return toAffine(p.Double())</span>
}

// ScalarMult multiplies a point by a scalar.
func (*ellipticK256) ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int) <span class="cov0" title="0">{
        p, err := fromAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called on an invalid point")</span>
        }
        <span class="cov0" title="0">s, err := NewScalarField().FromWideBytes(k)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called with an invalid scalar")</span>
        }

        <span class="cov0" title="0">return toAffine(p.ScalarMul(s))</span>
}

// ScalarBaseMult multiplies the generator by a scalar.
func (*ellipticK256) ScalarBaseMult(k []byte) (x, y *big.Int) <span class="cov0" title="0">{
        s, err := NewScalarField().FromWideBytes(k)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called with an invalid scalar")</span>
        }
        <span class="cov0" title="0">return toAffine(NewCurve().ScalarBaseMul(s))</span>
}

func mustSetBigIntString(s string) *big.Int <span class="cov8" title="1">{
        bi, ok := new(big.Int).SetString(s, 16)
        if !ok </span><span class="cov0" title="0">{
                panic("cannot set Int string")</span>
        }
        <span class="cov8" title="1">return bi</span>
}

func fromAffine(x *big.Int, y *big.Int) (*Point, error) <span class="cov0" title="0">{
        var xBytes, yBytes [32]byte
        x.FillBytes(xBytes[:])
        y.FillBytes(yBytes[:])
        return NewCurve().FromUncompressed(slices.Concat([]byte{0x04}, xBytes[:], yBytes[:]))
}</span>

func toAffine(p *Point) (x *big.Int, y *big.Int) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return new(big.Int), new(big.Int)
        }</span>
        <span class="cov0" title="0">xp, _ := p.AffineX()
        yp, _ := p.AffineY()
        return xp.Cardinal().Big(), yp.Cardinal().Big()</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package k256

import (
        "encoding"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        k256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

const (
        // BaseFieldName is the base field name.
        BaseFieldName = "secp256k1Fp"
)

var (
        _ algebra.PrimeField[*BaseFieldElement]        = (*BaseField)(nil)
        _ algebra.PrimeFieldElement[*BaseFieldElement] = (*BaseFieldElement)(nil)
        _ encoding.BinaryMarshaler                     = (*BaseFieldElement)(nil)
        _ encoding.BinaryUnmarshaler                   = (*BaseFieldElement)(nil)

        baseFieldInstance *BaseField
        baseFieldInitOnce sync.Once
        baseFieldOrder    *numct.Modulus
)

// BaseField represents the curve base field.
type BaseField struct {
        traits.PrimeFieldTrait[*k256Impl.Fp, *BaseFieldElement, BaseFieldElement]
}

// NewBaseField returns the base field instance.
func NewBaseField() *BaseField <span class="cov8" title="1">{
        baseFieldInitOnce.Do(func() </span><span class="cov8" title="1">{
                baseFieldOrder, _ = numct.NewModulusFromBytesBE(sliceutils.Reversed(k256Impl.FpModulus[:]))
                //nolint:exhaustruct // no need for a trait
                baseFieldInstance = &amp;BaseField{}
        }</span>)

        <span class="cov8" title="1">return baseFieldInstance</span>
}

// Name returns the name of the structure.
func (*BaseField) Name() string <span class="cov0" title="0">{
        return BaseFieldName
}</span>

// Order returns the group or field order.
func (*BaseField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(baseFieldOrder.Nat())
}</span>

// Characteristic returns the field characteristic.
func (*BaseField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(baseFieldOrder.Nat())
}</span>

// Hash maps input bytes to an element or point.
func (*BaseField) Hash(bytes []byte) (*BaseFieldElement, error) <span class="cov0" title="0">{
        var e [1]k256Impl.Fp
        h2c.HashToField(e[:], k256Impl.CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveSuite, bytes)

        var s BaseFieldElement
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// ElementSize returns the element size in bytes.
func (*BaseField) ElementSize() int <span class="cov0" title="0">{
        return k256Impl.FpBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*BaseField) WideElementSize() int <span class="cov0" title="0">{
        return k256Impl.FpWideBytes
}</span>

// BitLen returns the field modulus bit length.
func (*BaseField) BitLen() int <span class="cov0" title="0">{
        return k256Impl.FpBits
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *BaseField) FromBytesBEReduce(input []byte) (*BaseFieldElement, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        baseFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// BaseFieldElement represents an element of the base field.
type BaseFieldElement struct {
        traits.PrimeFieldElementTrait[*k256Impl.Fp, k256Impl.Fp, *BaseFieldElement, BaseFieldElement]
}

// Structure returns the algebraic structure for the receiver.
func (*BaseFieldElement) Structure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *BaseFieldElement) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *BaseFieldElement) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("failed to unmarshal field element")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fp 64 '2^256 - 2^32 - 977'
//
// curve description: Fp
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f (from "2^256 - 2^32 - 977")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) in
//
//                            if x1 &amp; (2^256-1) &lt; 2^255 then x1 &amp; (2^256-1) else (x1 &amp; (2^256-1)) - 2^256
package impl

import "math/bits"

type fiatFpUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFpInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFpMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFpMontgomeryDomainFieldElement [4]uint64

// fiatFpNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFpNonMontgomeryDomainFieldElement [4]uint64

// fiatFpCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpCmovznzU64(out1 *uint64, arg1 fiatFpUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFpMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpMul(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg2[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg2[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg2[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg2[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFpUint1(x16)))
        x19 := (uint64(fiatFpUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0xd838091dd2253531)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0xffffffffffffffff)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0xffffffffffffffff)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0xffffffffffffffff)
        var x28 uint64
        var x29 uint64
        x29, x28 = bits.Mul64(x20, 0xfffffffefffffc2f)
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x29, x26, uint64(0x0))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x27, x24, uint64(fiatFpUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x25, x22, uint64(fiatFpUint1(x33)))
        x36 := (uint64(fiatFpUint1(x35)) + x23)
        var x38 uint64
        _, x38 = bits.Add64(x11, x28, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x13, x30, uint64(fiatFpUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x15, x32, uint64(fiatFpUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x17, x34, uint64(fiatFpUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x19, x36, uint64(fiatFpUint1(x44)))
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg2[3])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, arg2[2])
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, arg2[1])
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x1, arg2[0])
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x54, x51, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x52, x49, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x50, x47, uint64(fiatFpUint1(x58)))
        x61 := (uint64(fiatFpUint1(x60)) + x48)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x41, x55, uint64(fiatFpUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x43, x57, uint64(fiatFpUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x45, x59, uint64(fiatFpUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(uint64(fiatFpUint1(x46)), x61, uint64(fiatFpUint1(x69)))
        var x72 uint64
        _, x72 = bits.Mul64(x62, 0xd838091dd2253531)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x72, 0xffffffffffffffff)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x72, 0xffffffffffffffff)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x72, 0xffffffffffffffff)
        var x80 uint64
        var x81 uint64
        x81, x80 = bits.Mul64(x72, 0xfffffffefffffc2f)
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x81, x78, uint64(0x0))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x79, x76, uint64(fiatFpUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x77, x74, uint64(fiatFpUint1(x85)))
        x88 := (uint64(fiatFpUint1(x87)) + x75)
        var x90 uint64
        _, x90 = bits.Add64(x62, x80, uint64(0x0))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x64, x82, uint64(fiatFpUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x66, x84, uint64(fiatFpUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x68, x86, uint64(fiatFpUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x70, x88, uint64(fiatFpUint1(x96)))
        x99 := (uint64(fiatFpUint1(x98)) + uint64(fiatFpUint1(x71)))
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x2, arg2[3])
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x2, arg2[2])
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x2, arg2[1])
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x2, arg2[0])
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFpUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFpUint1(x111)))
        x114 := (uint64(fiatFpUint1(x113)) + x101)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x91, x106, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x93, x108, uint64(fiatFpUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x95, x110, uint64(fiatFpUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x97, x112, uint64(fiatFpUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x99, x114, uint64(fiatFpUint1(x122)))
        var x125 uint64
        _, x125 = bits.Mul64(x115, 0xd838091dd2253531)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x125, 0xffffffffffffffff)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x125, 0xffffffffffffffff)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x125, 0xffffffffffffffff)
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x125, 0xfffffffefffffc2f)
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x134, x131, uint64(0x0))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x132, x129, uint64(fiatFpUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x130, x127, uint64(fiatFpUint1(x138)))
        x141 := (uint64(fiatFpUint1(x140)) + x128)
        var x143 uint64
        _, x143 = bits.Add64(x115, x133, uint64(0x0))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x117, x135, uint64(fiatFpUint1(x143)))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x119, x137, uint64(fiatFpUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x121, x139, uint64(fiatFpUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x123, x141, uint64(fiatFpUint1(x149)))
        x152 := (uint64(fiatFpUint1(x151)) + uint64(fiatFpUint1(x124)))
        var x153 uint64
        var x154 uint64
        x154, x153 = bits.Mul64(x3, arg2[3])
        var x155 uint64
        var x156 uint64
        x156, x155 = bits.Mul64(x3, arg2[2])
        var x157 uint64
        var x158 uint64
        x158, x157 = bits.Mul64(x3, arg2[1])
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x3, arg2[0])
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x160, x157, uint64(0x0))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x158, x155, uint64(fiatFpUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x156, x153, uint64(fiatFpUint1(x164)))
        x167 := (uint64(fiatFpUint1(x166)) + x154)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x144, x159, uint64(0x0))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x146, x161, uint64(fiatFpUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x148, x163, uint64(fiatFpUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64(x150, x165, uint64(fiatFpUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x152, x167, uint64(fiatFpUint1(x175)))
        var x178 uint64
        _, x178 = bits.Mul64(x168, 0xd838091dd2253531)
        var x180 uint64
        var x181 uint64
        x181, x180 = bits.Mul64(x178, 0xffffffffffffffff)
        var x182 uint64
        var x183 uint64
        x183, x182 = bits.Mul64(x178, 0xffffffffffffffff)
        var x184 uint64
        var x185 uint64
        x185, x184 = bits.Mul64(x178, 0xffffffffffffffff)
        var x186 uint64
        var x187 uint64
        x187, x186 = bits.Mul64(x178, 0xfffffffefffffc2f)
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Add64(x187, x184, uint64(0x0))
        var x190 uint64
        var x191 uint64
        x190, x191 = bits.Add64(x185, x182, uint64(fiatFpUint1(x189)))
        var x192 uint64
        var x193 uint64
        x192, x193 = bits.Add64(x183, x180, uint64(fiatFpUint1(x191)))
        x194 := (uint64(fiatFpUint1(x193)) + x181)
        var x196 uint64
        _, x196 = bits.Add64(x168, x186, uint64(0x0))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x170, x188, uint64(fiatFpUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x172, x190, uint64(fiatFpUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x174, x192, uint64(fiatFpUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x176, x194, uint64(fiatFpUint1(x202)))
        x205 := (uint64(fiatFpUint1(x204)) + uint64(fiatFpUint1(x177)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Sub64(x197, 0xfffffffefffffc2f, uint64(0x0))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Sub64(x199, 0xffffffffffffffff, uint64(fiatFpUint1(x207)))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Sub64(x201, 0xffffffffffffffff, uint64(fiatFpUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Sub64(x203, 0xffffffffffffffff, uint64(fiatFpUint1(x211)))
        var x215 uint64
        _, x215 = bits.Sub64(x205, uint64(0x0), uint64(fiatFpUint1(x213)))
        var x216 uint64
        fiatFpCmovznzU64(&amp;x216, fiatFpUint1(x215), x206, x197)
        var x217 uint64
        fiatFpCmovznzU64(&amp;x217, fiatFpUint1(x215), x208, x199)
        var x218 uint64
        fiatFpCmovznzU64(&amp;x218, fiatFpUint1(x215), x210, x201)
        var x219 uint64
        fiatFpCmovznzU64(&amp;x219, fiatFpUint1(x215), x212, x203)
        out1[0] = x216
        out1[1] = x217
        out1[2] = x218
        out1[3] = x219
}</span>

// fiatFpSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFpSquare(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg1[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg1[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg1[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg1[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFpUint1(x16)))
        x19 := (uint64(fiatFpUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0xd838091dd2253531)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0xffffffffffffffff)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0xffffffffffffffff)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0xffffffffffffffff)
        var x28 uint64
        var x29 uint64
        x29, x28 = bits.Mul64(x20, 0xfffffffefffffc2f)
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x29, x26, uint64(0x0))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x27, x24, uint64(fiatFpUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x25, x22, uint64(fiatFpUint1(x33)))
        x36 := (uint64(fiatFpUint1(x35)) + x23)
        var x38 uint64
        _, x38 = bits.Add64(x11, x28, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x13, x30, uint64(fiatFpUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x15, x32, uint64(fiatFpUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x17, x34, uint64(fiatFpUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x19, x36, uint64(fiatFpUint1(x44)))
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg1[3])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, arg1[2])
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, arg1[1])
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x1, arg1[0])
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x54, x51, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x52, x49, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x50, x47, uint64(fiatFpUint1(x58)))
        x61 := (uint64(fiatFpUint1(x60)) + x48)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x41, x55, uint64(fiatFpUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x43, x57, uint64(fiatFpUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x45, x59, uint64(fiatFpUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(uint64(fiatFpUint1(x46)), x61, uint64(fiatFpUint1(x69)))
        var x72 uint64
        _, x72 = bits.Mul64(x62, 0xd838091dd2253531)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x72, 0xffffffffffffffff)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x72, 0xffffffffffffffff)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x72, 0xffffffffffffffff)
        var x80 uint64
        var x81 uint64
        x81, x80 = bits.Mul64(x72, 0xfffffffefffffc2f)
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x81, x78, uint64(0x0))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x79, x76, uint64(fiatFpUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x77, x74, uint64(fiatFpUint1(x85)))
        x88 := (uint64(fiatFpUint1(x87)) + x75)
        var x90 uint64
        _, x90 = bits.Add64(x62, x80, uint64(0x0))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x64, x82, uint64(fiatFpUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x66, x84, uint64(fiatFpUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x68, x86, uint64(fiatFpUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x70, x88, uint64(fiatFpUint1(x96)))
        x99 := (uint64(fiatFpUint1(x98)) + uint64(fiatFpUint1(x71)))
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x2, arg1[3])
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x2, arg1[2])
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x2, arg1[1])
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x2, arg1[0])
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFpUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFpUint1(x111)))
        x114 := (uint64(fiatFpUint1(x113)) + x101)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x91, x106, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x93, x108, uint64(fiatFpUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x95, x110, uint64(fiatFpUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x97, x112, uint64(fiatFpUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x99, x114, uint64(fiatFpUint1(x122)))
        var x125 uint64
        _, x125 = bits.Mul64(x115, 0xd838091dd2253531)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x125, 0xffffffffffffffff)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x125, 0xffffffffffffffff)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x125, 0xffffffffffffffff)
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x125, 0xfffffffefffffc2f)
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x134, x131, uint64(0x0))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x132, x129, uint64(fiatFpUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x130, x127, uint64(fiatFpUint1(x138)))
        x141 := (uint64(fiatFpUint1(x140)) + x128)
        var x143 uint64
        _, x143 = bits.Add64(x115, x133, uint64(0x0))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x117, x135, uint64(fiatFpUint1(x143)))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x119, x137, uint64(fiatFpUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x121, x139, uint64(fiatFpUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x123, x141, uint64(fiatFpUint1(x149)))
        x152 := (uint64(fiatFpUint1(x151)) + uint64(fiatFpUint1(x124)))
        var x153 uint64
        var x154 uint64
        x154, x153 = bits.Mul64(x3, arg1[3])
        var x155 uint64
        var x156 uint64
        x156, x155 = bits.Mul64(x3, arg1[2])
        var x157 uint64
        var x158 uint64
        x158, x157 = bits.Mul64(x3, arg1[1])
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x3, arg1[0])
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x160, x157, uint64(0x0))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x158, x155, uint64(fiatFpUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x156, x153, uint64(fiatFpUint1(x164)))
        x167 := (uint64(fiatFpUint1(x166)) + x154)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x144, x159, uint64(0x0))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x146, x161, uint64(fiatFpUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x148, x163, uint64(fiatFpUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64(x150, x165, uint64(fiatFpUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x152, x167, uint64(fiatFpUint1(x175)))
        var x178 uint64
        _, x178 = bits.Mul64(x168, 0xd838091dd2253531)
        var x180 uint64
        var x181 uint64
        x181, x180 = bits.Mul64(x178, 0xffffffffffffffff)
        var x182 uint64
        var x183 uint64
        x183, x182 = bits.Mul64(x178, 0xffffffffffffffff)
        var x184 uint64
        var x185 uint64
        x185, x184 = bits.Mul64(x178, 0xffffffffffffffff)
        var x186 uint64
        var x187 uint64
        x187, x186 = bits.Mul64(x178, 0xfffffffefffffc2f)
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Add64(x187, x184, uint64(0x0))
        var x190 uint64
        var x191 uint64
        x190, x191 = bits.Add64(x185, x182, uint64(fiatFpUint1(x189)))
        var x192 uint64
        var x193 uint64
        x192, x193 = bits.Add64(x183, x180, uint64(fiatFpUint1(x191)))
        x194 := (uint64(fiatFpUint1(x193)) + x181)
        var x196 uint64
        _, x196 = bits.Add64(x168, x186, uint64(0x0))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x170, x188, uint64(fiatFpUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x172, x190, uint64(fiatFpUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x174, x192, uint64(fiatFpUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x176, x194, uint64(fiatFpUint1(x202)))
        x205 := (uint64(fiatFpUint1(x204)) + uint64(fiatFpUint1(x177)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Sub64(x197, 0xfffffffefffffc2f, uint64(0x0))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Sub64(x199, 0xffffffffffffffff, uint64(fiatFpUint1(x207)))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Sub64(x201, 0xffffffffffffffff, uint64(fiatFpUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Sub64(x203, 0xffffffffffffffff, uint64(fiatFpUint1(x211)))
        var x215 uint64
        _, x215 = bits.Sub64(x205, uint64(0x0), uint64(fiatFpUint1(x213)))
        var x216 uint64
        fiatFpCmovznzU64(&amp;x216, fiatFpUint1(x215), x206, x197)
        var x217 uint64
        fiatFpCmovznzU64(&amp;x217, fiatFpUint1(x215), x208, x199)
        var x218 uint64
        fiatFpCmovznzU64(&amp;x218, fiatFpUint1(x215), x210, x201)
        var x219 uint64
        fiatFpCmovznzU64(&amp;x219, fiatFpUint1(x215), x212, x203)
        out1[0] = x216
        out1[1] = x217
        out1[2] = x218
        out1[3] = x219
}</span>

// fiatFpAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpAdd(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(x1, 0xfffffffefffffc2f, uint64(0x0))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(x3, 0xffffffffffffffff, uint64(fiatFpUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x5, 0xffffffffffffffff, uint64(fiatFpUint1(x12)))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x7, 0xffffffffffffffff, uint64(fiatFpUint1(x14)))
        var x18 uint64
        _, x18 = bits.Sub64(uint64(fiatFpUint1(x8)), uint64(0x0), uint64(fiatFpUint1(x16)))
        var x19 uint64
        fiatFpCmovznzU64(&amp;x19, fiatFpUint1(x18), x9, x1)
        var x20 uint64
        fiatFpCmovznzU64(&amp;x20, fiatFpUint1(x18), x11, x3)
        var x21 uint64
        fiatFpCmovznzU64(&amp;x21, fiatFpUint1(x18), x13, x5)
        var x22 uint64
        fiatFpCmovznzU64(&amp;x22, fiatFpUint1(x18), x15, x7)
        out1[0] = x19
        out1[1] = x20
        out1[2] = x21
        out1[3] = x22
}</span>

// fiatFpSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpSub(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, fiatFpUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0xfffffffefffffc2f), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, x9, uint64(fiatFpUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, x9, uint64(fiatFpUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, x9, uint64(fiatFpUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFpOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFpOpp(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, fiatFpUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0xfffffffefffffc2f), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, x9, uint64(fiatFpUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, x9, uint64(fiatFpUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, x9, uint64(fiatFpUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFpFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^4) mod m
//   0  eval out1 &lt; m
//
func fiatFpFromMontgomery(out1 *fiatFpNonMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[0]
        var x2 uint64
        _, x2 = bits.Mul64(x1, 0xd838091dd2253531)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x2, 0xffffffffffffffff)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x2, 0xffffffffffffffff)
        var x8 uint64
        var x9 uint64
        x9, x8 = bits.Mul64(x2, 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x11, x10 = bits.Mul64(x2, 0xfffffffefffffc2f)
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x11, x8, uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x9, x6, uint64(fiatFpUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x7, x4, uint64(fiatFpUint1(x15)))
        var x19 uint64
        _, x19 = bits.Add64(x1, x10, uint64(0x0))
        var x20 uint64
        var x21 uint64
        x20, x21 = bits.Add64(uint64(0x0), x12, uint64(fiatFpUint1(x19)))
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(uint64(0x0), x14, uint64(fiatFpUint1(x21)))
        var x24 uint64
        var x25 uint64
        x24, x25 = bits.Add64(uint64(0x0), x16, uint64(fiatFpUint1(x23)))
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(uint64(0x0), (uint64(fiatFpUint1(x17)) + x5), uint64(fiatFpUint1(x25)))
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x20, arg1[1], uint64(0x0))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x22, uint64(0x0), uint64(fiatFpUint1(x29)))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x24, uint64(0x0), uint64(fiatFpUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x26, uint64(0x0), uint64(fiatFpUint1(x33)))
        var x36 uint64
        _, x36 = bits.Mul64(x28, 0xd838091dd2253531)
        var x38 uint64
        var x39 uint64
        x39, x38 = bits.Mul64(x36, 0xffffffffffffffff)
        var x40 uint64
        var x41 uint64
        x41, x40 = bits.Mul64(x36, 0xffffffffffffffff)
        var x42 uint64
        var x43 uint64
        x43, x42 = bits.Mul64(x36, 0xffffffffffffffff)
        var x44 uint64
        var x45 uint64
        x45, x44 = bits.Mul64(x36, 0xfffffffefffffc2f)
        var x46 uint64
        var x47 uint64
        x46, x47 = bits.Add64(x45, x42, uint64(0x0))
        var x48 uint64
        var x49 uint64
        x48, x49 = bits.Add64(x43, x40, uint64(fiatFpUint1(x47)))
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x41, x38, uint64(fiatFpUint1(x49)))
        var x53 uint64
        _, x53 = bits.Add64(x28, x44, uint64(0x0))
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64(x30, x46, uint64(fiatFpUint1(x53)))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x32, x48, uint64(fiatFpUint1(x55)))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x34, x50, uint64(fiatFpUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64((uint64(fiatFpUint1(x35)) + uint64(fiatFpUint1(x27))), (uint64(fiatFpUint1(x51)) + x39), uint64(fiatFpUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x54, arg1[2], uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x56, uint64(0x0), uint64(fiatFpUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x58, uint64(0x0), uint64(fiatFpUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x60, uint64(0x0), uint64(fiatFpUint1(x67)))
        var x70 uint64
        _, x70 = bits.Mul64(x62, 0xd838091dd2253531)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x70, 0xffffffffffffffff)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x70, 0xffffffffffffffff)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x70, 0xffffffffffffffff)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x70, 0xfffffffefffffc2f)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x79, x76, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x77, x74, uint64(fiatFpUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x75, x72, uint64(fiatFpUint1(x83)))
        var x87 uint64
        _, x87 = bits.Add64(x62, x78, uint64(0x0))
        var x88 uint64
        var x89 uint64
        x88, x89 = bits.Add64(x64, x80, uint64(fiatFpUint1(x87)))
        var x90 uint64
        var x91 uint64
        x90, x91 = bits.Add64(x66, x82, uint64(fiatFpUint1(x89)))
        var x92 uint64
        var x93 uint64
        x92, x93 = bits.Add64(x68, x84, uint64(fiatFpUint1(x91)))
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64((uint64(fiatFpUint1(x69)) + uint64(fiatFpUint1(x61))), (uint64(fiatFpUint1(x85)) + x73), uint64(fiatFpUint1(x93)))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x88, arg1[3], uint64(0x0))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x90, uint64(0x0), uint64(fiatFpUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x92, uint64(0x0), uint64(fiatFpUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Add64(x94, uint64(0x0), uint64(fiatFpUint1(x101)))
        var x104 uint64
        _, x104 = bits.Mul64(x96, 0xd838091dd2253531)
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x104, 0xffffffffffffffff)
        var x108 uint64
        var x109 uint64
        x109, x108 = bits.Mul64(x104, 0xffffffffffffffff)
        var x110 uint64
        var x111 uint64
        x111, x110 = bits.Mul64(x104, 0xffffffffffffffff)
        var x112 uint64
        var x113 uint64
        x113, x112 = bits.Mul64(x104, 0xfffffffefffffc2f)
        var x114 uint64
        var x115 uint64
        x114, x115 = bits.Add64(x113, x110, uint64(0x0))
        var x116 uint64
        var x117 uint64
        x116, x117 = bits.Add64(x111, x108, uint64(fiatFpUint1(x115)))
        var x118 uint64
        var x119 uint64
        x118, x119 = bits.Add64(x109, x106, uint64(fiatFpUint1(x117)))
        var x121 uint64
        _, x121 = bits.Add64(x96, x112, uint64(0x0))
        var x122 uint64
        var x123 uint64
        x122, x123 = bits.Add64(x98, x114, uint64(fiatFpUint1(x121)))
        var x124 uint64
        var x125 uint64
        x124, x125 = bits.Add64(x100, x116, uint64(fiatFpUint1(x123)))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x102, x118, uint64(fiatFpUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64((uint64(fiatFpUint1(x103)) + uint64(fiatFpUint1(x95))), (uint64(fiatFpUint1(x119)) + x107), uint64(fiatFpUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Sub64(x122, 0xfffffffefffffc2f, uint64(0x0))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Sub64(x124, 0xffffffffffffffff, uint64(fiatFpUint1(x131)))
        var x134 uint64
        var x135 uint64
        x134, x135 = bits.Sub64(x126, 0xffffffffffffffff, uint64(fiatFpUint1(x133)))
        var x136 uint64
        var x137 uint64
        x136, x137 = bits.Sub64(x128, 0xffffffffffffffff, uint64(fiatFpUint1(x135)))
        var x139 uint64
        _, x139 = bits.Sub64(uint64(fiatFpUint1(x129)), uint64(0x0), uint64(fiatFpUint1(x137)))
        var x140 uint64
        fiatFpCmovznzU64(&amp;x140, fiatFpUint1(x139), x130, x122)
        var x141 uint64
        fiatFpCmovznzU64(&amp;x141, fiatFpUint1(x139), x132, x124)
        var x142 uint64
        fiatFpCmovznzU64(&amp;x142, fiatFpUint1(x139), x134, x126)
        var x143 uint64
        fiatFpCmovznzU64(&amp;x143, fiatFpUint1(x139), x136, x128)
        out1[0] = x140
        out1[1] = x141
        out1[2] = x142
        out1[3] = x143
}</span>

// fiatFpToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFpToMontgomery(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, 0x7a2000e90a1)
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(x6, x4, uint64(0x0))
        var x9 uint64
        _, x9 = bits.Mul64(x5, 0xd838091dd2253531)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x9, 0xffffffffffffffff)
        var x13 uint64
        var x14 uint64
        x14, x13 = bits.Mul64(x9, 0xffffffffffffffff)
        var x15 uint64
        var x16 uint64
        x16, x15 = bits.Mul64(x9, 0xffffffffffffffff)
        var x17 uint64
        var x18 uint64
        x18, x17 = bits.Mul64(x9, 0xfffffffefffffc2f)
        var x19 uint64
        var x20 uint64
        x19, x20 = bits.Add64(x18, x15, uint64(0x0))
        var x21 uint64
        var x22 uint64
        x21, x22 = bits.Add64(x16, x13, uint64(fiatFpUint1(x20)))
        var x23 uint64
        var x24 uint64
        x23, x24 = bits.Add64(x14, x11, uint64(fiatFpUint1(x22)))
        var x26 uint64
        _, x26 = bits.Add64(x5, x17, uint64(0x0))
        var x27 uint64
        var x28 uint64
        x27, x28 = bits.Add64(x7, x19, uint64(fiatFpUint1(x26)))
        var x29 uint64
        var x30 uint64
        x29, x30 = bits.Add64(uint64(fiatFpUint1(x8)), x21, uint64(fiatFpUint1(x28)))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(uint64(0x0), x23, uint64(fiatFpUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(uint64(0x0), (uint64(fiatFpUint1(x24)) + x12), uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x36, x35 = bits.Mul64(x1, 0x7a2000e90a1)
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x36, x1, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x27, x35, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x29, x37, uint64(fiatFpUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x31, uint64(fiatFpUint1(x38)), uint64(fiatFpUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x33, uint64(0x0), uint64(fiatFpUint1(x44)))
        var x47 uint64
        _, x47 = bits.Mul64(x39, 0xd838091dd2253531)
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x47, 0xffffffffffffffff)
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x47, 0xffffffffffffffff)
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x47, 0xffffffffffffffff)
        var x55 uint64
        var x56 uint64
        x56, x55 = bits.Mul64(x47, 0xfffffffefffffc2f)
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x56, x53, uint64(0x0))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x54, x51, uint64(fiatFpUint1(x58)))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Add64(x52, x49, uint64(fiatFpUint1(x60)))
        var x64 uint64
        _, x64 = bits.Add64(x39, x55, uint64(0x0))
        var x65 uint64
        var x66 uint64
        x65, x66 = bits.Add64(x41, x57, uint64(fiatFpUint1(x64)))
        var x67 uint64
        var x68 uint64
        x67, x68 = bits.Add64(x43, x59, uint64(fiatFpUint1(x66)))
        var x69 uint64
        var x70 uint64
        x69, x70 = bits.Add64(x45, x61, uint64(fiatFpUint1(x68)))
        var x71 uint64
        var x72 uint64
        x71, x72 = bits.Add64((uint64(fiatFpUint1(x46)) + uint64(fiatFpUint1(x34))), (uint64(fiatFpUint1(x62)) + x50), uint64(fiatFpUint1(x70)))
        var x73 uint64
        var x74 uint64
        x74, x73 = bits.Mul64(x2, 0x7a2000e90a1)
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Add64(x74, x2, uint64(0x0))
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x65, x73, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x67, x75, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x69, uint64(fiatFpUint1(x76)), uint64(fiatFpUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x71, uint64(0x0), uint64(fiatFpUint1(x82)))
        var x85 uint64
        _, x85 = bits.Mul64(x77, 0xd838091dd2253531)
        var x87 uint64
        var x88 uint64
        x88, x87 = bits.Mul64(x85, 0xffffffffffffffff)
        var x89 uint64
        var x90 uint64
        x90, x89 = bits.Mul64(x85, 0xffffffffffffffff)
        var x91 uint64
        var x92 uint64
        x92, x91 = bits.Mul64(x85, 0xffffffffffffffff)
        var x93 uint64
        var x94 uint64
        x94, x93 = bits.Mul64(x85, 0xfffffffefffffc2f)
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x94, x91, uint64(0x0))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x92, x89, uint64(fiatFpUint1(x96)))
        var x99 uint64
        var x100 uint64
        x99, x100 = bits.Add64(x90, x87, uint64(fiatFpUint1(x98)))
        var x102 uint64
        _, x102 = bits.Add64(x77, x93, uint64(0x0))
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x95, uint64(fiatFpUint1(x102)))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x97, uint64(fiatFpUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x99, uint64(fiatFpUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64((uint64(fiatFpUint1(x84)) + uint64(fiatFpUint1(x72))), (uint64(fiatFpUint1(x100)) + x88), uint64(fiatFpUint1(x108)))
        var x111 uint64
        var x112 uint64
        x112, x111 = bits.Mul64(x3, 0x7a2000e90a1)
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x112, x3, uint64(0x0))
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x103, x111, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x105, x113, uint64(fiatFpUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x107, uint64(fiatFpUint1(x114)), uint64(fiatFpUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x109, uint64(0x0), uint64(fiatFpUint1(x120)))
        var x123 uint64
        _, x123 = bits.Mul64(x115, 0xd838091dd2253531)
        var x125 uint64
        var x126 uint64
        x126, x125 = bits.Mul64(x123, 0xffffffffffffffff)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x123, 0xffffffffffffffff)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x123, 0xffffffffffffffff)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x123, 0xfffffffefffffc2f)
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x132, x129, uint64(0x0))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x130, x127, uint64(fiatFpUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x128, x125, uint64(fiatFpUint1(x136)))
        var x140 uint64
        _, x140 = bits.Add64(x115, x131, uint64(0x0))
        var x141 uint64
        var x142 uint64
        x141, x142 = bits.Add64(x117, x133, uint64(fiatFpUint1(x140)))
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x119, x135, uint64(fiatFpUint1(x142)))
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x121, x137, uint64(fiatFpUint1(x144)))
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64((uint64(fiatFpUint1(x122)) + uint64(fiatFpUint1(x110))), (uint64(fiatFpUint1(x138)) + x126), uint64(fiatFpUint1(x146)))
        var x149 uint64
        var x150 uint64
        x149, x150 = bits.Sub64(x141, 0xfffffffefffffc2f, uint64(0x0))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Sub64(x143, 0xffffffffffffffff, uint64(fiatFpUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Sub64(x145, 0xffffffffffffffff, uint64(fiatFpUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Sub64(x147, 0xffffffffffffffff, uint64(fiatFpUint1(x154)))
        var x158 uint64
        _, x158 = bits.Sub64(uint64(fiatFpUint1(x148)), uint64(0x0), uint64(fiatFpUint1(x156)))
        var x159 uint64
        fiatFpCmovznzU64(&amp;x159, fiatFpUint1(x158), x149, x141)
        var x160 uint64
        fiatFpCmovznzU64(&amp;x160, fiatFpUint1(x158), x151, x143)
        var x161 uint64
        fiatFpCmovznzU64(&amp;x161, fiatFpUint1(x158), x153, x145)
        var x162 uint64
        fiatFpCmovznzU64(&amp;x162, fiatFpUint1(x158), x155, x147)
        out1[0] = x159
        out1[1] = x160
        out1[2] = x161
        out1[3] = x162
}</span>

// fiatFpNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpNonzero(out1 *uint64, arg1 *[4]uint64) <span class="cov8" title="1">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | arg1[3])))
        *out1 = x1
}</span>

// fiatFpSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpSelectznz(out1 *[4]uint64, arg1 fiatFpUint1, arg2 *[4]uint64, arg3 *[4]uint64) <span class="cov8" title="1">{
        var x1 uint64
        fiatFpCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFpCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFpCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFpCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
}</span>

// fiatFpToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff]]
func fiatFpToBytes(out1 *[32]uint8, arg1 *[4]uint64) <span class="cov8" title="1">{
        x1 := arg1[3]
        x2 := arg1[2]
        x3 := arg1[1]
        x4 := arg1[0]
        x5 := (uint8(x4) &amp; 0xff)
        x6 := (x4 &gt;&gt; 8)
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := uint8((x16 &gt;&gt; 8))
        x19 := (uint8(x3) &amp; 0xff)
        x20 := (x3 &gt;&gt; 8)
        x21 := (uint8(x20) &amp; 0xff)
        x22 := (x20 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := uint8((x30 &gt;&gt; 8))
        x33 := (uint8(x2) &amp; 0xff)
        x34 := (x2 &gt;&gt; 8)
        x35 := (uint8(x34) &amp; 0xff)
        x36 := (x34 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := uint8((x44 &gt;&gt; 8))
        x47 := (uint8(x1) &amp; 0xff)
        x48 := (x1 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := (x48 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := uint8((x58 &gt;&gt; 8))
        out1[0] = x5
        out1[1] = x7
        out1[2] = x9
        out1[3] = x11
        out1[4] = x13
        out1[5] = x15
        out1[6] = x17
        out1[7] = x18
        out1[8] = x19
        out1[9] = x21
        out1[10] = x23
        out1[11] = x25
        out1[12] = x27
        out1[13] = x29
        out1[14] = x31
        out1[15] = x32
        out1[16] = x33
        out1[17] = x35
        out1[18] = x37
        out1[19] = x39
        out1[20] = x41
        out1[21] = x43
        out1[22] = x45
        out1[23] = x46
        out1[24] = x47
        out1[25] = x49
        out1[26] = x51
        out1[27] = x53
        out1[28] = x55
        out1[29] = x57
        out1[30] = x59
        out1[31] = x60
}</span>

// fiatFpFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpFromBytes(out1 *[4]uint64, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 56)
        x2 := (uint64(arg1[30]) &lt;&lt; 48)
        x3 := (uint64(arg1[29]) &lt;&lt; 40)
        x4 := (uint64(arg1[28]) &lt;&lt; 32)
        x5 := (uint64(arg1[27]) &lt;&lt; 24)
        x6 := (uint64(arg1[26]) &lt;&lt; 16)
        x7 := (uint64(arg1[25]) &lt;&lt; 8)
        x8 := arg1[24]
        x9 := (uint64(arg1[23]) &lt;&lt; 56)
        x10 := (uint64(arg1[22]) &lt;&lt; 48)
        x11 := (uint64(arg1[21]) &lt;&lt; 40)
        x12 := (uint64(arg1[20]) &lt;&lt; 32)
        x13 := (uint64(arg1[19]) &lt;&lt; 24)
        x14 := (uint64(arg1[18]) &lt;&lt; 16)
        x15 := (uint64(arg1[17]) &lt;&lt; 8)
        x16 := arg1[16]
        x17 := (uint64(arg1[15]) &lt;&lt; 56)
        x18 := (uint64(arg1[14]) &lt;&lt; 48)
        x19 := (uint64(arg1[13]) &lt;&lt; 40)
        x20 := (uint64(arg1[12]) &lt;&lt; 32)
        x21 := (uint64(arg1[11]) &lt;&lt; 24)
        x22 := (uint64(arg1[10]) &lt;&lt; 16)
        x23 := (uint64(arg1[9]) &lt;&lt; 8)
        x24 := arg1[8]
        x25 := (uint64(arg1[7]) &lt;&lt; 56)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x25 + x38)
        x40 := (x23 + uint64(x24))
        x41 := (x22 + x40)
        x42 := (x21 + x41)
        x43 := (x20 + x42)
        x44 := (x19 + x43)
        x45 := (x18 + x44)
        x46 := (x17 + x45)
        x47 := (x15 + uint64(x16))
        x48 := (x14 + x47)
        x49 := (x13 + x48)
        x50 := (x12 + x49)
        x51 := (x11 + x50)
        x52 := (x10 + x51)
        x53 := (x9 + x52)
        x54 := (x7 + uint64(x8))
        x55 := (x6 + x54)
        x56 := (x5 + x55)
        x57 := (x4 + x56)
        x58 := (x3 + x57)
        x59 := (x2 + x58)
        x60 := (x1 + x59)
        out1[0] = x39
        out1[1] = x46
        out1[2] = x53
        out1[3] = x60
}</span>

// fiatFpSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFpSetOne(out1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        out1[0] = 0x1000003d1
        out1[1] = uint64(0x0)
        out1[2] = uint64(0x0)
        out1[3] = uint64(0x0)
}</span>

// fiatFpMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpMsat(out1 *[5]uint64) <span class="cov8" title="1">{
        out1[0] = 0xfffffffefffffc2f
        out1[1] = 0xffffffffffffffff
        out1[2] = 0xffffffffffffffff
        out1[3] = 0xffffffffffffffff
        out1[4] = uint64(0x0)
}</span>

// fiatFpDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpDivstepPrecomp(out1 *[4]uint64) <span class="cov8" title="1">{
        out1[0] = 0xf201a41831525e0a
        out1[1] = 0x9953f9ddcd648d85
        out1[2] = 0xe86029463db210a9
        out1[3] = 0x24fb8a3104b03709
}</span>

// fiatFpDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpDivstep(out1 *uint64, out2 *[5]uint64, out3 *[5]uint64, out4 *[4]uint64, out5 *[4]uint64, arg1 uint64, arg2 *[5]uint64, arg3 *[5]uint64, arg4 *[4]uint64, arg5 *[4]uint64) <span class="cov8" title="1">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFpUint1((x1 &gt;&gt; 63)) &amp; (fiatFpUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFpCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFpCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFpCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFpCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFpCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFpUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFpUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFpUint1(x17)))
        var x20 uint64
        x20, _ = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFpUint1(x19)))
        var x22 uint64
        fiatFpCmovznzU64(&amp;x22, x3, arg3[0], x12)
        var x23 uint64
        fiatFpCmovznzU64(&amp;x23, x3, arg3[1], x14)
        var x24 uint64
        fiatFpCmovznzU64(&amp;x24, x3, arg3[2], x16)
        var x25 uint64
        fiatFpCmovznzU64(&amp;x25, x3, arg3[3], x18)
        var x26 uint64
        fiatFpCmovznzU64(&amp;x26, x3, arg3[4], x20)
        var x27 uint64
        fiatFpCmovznzU64(&amp;x27, x3, arg4[0], arg5[0])
        var x28 uint64
        fiatFpCmovznzU64(&amp;x28, x3, arg4[1], arg5[1])
        var x29 uint64
        fiatFpCmovznzU64(&amp;x29, x3, arg4[2], arg5[2])
        var x30 uint64
        fiatFpCmovznzU64(&amp;x30, x3, arg4[3], arg5[3])
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x27, x27, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x28, x28, uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x29, x29, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x30, x30, uint64(fiatFpUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Sub64(x31, 0xfffffffefffffc2f, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Sub64(x33, 0xffffffffffffffff, uint64(fiatFpUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Sub64(x35, 0xffffffffffffffff, uint64(fiatFpUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Sub64(x37, 0xffffffffffffffff, uint64(fiatFpUint1(x44)))
        var x48 uint64
        _, x48 = bits.Sub64(uint64(fiatFpUint1(x38)), uint64(0x0), uint64(fiatFpUint1(x46)))
        x49 := arg4[3]
        x50 := arg4[2]
        x51 := arg4[1]
        x52 := arg4[0]
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(uint64(0x0), x52, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(uint64(0x0), x51, uint64(fiatFpUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(uint64(0x0), x50, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(uint64(0x0), x49, uint64(fiatFpUint1(x58)))
        var x61 uint64
        fiatFpCmovznzU64(&amp;x61, fiatFpUint1(x60), uint64(0x0), 0xffffffffffffffff)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x53, (x61 &amp; 0xfffffffefffffc2f), uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x55, x61, uint64(fiatFpUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, x61, uint64(fiatFpUint1(x65)))
        var x68 uint64
        x68, _ = bits.Add64(x59, x61, uint64(fiatFpUint1(x67)))
        var x70 uint64
        fiatFpCmovznzU64(&amp;x70, x3, arg5[0], x62)
        var x71 uint64
        fiatFpCmovznzU64(&amp;x71, x3, arg5[1], x64)
        var x72 uint64
        fiatFpCmovznzU64(&amp;x72, x3, arg5[2], x66)
        var x73 uint64
        fiatFpCmovznzU64(&amp;x73, x3, arg5[3], x68)
        x74 := (fiatFpUint1(x22) &amp; 0x1)
        var x75 uint64
        fiatFpCmovznzU64(&amp;x75, x74, uint64(0x0), x7)
        var x76 uint64
        fiatFpCmovznzU64(&amp;x76, x74, uint64(0x0), x8)
        var x77 uint64
        fiatFpCmovznzU64(&amp;x77, x74, uint64(0x0), x9)
        var x78 uint64
        fiatFpCmovznzU64(&amp;x78, x74, uint64(0x0), x10)
        var x79 uint64
        fiatFpCmovznzU64(&amp;x79, x74, uint64(0x0), x11)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x22, x75, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x23, x76, uint64(fiatFpUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x24, x77, uint64(fiatFpUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x25, x78, uint64(fiatFpUint1(x85)))
        var x88 uint64
        x88, _ = bits.Add64(x26, x79, uint64(fiatFpUint1(x87)))
        var x90 uint64
        fiatFpCmovznzU64(&amp;x90, x74, uint64(0x0), x27)
        var x91 uint64
        fiatFpCmovznzU64(&amp;x91, x74, uint64(0x0), x28)
        var x92 uint64
        fiatFpCmovznzU64(&amp;x92, x74, uint64(0x0), x29)
        var x93 uint64
        fiatFpCmovznzU64(&amp;x93, x74, uint64(0x0), x30)
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x70, x90, uint64(0x0))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x71, x91, uint64(fiatFpUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x72, x92, uint64(fiatFpUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x73, x93, uint64(fiatFpUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Sub64(x94, 0xfffffffefffffc2f, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Sub64(x96, 0xffffffffffffffff, uint64(fiatFpUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Sub64(x98, 0xffffffffffffffff, uint64(fiatFpUint1(x105)))
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Sub64(x100, 0xffffffffffffffff, uint64(fiatFpUint1(x107)))
        var x111 uint64
        _, x111 = bits.Sub64(uint64(fiatFpUint1(x101)), uint64(0x0), uint64(fiatFpUint1(x109)))
        var x112 uint64
        x112, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x114 := ((x80 &gt;&gt; 1) | ((x82 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x115 := ((x82 &gt;&gt; 1) | ((x84 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x116 := ((x84 &gt;&gt; 1) | ((x86 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x117 := ((x86 &gt;&gt; 1) | ((x88 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x118 := ((x88 &amp; 0x8000000000000000) | (x88 &gt;&gt; 1))
        var x119 uint64
        fiatFpCmovznzU64(&amp;x119, fiatFpUint1(x48), x39, x31)
        var x120 uint64
        fiatFpCmovznzU64(&amp;x120, fiatFpUint1(x48), x41, x33)
        var x121 uint64
        fiatFpCmovznzU64(&amp;x121, fiatFpUint1(x48), x43, x35)
        var x122 uint64
        fiatFpCmovznzU64(&amp;x122, fiatFpUint1(x48), x45, x37)
        var x123 uint64
        fiatFpCmovznzU64(&amp;x123, fiatFpUint1(x111), x102, x94)
        var x124 uint64
        fiatFpCmovznzU64(&amp;x124, fiatFpUint1(x111), x104, x96)
        var x125 uint64
        fiatFpCmovznzU64(&amp;x125, fiatFpUint1(x111), x106, x98)
        var x126 uint64
        fiatFpCmovznzU64(&amp;x126, fiatFpUint1(x111), x108, x100)
        *out1 = x112
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out3[0] = x114
        out3[1] = x115
        out3[2] = x116
        out3[3] = x117
        out3[4] = x118
        out4[0] = x119
        out4[1] = x120
        out4[2] = x121
        out4[3] = x122
        out5[0] = x123
        out5[1] = x124
        out5[2] = x125
        out5[3] = x126
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fq 64 '2^256 - 432420386565659656852420866394968145599'
//
// curve description: Fq
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 (from "2^256 - 432420386565659656852420866394968145599")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) in
//
//                            if x1 &amp; (2^256-1) &lt; 2^255 then x1 &amp; (2^256-1) else (x1 &amp; (2^256-1)) - 2^256
package impl

import "math/bits"

type fiatFqUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFqInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFqMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqMontgomeryDomainFieldElement [4]uint64

// fiatFqNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqNonMontgomeryDomainFieldElement [4]uint64

// fiatFqCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqCmovznzU64(out1 *uint64, arg1 fiatFqUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFqMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqMul(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg2[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg2[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg2[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg2[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0x4b0dff665588b13f)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0xffffffffffffffff)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0xfffffffffffffffe)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0xbaaedce6af48a03b)
        var x28 uint64
        var x29 uint64
        x29, x28 = bits.Mul64(x20, 0xbfd25e8cd0364141)
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x29, x26, uint64(0x0))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x27, x24, uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x25, x22, uint64(fiatFqUint1(x33)))
        x36 := (uint64(fiatFqUint1(x35)) + x23)
        var x38 uint64
        _, x38 = bits.Add64(x11, x28, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x13, x30, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x15, x32, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x17, x34, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x19, x36, uint64(fiatFqUint1(x44)))
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg2[3])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, arg2[2])
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, arg2[1])
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x1, arg2[0])
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x54, x51, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x52, x49, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x50, x47, uint64(fiatFqUint1(x58)))
        x61 := (uint64(fiatFqUint1(x60)) + x48)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x41, x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x43, x57, uint64(fiatFqUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x45, x59, uint64(fiatFqUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(uint64(fiatFqUint1(x46)), x61, uint64(fiatFqUint1(x69)))
        var x72 uint64
        _, x72 = bits.Mul64(x62, 0x4b0dff665588b13f)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x72, 0xffffffffffffffff)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x72, 0xfffffffffffffffe)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x72, 0xbaaedce6af48a03b)
        var x80 uint64
        var x81 uint64
        x81, x80 = bits.Mul64(x72, 0xbfd25e8cd0364141)
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x81, x78, uint64(0x0))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x79, x76, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x77, x74, uint64(fiatFqUint1(x85)))
        x88 := (uint64(fiatFqUint1(x87)) + x75)
        var x90 uint64
        _, x90 = bits.Add64(x62, x80, uint64(0x0))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x64, x82, uint64(fiatFqUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x66, x84, uint64(fiatFqUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x68, x86, uint64(fiatFqUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x70, x88, uint64(fiatFqUint1(x96)))
        x99 := (uint64(fiatFqUint1(x98)) + uint64(fiatFqUint1(x71)))
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x2, arg2[3])
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x2, arg2[2])
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x2, arg2[1])
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x2, arg2[0])
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFqUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFqUint1(x111)))
        x114 := (uint64(fiatFqUint1(x113)) + x101)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x91, x106, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x93, x108, uint64(fiatFqUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x95, x110, uint64(fiatFqUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x97, x112, uint64(fiatFqUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x99, x114, uint64(fiatFqUint1(x122)))
        var x125 uint64
        _, x125 = bits.Mul64(x115, 0x4b0dff665588b13f)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x125, 0xffffffffffffffff)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x125, 0xfffffffffffffffe)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x125, 0xbaaedce6af48a03b)
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x125, 0xbfd25e8cd0364141)
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x134, x131, uint64(0x0))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x132, x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x130, x127, uint64(fiatFqUint1(x138)))
        x141 := (uint64(fiatFqUint1(x140)) + x128)
        var x143 uint64
        _, x143 = bits.Add64(x115, x133, uint64(0x0))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x117, x135, uint64(fiatFqUint1(x143)))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x119, x137, uint64(fiatFqUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x121, x139, uint64(fiatFqUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x123, x141, uint64(fiatFqUint1(x149)))
        x152 := (uint64(fiatFqUint1(x151)) + uint64(fiatFqUint1(x124)))
        var x153 uint64
        var x154 uint64
        x154, x153 = bits.Mul64(x3, arg2[3])
        var x155 uint64
        var x156 uint64
        x156, x155 = bits.Mul64(x3, arg2[2])
        var x157 uint64
        var x158 uint64
        x158, x157 = bits.Mul64(x3, arg2[1])
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x3, arg2[0])
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x160, x157, uint64(0x0))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x158, x155, uint64(fiatFqUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x156, x153, uint64(fiatFqUint1(x164)))
        x167 := (uint64(fiatFqUint1(x166)) + x154)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x144, x159, uint64(0x0))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x146, x161, uint64(fiatFqUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x148, x163, uint64(fiatFqUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64(x150, x165, uint64(fiatFqUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x152, x167, uint64(fiatFqUint1(x175)))
        var x178 uint64
        _, x178 = bits.Mul64(x168, 0x4b0dff665588b13f)
        var x180 uint64
        var x181 uint64
        x181, x180 = bits.Mul64(x178, 0xffffffffffffffff)
        var x182 uint64
        var x183 uint64
        x183, x182 = bits.Mul64(x178, 0xfffffffffffffffe)
        var x184 uint64
        var x185 uint64
        x185, x184 = bits.Mul64(x178, 0xbaaedce6af48a03b)
        var x186 uint64
        var x187 uint64
        x187, x186 = bits.Mul64(x178, 0xbfd25e8cd0364141)
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Add64(x187, x184, uint64(0x0))
        var x190 uint64
        var x191 uint64
        x190, x191 = bits.Add64(x185, x182, uint64(fiatFqUint1(x189)))
        var x192 uint64
        var x193 uint64
        x192, x193 = bits.Add64(x183, x180, uint64(fiatFqUint1(x191)))
        x194 := (uint64(fiatFqUint1(x193)) + x181)
        var x196 uint64
        _, x196 = bits.Add64(x168, x186, uint64(0x0))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x170, x188, uint64(fiatFqUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x172, x190, uint64(fiatFqUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x174, x192, uint64(fiatFqUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x176, x194, uint64(fiatFqUint1(x202)))
        x205 := (uint64(fiatFqUint1(x204)) + uint64(fiatFqUint1(x177)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Sub64(x197, 0xbfd25e8cd0364141, uint64(0x0))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Sub64(x199, 0xbaaedce6af48a03b, uint64(fiatFqUint1(x207)))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Sub64(x201, 0xfffffffffffffffe, uint64(fiatFqUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Sub64(x203, 0xffffffffffffffff, uint64(fiatFqUint1(x211)))
        var x215 uint64
        _, x215 = bits.Sub64(x205, uint64(0x0), uint64(fiatFqUint1(x213)))
        var x216 uint64
        fiatFqCmovznzU64(&amp;x216, fiatFqUint1(x215), x206, x197)
        var x217 uint64
        fiatFqCmovznzU64(&amp;x217, fiatFqUint1(x215), x208, x199)
        var x218 uint64
        fiatFqCmovznzU64(&amp;x218, fiatFqUint1(x215), x210, x201)
        var x219 uint64
        fiatFqCmovznzU64(&amp;x219, fiatFqUint1(x215), x212, x203)
        out1[0] = x216
        out1[1] = x217
        out1[2] = x218
        out1[3] = x219
}</span>

// fiatFqSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSquare(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg1[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg1[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg1[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg1[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0x4b0dff665588b13f)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0xffffffffffffffff)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0xfffffffffffffffe)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0xbaaedce6af48a03b)
        var x28 uint64
        var x29 uint64
        x29, x28 = bits.Mul64(x20, 0xbfd25e8cd0364141)
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x29, x26, uint64(0x0))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x27, x24, uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x25, x22, uint64(fiatFqUint1(x33)))
        x36 := (uint64(fiatFqUint1(x35)) + x23)
        var x38 uint64
        _, x38 = bits.Add64(x11, x28, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x13, x30, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x15, x32, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x17, x34, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x19, x36, uint64(fiatFqUint1(x44)))
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg1[3])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, arg1[2])
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, arg1[1])
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x1, arg1[0])
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x54, x51, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x52, x49, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x50, x47, uint64(fiatFqUint1(x58)))
        x61 := (uint64(fiatFqUint1(x60)) + x48)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x41, x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x43, x57, uint64(fiatFqUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x45, x59, uint64(fiatFqUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(uint64(fiatFqUint1(x46)), x61, uint64(fiatFqUint1(x69)))
        var x72 uint64
        _, x72 = bits.Mul64(x62, 0x4b0dff665588b13f)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x72, 0xffffffffffffffff)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x72, 0xfffffffffffffffe)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x72, 0xbaaedce6af48a03b)
        var x80 uint64
        var x81 uint64
        x81, x80 = bits.Mul64(x72, 0xbfd25e8cd0364141)
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x81, x78, uint64(0x0))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x79, x76, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x77, x74, uint64(fiatFqUint1(x85)))
        x88 := (uint64(fiatFqUint1(x87)) + x75)
        var x90 uint64
        _, x90 = bits.Add64(x62, x80, uint64(0x0))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x64, x82, uint64(fiatFqUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x66, x84, uint64(fiatFqUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x68, x86, uint64(fiatFqUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x70, x88, uint64(fiatFqUint1(x96)))
        x99 := (uint64(fiatFqUint1(x98)) + uint64(fiatFqUint1(x71)))
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x2, arg1[3])
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x2, arg1[2])
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x2, arg1[1])
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x2, arg1[0])
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFqUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFqUint1(x111)))
        x114 := (uint64(fiatFqUint1(x113)) + x101)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x91, x106, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x93, x108, uint64(fiatFqUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x95, x110, uint64(fiatFqUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x97, x112, uint64(fiatFqUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x99, x114, uint64(fiatFqUint1(x122)))
        var x125 uint64
        _, x125 = bits.Mul64(x115, 0x4b0dff665588b13f)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x125, 0xffffffffffffffff)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x125, 0xfffffffffffffffe)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x125, 0xbaaedce6af48a03b)
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x125, 0xbfd25e8cd0364141)
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x134, x131, uint64(0x0))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x132, x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x130, x127, uint64(fiatFqUint1(x138)))
        x141 := (uint64(fiatFqUint1(x140)) + x128)
        var x143 uint64
        _, x143 = bits.Add64(x115, x133, uint64(0x0))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x117, x135, uint64(fiatFqUint1(x143)))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x119, x137, uint64(fiatFqUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x121, x139, uint64(fiatFqUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x123, x141, uint64(fiatFqUint1(x149)))
        x152 := (uint64(fiatFqUint1(x151)) + uint64(fiatFqUint1(x124)))
        var x153 uint64
        var x154 uint64
        x154, x153 = bits.Mul64(x3, arg1[3])
        var x155 uint64
        var x156 uint64
        x156, x155 = bits.Mul64(x3, arg1[2])
        var x157 uint64
        var x158 uint64
        x158, x157 = bits.Mul64(x3, arg1[1])
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x3, arg1[0])
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x160, x157, uint64(0x0))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x158, x155, uint64(fiatFqUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x156, x153, uint64(fiatFqUint1(x164)))
        x167 := (uint64(fiatFqUint1(x166)) + x154)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x144, x159, uint64(0x0))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x146, x161, uint64(fiatFqUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x148, x163, uint64(fiatFqUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64(x150, x165, uint64(fiatFqUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x152, x167, uint64(fiatFqUint1(x175)))
        var x178 uint64
        _, x178 = bits.Mul64(x168, 0x4b0dff665588b13f)
        var x180 uint64
        var x181 uint64
        x181, x180 = bits.Mul64(x178, 0xffffffffffffffff)
        var x182 uint64
        var x183 uint64
        x183, x182 = bits.Mul64(x178, 0xfffffffffffffffe)
        var x184 uint64
        var x185 uint64
        x185, x184 = bits.Mul64(x178, 0xbaaedce6af48a03b)
        var x186 uint64
        var x187 uint64
        x187, x186 = bits.Mul64(x178, 0xbfd25e8cd0364141)
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Add64(x187, x184, uint64(0x0))
        var x190 uint64
        var x191 uint64
        x190, x191 = bits.Add64(x185, x182, uint64(fiatFqUint1(x189)))
        var x192 uint64
        var x193 uint64
        x192, x193 = bits.Add64(x183, x180, uint64(fiatFqUint1(x191)))
        x194 := (uint64(fiatFqUint1(x193)) + x181)
        var x196 uint64
        _, x196 = bits.Add64(x168, x186, uint64(0x0))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x170, x188, uint64(fiatFqUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x172, x190, uint64(fiatFqUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x174, x192, uint64(fiatFqUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x176, x194, uint64(fiatFqUint1(x202)))
        x205 := (uint64(fiatFqUint1(x204)) + uint64(fiatFqUint1(x177)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Sub64(x197, 0xbfd25e8cd0364141, uint64(0x0))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Sub64(x199, 0xbaaedce6af48a03b, uint64(fiatFqUint1(x207)))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Sub64(x201, 0xfffffffffffffffe, uint64(fiatFqUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Sub64(x203, 0xffffffffffffffff, uint64(fiatFqUint1(x211)))
        var x215 uint64
        _, x215 = bits.Sub64(x205, uint64(0x0), uint64(fiatFqUint1(x213)))
        var x216 uint64
        fiatFqCmovznzU64(&amp;x216, fiatFqUint1(x215), x206, x197)
        var x217 uint64
        fiatFqCmovznzU64(&amp;x217, fiatFqUint1(x215), x208, x199)
        var x218 uint64
        fiatFqCmovznzU64(&amp;x218, fiatFqUint1(x215), x210, x201)
        var x219 uint64
        fiatFqCmovznzU64(&amp;x219, fiatFqUint1(x215), x212, x203)
        out1[0] = x216
        out1[1] = x217
        out1[2] = x218
        out1[3] = x219
}</span>

// fiatFqAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqAdd(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(x1, 0xbfd25e8cd0364141, uint64(0x0))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(x3, 0xbaaedce6af48a03b, uint64(fiatFqUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x5, 0xfffffffffffffffe, uint64(fiatFqUint1(x12)))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x7, 0xffffffffffffffff, uint64(fiatFqUint1(x14)))
        var x18 uint64
        _, x18 = bits.Sub64(uint64(fiatFqUint1(x8)), uint64(0x0), uint64(fiatFqUint1(x16)))
        var x19 uint64
        fiatFqCmovznzU64(&amp;x19, fiatFqUint1(x18), x9, x1)
        var x20 uint64
        fiatFqCmovznzU64(&amp;x20, fiatFqUint1(x18), x11, x3)
        var x21 uint64
        fiatFqCmovznzU64(&amp;x21, fiatFqUint1(x18), x13, x5)
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, fiatFqUint1(x18), x15, x7)
        out1[0] = x19
        out1[1] = x20
        out1[2] = x21
        out1[3] = x22
}</span>

// fiatFqSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSub(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0xbfd25e8cd0364141), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0xbaaedce6af48a03b), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, (x9 &amp; 0xfffffffffffffffe), uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, x9, uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFqOpp(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0xbfd25e8cd0364141), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0xbaaedce6af48a03b), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, (x9 &amp; 0xfffffffffffffffe), uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, x9, uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^4) mod m
//   0  eval out1 &lt; m
//
func fiatFqFromMontgomery(out1 *fiatFqNonMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[0]
        var x2 uint64
        _, x2 = bits.Mul64(x1, 0x4b0dff665588b13f)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x2, 0xffffffffffffffff)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x2, 0xfffffffffffffffe)
        var x8 uint64
        var x9 uint64
        x9, x8 = bits.Mul64(x2, 0xbaaedce6af48a03b)
        var x10 uint64
        var x11 uint64
        x11, x10 = bits.Mul64(x2, 0xbfd25e8cd0364141)
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x11, x8, uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x9, x6, uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x7, x4, uint64(fiatFqUint1(x15)))
        var x19 uint64
        _, x19 = bits.Add64(x1, x10, uint64(0x0))
        var x20 uint64
        var x21 uint64
        x20, x21 = bits.Add64(uint64(0x0), x12, uint64(fiatFqUint1(x19)))
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(uint64(0x0), x14, uint64(fiatFqUint1(x21)))
        var x24 uint64
        var x25 uint64
        x24, x25 = bits.Add64(uint64(0x0), x16, uint64(fiatFqUint1(x23)))
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(uint64(0x0), (uint64(fiatFqUint1(x17)) + x5), uint64(fiatFqUint1(x25)))
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x20, arg1[1], uint64(0x0))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x22, uint64(0x0), uint64(fiatFqUint1(x29)))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x24, uint64(0x0), uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x26, uint64(0x0), uint64(fiatFqUint1(x33)))
        var x36 uint64
        _, x36 = bits.Mul64(x28, 0x4b0dff665588b13f)
        var x38 uint64
        var x39 uint64
        x39, x38 = bits.Mul64(x36, 0xffffffffffffffff)
        var x40 uint64
        var x41 uint64
        x41, x40 = bits.Mul64(x36, 0xfffffffffffffffe)
        var x42 uint64
        var x43 uint64
        x43, x42 = bits.Mul64(x36, 0xbaaedce6af48a03b)
        var x44 uint64
        var x45 uint64
        x45, x44 = bits.Mul64(x36, 0xbfd25e8cd0364141)
        var x46 uint64
        var x47 uint64
        x46, x47 = bits.Add64(x45, x42, uint64(0x0))
        var x48 uint64
        var x49 uint64
        x48, x49 = bits.Add64(x43, x40, uint64(fiatFqUint1(x47)))
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x41, x38, uint64(fiatFqUint1(x49)))
        var x53 uint64
        _, x53 = bits.Add64(x28, x44, uint64(0x0))
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64(x30, x46, uint64(fiatFqUint1(x53)))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x32, x48, uint64(fiatFqUint1(x55)))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x34, x50, uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64((uint64(fiatFqUint1(x35)) + uint64(fiatFqUint1(x27))), (uint64(fiatFqUint1(x51)) + x39), uint64(fiatFqUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x54, arg1[2], uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x56, uint64(0x0), uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x58, uint64(0x0), uint64(fiatFqUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x60, uint64(0x0), uint64(fiatFqUint1(x67)))
        var x70 uint64
        _, x70 = bits.Mul64(x62, 0x4b0dff665588b13f)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x70, 0xffffffffffffffff)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x70, 0xfffffffffffffffe)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x70, 0xbaaedce6af48a03b)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x70, 0xbfd25e8cd0364141)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x79, x76, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x77, x74, uint64(fiatFqUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x75, x72, uint64(fiatFqUint1(x83)))
        var x87 uint64
        _, x87 = bits.Add64(x62, x78, uint64(0x0))
        var x88 uint64
        var x89 uint64
        x88, x89 = bits.Add64(x64, x80, uint64(fiatFqUint1(x87)))
        var x90 uint64
        var x91 uint64
        x90, x91 = bits.Add64(x66, x82, uint64(fiatFqUint1(x89)))
        var x92 uint64
        var x93 uint64
        x92, x93 = bits.Add64(x68, x84, uint64(fiatFqUint1(x91)))
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64((uint64(fiatFqUint1(x69)) + uint64(fiatFqUint1(x61))), (uint64(fiatFqUint1(x85)) + x73), uint64(fiatFqUint1(x93)))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x88, arg1[3], uint64(0x0))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x90, uint64(0x0), uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x92, uint64(0x0), uint64(fiatFqUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Add64(x94, uint64(0x0), uint64(fiatFqUint1(x101)))
        var x104 uint64
        _, x104 = bits.Mul64(x96, 0x4b0dff665588b13f)
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x104, 0xffffffffffffffff)
        var x108 uint64
        var x109 uint64
        x109, x108 = bits.Mul64(x104, 0xfffffffffffffffe)
        var x110 uint64
        var x111 uint64
        x111, x110 = bits.Mul64(x104, 0xbaaedce6af48a03b)
        var x112 uint64
        var x113 uint64
        x113, x112 = bits.Mul64(x104, 0xbfd25e8cd0364141)
        var x114 uint64
        var x115 uint64
        x114, x115 = bits.Add64(x113, x110, uint64(0x0))
        var x116 uint64
        var x117 uint64
        x116, x117 = bits.Add64(x111, x108, uint64(fiatFqUint1(x115)))
        var x118 uint64
        var x119 uint64
        x118, x119 = bits.Add64(x109, x106, uint64(fiatFqUint1(x117)))
        var x121 uint64
        _, x121 = bits.Add64(x96, x112, uint64(0x0))
        var x122 uint64
        var x123 uint64
        x122, x123 = bits.Add64(x98, x114, uint64(fiatFqUint1(x121)))
        var x124 uint64
        var x125 uint64
        x124, x125 = bits.Add64(x100, x116, uint64(fiatFqUint1(x123)))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x102, x118, uint64(fiatFqUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64((uint64(fiatFqUint1(x103)) + uint64(fiatFqUint1(x95))), (uint64(fiatFqUint1(x119)) + x107), uint64(fiatFqUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Sub64(x122, 0xbfd25e8cd0364141, uint64(0x0))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Sub64(x124, 0xbaaedce6af48a03b, uint64(fiatFqUint1(x131)))
        var x134 uint64
        var x135 uint64
        x134, x135 = bits.Sub64(x126, 0xfffffffffffffffe, uint64(fiatFqUint1(x133)))
        var x136 uint64
        var x137 uint64
        x136, x137 = bits.Sub64(x128, 0xffffffffffffffff, uint64(fiatFqUint1(x135)))
        var x139 uint64
        _, x139 = bits.Sub64(uint64(fiatFqUint1(x129)), uint64(0x0), uint64(fiatFqUint1(x137)))
        var x140 uint64
        fiatFqCmovznzU64(&amp;x140, fiatFqUint1(x139), x130, x122)
        var x141 uint64
        fiatFqCmovznzU64(&amp;x141, fiatFqUint1(x139), x132, x124)
        var x142 uint64
        fiatFqCmovznzU64(&amp;x142, fiatFqUint1(x139), x134, x126)
        var x143 uint64
        fiatFqCmovznzU64(&amp;x143, fiatFqUint1(x139), x136, x128)
        out1[0] = x140
        out1[1] = x141
        out1[2] = x142
        out1[3] = x143
}</span>

// fiatFqToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFqToMontgomery(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, 0x9d671cd581c69bc5)
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, 0xe697f5e45bcd07c6)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, 0x741496c20e7cf878)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, 0x896cf21467d7d140)
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        var x19 uint64
        _, x19 = bits.Mul64(x11, 0x4b0dff665588b13f)
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(x19, 0xffffffffffffffff)
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(x19, 0xfffffffffffffffe)
        var x25 uint64
        var x26 uint64
        x26, x25 = bits.Mul64(x19, 0xbaaedce6af48a03b)
        var x27 uint64
        var x28 uint64
        x28, x27 = bits.Mul64(x19, 0xbfd25e8cd0364141)
        var x29 uint64
        var x30 uint64
        x29, x30 = bits.Add64(x28, x25, uint64(0x0))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x26, x23, uint64(fiatFqUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x24, x21, uint64(fiatFqUint1(x32)))
        var x36 uint64
        _, x36 = bits.Add64(x11, x27, uint64(0x0))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x13, x29, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x15, x31, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x17, x33, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64((uint64(fiatFqUint1(x18)) + x6), (uint64(fiatFqUint1(x34)) + x22), uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, 0x9d671cd581c69bc5)
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, 0xe697f5e45bcd07c6)
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, 0x741496c20e7cf878)
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, 0x896cf21467d7d140)
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x52, x49, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x50, x47, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x48, x45, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x37, x51, uint64(0x0))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Add64(x39, x53, uint64(fiatFqUint1(x60)))
        var x63 uint64
        var x64 uint64
        x63, x64 = bits.Add64(x41, x55, uint64(fiatFqUint1(x62)))
        var x65 uint64
        var x66 uint64
        x65, x66 = bits.Add64(x43, x57, uint64(fiatFqUint1(x64)))
        var x67 uint64
        _, x67 = bits.Mul64(x59, 0x4b0dff665588b13f)
        var x69 uint64
        var x70 uint64
        x70, x69 = bits.Mul64(x67, 0xffffffffffffffff)
        var x71 uint64
        var x72 uint64
        x72, x71 = bits.Mul64(x67, 0xfffffffffffffffe)
        var x73 uint64
        var x74 uint64
        x74, x73 = bits.Mul64(x67, 0xbaaedce6af48a03b)
        var x75 uint64
        var x76 uint64
        x76, x75 = bits.Mul64(x67, 0xbfd25e8cd0364141)
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x76, x73, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x74, x71, uint64(fiatFqUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x72, x69, uint64(fiatFqUint1(x80)))
        var x84 uint64
        _, x84 = bits.Add64(x59, x75, uint64(0x0))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x61, x77, uint64(fiatFqUint1(x84)))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x63, x79, uint64(fiatFqUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x65, x81, uint64(fiatFqUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(((uint64(fiatFqUint1(x66)) + uint64(fiatFqUint1(x44))) + (uint64(fiatFqUint1(x58)) + x46)), (uint64(fiatFqUint1(x82)) + x70), uint64(fiatFqUint1(x90)))
        var x93 uint64
        var x94 uint64
        x94, x93 = bits.Mul64(x2, 0x9d671cd581c69bc5)
        var x95 uint64
        var x96 uint64
        x96, x95 = bits.Mul64(x2, 0xe697f5e45bcd07c6)
        var x97 uint64
        var x98 uint64
        x98, x97 = bits.Mul64(x2, 0x741496c20e7cf878)
        var x99 uint64
        var x100 uint64
        x100, x99 = bits.Mul64(x2, 0x896cf21467d7d140)
        var x101 uint64
        var x102 uint64
        x101, x102 = bits.Add64(x100, x97, uint64(0x0))
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x98, x95, uint64(fiatFqUint1(x102)))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x96, x93, uint64(fiatFqUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x85, x99, uint64(0x0))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x87, x101, uint64(fiatFqUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x89, x103, uint64(fiatFqUint1(x110)))
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x91, x105, uint64(fiatFqUint1(x112)))
        var x115 uint64
        _, x115 = bits.Mul64(x107, 0x4b0dff665588b13f)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x115, 0xffffffffffffffff)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x115, 0xfffffffffffffffe)
        var x121 uint64
        var x122 uint64
        x122, x121 = bits.Mul64(x115, 0xbaaedce6af48a03b)
        var x123 uint64
        var x124 uint64
        x124, x123 = bits.Mul64(x115, 0xbfd25e8cd0364141)
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x124, x121, uint64(0x0))
        var x127 uint64
        var x128 uint64
        x127, x128 = bits.Add64(x122, x119, uint64(fiatFqUint1(x126)))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x120, x117, uint64(fiatFqUint1(x128)))
        var x132 uint64
        _, x132 = bits.Add64(x107, x123, uint64(0x0))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x109, x125, uint64(fiatFqUint1(x132)))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x111, x127, uint64(fiatFqUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x113, x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(((uint64(fiatFqUint1(x114)) + uint64(fiatFqUint1(x92))) + (uint64(fiatFqUint1(x106)) + x94)), (uint64(fiatFqUint1(x130)) + x118), uint64(fiatFqUint1(x138)))
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, 0x9d671cd581c69bc5)
        var x143 uint64
        var x144 uint64
        x144, x143 = bits.Mul64(x3, 0xe697f5e45bcd07c6)
        var x145 uint64
        var x146 uint64
        x146, x145 = bits.Mul64(x3, 0x741496c20e7cf878)
        var x147 uint64
        var x148 uint64
        x148, x147 = bits.Mul64(x3, 0x896cf21467d7d140)
        var x149 uint64
        var x150 uint64
        x149, x150 = bits.Add64(x148, x145, uint64(0x0))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Add64(x146, x143, uint64(fiatFqUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Add64(x144, x141, uint64(fiatFqUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Add64(x133, x147, uint64(0x0))
        var x157 uint64
        var x158 uint64
        x157, x158 = bits.Add64(x135, x149, uint64(fiatFqUint1(x156)))
        var x159 uint64
        var x160 uint64
        x159, x160 = bits.Add64(x137, x151, uint64(fiatFqUint1(x158)))
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x139, x153, uint64(fiatFqUint1(x160)))
        var x163 uint64
        _, x163 = bits.Mul64(x155, 0x4b0dff665588b13f)
        var x165 uint64
        var x166 uint64
        x166, x165 = bits.Mul64(x163, 0xffffffffffffffff)
        var x167 uint64
        var x168 uint64
        x168, x167 = bits.Mul64(x163, 0xfffffffffffffffe)
        var x169 uint64
        var x170 uint64
        x170, x169 = bits.Mul64(x163, 0xbaaedce6af48a03b)
        var x171 uint64
        var x172 uint64
        x172, x171 = bits.Mul64(x163, 0xbfd25e8cd0364141)
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x172, x169, uint64(0x0))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x170, x167, uint64(fiatFqUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x168, x165, uint64(fiatFqUint1(x176)))
        var x180 uint64
        _, x180 = bits.Add64(x155, x171, uint64(0x0))
        var x181 uint64
        var x182 uint64
        x181, x182 = bits.Add64(x157, x173, uint64(fiatFqUint1(x180)))
        var x183 uint64
        var x184 uint64
        x183, x184 = bits.Add64(x159, x175, uint64(fiatFqUint1(x182)))
        var x185 uint64
        var x186 uint64
        x185, x186 = bits.Add64(x161, x177, uint64(fiatFqUint1(x184)))
        var x187 uint64
        var x188 uint64
        x187, x188 = bits.Add64(((uint64(fiatFqUint1(x162)) + uint64(fiatFqUint1(x140))) + (uint64(fiatFqUint1(x154)) + x142)), (uint64(fiatFqUint1(x178)) + x166), uint64(fiatFqUint1(x186)))
        var x189 uint64
        var x190 uint64
        x189, x190 = bits.Sub64(x181, 0xbfd25e8cd0364141, uint64(0x0))
        var x191 uint64
        var x192 uint64
        x191, x192 = bits.Sub64(x183, 0xbaaedce6af48a03b, uint64(fiatFqUint1(x190)))
        var x193 uint64
        var x194 uint64
        x193, x194 = bits.Sub64(x185, 0xfffffffffffffffe, uint64(fiatFqUint1(x192)))
        var x195 uint64
        var x196 uint64
        x195, x196 = bits.Sub64(x187, 0xffffffffffffffff, uint64(fiatFqUint1(x194)))
        var x198 uint64
        _, x198 = bits.Sub64(uint64(fiatFqUint1(x188)), uint64(0x0), uint64(fiatFqUint1(x196)))
        var x199 uint64
        fiatFqCmovznzU64(&amp;x199, fiatFqUint1(x198), x189, x181)
        var x200 uint64
        fiatFqCmovznzU64(&amp;x200, fiatFqUint1(x198), x191, x183)
        var x201 uint64
        fiatFqCmovznzU64(&amp;x201, fiatFqUint1(x198), x193, x185)
        var x202 uint64
        fiatFqCmovznzU64(&amp;x202, fiatFqUint1(x198), x195, x187)
        out1[0] = x199
        out1[1] = x200
        out1[2] = x201
        out1[3] = x202
}</span>

// fiatFqNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqNonzero(out1 *uint64, arg1 *[4]uint64) <span class="cov0" title="0">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | arg1[3])))
        *out1 = x1
}</span>

// fiatFqSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqSelectznz(out1 *[4]uint64, arg1 fiatFqUint1, arg2 *[4]uint64, arg3 *[4]uint64) <span class="cov0" title="0">{
        var x1 uint64
        fiatFqCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFqCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFqCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFqCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
}</span>

// fiatFqToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff]]
func fiatFqToBytes(out1 *[32]uint8, arg1 *[4]uint64) <span class="cov0" title="0">{
        x1 := arg1[3]
        x2 := arg1[2]
        x3 := arg1[1]
        x4 := arg1[0]
        x5 := (uint8(x4) &amp; 0xff)
        x6 := (x4 &gt;&gt; 8)
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := uint8((x16 &gt;&gt; 8))
        x19 := (uint8(x3) &amp; 0xff)
        x20 := (x3 &gt;&gt; 8)
        x21 := (uint8(x20) &amp; 0xff)
        x22 := (x20 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := uint8((x30 &gt;&gt; 8))
        x33 := (uint8(x2) &amp; 0xff)
        x34 := (x2 &gt;&gt; 8)
        x35 := (uint8(x34) &amp; 0xff)
        x36 := (x34 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := uint8((x44 &gt;&gt; 8))
        x47 := (uint8(x1) &amp; 0xff)
        x48 := (x1 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := (x48 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := uint8((x58 &gt;&gt; 8))
        out1[0] = x5
        out1[1] = x7
        out1[2] = x9
        out1[3] = x11
        out1[4] = x13
        out1[5] = x15
        out1[6] = x17
        out1[7] = x18
        out1[8] = x19
        out1[9] = x21
        out1[10] = x23
        out1[11] = x25
        out1[12] = x27
        out1[13] = x29
        out1[14] = x31
        out1[15] = x32
        out1[16] = x33
        out1[17] = x35
        out1[18] = x37
        out1[19] = x39
        out1[20] = x41
        out1[21] = x43
        out1[22] = x45
        out1[23] = x46
        out1[24] = x47
        out1[25] = x49
        out1[26] = x51
        out1[27] = x53
        out1[28] = x55
        out1[29] = x57
        out1[30] = x59
        out1[31] = x60
}</span>

// fiatFqFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqFromBytes(out1 *[4]uint64, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 56)
        x2 := (uint64(arg1[30]) &lt;&lt; 48)
        x3 := (uint64(arg1[29]) &lt;&lt; 40)
        x4 := (uint64(arg1[28]) &lt;&lt; 32)
        x5 := (uint64(arg1[27]) &lt;&lt; 24)
        x6 := (uint64(arg1[26]) &lt;&lt; 16)
        x7 := (uint64(arg1[25]) &lt;&lt; 8)
        x8 := arg1[24]
        x9 := (uint64(arg1[23]) &lt;&lt; 56)
        x10 := (uint64(arg1[22]) &lt;&lt; 48)
        x11 := (uint64(arg1[21]) &lt;&lt; 40)
        x12 := (uint64(arg1[20]) &lt;&lt; 32)
        x13 := (uint64(arg1[19]) &lt;&lt; 24)
        x14 := (uint64(arg1[18]) &lt;&lt; 16)
        x15 := (uint64(arg1[17]) &lt;&lt; 8)
        x16 := arg1[16]
        x17 := (uint64(arg1[15]) &lt;&lt; 56)
        x18 := (uint64(arg1[14]) &lt;&lt; 48)
        x19 := (uint64(arg1[13]) &lt;&lt; 40)
        x20 := (uint64(arg1[12]) &lt;&lt; 32)
        x21 := (uint64(arg1[11]) &lt;&lt; 24)
        x22 := (uint64(arg1[10]) &lt;&lt; 16)
        x23 := (uint64(arg1[9]) &lt;&lt; 8)
        x24 := arg1[8]
        x25 := (uint64(arg1[7]) &lt;&lt; 56)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x25 + x38)
        x40 := (x23 + uint64(x24))
        x41 := (x22 + x40)
        x42 := (x21 + x41)
        x43 := (x20 + x42)
        x44 := (x19 + x43)
        x45 := (x18 + x44)
        x46 := (x17 + x45)
        x47 := (x15 + uint64(x16))
        x48 := (x14 + x47)
        x49 := (x13 + x48)
        x50 := (x12 + x49)
        x51 := (x11 + x50)
        x52 := (x10 + x51)
        x53 := (x9 + x52)
        x54 := (x7 + uint64(x8))
        x55 := (x6 + x54)
        x56 := (x5 + x55)
        x57 := (x4 + x56)
        x58 := (x3 + x57)
        x59 := (x2 + x58)
        x60 := (x1 + x59)
        out1[0] = x39
        out1[1] = x46
        out1[2] = x53
        out1[3] = x60
}</span>

// fiatFqSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFqSetOne(out1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        out1[0] = 0x402da1732fc9bebf
        out1[1] = 0x4551231950b75fc4
        out1[2] = uint64(0x1)
        out1[3] = uint64(0x0)
}</span>

// fiatFqMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqMsat(out1 *[5]uint64) <span class="cov0" title="0">{
        out1[0] = 0xbfd25e8cd0364141
        out1[1] = 0xbaaedce6af48a03b
        out1[2] = 0xfffffffffffffffe
        out1[3] = 0xffffffffffffffff
        out1[4] = uint64(0x0)
}</span>

// fiatFqDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstepPrecomp(out1 *[4]uint64) <span class="cov0" title="0">{
        out1[0] = 0xd7431a4d2b9cb4e9
        out1[1] = 0xab67d35a32d9c503
        out1[2] = 0xadf6c7e5859ce35f
        out1[3] = 0x615441451df6c379
}</span>

// fiatFqDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstep(out1 *uint64, out2 *[5]uint64, out3 *[5]uint64, out4 *[4]uint64, out5 *[4]uint64, arg1 uint64, arg2 *[5]uint64, arg3 *[5]uint64, arg4 *[4]uint64, arg5 *[4]uint64) <span class="cov0" title="0">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFqUint1((x1 &gt;&gt; 63)) &amp; (fiatFqUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFqCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFqCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFqCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFqCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFqCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFqUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFqUint1(x17)))
        var x20 uint64
        x20, _ = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFqUint1(x19)))
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, x3, arg3[0], x12)
        var x23 uint64
        fiatFqCmovznzU64(&amp;x23, x3, arg3[1], x14)
        var x24 uint64
        fiatFqCmovznzU64(&amp;x24, x3, arg3[2], x16)
        var x25 uint64
        fiatFqCmovznzU64(&amp;x25, x3, arg3[3], x18)
        var x26 uint64
        fiatFqCmovznzU64(&amp;x26, x3, arg3[4], x20)
        var x27 uint64
        fiatFqCmovznzU64(&amp;x27, x3, arg4[0], arg5[0])
        var x28 uint64
        fiatFqCmovznzU64(&amp;x28, x3, arg4[1], arg5[1])
        var x29 uint64
        fiatFqCmovznzU64(&amp;x29, x3, arg4[2], arg5[2])
        var x30 uint64
        fiatFqCmovznzU64(&amp;x30, x3, arg4[3], arg5[3])
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x27, x27, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x28, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x29, x29, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x30, x30, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Sub64(x31, 0xbfd25e8cd0364141, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Sub64(x33, 0xbaaedce6af48a03b, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Sub64(x35, 0xfffffffffffffffe, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Sub64(x37, 0xffffffffffffffff, uint64(fiatFqUint1(x44)))
        var x48 uint64
        _, x48 = bits.Sub64(uint64(fiatFqUint1(x38)), uint64(0x0), uint64(fiatFqUint1(x46)))
        x49 := arg4[3]
        x50 := arg4[2]
        x51 := arg4[1]
        x52 := arg4[0]
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(uint64(0x0), x52, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(uint64(0x0), x51, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(uint64(0x0), x50, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(uint64(0x0), x49, uint64(fiatFqUint1(x58)))
        var x61 uint64
        fiatFqCmovznzU64(&amp;x61, fiatFqUint1(x60), uint64(0x0), 0xffffffffffffffff)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x53, (x61 &amp; 0xbfd25e8cd0364141), uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x55, (x61 &amp; 0xbaaedce6af48a03b), uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, (x61 &amp; 0xfffffffffffffffe), uint64(fiatFqUint1(x65)))
        var x68 uint64
        x68, _ = bits.Add64(x59, x61, uint64(fiatFqUint1(x67)))
        var x70 uint64
        fiatFqCmovznzU64(&amp;x70, x3, arg5[0], x62)
        var x71 uint64
        fiatFqCmovznzU64(&amp;x71, x3, arg5[1], x64)
        var x72 uint64
        fiatFqCmovznzU64(&amp;x72, x3, arg5[2], x66)
        var x73 uint64
        fiatFqCmovznzU64(&amp;x73, x3, arg5[3], x68)
        x74 := (fiatFqUint1(x22) &amp; 0x1)
        var x75 uint64
        fiatFqCmovznzU64(&amp;x75, x74, uint64(0x0), x7)
        var x76 uint64
        fiatFqCmovznzU64(&amp;x76, x74, uint64(0x0), x8)
        var x77 uint64
        fiatFqCmovznzU64(&amp;x77, x74, uint64(0x0), x9)
        var x78 uint64
        fiatFqCmovznzU64(&amp;x78, x74, uint64(0x0), x10)
        var x79 uint64
        fiatFqCmovznzU64(&amp;x79, x74, uint64(0x0), x11)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x22, x75, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x23, x76, uint64(fiatFqUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x24, x77, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x25, x78, uint64(fiatFqUint1(x85)))
        var x88 uint64
        x88, _ = bits.Add64(x26, x79, uint64(fiatFqUint1(x87)))
        var x90 uint64
        fiatFqCmovznzU64(&amp;x90, x74, uint64(0x0), x27)
        var x91 uint64
        fiatFqCmovznzU64(&amp;x91, x74, uint64(0x0), x28)
        var x92 uint64
        fiatFqCmovznzU64(&amp;x92, x74, uint64(0x0), x29)
        var x93 uint64
        fiatFqCmovznzU64(&amp;x93, x74, uint64(0x0), x30)
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x70, x90, uint64(0x0))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x71, x91, uint64(fiatFqUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x72, x92, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x73, x93, uint64(fiatFqUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Sub64(x94, 0xbfd25e8cd0364141, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Sub64(x96, 0xbaaedce6af48a03b, uint64(fiatFqUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Sub64(x98, 0xfffffffffffffffe, uint64(fiatFqUint1(x105)))
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Sub64(x100, 0xffffffffffffffff, uint64(fiatFqUint1(x107)))
        var x111 uint64
        _, x111 = bits.Sub64(uint64(fiatFqUint1(x101)), uint64(0x0), uint64(fiatFqUint1(x109)))
        var x112 uint64
        x112, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x114 := ((x80 &gt;&gt; 1) | ((x82 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x115 := ((x82 &gt;&gt; 1) | ((x84 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x116 := ((x84 &gt;&gt; 1) | ((x86 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x117 := ((x86 &gt;&gt; 1) | ((x88 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x118 := ((x88 &amp; 0x8000000000000000) | (x88 &gt;&gt; 1))
        var x119 uint64
        fiatFqCmovznzU64(&amp;x119, fiatFqUint1(x48), x39, x31)
        var x120 uint64
        fiatFqCmovznzU64(&amp;x120, fiatFqUint1(x48), x41, x33)
        var x121 uint64
        fiatFqCmovznzU64(&amp;x121, fiatFqUint1(x48), x43, x35)
        var x122 uint64
        fiatFqCmovznzU64(&amp;x122, fiatFqUint1(x48), x45, x37)
        var x123 uint64
        fiatFqCmovznzU64(&amp;x123, fiatFqUint1(x111), x102, x94)
        var x124 uint64
        fiatFqCmovznzU64(&amp;x124, fiatFqUint1(x111), x104, x96)
        var x125 uint64
        fiatFqCmovznzU64(&amp;x125, fiatFqUint1(x111), x106, x98)
        var x126 uint64
        fiatFqCmovznzU64(&amp;x126, fiatFqUint1(x111), x108, x100)
        *out1 = x112
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out3[0] = x114
        out3[1] = x115
        out3[2] = x116
        out3[3] = x117
        out3[4] = x118
        out4[0] = x119
        out4[1] = x120
        out4[2] = x121
        out4[3] = x122
        out5[0] = x123
        out5[1] = x124
        out5[2] = x125
        out5[3] = x126
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "2^256 - 2^32 - 977" --type Fp --sqrt sqrt
//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "2^256 - 432420386565659656852420866394968145599" --type Fq --sqrt sqrt
package impl

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func sqrt[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any](out, x, rootOfUnity *F, e uint64, progenitorExp []uint8) (ok ct.Bool) <span class="cov0" title="0">{
        return fieldsImpl.TonelliShanks[FP, F](out, x, rootOfUnity, e, progenitorExp)
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FpLimbs     = 4
        FpSatLimbs  = FpLimbs + 1
        FpBits      = 256
        FpBytes     = 8 * (((FpBits - 1) / 64) + 1)
        FpWideBytes = 2 * FpBytes
        FpDivSteps  = ((49 * FpBits) + 57) / 17
        FpE         = 1
)

var (
        FpProgenitorExp = [...]byte{0x0b, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f}
        FpModulus       = [...]byte{0x2f, 0xfc, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
        FpRootOfUnity   Fp
)

func init() <span class="cov8" title="1">{
        FpRootOfUnity.MustSetHex("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e")
}</span>

type Fp struct {
        fiatFpMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fp) Set(v *Fp) <span class="cov8" title="1">{
        *f = *v
}</span>

func (f *Fp) SetZero() <span class="cov8" title="1">{
        *f = Fp{}
}</span>

func (f *Fp) SetOne() <span class="cov8" title="1">{
        fiatFpSetOne(&amp;f.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FpLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fp) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFpToMontgomery(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fp) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FpBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromBytes((*[FpLimbs]uint64)(&amp;nonMonty), (*[FpBytes]uint8)(data))
        fiatFpToMontgomery(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fp) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) &gt; FpWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var wideData [FpWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FpLimbs]uint64
        fiatFpFromBytes(&amp;d0, (*[FpBytes]uint8)(wideData[:FpBytes]))
        fiatFpFromBytes(&amp;d1, (*[FpBytes]uint8)(wideData[FpBytes:]))

        // d0*r2 + d1*r3
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d0), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d1), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d1), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&amp;d0), (*fiatFpMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fp) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fp) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FpBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fp) Select(choice ct.Choice, z, nz *Fp) <span class="cov8" title="1">{
        fiatFpSelectznz((*[FpLimbs]uint64)(&amp;f.fiatFpMontgomeryDomainFieldElement),fiatFpUint1(choice), (*[FpLimbs]uint64)(&amp;z.fiatFpMontgomeryDomainFieldElement), (*[FpLimbs]uint64)(&amp;nz.fiatFpMontgomeryDomainFieldElement))
}</span>

func (f *Fp) Add(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Double(x *Fp) <span class="cov0" title="0">{
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;x.fiatFpMontgomeryDomainFieldElement, &amp;x.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Sub(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpSub(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Neg(v *Fp) <span class="cov8" title="1">{
        fiatFpOpp(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;v.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Mul(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpMul(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Square(v *Fp) <span class="cov8" title="1">{
        fiatFpSquare(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;v.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Inv(a *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var precomp, h, v, r, out4, out5 [FpLimbs]uint64
        var ff, g, out2, out3 [FpSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFpDivstepPrecomp(&amp;precomp)
        fiatFpFromMontgomery((*fiatFpNonMontgomeryDomainFieldElement)(g[:FpLimbs]), &amp;a.fiatFpMontgomeryDomainFieldElement)
        fiatFpMsat(&amp;ff)
        fiatFpSetOne((*fiatFpMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FpDivSteps-(FpDivSteps%2); i += 2 </span><span class="cov8" title="1">{
                fiatFpDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFpDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov8" title="1">if (FpDivSteps % 2) != 0 </span><span class="cov8" title="1">{ // compile time if - always true
                fiatFpDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov8" title="1">fiatFpOpp((*fiatFpMontgomeryDomainFieldElement)(&amp;h), (*fiatFpMontgomeryDomainFieldElement)(&amp;v))
        fiatFpSelectznz(&amp;v, fiatFpUint1(ff[FpLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFpMul(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&amp;v), (*fiatFpMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFpNonzero(&amp;inverted, (*[FpLimbs]uint64)(&amp;f.fiatFpMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fp) Div(lhs, rhs *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var rhsInv Fp
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fp) Sqrt(x *Fp) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(sqrt(f, x, &amp;FpRootOfUnity, FpE, FpProgenitorExp[:]))
}</span>

func (f *Fp) IsNonZero() ct.Bool <span class="cov8" title="1">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFpNonzero(&amp;nonZero, (*[FpLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fp) IsZero() ct.Bool <span class="cov8" title="1">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fp) IsOne() ct.Bool <span class="cov0" title="0">{
        var one Fp
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fp) Equal(v *Fp) ct.Bool <span class="cov8" title="1">{
        var diff Fp
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fp) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fp) Bytes() []byte <span class="cov8" title="1">{
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)
        var data [FpBytes]byte
        fiatFpToBytes(&amp;data, (*[FpLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fp) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fp) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fp) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fp) Degree() uint64 <span class="cov8" title="1">{
        return 1
}</span>

func (f *Fp) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fp) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FqLimbs     = 4
        FqSatLimbs  = FqLimbs + 1
        FqBits      = 256
        FqBytes     = 8 * (((FqBits - 1) / 64) + 1)
        FqWideBytes = 2 * FqBytes
        FqDivSteps  = ((49 * FqBits) + 57) / 17
        FqE         = 6
)

var (
        FqProgenitorExp = [...]byte{0x82, 0x6c, 0xa0, 0x19, 0xbd, 0xa4, 0x7f, 0x77, 0x40, 0x91, 0x5e, 0xcd, 0xb9, 0x5d, 0x75, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01}
        FqModulus       = [...]byte{0x41, 0x41, 0x36, 0xd0, 0x8c, 0x5e, 0xd2, 0xbf, 0x3b, 0xa0, 0x48, 0xaf, 0xe6, 0xdc, 0xae, 0xba, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
        FqRootOfUnity   Fq
)

func init() <span class="cov8" title="1">{
        FqRootOfUnity.MustSetHex("0c1dc060e7a91986df9879a3fbc483a898bdeab680756045992f4b5402b052f2")
}</span>

type Fq struct {
        fiatFqMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fq) Set(v *Fq) <span class="cov0" title="0">{
        *f = *v
}</span>

func (f *Fq) SetZero() <span class="cov0" title="0">{
        *f = Fq{}
}</span>

func (f *Fq) SetOne() <span class="cov0" title="0">{
        fiatFqSetOne(&amp;f.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FqLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fq) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fq) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FqBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromBytes((*[FqLimbs]uint64)(&amp;nonMonty), (*[FqBytes]uint8)(data))
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fq) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(data) &gt; FqWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var wideData [FqWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FqLimbs]uint64
        fiatFqFromBytes(&amp;d0, (*[FqBytes]uint8)(wideData[:FqBytes]))
        fiatFqFromBytes(&amp;d1, (*[FqBytes]uint8)(wideData[FqBytes:]))

        // d0*r2 + d1*r3
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fq) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fq) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FqBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fq) Select(choice ct.Choice, z, nz *Fq) <span class="cov0" title="0">{
        fiatFqSelectznz((*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement),fiatFqUint1(choice), (*[FqLimbs]uint64)(&amp;z.fiatFqMontgomeryDomainFieldElement), (*[FqLimbs]uint64)(&amp;nz.fiatFqMontgomeryDomainFieldElement))
}</span>

func (f *Fq) Add(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Double(x *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Sub(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqSub(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Neg(v *Fq) <span class="cov0" title="0">{
        fiatFqOpp(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Mul(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Square(v *Fq) <span class="cov0" title="0">{
        fiatFqSquare(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Inv(a *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        var precomp, h, v, r, out4, out5 [FqLimbs]uint64
        var ff, g, out2, out3 [FqSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFqDivstepPrecomp(&amp;precomp)
        fiatFqFromMontgomery((*fiatFqNonMontgomeryDomainFieldElement)(g[:FqLimbs]), &amp;a.fiatFqMontgomeryDomainFieldElement)
        fiatFqMsat(&amp;ff)
        fiatFqSetOne((*fiatFqMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FqDivSteps-(FqDivSteps%2); i += 2 </span><span class="cov0" title="0">{
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFqDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov0" title="0">if (FqDivSteps % 2) != 0 </span><span class="cov0" title="0">{ // compile time if - always true
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov0" title="0">fiatFqOpp((*fiatFqMontgomeryDomainFieldElement)(&amp;h), (*fiatFqMontgomeryDomainFieldElement)(&amp;v))
        fiatFqSelectznz(&amp;v, fiatFqUint1(ff[FqLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;v), (*fiatFqMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFqNonzero(&amp;inverted, (*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fq) Div(lhs, rhs *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        var rhsInv Fq
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fq) Sqrt(x *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(sqrt(f, x, &amp;FqRootOfUnity, FqE, FqProgenitorExp[:]))
}</span>

func (f *Fq) IsNonZero() ct.Bool <span class="cov0" title="0">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFqNonzero(&amp;nonZero, (*[FqLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fq) IsZero() ct.Bool <span class="cov0" title="0">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fq) IsOne() ct.Bool <span class="cov0" title="0">{
        var one Fq
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fq) Equal(v *Fq) ct.Bool <span class="cov0" title="0">{
        var diff Fq
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fq) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fq) Bytes() []byte <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        var data [FqBytes]byte
        fiatFqToBytes(&amp;data, (*[FqLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fq) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fq) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fq) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fq) Degree() uint64 <span class="cov0" title="0">{
        return 1
}</span>

func (f *Fq) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fq) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package impl

import (
        "crypto/sha256"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        pointsImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu"
)

var (
        _ pointsImpl.ShortWeierstrassCurveParams[*Fp] = curveParams{}
        _ h2c.HasherParams                            = CurveHasherParams{}
        _ sswu.ZeroPointMapperParams[*Fp, Fp]         = curveMapperParams{}
        _ h2c.PointMapper[*Fp]                        = curveMapper{}
)

var (
        curveB               Fp
        curveB3              Fp
        curveGx              Fp
        curveGy              Fp
        curveMessageExpander = h2c.NewXMDMessageExpander(sha256.New)

        sqrtRatioC1 = [...]uint8{0x0b, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f}
        sqrtRatioC2 Fp

        sswuZ           Fp
        sswuIsogenyA    Fp
        sswuIsogenyB    Fp
        sswuIsogenyXNum [4]Fp
        sswuIsogenyXDen [3]Fp
        sswuIsogenyYNum [4]Fp
        sswuIsogenyYDen [4]Fp
)

type curveParams struct{}

// CurveHasherParams defines hash-to-curve parameters.
type CurveHasherParams struct{}
type curveMapperParams struct{}
type curveMapper = sswu.ZeroPointMapper[*Fp, curveMapperParams, Fp]

//nolint:gochecknoinits // keep for static parameters
func init() <span class="cov8" title="1">{
        curveB.MustSetHex("0000000000000000000000000000000000000000000000000000000000000007")
        curveB3.MustSetHex("0000000000000000000000000000000000000000000000000000000000000015")
        curveGx.MustSetHex("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        curveGy.MustSetHex("483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")

        sqrtRatioC2.MustSetHex("31fdf302724013e57ad13fb38f842afeec184f00a74789dd286729c8303c4a59")

        sswuZ.MustSetHex("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc24")
        sswuIsogenyA.MustSetHex("3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533")
        sswuIsogenyB.MustSetHex("00000000000000000000000000000000000000000000000000000000000006eb")
        sswuIsogenyXNum[0].MustSetHex("8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7")
        sswuIsogenyXNum[1].MustSetHex("07d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581")
        sswuIsogenyXNum[2].MustSetHex("534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262")
        sswuIsogenyXNum[3].MustSetHex("8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c")
        sswuIsogenyXDen[0].MustSetHex("d35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b")
        sswuIsogenyXDen[1].MustSetHex("edadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14")
        sswuIsogenyXDen[2].SetOne()
        sswuIsogenyYNum[0].MustSetHex("4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c")
        sswuIsogenyYNum[1].MustSetHex("c75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3")
        sswuIsogenyYNum[2].MustSetHex("29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931")
        sswuIsogenyYNum[3].MustSetHex("2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84")
        sswuIsogenyYDen[0].MustSetHex("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b")
        sswuIsogenyYDen[1].MustSetHex("7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573")
        sswuIsogenyYDen[2].MustSetHex("6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f")
        sswuIsogenyYDen[3].SetOne()
}</span>

// SetGenerator sets generator coordinates.
func (curveParams) SetGenerator(xOut, yOut, zOut *Fp) <span class="cov0" title="0">{
        xOut.Set(&amp;curveGx)
        yOut.Set(&amp;curveGy)
        zOut.SetOne()
}</span>

// ClearCofactor clears the cofactor of the input point.
func (curveParams) ClearCofactor(xOut, yOut, zOut, xIn, yIn, zIn *Fp) <span class="cov8" title="1">{
        xOut.Set(xIn)
        yOut.Set(yIn)
        zOut.Set(zIn)
}</span>

// MulByA multiples provided element by 0 (secp256k1 a=0).
func (curveParams) MulByA(out *Fp, _ *Fp) <span class="cov8" title="1">{
        out.SetZero()
}</span>

// MulBy3B multiples provided element by 21 (secp256k1 b=7, hence 3*7 = 21).
func (curveParams) MulBy3B(out *Fp, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;curveB3)
}</span>

// AddA adds the curve A parameter to in.
func (curveParams) AddA(out *Fp, in *Fp) <span class="cov0" title="0">{
        out.Set(in)
}</span>

// AddB adds the curve B parameter to in.
func (curveParams) AddB(out *Fp, in *Fp) <span class="cov0" title="0">{
        out.Add(in, &amp;curveB)
}</span>

// L returns the hash-to-field length in bytes.
func (CurveHasherParams) L() uint64 <span class="cov8" title="1">{
        return 48
}</span>

// MessageExpander returns the RFC 9380 message expander.
func (CurveHasherParams) MessageExpander() h2c.MessageExpander <span class="cov8" title="1">{
        return curveMessageExpander
}</span>

// MulByA multiplies by the curve A parameter.
func (curveMapperParams) MulByA(out, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;sswuIsogenyA)
}</span>

// MulByB multiplies by the curve B parameter.
func (curveMapperParams) MulByB(out, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;sswuIsogenyB)
}</span>

// SetZ sets the SSWU Z parameter.
func (curveMapperParams) SetZ(out *Fp) <span class="cov8" title="1">{
        out.Set(&amp;sswuZ)
}</span>

// SqrtRatio computes sqrt(u/v) with curve-specific parameters.
func (curveMapperParams) SqrtRatio(y, u, v *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        return sswu.SqrtRatio3Mod4(y, sqrtRatioC1[:], &amp;sqrtRatioC2, u, v)
}</span>

// Sgn0 returns the sign bit per RFC 9380.
func (curveMapperParams) Sgn0(v *Fp) ct.Bool <span class="cov8" title="1">{
        return ct.Bool(uint64(v.Bytes()[0] &amp; 0b1))
}</span>

// XNum returns isogeny x numerator coefficients.
func (curveMapperParams) XNum() []Fp <span class="cov8" title="1">{
        return sswuIsogenyXNum[:]
}</span>

// XDen returns isogeny x denominator coefficients.
func (curveMapperParams) XDen() []Fp <span class="cov8" title="1">{
        return sswuIsogenyXDen[:]
}</span>

// YNum returns isogeny y numerator coefficients.
func (curveMapperParams) YNum() []Fp <span class="cov8" title="1">{
        return sswuIsogenyYNum[:]
}</span>

// YDen returns isogeny y denominator coefficients.
func (curveMapperParams) YDen() []Fp <span class="cov8" title="1">{
        return sswuIsogenyYDen[:]
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package k256

import (
        "encoding"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        k256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

const (
        // ScalarFieldName is the scalar field name.
        ScalarFieldName = "secp256k1Fq"
)

var (
        _ algebra.PrimeField[*Scalar]        = (*ScalarField)(nil)
        _ algebra.PrimeFieldElement[*Scalar] = (*Scalar)(nil)
        _ encoding.BinaryMarshaler           = (*Scalar)(nil)
        _ encoding.BinaryUnmarshaler         = (*Scalar)(nil)

        scalarFieldInitOnce sync.Once
        scalarFieldInstance *ScalarField
        scalarFieldOrder    *numct.Modulus
)

func scalarFieldInit() <span class="cov8" title="1">{
        orderBytes := make([]byte, len(k256Impl.FqModulus))
        copy(orderBytes, k256Impl.FqModulus[:])
        slices.Reverse(orderBytes)
        scalarFieldOrder, _ = numct.NewModulusFromBytesBE(orderBytes)
        //nolint:exhaustruct // no need for trait
        scalarFieldInstance = &amp;ScalarField{}
}</span>

// ScalarField represents the scalar field.
type ScalarField struct {
        traits.PrimeFieldTrait[*k256Impl.Fq, *Scalar, Scalar]
}

// NewScalarField returns the scalar field instance.
func NewScalarField() *ScalarField <span class="cov8" title="1">{
        scalarFieldInitOnce.Do(scalarFieldInit)
        return scalarFieldInstance
}</span>

// Name returns the name of the structure.
func (*ScalarField) Name() string <span class="cov0" title="0">{
        return ScalarFieldName
}</span>

// Order returns the group or field order.
func (*ScalarField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder.Nat())
}</span>

// Characteristic returns the field characteristic.
func (*ScalarField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder.Nat())
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *ScalarField) FromBytesBEReduce(input []byte) (*Scalar, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        scalarFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// Hash maps input bytes to an element or point.
func (*ScalarField) Hash(bytes []byte) (*Scalar, error) <span class="cov0" title="0">{
        var e [1]k256Impl.Fq
        h2c.HashToField(e[:], k256Impl.CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveScalarSuite, bytes)

        var s Scalar
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// ElementSize returns the element size in bytes.
func (*ScalarField) ElementSize() int <span class="cov0" title="0">{
        return k256Impl.FqBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*ScalarField) WideElementSize() int <span class="cov0" title="0">{
        return k256Impl.FqWideBytes
}</span>

// BitLen returns the field modulus bit length.
func (*ScalarField) BitLen() int <span class="cov0" title="0">{
        return k256Impl.FqBits
}</span>

// Scalar represents a scalar field element.
type Scalar struct {
        traits.PrimeFieldElementTrait[*k256Impl.Fq, k256Impl.Fq, *Scalar, Scalar]
}

// Structure returns the algebraic structure for the receiver.
func (*Scalar) Structure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *Scalar) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *Scalar) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("failed to unmarshal field element")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package p256

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*BaseFieldElement)(nil)
        _ cbor.Unmarshaler = (*BaseFieldElement)(nil)
        _ cbor.Marshaler   = (*Scalar)(nil)
        _ cbor.Unmarshaler = (*Scalar)(nil)
        _ cbor.Marshaler   = (*Point)(nil)
        _ cbor.Unmarshaler = (*Point)(nil)
)

type baseFieldDTO struct {
        BaseFieldBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *BaseFieldElement) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;baseFieldDTO{BaseFieldBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *BaseFieldElement) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*baseFieldDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">bfe, err := NewBaseField().FromBytes(dto.BaseFieldBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize base field element")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;bfe.V)
        return nil</span>
}

type scalarDTO struct {
        ScalarBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *Scalar) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;scalarDTO{ScalarBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *Scalar) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*scalarDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s, err := NewScalarField().FromBytes(dto.ScalarBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize scalar")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;s.V)
        return nil</span>
}

type pointDTO struct {
        AffineCompressedBytes []byte `cbor:"compressedBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (p *Point) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;pointDTO{AffineCompressedBytes: p.ToCompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *Point) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*pointDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pp, err := NewCurve().FromCompressed(dto.AffineCompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov8" title="1">p.V.Set(&amp;pp.V)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package p256

import (
        "crypto/elliptic"
        "encoding"
        "fmt"
        "hash/fnv"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        p256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // CurveName is the curve name.
        CurveName = "P256"
        // Hash2CurveSuite is the hash-to-curve suite string.
        Hash2CurveSuite = "P256_XMD:SHA-256_SSWU_RO_"
        // Hash2CurveScalarSuite is the hash-to-curve scalar suite string.
        Hash2CurveScalarSuite = "P256_XMD:SHA-256_SSWU_RO_SC_"
        compressedPointBytes  = p256Impl.FpBytes + 1 // 33 bytes for compressed point
)

var (
        _ curves.Curve[*Point, *BaseFieldElement, *Scalar] = (*Curve)(nil)
        _ curves.Point[*Point, *BaseFieldElement, *Scalar] = (*Point)(nil)
        _ encoding.BinaryMarshaler                         = (*Point)(nil)
        _ encoding.BinaryUnmarshaler                       = (*Point)(nil)

        curveInstance *Curve
        curveInitOnce sync.Once
)

// Curve represents the elliptic curve group.
type Curve struct {
        traits.PrimeCurveTrait[*p256Impl.Fp, *p256Impl.Point, *Point, Point]
}

// NewCurve returns the curve instance.
func NewCurve() *Curve <span class="cov8" title="1">{
        curveInitOnce.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for a trait
                curveInstance = &amp;Curve{}
        }</span>)

        <span class="cov8" title="1">return curveInstance</span>
}

// Name returns the name of the structure.
func (*Curve) Name() string <span class="cov0" title="0">{
        return CurveName
}</span>

// ElementSize returns the element size in bytes.
func (*Curve) ElementSize() int <span class="cov0" title="0">{
        return compressedPointBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*Curve) WideElementSize() int <span class="cov0" title="0">{
        return int(^uint(0) &gt;&gt; 1)
}</span>

// FromWideBytes decodes an element from wide bytes.
func (c *Curve) FromWideBytes(input []byte) (*Point, error) <span class="cov0" title="0">{
        return c.Hash(input)
}</span>

// Cofactor returns the curve cofactor.
func (*Curve) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(1)
}</span>

// Order returns the group or field order.
func (*Curve) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewScalarField().Order()
}</span>

// FromCompressed decodes a compressed point.
func (c *Curve) FromCompressed(input []byte) (*Point, error) <span class="cov8" title="1">{
        if len(input) != compressedPointBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid byte sequence")
        }</span>

        <span class="cov8" title="1">sign := input[0]
        if sign != 2 &amp;&amp; sign != 3 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid sign byte")
        }</span>
        <span class="cov8" title="1">sign &amp;= 0x1

        var xBytes [p256Impl.FpBytes]byte
        copy(xBytes[:], input[1:])
        slices.Reverse(xBytes[:])

        var x, y p256Impl.Fp
        ok := x.SetBytes(xBytes[:])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov8" title="1">if x.IsZero() == 1 </span><span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov8" title="1">var result Point
        ok = result.V.SetFromAffineX(&amp;x)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov8" title="1">ok = result.V.ToAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov8" title="1">ySign := result.V.Y.Bytes()[0] &amp; 0b1
        if sign != ySign </span><span class="cov0" title="0">{
                result.V.Neg(&amp;result.V)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// FromBytes decodes an element from bytes.
func (c *Curve) FromBytes(input []byte) (*Point, error) <span class="cov0" title="0">{
        return c.FromCompressed(input)
}</span>

// FromUncompressed decodes an uncompressed point.
func (c *Curve) FromUncompressed(input []byte) (*Point, error) <span class="cov0" title="0">{
        if len(input) != 65 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid byte sequence")
        }</span>
        <span class="cov0" title="0">if input[0] != 4 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid sign byte")
        }</span>

        <span class="cov0" title="0">var xBytes, yBytes [32]byte
        copy(xBytes[:], input[1:33])
        copy(yBytes[:], input[33:])
        slices.Reverse(xBytes[:])
        slices.Reverse(yBytes[:])

        var x, y p256Impl.Fp
        okx := x.SetBytes(xBytes[:])
        if okx != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov0" title="0">oky := y.SetBytes(yBytes[:])
        if oky != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("y")
        }</span>
        <span class="cov0" title="0">if x.IsZero() == 1 &amp;&amp; y.IsZero() == 1 </span><span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov0" title="0">var result Point
        ok := result.V.SetAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// FromAffine builds a point from affine coordinates.
func (*Curve) FromAffine(x, y *BaseFieldElement) (*Point, error) <span class="cov0" title="0">{
        var p Point
        ok := p.V.SetAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

// FromAffineX builds a point from an affine x-coordinate.
func (*Curve) FromAffineX(x *BaseFieldElement, b bool) (*Point, error) <span class="cov0" title="0">{
        var p Point
        ok := p.V.SetFromAffineX(&amp;x.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov0" title="0">y, err := p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // should never happen
        }
        <span class="cov0" title="0">if y.IsOdd() != b </span><span class="cov0" title="0">{
                return p.Neg(), nil
        }</span> else<span class="cov0" title="0"> {
                return &amp;p, nil
        }</span>
}

// Hash maps input bytes to an element or point.
func (c *Curve) Hash(bytes []byte) (*Point, error) <span class="cov0" title="0">{
        return c.HashWithDst(base.Hash2CurveAppTag+Hash2CurveSuite, bytes)
}</span>

// HashWithDst maps input bytes to a point with a custom DST.
func (*Curve) HashWithDst(dst string, bytes []byte) (*Point, error) <span class="cov0" title="0">{
        var p Point
        p.V.Hash(dst, bytes)
        return &amp;p, nil
}</span>

// ToElliptic returns the standard library elliptic.Curve adapter.
func (*Curve) ToElliptic() elliptic.Curve <span class="cov0" title="0">{
        return elliptic.P256()
}</span>

// ScalarStructure returns the scalar structure.
func (*Curve) ScalarStructure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseStructure returns the base field structure.
func (*Curve) BaseStructure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// ScalarRing returns the scalar ring.
func (*Curve) ScalarRing() algebra.ZModLike[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarField returns the scalar field.
func (*Curve) ScalarField() algebra.PrimeField[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseField returns the base field.
func (*Curve) BaseField() algebra.FiniteField[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// ScalarBaseOp adds a scalar multiple of the generator.
func (c *Curve) ScalarBaseOp(sc *Scalar) *Point <span class="cov0" title="0">{
        if sc.IsZero() </span><span class="cov0" title="0">{
                return c.OpIdentity()
        }</span>
        <span class="cov0" title="0">return c.ScalarBaseMul(sc)</span>
}

// ScalarBaseMul multiplies the generator by a scalar.
func (c *Curve) ScalarBaseMul(sc *Scalar) *Point <span class="cov0" title="0">{
        return c.Generator().ScalarMul(sc)
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *Curve) MultiScalarOp(scalars []*Scalar, points []*Point) (*Point, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*Curve) MultiScalarMul(scalars []*Scalar, points []*Point) (*Point, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result Point
        scs := make([][]byte, len(scalars))
        pts := make([]*p256Impl.Point, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// Point represents a curve point.
type Point struct {
        traits.PrimePointTrait[*p256Impl.Fp, *p256Impl.Point, p256Impl.Point, *Point, Point]
}

// HashCode returns a hash code for the receiver.
func (p *Point) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(p.ToCompressed())
        return base.HashCode(h.Sum64())
}</span>

// Structure returns the algebraic structure for the receiver.
func (*Point) Structure() algebra.Structure[*Point] <span class="cov0" title="0">{
        return NewCurve()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (p *Point) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return p.ToCompressed(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (p *Point) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        pp, err := NewCurve().FromCompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}

// ToCompressed encodes the point in compressed form.
func (p *Point) ToCompressed() []byte <span class="cov8" title="1">{
        var compressedBytes [compressedPointBytes]byte
        compressedBytes[0] = byte(2)
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                return compressedBytes[:]
        }</span>

        <span class="cov8" title="1">var px, py p256Impl.Fp
        ok := p.V.ToAffine(&amp;px, &amp;py)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov8" title="1">compressedBytes[0] |= py.Bytes()[0] &amp; 1
        pxBytes := px.Bytes()
        slices.Reverse(pxBytes)
        copy(compressedBytes[1:], pxBytes)
        return compressedBytes[:]</span>
}

// Bytes returns the canonical byte encoding.
func (p *Point) Bytes() []byte <span class="cov0" title="0">{
        return p.ToCompressed()
}</span>

// ToUncompressed encodes the point in uncompressed form.
func (p *Point) ToUncompressed() []byte <span class="cov0" title="0">{
        var out [65]byte
        out[0] = byte(4)
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                return out[:]
        }</span>

        <span class="cov0" title="0">var px, py p256Impl.Fp
        ok := p.V.ToAffine(&amp;px, &amp;py)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov0" title="0">pxBytes := px.Bytes()
        slices.Reverse(pxBytes)
        copy(out[1:33], pxBytes)

        pyBytes := py.Bytes()
        slices.Reverse(pyBytes)
        copy(out[33:], pyBytes)

        return out[:]</span>
}

// AffineX returns the affine x-coordinate.
func (p *Point) AffineX() (*BaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;x, nil</span>
}

// AffineY returns the affine y-coordinate.
func (p *Point) AffineY() (*BaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;y, nil</span>
}

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *Point) ScalarOp(sc *Scalar) *Point <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *Point) ScalarMul(actor *Scalar) *Point <span class="cov0" title="0">{
        var result Point
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (*Point) IsTorsionFree() bool <span class="cov0" title="0">{
        return true
}</span>

// String returns the string form of the receiver.
func (p *Point) String() string <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return "(0, 1, 0)"
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("(%s, %s, %s)", p.V.X.String(), p.V.Y.String(), p.V.Z.String())
        }</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package p256

import (
        "encoding"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        p256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

const (
        // BaseFieldName is the base field name.
        BaseFieldName = "P256Fp"
)

var (
        _ algebra.PrimeField[*BaseFieldElement]        = (*BaseField)(nil)
        _ algebra.PrimeFieldElement[*BaseFieldElement] = (*BaseFieldElement)(nil)
        _ encoding.BinaryMarshaler                     = (*BaseFieldElement)(nil)
        _ encoding.BinaryUnmarshaler                   = (*BaseFieldElement)(nil)

        baseFieldInstance *BaseField
        baseFieldInitOnce sync.Once
        baseFieldOrder    *numct.Modulus
)

// BaseField represents the curve base field.
type BaseField struct {
        traits.PrimeFieldTrait[*p256Impl.Fp, *BaseFieldElement, BaseFieldElement]
}

// NewBaseField returns the base field instance.
func NewBaseField() *BaseField <span class="cov8" title="1">{
        baseFieldInitOnce.Do(func() </span><span class="cov8" title="1">{
                var ok ct.Bool
                v := numct.NewNatFromBytes(sliceutils.Reversed(p256Impl.FpModulus[:]))
                baseFieldOrder, ok = numct.NewModulus(v)
                if ok == ct.False </span><span class="cov0" title="0">{
                        panic("failed to create base field modulus")</span>
                }
                //nolint:exhaustruct // no need for a trait
                <span class="cov8" title="1">baseFieldInstance = &amp;BaseField{}</span>
        })

        <span class="cov8" title="1">return baseFieldInstance</span>
}

// Name returns the name of the structure.
func (*BaseField) Name() string <span class="cov0" title="0">{
        return BaseFieldName
}</span>

// Order returns the group or field order.
func (*BaseField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(baseFieldOrder.Nat())
}</span>

// Characteristic returns the field characteristic.
func (*BaseField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(baseFieldOrder.Nat())
}</span>

// Hash maps input bytes to an element or point.
func (*BaseField) Hash(bytes []byte) (*BaseFieldElement, error) <span class="cov0" title="0">{
        var e [1]p256Impl.Fp
        h2c.HashToField(e[:], p256Impl.CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveSuite, bytes)

        var s BaseFieldElement
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// ElementSize returns the element size in bytes.
func (*BaseField) ElementSize() int <span class="cov0" title="0">{
        return p256Impl.FpBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*BaseField) WideElementSize() int <span class="cov0" title="0">{
        return p256Impl.FpWideBytes
}</span>

// BitLen returns the field modulus bit length.
func (*BaseField) BitLen() int <span class="cov0" title="0">{
        return p256Impl.FpBits
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *BaseField) FromBytesBEReduce(input []byte) (*BaseFieldElement, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        baseFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// BaseFieldElement represents an element of the base field.
type BaseFieldElement struct {
        traits.PrimeFieldElementTrait[*p256Impl.Fp, p256Impl.Fp, *BaseFieldElement, BaseFieldElement]
}

// Structure returns the algebraic structure for the receiver.
func (*BaseFieldElement) Structure() algebra.Structure[*BaseFieldElement] <span class="cov0" title="0">{
        return NewBaseField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *BaseFieldElement) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *BaseFieldElement) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("failed to unmarshal field element")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fp 64 '2^256 - 2^224 + 2^192 + 2^96 - 1'
//
// curve description: Fp
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff (from "2^256 - 2^224 + 2^192 + 2^96 - 1")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) in
//
//                            if x1 &amp; (2^256-1) &lt; 2^255 then x1 &amp; (2^256-1) else (x1 &amp; (2^256-1)) - 2^256
package impl

import "math/bits"

type fiatFpUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFpInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFpMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFpMontgomeryDomainFieldElement [4]uint64

// fiatFpNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFpNonMontgomeryDomainFieldElement [4]uint64

// fiatFpCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpCmovznzU64(out1 *uint64, arg1 fiatFpUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFpMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpMul(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg2[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg2[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg2[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg2[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFpUint1(x16)))
        x19 := (uint64(fiatFpUint1(x18)) + x6)
        var x20 uint64
        var x21 uint64
        x21, x20 = bits.Mul64(x11, 0xffffffff00000001)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x11, 0xffffffff)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x11, 0xffffffffffffffff)
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(x25, x22, uint64(0x0))
        x28 := (uint64(fiatFpUint1(x27)) + x23)
        var x30 uint64
        _, x30 = bits.Add64(x11, x24, uint64(0x0))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x13, x26, uint64(fiatFpUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x15, x28, uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x17, x20, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x19, x21, uint64(fiatFpUint1(x36)))
        var x39 uint64
        var x40 uint64
        x40, x39 = bits.Mul64(x1, arg2[3])
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, arg2[2])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, arg2[1])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, arg2[0])
        var x47 uint64
        var x48 uint64
        x47, x48 = bits.Add64(x46, x43, uint64(0x0))
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x44, x41, uint64(fiatFpUint1(x48)))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x42, x39, uint64(fiatFpUint1(x50)))
        x53 := (uint64(fiatFpUint1(x52)) + x40)
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64(x31, x45, uint64(0x0))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x33, x47, uint64(fiatFpUint1(x55)))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x35, x49, uint64(fiatFpUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x37, x51, uint64(fiatFpUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(uint64(fiatFpUint1(x38)), x53, uint64(fiatFpUint1(x61)))
        var x64 uint64
        var x65 uint64
        x65, x64 = bits.Mul64(x54, 0xffffffff00000001)
        var x66 uint64
        var x67 uint64
        x67, x66 = bits.Mul64(x54, 0xffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x54, 0xffffffffffffffff)
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(x69, x66, uint64(0x0))
        x72 := (uint64(fiatFpUint1(x71)) + x67)
        var x74 uint64
        _, x74 = bits.Add64(x54, x68, uint64(0x0))
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Add64(x56, x70, uint64(fiatFpUint1(x74)))
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x58, x72, uint64(fiatFpUint1(x76)))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x60, x64, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x62, x65, uint64(fiatFpUint1(x80)))
        x83 := (uint64(fiatFpUint1(x82)) + uint64(fiatFpUint1(x63)))
        var x84 uint64
        var x85 uint64
        x85, x84 = bits.Mul64(x2, arg2[3])
        var x86 uint64
        var x87 uint64
        x87, x86 = bits.Mul64(x2, arg2[2])
        var x88 uint64
        var x89 uint64
        x89, x88 = bits.Mul64(x2, arg2[1])
        var x90 uint64
        var x91 uint64
        x91, x90 = bits.Mul64(x2, arg2[0])
        var x92 uint64
        var x93 uint64
        x92, x93 = bits.Add64(x91, x88, uint64(0x0))
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x89, x86, uint64(fiatFpUint1(x93)))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x87, x84, uint64(fiatFpUint1(x95)))
        x98 := (uint64(fiatFpUint1(x97)) + x85)
        var x99 uint64
        var x100 uint64
        x99, x100 = bits.Add64(x75, x90, uint64(0x0))
        var x101 uint64
        var x102 uint64
        x101, x102 = bits.Add64(x77, x92, uint64(fiatFpUint1(x100)))
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x94, uint64(fiatFpUint1(x102)))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x96, uint64(fiatFpUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x98, uint64(fiatFpUint1(x106)))
        var x109 uint64
        var x110 uint64
        x110, x109 = bits.Mul64(x99, 0xffffffff00000001)
        var x111 uint64
        var x112 uint64
        x112, x111 = bits.Mul64(x99, 0xffffffff)
        var x113 uint64
        var x114 uint64
        x114, x113 = bits.Mul64(x99, 0xffffffffffffffff)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x114, x111, uint64(0x0))
        x117 := (uint64(fiatFpUint1(x116)) + x112)
        var x119 uint64
        _, x119 = bits.Add64(x99, x113, uint64(0x0))
        var x120 uint64
        var x121 uint64
        x120, x121 = bits.Add64(x101, x115, uint64(fiatFpUint1(x119)))
        var x122 uint64
        var x123 uint64
        x122, x123 = bits.Add64(x103, x117, uint64(fiatFpUint1(x121)))
        var x124 uint64
        var x125 uint64
        x124, x125 = bits.Add64(x105, x109, uint64(fiatFpUint1(x123)))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x107, x110, uint64(fiatFpUint1(x125)))
        x128 := (uint64(fiatFpUint1(x127)) + uint64(fiatFpUint1(x108)))
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x3, arg2[3])
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x3, arg2[2])
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x3, arg2[1])
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, arg2[0])
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x136, x133, uint64(0x0))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x134, x131, uint64(fiatFpUint1(x138)))
        var x141 uint64
        var x142 uint64
        x141, x142 = bits.Add64(x132, x129, uint64(fiatFpUint1(x140)))
        x143 := (uint64(fiatFpUint1(x142)) + x130)
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x120, x135, uint64(0x0))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x122, x137, uint64(fiatFpUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x124, x139, uint64(fiatFpUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x126, x141, uint64(fiatFpUint1(x149)))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Add64(x128, x143, uint64(fiatFpUint1(x151)))
        var x154 uint64
        var x155 uint64
        x155, x154 = bits.Mul64(x144, 0xffffffff00000001)
        var x156 uint64
        var x157 uint64
        x157, x156 = bits.Mul64(x144, 0xffffffff)
        var x158 uint64
        var x159 uint64
        x159, x158 = bits.Mul64(x144, 0xffffffffffffffff)
        var x160 uint64
        var x161 uint64
        x160, x161 = bits.Add64(x159, x156, uint64(0x0))
        x162 := (uint64(fiatFpUint1(x161)) + x157)
        var x164 uint64
        _, x164 = bits.Add64(x144, x158, uint64(0x0))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x146, x160, uint64(fiatFpUint1(x164)))
        var x167 uint64
        var x168 uint64
        x167, x168 = bits.Add64(x148, x162, uint64(fiatFpUint1(x166)))
        var x169 uint64
        var x170 uint64
        x169, x170 = bits.Add64(x150, x154, uint64(fiatFpUint1(x168)))
        var x171 uint64
        var x172 uint64
        x171, x172 = bits.Add64(x152, x155, uint64(fiatFpUint1(x170)))
        x173 := (uint64(fiatFpUint1(x172)) + uint64(fiatFpUint1(x153)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Sub64(x165, 0xffffffffffffffff, uint64(0x0))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Sub64(x167, 0xffffffff, uint64(fiatFpUint1(x175)))
        var x178 uint64
        var x179 uint64
        x178, x179 = bits.Sub64(x169, uint64(0x0), uint64(fiatFpUint1(x177)))
        var x180 uint64
        var x181 uint64
        x180, x181 = bits.Sub64(x171, 0xffffffff00000001, uint64(fiatFpUint1(x179)))
        var x183 uint64
        _, x183 = bits.Sub64(x173, uint64(0x0), uint64(fiatFpUint1(x181)))
        var x184 uint64
        fiatFpCmovznzU64(&amp;x184, fiatFpUint1(x183), x174, x165)
        var x185 uint64
        fiatFpCmovznzU64(&amp;x185, fiatFpUint1(x183), x176, x167)
        var x186 uint64
        fiatFpCmovznzU64(&amp;x186, fiatFpUint1(x183), x178, x169)
        var x187 uint64
        fiatFpCmovznzU64(&amp;x187, fiatFpUint1(x183), x180, x171)
        out1[0] = x184
        out1[1] = x185
        out1[2] = x186
        out1[3] = x187
}</span>

// fiatFpSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFpSquare(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg1[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg1[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg1[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg1[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFpUint1(x16)))
        x19 := (uint64(fiatFpUint1(x18)) + x6)
        var x20 uint64
        var x21 uint64
        x21, x20 = bits.Mul64(x11, 0xffffffff00000001)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x11, 0xffffffff)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x11, 0xffffffffffffffff)
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(x25, x22, uint64(0x0))
        x28 := (uint64(fiatFpUint1(x27)) + x23)
        var x30 uint64
        _, x30 = bits.Add64(x11, x24, uint64(0x0))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x13, x26, uint64(fiatFpUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x15, x28, uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x17, x20, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x19, x21, uint64(fiatFpUint1(x36)))
        var x39 uint64
        var x40 uint64
        x40, x39 = bits.Mul64(x1, arg1[3])
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, arg1[2])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, arg1[1])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, arg1[0])
        var x47 uint64
        var x48 uint64
        x47, x48 = bits.Add64(x46, x43, uint64(0x0))
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x44, x41, uint64(fiatFpUint1(x48)))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x42, x39, uint64(fiatFpUint1(x50)))
        x53 := (uint64(fiatFpUint1(x52)) + x40)
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64(x31, x45, uint64(0x0))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x33, x47, uint64(fiatFpUint1(x55)))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x35, x49, uint64(fiatFpUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x37, x51, uint64(fiatFpUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(uint64(fiatFpUint1(x38)), x53, uint64(fiatFpUint1(x61)))
        var x64 uint64
        var x65 uint64
        x65, x64 = bits.Mul64(x54, 0xffffffff00000001)
        var x66 uint64
        var x67 uint64
        x67, x66 = bits.Mul64(x54, 0xffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x54, 0xffffffffffffffff)
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(x69, x66, uint64(0x0))
        x72 := (uint64(fiatFpUint1(x71)) + x67)
        var x74 uint64
        _, x74 = bits.Add64(x54, x68, uint64(0x0))
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Add64(x56, x70, uint64(fiatFpUint1(x74)))
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x58, x72, uint64(fiatFpUint1(x76)))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x60, x64, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x62, x65, uint64(fiatFpUint1(x80)))
        x83 := (uint64(fiatFpUint1(x82)) + uint64(fiatFpUint1(x63)))
        var x84 uint64
        var x85 uint64
        x85, x84 = bits.Mul64(x2, arg1[3])
        var x86 uint64
        var x87 uint64
        x87, x86 = bits.Mul64(x2, arg1[2])
        var x88 uint64
        var x89 uint64
        x89, x88 = bits.Mul64(x2, arg1[1])
        var x90 uint64
        var x91 uint64
        x91, x90 = bits.Mul64(x2, arg1[0])
        var x92 uint64
        var x93 uint64
        x92, x93 = bits.Add64(x91, x88, uint64(0x0))
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x89, x86, uint64(fiatFpUint1(x93)))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x87, x84, uint64(fiatFpUint1(x95)))
        x98 := (uint64(fiatFpUint1(x97)) + x85)
        var x99 uint64
        var x100 uint64
        x99, x100 = bits.Add64(x75, x90, uint64(0x0))
        var x101 uint64
        var x102 uint64
        x101, x102 = bits.Add64(x77, x92, uint64(fiatFpUint1(x100)))
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x94, uint64(fiatFpUint1(x102)))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x96, uint64(fiatFpUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x98, uint64(fiatFpUint1(x106)))
        var x109 uint64
        var x110 uint64
        x110, x109 = bits.Mul64(x99, 0xffffffff00000001)
        var x111 uint64
        var x112 uint64
        x112, x111 = bits.Mul64(x99, 0xffffffff)
        var x113 uint64
        var x114 uint64
        x114, x113 = bits.Mul64(x99, 0xffffffffffffffff)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x114, x111, uint64(0x0))
        x117 := (uint64(fiatFpUint1(x116)) + x112)
        var x119 uint64
        _, x119 = bits.Add64(x99, x113, uint64(0x0))
        var x120 uint64
        var x121 uint64
        x120, x121 = bits.Add64(x101, x115, uint64(fiatFpUint1(x119)))
        var x122 uint64
        var x123 uint64
        x122, x123 = bits.Add64(x103, x117, uint64(fiatFpUint1(x121)))
        var x124 uint64
        var x125 uint64
        x124, x125 = bits.Add64(x105, x109, uint64(fiatFpUint1(x123)))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x107, x110, uint64(fiatFpUint1(x125)))
        x128 := (uint64(fiatFpUint1(x127)) + uint64(fiatFpUint1(x108)))
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x3, arg1[3])
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x3, arg1[2])
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x3, arg1[1])
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, arg1[0])
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x136, x133, uint64(0x0))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x134, x131, uint64(fiatFpUint1(x138)))
        var x141 uint64
        var x142 uint64
        x141, x142 = bits.Add64(x132, x129, uint64(fiatFpUint1(x140)))
        x143 := (uint64(fiatFpUint1(x142)) + x130)
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x120, x135, uint64(0x0))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x122, x137, uint64(fiatFpUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x124, x139, uint64(fiatFpUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x126, x141, uint64(fiatFpUint1(x149)))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Add64(x128, x143, uint64(fiatFpUint1(x151)))
        var x154 uint64
        var x155 uint64
        x155, x154 = bits.Mul64(x144, 0xffffffff00000001)
        var x156 uint64
        var x157 uint64
        x157, x156 = bits.Mul64(x144, 0xffffffff)
        var x158 uint64
        var x159 uint64
        x159, x158 = bits.Mul64(x144, 0xffffffffffffffff)
        var x160 uint64
        var x161 uint64
        x160, x161 = bits.Add64(x159, x156, uint64(0x0))
        x162 := (uint64(fiatFpUint1(x161)) + x157)
        var x164 uint64
        _, x164 = bits.Add64(x144, x158, uint64(0x0))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x146, x160, uint64(fiatFpUint1(x164)))
        var x167 uint64
        var x168 uint64
        x167, x168 = bits.Add64(x148, x162, uint64(fiatFpUint1(x166)))
        var x169 uint64
        var x170 uint64
        x169, x170 = bits.Add64(x150, x154, uint64(fiatFpUint1(x168)))
        var x171 uint64
        var x172 uint64
        x171, x172 = bits.Add64(x152, x155, uint64(fiatFpUint1(x170)))
        x173 := (uint64(fiatFpUint1(x172)) + uint64(fiatFpUint1(x153)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Sub64(x165, 0xffffffffffffffff, uint64(0x0))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Sub64(x167, 0xffffffff, uint64(fiatFpUint1(x175)))
        var x178 uint64
        var x179 uint64
        x178, x179 = bits.Sub64(x169, uint64(0x0), uint64(fiatFpUint1(x177)))
        var x180 uint64
        var x181 uint64
        x180, x181 = bits.Sub64(x171, 0xffffffff00000001, uint64(fiatFpUint1(x179)))
        var x183 uint64
        _, x183 = bits.Sub64(x173, uint64(0x0), uint64(fiatFpUint1(x181)))
        var x184 uint64
        fiatFpCmovznzU64(&amp;x184, fiatFpUint1(x183), x174, x165)
        var x185 uint64
        fiatFpCmovznzU64(&amp;x185, fiatFpUint1(x183), x176, x167)
        var x186 uint64
        fiatFpCmovznzU64(&amp;x186, fiatFpUint1(x183), x178, x169)
        var x187 uint64
        fiatFpCmovznzU64(&amp;x187, fiatFpUint1(x183), x180, x171)
        out1[0] = x184
        out1[1] = x185
        out1[2] = x186
        out1[3] = x187
}</span>

// fiatFpAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpAdd(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(x1, 0xffffffffffffffff, uint64(0x0))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(x3, 0xffffffff, uint64(fiatFpUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x5, uint64(0x0), uint64(fiatFpUint1(x12)))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x7, 0xffffffff00000001, uint64(fiatFpUint1(x14)))
        var x18 uint64
        _, x18 = bits.Sub64(uint64(fiatFpUint1(x8)), uint64(0x0), uint64(fiatFpUint1(x16)))
        var x19 uint64
        fiatFpCmovznzU64(&amp;x19, fiatFpUint1(x18), x9, x1)
        var x20 uint64
        fiatFpCmovznzU64(&amp;x20, fiatFpUint1(x18), x11, x3)
        var x21 uint64
        fiatFpCmovznzU64(&amp;x21, fiatFpUint1(x18), x13, x5)
        var x22 uint64
        fiatFpCmovznzU64(&amp;x22, fiatFpUint1(x18), x15, x7)
        out1[0] = x19
        out1[1] = x20
        out1[2] = x21
        out1[3] = x22
}</span>

// fiatFpSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpSub(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, fiatFpUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, x9, uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0xffffffff), uint64(fiatFpUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, uint64(0x0), uint64(fiatFpUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0xffffffff00000001), uint64(fiatFpUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFpOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFpOpp(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, fiatFpUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, x9, uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0xffffffff), uint64(fiatFpUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, uint64(0x0), uint64(fiatFpUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0xffffffff00000001), uint64(fiatFpUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFpFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^4) mod m
//   0  eval out1 &lt; m
//
func fiatFpFromMontgomery(out1 *fiatFpNonMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[0]
        var x2 uint64
        var x3 uint64
        x3, x2 = bits.Mul64(x1, 0xffffffff00000001)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x1, 0xffffffff)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x1, 0xffffffffffffffff)
        var x8 uint64
        var x9 uint64
        x8, x9 = bits.Add64(x7, x4, uint64(0x0))
        var x11 uint64
        _, x11 = bits.Add64(x1, x6, uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x0), x8, uint64(fiatFpUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x12, arg1[1], uint64(0x0))
        var x16 uint64
        var x17 uint64
        x17, x16 = bits.Mul64(x14, 0xffffffff00000001)
        var x18 uint64
        var x19 uint64
        x19, x18 = bits.Mul64(x14, 0xffffffff)
        var x20 uint64
        var x21 uint64
        x21, x20 = bits.Mul64(x14, 0xffffffffffffffff)
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(x21, x18, uint64(0x0))
        var x25 uint64
        _, x25 = bits.Add64(x14, x20, uint64(0x0))
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64((uint64(fiatFpUint1(x15)) + (uint64(fiatFpUint1(x13)) + (uint64(fiatFpUint1(x9)) + x5))), x22, uint64(fiatFpUint1(x25)))
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x2, (uint64(fiatFpUint1(x23)) + x19), uint64(fiatFpUint1(x27)))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x3, x16, uint64(fiatFpUint1(x29)))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x26, arg1[2], uint64(0x0))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x28, uint64(0x0), uint64(fiatFpUint1(x33)))
        var x36 uint64
        var x37 uint64
        x36, x37 = bits.Add64(x30, uint64(0x0), uint64(fiatFpUint1(x35)))
        var x38 uint64
        var x39 uint64
        x39, x38 = bits.Mul64(x32, 0xffffffff00000001)
        var x40 uint64
        var x41 uint64
        x41, x40 = bits.Mul64(x32, 0xffffffff)
        var x42 uint64
        var x43 uint64
        x43, x42 = bits.Mul64(x32, 0xffffffffffffffff)
        var x44 uint64
        var x45 uint64
        x44, x45 = bits.Add64(x43, x40, uint64(0x0))
        var x47 uint64
        _, x47 = bits.Add64(x32, x42, uint64(0x0))
        var x48 uint64
        var x49 uint64
        x48, x49 = bits.Add64(x34, x44, uint64(fiatFpUint1(x47)))
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x36, (uint64(fiatFpUint1(x45)) + x41), uint64(fiatFpUint1(x49)))
        var x52 uint64
        var x53 uint64
        x52, x53 = bits.Add64((uint64(fiatFpUint1(x37)) + (uint64(fiatFpUint1(x31)) + x17)), x38, uint64(fiatFpUint1(x51)))
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64(x48, arg1[3], uint64(0x0))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x50, uint64(0x0), uint64(fiatFpUint1(x55)))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x52, uint64(0x0), uint64(fiatFpUint1(x57)))
        var x60 uint64
        var x61 uint64
        x61, x60 = bits.Mul64(x54, 0xffffffff00000001)
        var x62 uint64
        var x63 uint64
        x63, x62 = bits.Mul64(x54, 0xffffffff)
        var x64 uint64
        var x65 uint64
        x65, x64 = bits.Mul64(x54, 0xffffffffffffffff)
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x65, x62, uint64(0x0))
        var x69 uint64
        _, x69 = bits.Add64(x54, x64, uint64(0x0))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(x56, x66, uint64(fiatFpUint1(x69)))
        var x72 uint64
        var x73 uint64
        x72, x73 = bits.Add64(x58, (uint64(fiatFpUint1(x67)) + x63), uint64(fiatFpUint1(x71)))
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64((uint64(fiatFpUint1(x59)) + (uint64(fiatFpUint1(x53)) + x39)), x60, uint64(fiatFpUint1(x73)))
        x76 := (uint64(fiatFpUint1(x75)) + x61)
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Sub64(x70, 0xffffffffffffffff, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Sub64(x72, 0xffffffff, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Sub64(x74, uint64(0x0), uint64(fiatFpUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Sub64(x76, 0xffffffff00000001, uint64(fiatFpUint1(x82)))
        var x86 uint64
        _, x86 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFpUint1(x84)))
        var x87 uint64
        fiatFpCmovznzU64(&amp;x87, fiatFpUint1(x86), x77, x70)
        var x88 uint64
        fiatFpCmovznzU64(&amp;x88, fiatFpUint1(x86), x79, x72)
        var x89 uint64
        fiatFpCmovznzU64(&amp;x89, fiatFpUint1(x86), x81, x74)
        var x90 uint64
        fiatFpCmovznzU64(&amp;x90, fiatFpUint1(x86), x83, x76)
        out1[0] = x87
        out1[1] = x88
        out1[2] = x89
        out1[3] = x90
}</span>

// fiatFpToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFpToMontgomery(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, 0x4fffffffd)
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, 0xfffffffffffffffe)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, 0xfffffffbffffffff)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, 0x3)
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFpUint1(x16)))
        var x19 uint64
        var x20 uint64
        x20, x19 = bits.Mul64(x11, 0xffffffff00000001)
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(x11, 0xffffffff)
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(x11, 0xffffffffffffffff)
        var x25 uint64
        var x26 uint64
        x25, x26 = bits.Add64(x24, x21, uint64(0x0))
        var x28 uint64
        _, x28 = bits.Add64(x11, x23, uint64(0x0))
        var x29 uint64
        var x30 uint64
        x29, x30 = bits.Add64(x13, x25, uint64(fiatFpUint1(x28)))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x15, (uint64(fiatFpUint1(x26)) + x22), uint64(fiatFpUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x17, x19, uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64((uint64(fiatFpUint1(x18)) + x6), x20, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x38, x37 = bits.Mul64(x1, 0x4fffffffd)
        var x39 uint64
        var x40 uint64
        x40, x39 = bits.Mul64(x1, 0xfffffffffffffffe)
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, 0xfffffffbffffffff)
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, 0x3)
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x44, x41, uint64(0x0))
        var x47 uint64
        var x48 uint64
        x47, x48 = bits.Add64(x42, x39, uint64(fiatFpUint1(x46)))
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x40, x37, uint64(fiatFpUint1(x48)))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x29, x43, uint64(0x0))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x31, x45, uint64(fiatFpUint1(x52)))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x33, x47, uint64(fiatFpUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x35, x49, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x60, x59 = bits.Mul64(x51, 0xffffffff00000001)
        var x61 uint64
        var x62 uint64
        x62, x61 = bits.Mul64(x51, 0xffffffff)
        var x63 uint64
        var x64 uint64
        x64, x63 = bits.Mul64(x51, 0xffffffffffffffff)
        var x65 uint64
        var x66 uint64
        x65, x66 = bits.Add64(x64, x61, uint64(0x0))
        var x68 uint64
        _, x68 = bits.Add64(x51, x63, uint64(0x0))
        var x69 uint64
        var x70 uint64
        x69, x70 = bits.Add64(x53, x65, uint64(fiatFpUint1(x68)))
        var x71 uint64
        var x72 uint64
        x71, x72 = bits.Add64(x55, (uint64(fiatFpUint1(x66)) + x62), uint64(fiatFpUint1(x70)))
        var x73 uint64
        var x74 uint64
        x73, x74 = bits.Add64(x57, x59, uint64(fiatFpUint1(x72)))
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Add64(((uint64(fiatFpUint1(x58)) + uint64(fiatFpUint1(x36))) + (uint64(fiatFpUint1(x50)) + x38)), x60, uint64(fiatFpUint1(x74)))
        var x77 uint64
        var x78 uint64
        x78, x77 = bits.Mul64(x2, 0x4fffffffd)
        var x79 uint64
        var x80 uint64
        x80, x79 = bits.Mul64(x2, 0xfffffffffffffffe)
        var x81 uint64
        var x82 uint64
        x82, x81 = bits.Mul64(x2, 0xfffffffbffffffff)
        var x83 uint64
        var x84 uint64
        x84, x83 = bits.Mul64(x2, 0x3)
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x84, x81, uint64(0x0))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x82, x79, uint64(fiatFpUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x80, x77, uint64(fiatFpUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x69, x83, uint64(0x0))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x71, x85, uint64(fiatFpUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x73, x87, uint64(fiatFpUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x75, x89, uint64(fiatFpUint1(x96)))
        var x99 uint64
        var x100 uint64
        x100, x99 = bits.Mul64(x91, 0xffffffff00000001)
        var x101 uint64
        var x102 uint64
        x102, x101 = bits.Mul64(x91, 0xffffffff)
        var x103 uint64
        var x104 uint64
        x104, x103 = bits.Mul64(x91, 0xffffffffffffffff)
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x104, x101, uint64(0x0))
        var x108 uint64
        _, x108 = bits.Add64(x91, x103, uint64(0x0))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x93, x105, uint64(fiatFpUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x95, (uint64(fiatFpUint1(x106)) + x102), uint64(fiatFpUint1(x110)))
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x97, x99, uint64(fiatFpUint1(x112)))
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(((uint64(fiatFpUint1(x98)) + uint64(fiatFpUint1(x76))) + (uint64(fiatFpUint1(x90)) + x78)), x100, uint64(fiatFpUint1(x114)))
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x3, 0x4fffffffd)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x3, 0xfffffffffffffffe)
        var x121 uint64
        var x122 uint64
        x122, x121 = bits.Mul64(x3, 0xfffffffbffffffff)
        var x123 uint64
        var x124 uint64
        x124, x123 = bits.Mul64(x3, 0x3)
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x124, x121, uint64(0x0))
        var x127 uint64
        var x128 uint64
        x127, x128 = bits.Add64(x122, x119, uint64(fiatFpUint1(x126)))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x120, x117, uint64(fiatFpUint1(x128)))
        var x131 uint64
        var x132 uint64
        x131, x132 = bits.Add64(x109, x123, uint64(0x0))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x111, x125, uint64(fiatFpUint1(x132)))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x113, x127, uint64(fiatFpUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x115, x129, uint64(fiatFpUint1(x136)))
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x131, 0xffffffff00000001)
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x131, 0xffffffff)
        var x143 uint64
        var x144 uint64
        x144, x143 = bits.Mul64(x131, 0xffffffffffffffff)
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x144, x141, uint64(0x0))
        var x148 uint64
        _, x148 = bits.Add64(x131, x143, uint64(0x0))
        var x149 uint64
        var x150 uint64
        x149, x150 = bits.Add64(x133, x145, uint64(fiatFpUint1(x148)))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Add64(x135, (uint64(fiatFpUint1(x146)) + x142), uint64(fiatFpUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Add64(x137, x139, uint64(fiatFpUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Add64(((uint64(fiatFpUint1(x138)) + uint64(fiatFpUint1(x116))) + (uint64(fiatFpUint1(x130)) + x118)), x140, uint64(fiatFpUint1(x154)))
        var x157 uint64
        var x158 uint64
        x157, x158 = bits.Sub64(x149, 0xffffffffffffffff, uint64(0x0))
        var x159 uint64
        var x160 uint64
        x159, x160 = bits.Sub64(x151, 0xffffffff, uint64(fiatFpUint1(x158)))
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Sub64(x153, uint64(0x0), uint64(fiatFpUint1(x160)))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Sub64(x155, 0xffffffff00000001, uint64(fiatFpUint1(x162)))
        var x166 uint64
        _, x166 = bits.Sub64(uint64(fiatFpUint1(x156)), uint64(0x0), uint64(fiatFpUint1(x164)))
        var x167 uint64
        fiatFpCmovznzU64(&amp;x167, fiatFpUint1(x166), x157, x149)
        var x168 uint64
        fiatFpCmovznzU64(&amp;x168, fiatFpUint1(x166), x159, x151)
        var x169 uint64
        fiatFpCmovznzU64(&amp;x169, fiatFpUint1(x166), x161, x153)
        var x170 uint64
        fiatFpCmovznzU64(&amp;x170, fiatFpUint1(x166), x163, x155)
        out1[0] = x167
        out1[1] = x168
        out1[2] = x169
        out1[3] = x170
}</span>

// fiatFpNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpNonzero(out1 *uint64, arg1 *[4]uint64) <span class="cov8" title="1">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | arg1[3])))
        *out1 = x1
}</span>

// fiatFpSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpSelectznz(out1 *[4]uint64, arg1 fiatFpUint1, arg2 *[4]uint64, arg3 *[4]uint64) <span class="cov8" title="1">{
        var x1 uint64
        fiatFpCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFpCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFpCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFpCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
}</span>

// fiatFpToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff]]
func fiatFpToBytes(out1 *[32]uint8, arg1 *[4]uint64) <span class="cov8" title="1">{
        x1 := arg1[3]
        x2 := arg1[2]
        x3 := arg1[1]
        x4 := arg1[0]
        x5 := (uint8(x4) &amp; 0xff)
        x6 := (x4 &gt;&gt; 8)
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := uint8((x16 &gt;&gt; 8))
        x19 := (uint8(x3) &amp; 0xff)
        x20 := (x3 &gt;&gt; 8)
        x21 := (uint8(x20) &amp; 0xff)
        x22 := (x20 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := uint8((x30 &gt;&gt; 8))
        x33 := (uint8(x2) &amp; 0xff)
        x34 := (x2 &gt;&gt; 8)
        x35 := (uint8(x34) &amp; 0xff)
        x36 := (x34 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := uint8((x44 &gt;&gt; 8))
        x47 := (uint8(x1) &amp; 0xff)
        x48 := (x1 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := (x48 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := uint8((x58 &gt;&gt; 8))
        out1[0] = x5
        out1[1] = x7
        out1[2] = x9
        out1[3] = x11
        out1[4] = x13
        out1[5] = x15
        out1[6] = x17
        out1[7] = x18
        out1[8] = x19
        out1[9] = x21
        out1[10] = x23
        out1[11] = x25
        out1[12] = x27
        out1[13] = x29
        out1[14] = x31
        out1[15] = x32
        out1[16] = x33
        out1[17] = x35
        out1[18] = x37
        out1[19] = x39
        out1[20] = x41
        out1[21] = x43
        out1[22] = x45
        out1[23] = x46
        out1[24] = x47
        out1[25] = x49
        out1[26] = x51
        out1[27] = x53
        out1[28] = x55
        out1[29] = x57
        out1[30] = x59
        out1[31] = x60
}</span>

// fiatFpFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpFromBytes(out1 *[4]uint64, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 56)
        x2 := (uint64(arg1[30]) &lt;&lt; 48)
        x3 := (uint64(arg1[29]) &lt;&lt; 40)
        x4 := (uint64(arg1[28]) &lt;&lt; 32)
        x5 := (uint64(arg1[27]) &lt;&lt; 24)
        x6 := (uint64(arg1[26]) &lt;&lt; 16)
        x7 := (uint64(arg1[25]) &lt;&lt; 8)
        x8 := arg1[24]
        x9 := (uint64(arg1[23]) &lt;&lt; 56)
        x10 := (uint64(arg1[22]) &lt;&lt; 48)
        x11 := (uint64(arg1[21]) &lt;&lt; 40)
        x12 := (uint64(arg1[20]) &lt;&lt; 32)
        x13 := (uint64(arg1[19]) &lt;&lt; 24)
        x14 := (uint64(arg1[18]) &lt;&lt; 16)
        x15 := (uint64(arg1[17]) &lt;&lt; 8)
        x16 := arg1[16]
        x17 := (uint64(arg1[15]) &lt;&lt; 56)
        x18 := (uint64(arg1[14]) &lt;&lt; 48)
        x19 := (uint64(arg1[13]) &lt;&lt; 40)
        x20 := (uint64(arg1[12]) &lt;&lt; 32)
        x21 := (uint64(arg1[11]) &lt;&lt; 24)
        x22 := (uint64(arg1[10]) &lt;&lt; 16)
        x23 := (uint64(arg1[9]) &lt;&lt; 8)
        x24 := arg1[8]
        x25 := (uint64(arg1[7]) &lt;&lt; 56)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x25 + x38)
        x40 := (x23 + uint64(x24))
        x41 := (x22 + x40)
        x42 := (x21 + x41)
        x43 := (x20 + x42)
        x44 := (x19 + x43)
        x45 := (x18 + x44)
        x46 := (x17 + x45)
        x47 := (x15 + uint64(x16))
        x48 := (x14 + x47)
        x49 := (x13 + x48)
        x50 := (x12 + x49)
        x51 := (x11 + x50)
        x52 := (x10 + x51)
        x53 := (x9 + x52)
        x54 := (x7 + uint64(x8))
        x55 := (x6 + x54)
        x56 := (x5 + x55)
        x57 := (x4 + x56)
        x58 := (x3 + x57)
        x59 := (x2 + x58)
        x60 := (x1 + x59)
        out1[0] = x39
        out1[1] = x46
        out1[2] = x53
        out1[3] = x60
}</span>

// fiatFpSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFpSetOne(out1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        out1[0] = uint64(0x1)
        out1[1] = 0xffffffff00000000
        out1[2] = 0xffffffffffffffff
        out1[3] = 0xfffffffe
}</span>

// fiatFpMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpMsat(out1 *[5]uint64) <span class="cov8" title="1">{
        out1[0] = 0xffffffffffffffff
        out1[1] = 0xffffffff
        out1[2] = uint64(0x0)
        out1[3] = 0xffffffff00000001
        out1[4] = uint64(0x0)
}</span>

// fiatFpDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpDivstepPrecomp(out1 *[4]uint64) <span class="cov8" title="1">{
        out1[0] = 0x67ffffffb8000000
        out1[1] = 0xc000000038000000
        out1[2] = 0xd80000007fffffff
        out1[3] = 0x2fffffffffffffff
}</span>

// fiatFpDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpDivstep(out1 *uint64, out2 *[5]uint64, out3 *[5]uint64, out4 *[4]uint64, out5 *[4]uint64, arg1 uint64, arg2 *[5]uint64, arg3 *[5]uint64, arg4 *[4]uint64, arg5 *[4]uint64) <span class="cov8" title="1">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFpUint1((x1 &gt;&gt; 63)) &amp; (fiatFpUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFpCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFpCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFpCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFpCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFpCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFpUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFpUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFpUint1(x17)))
        var x20 uint64
        x20, _ = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFpUint1(x19)))
        var x22 uint64
        fiatFpCmovznzU64(&amp;x22, x3, arg3[0], x12)
        var x23 uint64
        fiatFpCmovznzU64(&amp;x23, x3, arg3[1], x14)
        var x24 uint64
        fiatFpCmovznzU64(&amp;x24, x3, arg3[2], x16)
        var x25 uint64
        fiatFpCmovznzU64(&amp;x25, x3, arg3[3], x18)
        var x26 uint64
        fiatFpCmovznzU64(&amp;x26, x3, arg3[4], x20)
        var x27 uint64
        fiatFpCmovznzU64(&amp;x27, x3, arg4[0], arg5[0])
        var x28 uint64
        fiatFpCmovznzU64(&amp;x28, x3, arg4[1], arg5[1])
        var x29 uint64
        fiatFpCmovznzU64(&amp;x29, x3, arg4[2], arg5[2])
        var x30 uint64
        fiatFpCmovznzU64(&amp;x30, x3, arg4[3], arg5[3])
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x27, x27, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x28, x28, uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x29, x29, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x30, x30, uint64(fiatFpUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Sub64(x31, 0xffffffffffffffff, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Sub64(x33, 0xffffffff, uint64(fiatFpUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Sub64(x35, uint64(0x0), uint64(fiatFpUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Sub64(x37, 0xffffffff00000001, uint64(fiatFpUint1(x44)))
        var x48 uint64
        _, x48 = bits.Sub64(uint64(fiatFpUint1(x38)), uint64(0x0), uint64(fiatFpUint1(x46)))
        x49 := arg4[3]
        x50 := arg4[2]
        x51 := arg4[1]
        x52 := arg4[0]
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(uint64(0x0), x52, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(uint64(0x0), x51, uint64(fiatFpUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(uint64(0x0), x50, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(uint64(0x0), x49, uint64(fiatFpUint1(x58)))
        var x61 uint64
        fiatFpCmovznzU64(&amp;x61, fiatFpUint1(x60), uint64(0x0), 0xffffffffffffffff)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x53, x61, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x55, (x61 &amp; 0xffffffff), uint64(fiatFpUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, uint64(0x0), uint64(fiatFpUint1(x65)))
        var x68 uint64
        x68, _ = bits.Add64(x59, (x61 &amp; 0xffffffff00000001), uint64(fiatFpUint1(x67)))
        var x70 uint64
        fiatFpCmovznzU64(&amp;x70, x3, arg5[0], x62)
        var x71 uint64
        fiatFpCmovznzU64(&amp;x71, x3, arg5[1], x64)
        var x72 uint64
        fiatFpCmovznzU64(&amp;x72, x3, arg5[2], x66)
        var x73 uint64
        fiatFpCmovznzU64(&amp;x73, x3, arg5[3], x68)
        x74 := (fiatFpUint1(x22) &amp; 0x1)
        var x75 uint64
        fiatFpCmovznzU64(&amp;x75, x74, uint64(0x0), x7)
        var x76 uint64
        fiatFpCmovznzU64(&amp;x76, x74, uint64(0x0), x8)
        var x77 uint64
        fiatFpCmovznzU64(&amp;x77, x74, uint64(0x0), x9)
        var x78 uint64
        fiatFpCmovznzU64(&amp;x78, x74, uint64(0x0), x10)
        var x79 uint64
        fiatFpCmovznzU64(&amp;x79, x74, uint64(0x0), x11)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x22, x75, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x23, x76, uint64(fiatFpUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x24, x77, uint64(fiatFpUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x25, x78, uint64(fiatFpUint1(x85)))
        var x88 uint64
        x88, _ = bits.Add64(x26, x79, uint64(fiatFpUint1(x87)))
        var x90 uint64
        fiatFpCmovznzU64(&amp;x90, x74, uint64(0x0), x27)
        var x91 uint64
        fiatFpCmovznzU64(&amp;x91, x74, uint64(0x0), x28)
        var x92 uint64
        fiatFpCmovznzU64(&amp;x92, x74, uint64(0x0), x29)
        var x93 uint64
        fiatFpCmovznzU64(&amp;x93, x74, uint64(0x0), x30)
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x70, x90, uint64(0x0))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x71, x91, uint64(fiatFpUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x72, x92, uint64(fiatFpUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x73, x93, uint64(fiatFpUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Sub64(x94, 0xffffffffffffffff, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Sub64(x96, 0xffffffff, uint64(fiatFpUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Sub64(x98, uint64(0x0), uint64(fiatFpUint1(x105)))
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Sub64(x100, 0xffffffff00000001, uint64(fiatFpUint1(x107)))
        var x111 uint64
        _, x111 = bits.Sub64(uint64(fiatFpUint1(x101)), uint64(0x0), uint64(fiatFpUint1(x109)))
        var x112 uint64
        x112, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x114 := ((x80 &gt;&gt; 1) | ((x82 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x115 := ((x82 &gt;&gt; 1) | ((x84 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x116 := ((x84 &gt;&gt; 1) | ((x86 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x117 := ((x86 &gt;&gt; 1) | ((x88 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x118 := ((x88 &amp; 0x8000000000000000) | (x88 &gt;&gt; 1))
        var x119 uint64
        fiatFpCmovznzU64(&amp;x119, fiatFpUint1(x48), x39, x31)
        var x120 uint64
        fiatFpCmovznzU64(&amp;x120, fiatFpUint1(x48), x41, x33)
        var x121 uint64
        fiatFpCmovznzU64(&amp;x121, fiatFpUint1(x48), x43, x35)
        var x122 uint64
        fiatFpCmovznzU64(&amp;x122, fiatFpUint1(x48), x45, x37)
        var x123 uint64
        fiatFpCmovznzU64(&amp;x123, fiatFpUint1(x111), x102, x94)
        var x124 uint64
        fiatFpCmovznzU64(&amp;x124, fiatFpUint1(x111), x104, x96)
        var x125 uint64
        fiatFpCmovznzU64(&amp;x125, fiatFpUint1(x111), x106, x98)
        var x126 uint64
        fiatFpCmovznzU64(&amp;x126, fiatFpUint1(x111), x108, x100)
        *out1 = x112
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out3[0] = x114
        out3[1] = x115
        out3[2] = x116
        out3[3] = x117
        out3[4] = x118
        out4[0] = x119
        out4[1] = x120
        out4[2] = x121
        out4[3] = x122
        out5[0] = x123
        out5[1] = x124
        out5[2] = x125
        out5[3] = x126
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fq 64 '2^256 - 2^224 + 2^192 - 89188191075325690597107910205041859247'
//
// curve description: Fq
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 (from "2^256 - 2^224 + 2^192 - 89188191075325690597107910205041859247")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) in
//
//                            if x1 &amp; (2^256-1) &lt; 2^255 then x1 &amp; (2^256-1) else (x1 &amp; (2^256-1)) - 2^256
package impl

import "math/bits"

type fiatFqUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFqInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFqMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqMontgomeryDomainFieldElement [4]uint64

// fiatFqNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqNonMontgomeryDomainFieldElement [4]uint64

// fiatFqCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqCmovznzU64(out1 *uint64, arg1 fiatFqUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFqMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqMul(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg2[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg2[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg2[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg2[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0xccd1c8aaee00bc4f)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0xffffffff00000000)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0xffffffffffffffff)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0xbce6faada7179e84)
        var x28 uint64
        var x29 uint64
        x29, x28 = bits.Mul64(x20, 0xf3b9cac2fc632551)
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x29, x26, uint64(0x0))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x27, x24, uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x25, x22, uint64(fiatFqUint1(x33)))
        x36 := (uint64(fiatFqUint1(x35)) + x23)
        var x38 uint64
        _, x38 = bits.Add64(x11, x28, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x13, x30, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x15, x32, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x17, x34, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x19, x36, uint64(fiatFqUint1(x44)))
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg2[3])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, arg2[2])
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, arg2[1])
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x1, arg2[0])
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x54, x51, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x52, x49, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x50, x47, uint64(fiatFqUint1(x58)))
        x61 := (uint64(fiatFqUint1(x60)) + x48)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x41, x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x43, x57, uint64(fiatFqUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x45, x59, uint64(fiatFqUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(uint64(fiatFqUint1(x46)), x61, uint64(fiatFqUint1(x69)))
        var x72 uint64
        _, x72 = bits.Mul64(x62, 0xccd1c8aaee00bc4f)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x72, 0xffffffff00000000)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x72, 0xffffffffffffffff)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x72, 0xbce6faada7179e84)
        var x80 uint64
        var x81 uint64
        x81, x80 = bits.Mul64(x72, 0xf3b9cac2fc632551)
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x81, x78, uint64(0x0))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x79, x76, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x77, x74, uint64(fiatFqUint1(x85)))
        x88 := (uint64(fiatFqUint1(x87)) + x75)
        var x90 uint64
        _, x90 = bits.Add64(x62, x80, uint64(0x0))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x64, x82, uint64(fiatFqUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x66, x84, uint64(fiatFqUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x68, x86, uint64(fiatFqUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x70, x88, uint64(fiatFqUint1(x96)))
        x99 := (uint64(fiatFqUint1(x98)) + uint64(fiatFqUint1(x71)))
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x2, arg2[3])
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x2, arg2[2])
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x2, arg2[1])
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x2, arg2[0])
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFqUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFqUint1(x111)))
        x114 := (uint64(fiatFqUint1(x113)) + x101)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x91, x106, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x93, x108, uint64(fiatFqUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x95, x110, uint64(fiatFqUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x97, x112, uint64(fiatFqUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x99, x114, uint64(fiatFqUint1(x122)))
        var x125 uint64
        _, x125 = bits.Mul64(x115, 0xccd1c8aaee00bc4f)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x125, 0xffffffff00000000)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x125, 0xffffffffffffffff)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x125, 0xbce6faada7179e84)
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x125, 0xf3b9cac2fc632551)
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x134, x131, uint64(0x0))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x132, x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x130, x127, uint64(fiatFqUint1(x138)))
        x141 := (uint64(fiatFqUint1(x140)) + x128)
        var x143 uint64
        _, x143 = bits.Add64(x115, x133, uint64(0x0))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x117, x135, uint64(fiatFqUint1(x143)))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x119, x137, uint64(fiatFqUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x121, x139, uint64(fiatFqUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x123, x141, uint64(fiatFqUint1(x149)))
        x152 := (uint64(fiatFqUint1(x151)) + uint64(fiatFqUint1(x124)))
        var x153 uint64
        var x154 uint64
        x154, x153 = bits.Mul64(x3, arg2[3])
        var x155 uint64
        var x156 uint64
        x156, x155 = bits.Mul64(x3, arg2[2])
        var x157 uint64
        var x158 uint64
        x158, x157 = bits.Mul64(x3, arg2[1])
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x3, arg2[0])
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x160, x157, uint64(0x0))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x158, x155, uint64(fiatFqUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x156, x153, uint64(fiatFqUint1(x164)))
        x167 := (uint64(fiatFqUint1(x166)) + x154)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x144, x159, uint64(0x0))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x146, x161, uint64(fiatFqUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x148, x163, uint64(fiatFqUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64(x150, x165, uint64(fiatFqUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x152, x167, uint64(fiatFqUint1(x175)))
        var x178 uint64
        _, x178 = bits.Mul64(x168, 0xccd1c8aaee00bc4f)
        var x180 uint64
        var x181 uint64
        x181, x180 = bits.Mul64(x178, 0xffffffff00000000)
        var x182 uint64
        var x183 uint64
        x183, x182 = bits.Mul64(x178, 0xffffffffffffffff)
        var x184 uint64
        var x185 uint64
        x185, x184 = bits.Mul64(x178, 0xbce6faada7179e84)
        var x186 uint64
        var x187 uint64
        x187, x186 = bits.Mul64(x178, 0xf3b9cac2fc632551)
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Add64(x187, x184, uint64(0x0))
        var x190 uint64
        var x191 uint64
        x190, x191 = bits.Add64(x185, x182, uint64(fiatFqUint1(x189)))
        var x192 uint64
        var x193 uint64
        x192, x193 = bits.Add64(x183, x180, uint64(fiatFqUint1(x191)))
        x194 := (uint64(fiatFqUint1(x193)) + x181)
        var x196 uint64
        _, x196 = bits.Add64(x168, x186, uint64(0x0))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x170, x188, uint64(fiatFqUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x172, x190, uint64(fiatFqUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x174, x192, uint64(fiatFqUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x176, x194, uint64(fiatFqUint1(x202)))
        x205 := (uint64(fiatFqUint1(x204)) + uint64(fiatFqUint1(x177)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Sub64(x197, 0xf3b9cac2fc632551, uint64(0x0))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Sub64(x199, 0xbce6faada7179e84, uint64(fiatFqUint1(x207)))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Sub64(x201, 0xffffffffffffffff, uint64(fiatFqUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Sub64(x203, 0xffffffff00000000, uint64(fiatFqUint1(x211)))
        var x215 uint64
        _, x215 = bits.Sub64(x205, uint64(0x0), uint64(fiatFqUint1(x213)))
        var x216 uint64
        fiatFqCmovznzU64(&amp;x216, fiatFqUint1(x215), x206, x197)
        var x217 uint64
        fiatFqCmovznzU64(&amp;x217, fiatFqUint1(x215), x208, x199)
        var x218 uint64
        fiatFqCmovznzU64(&amp;x218, fiatFqUint1(x215), x210, x201)
        var x219 uint64
        fiatFqCmovznzU64(&amp;x219, fiatFqUint1(x215), x212, x203)
        out1[0] = x216
        out1[1] = x217
        out1[2] = x218
        out1[3] = x219
}</span>

// fiatFqSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSquare(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg1[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg1[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg1[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg1[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0xccd1c8aaee00bc4f)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0xffffffff00000000)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0xffffffffffffffff)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0xbce6faada7179e84)
        var x28 uint64
        var x29 uint64
        x29, x28 = bits.Mul64(x20, 0xf3b9cac2fc632551)
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x29, x26, uint64(0x0))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x27, x24, uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x25, x22, uint64(fiatFqUint1(x33)))
        x36 := (uint64(fiatFqUint1(x35)) + x23)
        var x38 uint64
        _, x38 = bits.Add64(x11, x28, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x13, x30, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x15, x32, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x17, x34, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x19, x36, uint64(fiatFqUint1(x44)))
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg1[3])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, arg1[2])
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, arg1[1])
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x1, arg1[0])
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x54, x51, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x52, x49, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x50, x47, uint64(fiatFqUint1(x58)))
        x61 := (uint64(fiatFqUint1(x60)) + x48)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x41, x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x43, x57, uint64(fiatFqUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x45, x59, uint64(fiatFqUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(uint64(fiatFqUint1(x46)), x61, uint64(fiatFqUint1(x69)))
        var x72 uint64
        _, x72 = bits.Mul64(x62, 0xccd1c8aaee00bc4f)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x72, 0xffffffff00000000)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x72, 0xffffffffffffffff)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x72, 0xbce6faada7179e84)
        var x80 uint64
        var x81 uint64
        x81, x80 = bits.Mul64(x72, 0xf3b9cac2fc632551)
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x81, x78, uint64(0x0))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x79, x76, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x77, x74, uint64(fiatFqUint1(x85)))
        x88 := (uint64(fiatFqUint1(x87)) + x75)
        var x90 uint64
        _, x90 = bits.Add64(x62, x80, uint64(0x0))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x64, x82, uint64(fiatFqUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x66, x84, uint64(fiatFqUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x68, x86, uint64(fiatFqUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x70, x88, uint64(fiatFqUint1(x96)))
        x99 := (uint64(fiatFqUint1(x98)) + uint64(fiatFqUint1(x71)))
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x2, arg1[3])
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x2, arg1[2])
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x2, arg1[1])
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x2, arg1[0])
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFqUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFqUint1(x111)))
        x114 := (uint64(fiatFqUint1(x113)) + x101)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x91, x106, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x93, x108, uint64(fiatFqUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x95, x110, uint64(fiatFqUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x97, x112, uint64(fiatFqUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x99, x114, uint64(fiatFqUint1(x122)))
        var x125 uint64
        _, x125 = bits.Mul64(x115, 0xccd1c8aaee00bc4f)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x125, 0xffffffff00000000)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x125, 0xffffffffffffffff)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x125, 0xbce6faada7179e84)
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x125, 0xf3b9cac2fc632551)
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x134, x131, uint64(0x0))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x132, x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x130, x127, uint64(fiatFqUint1(x138)))
        x141 := (uint64(fiatFqUint1(x140)) + x128)
        var x143 uint64
        _, x143 = bits.Add64(x115, x133, uint64(0x0))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x117, x135, uint64(fiatFqUint1(x143)))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x119, x137, uint64(fiatFqUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x121, x139, uint64(fiatFqUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x123, x141, uint64(fiatFqUint1(x149)))
        x152 := (uint64(fiatFqUint1(x151)) + uint64(fiatFqUint1(x124)))
        var x153 uint64
        var x154 uint64
        x154, x153 = bits.Mul64(x3, arg1[3])
        var x155 uint64
        var x156 uint64
        x156, x155 = bits.Mul64(x3, arg1[2])
        var x157 uint64
        var x158 uint64
        x158, x157 = bits.Mul64(x3, arg1[1])
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x3, arg1[0])
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x160, x157, uint64(0x0))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x158, x155, uint64(fiatFqUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x156, x153, uint64(fiatFqUint1(x164)))
        x167 := (uint64(fiatFqUint1(x166)) + x154)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x144, x159, uint64(0x0))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x146, x161, uint64(fiatFqUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x148, x163, uint64(fiatFqUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64(x150, x165, uint64(fiatFqUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x152, x167, uint64(fiatFqUint1(x175)))
        var x178 uint64
        _, x178 = bits.Mul64(x168, 0xccd1c8aaee00bc4f)
        var x180 uint64
        var x181 uint64
        x181, x180 = bits.Mul64(x178, 0xffffffff00000000)
        var x182 uint64
        var x183 uint64
        x183, x182 = bits.Mul64(x178, 0xffffffffffffffff)
        var x184 uint64
        var x185 uint64
        x185, x184 = bits.Mul64(x178, 0xbce6faada7179e84)
        var x186 uint64
        var x187 uint64
        x187, x186 = bits.Mul64(x178, 0xf3b9cac2fc632551)
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Add64(x187, x184, uint64(0x0))
        var x190 uint64
        var x191 uint64
        x190, x191 = bits.Add64(x185, x182, uint64(fiatFqUint1(x189)))
        var x192 uint64
        var x193 uint64
        x192, x193 = bits.Add64(x183, x180, uint64(fiatFqUint1(x191)))
        x194 := (uint64(fiatFqUint1(x193)) + x181)
        var x196 uint64
        _, x196 = bits.Add64(x168, x186, uint64(0x0))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x170, x188, uint64(fiatFqUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x172, x190, uint64(fiatFqUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x174, x192, uint64(fiatFqUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x176, x194, uint64(fiatFqUint1(x202)))
        x205 := (uint64(fiatFqUint1(x204)) + uint64(fiatFqUint1(x177)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Sub64(x197, 0xf3b9cac2fc632551, uint64(0x0))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Sub64(x199, 0xbce6faada7179e84, uint64(fiatFqUint1(x207)))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Sub64(x201, 0xffffffffffffffff, uint64(fiatFqUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Sub64(x203, 0xffffffff00000000, uint64(fiatFqUint1(x211)))
        var x215 uint64
        _, x215 = bits.Sub64(x205, uint64(0x0), uint64(fiatFqUint1(x213)))
        var x216 uint64
        fiatFqCmovznzU64(&amp;x216, fiatFqUint1(x215), x206, x197)
        var x217 uint64
        fiatFqCmovznzU64(&amp;x217, fiatFqUint1(x215), x208, x199)
        var x218 uint64
        fiatFqCmovznzU64(&amp;x218, fiatFqUint1(x215), x210, x201)
        var x219 uint64
        fiatFqCmovznzU64(&amp;x219, fiatFqUint1(x215), x212, x203)
        out1[0] = x216
        out1[1] = x217
        out1[2] = x218
        out1[3] = x219
}</span>

// fiatFqAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqAdd(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(x1, 0xf3b9cac2fc632551, uint64(0x0))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(x3, 0xbce6faada7179e84, uint64(fiatFqUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x5, 0xffffffffffffffff, uint64(fiatFqUint1(x12)))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x7, 0xffffffff00000000, uint64(fiatFqUint1(x14)))
        var x18 uint64
        _, x18 = bits.Sub64(uint64(fiatFqUint1(x8)), uint64(0x0), uint64(fiatFqUint1(x16)))
        var x19 uint64
        fiatFqCmovznzU64(&amp;x19, fiatFqUint1(x18), x9, x1)
        var x20 uint64
        fiatFqCmovznzU64(&amp;x20, fiatFqUint1(x18), x11, x3)
        var x21 uint64
        fiatFqCmovznzU64(&amp;x21, fiatFqUint1(x18), x13, x5)
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, fiatFqUint1(x18), x15, x7)
        out1[0] = x19
        out1[1] = x20
        out1[2] = x21
        out1[3] = x22
}</span>

// fiatFqSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSub(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0xf3b9cac2fc632551), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0xbce6faada7179e84), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, x9, uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0xffffffff00000000), uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFqOpp(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0xf3b9cac2fc632551), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0xbce6faada7179e84), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, x9, uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0xffffffff00000000), uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^4) mod m
//   0  eval out1 &lt; m
//
func fiatFqFromMontgomery(out1 *fiatFqNonMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[0]
        var x2 uint64
        _, x2 = bits.Mul64(x1, 0xccd1c8aaee00bc4f)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x2, 0xffffffff00000000)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x2, 0xffffffffffffffff)
        var x8 uint64
        var x9 uint64
        x9, x8 = bits.Mul64(x2, 0xbce6faada7179e84)
        var x10 uint64
        var x11 uint64
        x11, x10 = bits.Mul64(x2, 0xf3b9cac2fc632551)
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x11, x8, uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x9, x6, uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x7, x4, uint64(fiatFqUint1(x15)))
        var x19 uint64
        _, x19 = bits.Add64(x1, x10, uint64(0x0))
        var x20 uint64
        var x21 uint64
        x20, x21 = bits.Add64(uint64(0x0), x12, uint64(fiatFqUint1(x19)))
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(uint64(0x0), x14, uint64(fiatFqUint1(x21)))
        var x24 uint64
        var x25 uint64
        x24, x25 = bits.Add64(uint64(0x0), x16, uint64(fiatFqUint1(x23)))
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(x20, arg1[1], uint64(0x0))
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x22, uint64(0x0), uint64(fiatFqUint1(x27)))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x24, uint64(0x0), uint64(fiatFqUint1(x29)))
        var x32 uint64
        _, x32 = bits.Mul64(x26, 0xccd1c8aaee00bc4f)
        var x34 uint64
        var x35 uint64
        x35, x34 = bits.Mul64(x32, 0xffffffff00000000)
        var x36 uint64
        var x37 uint64
        x37, x36 = bits.Mul64(x32, 0xffffffffffffffff)
        var x38 uint64
        var x39 uint64
        x39, x38 = bits.Mul64(x32, 0xbce6faada7179e84)
        var x40 uint64
        var x41 uint64
        x41, x40 = bits.Mul64(x32, 0xf3b9cac2fc632551)
        var x42 uint64
        var x43 uint64
        x42, x43 = bits.Add64(x41, x38, uint64(0x0))
        var x44 uint64
        var x45 uint64
        x44, x45 = bits.Add64(x39, x36, uint64(fiatFqUint1(x43)))
        var x46 uint64
        var x47 uint64
        x46, x47 = bits.Add64(x37, x34, uint64(fiatFqUint1(x45)))
        var x49 uint64
        _, x49 = bits.Add64(x26, x40, uint64(0x0))
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x28, x42, uint64(fiatFqUint1(x49)))
        var x52 uint64
        var x53 uint64
        x52, x53 = bits.Add64(x30, x44, uint64(fiatFqUint1(x51)))
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64((uint64(fiatFqUint1(x31)) + (uint64(fiatFqUint1(x25)) + (uint64(fiatFqUint1(x17)) + x5))), x46, uint64(fiatFqUint1(x53)))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x50, arg1[2], uint64(0x0))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x52, uint64(0x0), uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x54, uint64(0x0), uint64(fiatFqUint1(x59)))
        var x62 uint64
        _, x62 = bits.Mul64(x56, 0xccd1c8aaee00bc4f)
        var x64 uint64
        var x65 uint64
        x65, x64 = bits.Mul64(x62, 0xffffffff00000000)
        var x66 uint64
        var x67 uint64
        x67, x66 = bits.Mul64(x62, 0xffffffffffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x62, 0xbce6faada7179e84)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x62, 0xf3b9cac2fc632551)
        var x72 uint64
        var x73 uint64
        x72, x73 = bits.Add64(x71, x68, uint64(0x0))
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x69, x66, uint64(fiatFqUint1(x73)))
        var x76 uint64
        var x77 uint64
        x76, x77 = bits.Add64(x67, x64, uint64(fiatFqUint1(x75)))
        var x79 uint64
        _, x79 = bits.Add64(x56, x70, uint64(0x0))
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x58, x72, uint64(fiatFqUint1(x79)))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x60, x74, uint64(fiatFqUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64((uint64(fiatFqUint1(x61)) + (uint64(fiatFqUint1(x55)) + (uint64(fiatFqUint1(x47)) + x35))), x76, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x80, arg1[3], uint64(0x0))
        var x88 uint64
        var x89 uint64
        x88, x89 = bits.Add64(x82, uint64(0x0), uint64(fiatFqUint1(x87)))
        var x90 uint64
        var x91 uint64
        x90, x91 = bits.Add64(x84, uint64(0x0), uint64(fiatFqUint1(x89)))
        var x92 uint64
        _, x92 = bits.Mul64(x86, 0xccd1c8aaee00bc4f)
        var x94 uint64
        var x95 uint64
        x95, x94 = bits.Mul64(x92, 0xffffffff00000000)
        var x96 uint64
        var x97 uint64
        x97, x96 = bits.Mul64(x92, 0xffffffffffffffff)
        var x98 uint64
        var x99 uint64
        x99, x98 = bits.Mul64(x92, 0xbce6faada7179e84)
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x92, 0xf3b9cac2fc632551)
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Add64(x101, x98, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Add64(x99, x96, uint64(fiatFqUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Add64(x97, x94, uint64(fiatFqUint1(x105)))
        var x109 uint64
        _, x109 = bits.Add64(x86, x100, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x88, x102, uint64(fiatFqUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x90, x104, uint64(fiatFqUint1(x111)))
        var x114 uint64
        var x115 uint64
        x114, x115 = bits.Add64((uint64(fiatFqUint1(x91)) + (uint64(fiatFqUint1(x85)) + (uint64(fiatFqUint1(x77)) + x65))), x106, uint64(fiatFqUint1(x113)))
        x116 := (uint64(fiatFqUint1(x115)) + (uint64(fiatFqUint1(x107)) + x95))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Sub64(x110, 0xf3b9cac2fc632551, uint64(0x0))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Sub64(x112, 0xbce6faada7179e84, uint64(fiatFqUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Sub64(x114, 0xffffffffffffffff, uint64(fiatFqUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Sub64(x116, 0xffffffff00000000, uint64(fiatFqUint1(x122)))
        var x126 uint64
        _, x126 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFqUint1(x124)))
        var x127 uint64
        fiatFqCmovznzU64(&amp;x127, fiatFqUint1(x126), x117, x110)
        var x128 uint64
        fiatFqCmovznzU64(&amp;x128, fiatFqUint1(x126), x119, x112)
        var x129 uint64
        fiatFqCmovznzU64(&amp;x129, fiatFqUint1(x126), x121, x114)
        var x130 uint64
        fiatFqCmovznzU64(&amp;x130, fiatFqUint1(x126), x123, x116)
        out1[0] = x127
        out1[1] = x128
        out1[2] = x129
        out1[3] = x130
}</span>

// fiatFqToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFqToMontgomery(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, 0x66e12d94f3d95620)
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, 0x2845b2392b6bec59)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, 0x4699799c49bd6fa6)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, 0x83244c95be79eea2)
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        var x19 uint64
        _, x19 = bits.Mul64(x11, 0xccd1c8aaee00bc4f)
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(x19, 0xffffffff00000000)
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(x19, 0xffffffffffffffff)
        var x25 uint64
        var x26 uint64
        x26, x25 = bits.Mul64(x19, 0xbce6faada7179e84)
        var x27 uint64
        var x28 uint64
        x28, x27 = bits.Mul64(x19, 0xf3b9cac2fc632551)
        var x29 uint64
        var x30 uint64
        x29, x30 = bits.Add64(x28, x25, uint64(0x0))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x26, x23, uint64(fiatFqUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x24, x21, uint64(fiatFqUint1(x32)))
        var x36 uint64
        _, x36 = bits.Add64(x11, x27, uint64(0x0))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x13, x29, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x15, x31, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x17, x33, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64((uint64(fiatFqUint1(x18)) + x6), (uint64(fiatFqUint1(x34)) + x22), uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, 0x66e12d94f3d95620)
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, 0x2845b2392b6bec59)
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, 0x4699799c49bd6fa6)
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, 0x83244c95be79eea2)
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x52, x49, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x50, x47, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x48, x45, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x37, x51, uint64(0x0))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Add64(x39, x53, uint64(fiatFqUint1(x60)))
        var x63 uint64
        var x64 uint64
        x63, x64 = bits.Add64(x41, x55, uint64(fiatFqUint1(x62)))
        var x65 uint64
        var x66 uint64
        x65, x66 = bits.Add64(x43, x57, uint64(fiatFqUint1(x64)))
        var x67 uint64
        _, x67 = bits.Mul64(x59, 0xccd1c8aaee00bc4f)
        var x69 uint64
        var x70 uint64
        x70, x69 = bits.Mul64(x67, 0xffffffff00000000)
        var x71 uint64
        var x72 uint64
        x72, x71 = bits.Mul64(x67, 0xffffffffffffffff)
        var x73 uint64
        var x74 uint64
        x74, x73 = bits.Mul64(x67, 0xbce6faada7179e84)
        var x75 uint64
        var x76 uint64
        x76, x75 = bits.Mul64(x67, 0xf3b9cac2fc632551)
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x76, x73, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x74, x71, uint64(fiatFqUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x72, x69, uint64(fiatFqUint1(x80)))
        var x84 uint64
        _, x84 = bits.Add64(x59, x75, uint64(0x0))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x61, x77, uint64(fiatFqUint1(x84)))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x63, x79, uint64(fiatFqUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x65, x81, uint64(fiatFqUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(((uint64(fiatFqUint1(x66)) + uint64(fiatFqUint1(x44))) + (uint64(fiatFqUint1(x58)) + x46)), (uint64(fiatFqUint1(x82)) + x70), uint64(fiatFqUint1(x90)))
        var x93 uint64
        var x94 uint64
        x94, x93 = bits.Mul64(x2, 0x66e12d94f3d95620)
        var x95 uint64
        var x96 uint64
        x96, x95 = bits.Mul64(x2, 0x2845b2392b6bec59)
        var x97 uint64
        var x98 uint64
        x98, x97 = bits.Mul64(x2, 0x4699799c49bd6fa6)
        var x99 uint64
        var x100 uint64
        x100, x99 = bits.Mul64(x2, 0x83244c95be79eea2)
        var x101 uint64
        var x102 uint64
        x101, x102 = bits.Add64(x100, x97, uint64(0x0))
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x98, x95, uint64(fiatFqUint1(x102)))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x96, x93, uint64(fiatFqUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x85, x99, uint64(0x0))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x87, x101, uint64(fiatFqUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x89, x103, uint64(fiatFqUint1(x110)))
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x91, x105, uint64(fiatFqUint1(x112)))
        var x115 uint64
        _, x115 = bits.Mul64(x107, 0xccd1c8aaee00bc4f)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x115, 0xffffffff00000000)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x115, 0xffffffffffffffff)
        var x121 uint64
        var x122 uint64
        x122, x121 = bits.Mul64(x115, 0xbce6faada7179e84)
        var x123 uint64
        var x124 uint64
        x124, x123 = bits.Mul64(x115, 0xf3b9cac2fc632551)
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x124, x121, uint64(0x0))
        var x127 uint64
        var x128 uint64
        x127, x128 = bits.Add64(x122, x119, uint64(fiatFqUint1(x126)))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x120, x117, uint64(fiatFqUint1(x128)))
        var x132 uint64
        _, x132 = bits.Add64(x107, x123, uint64(0x0))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x109, x125, uint64(fiatFqUint1(x132)))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x111, x127, uint64(fiatFqUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x113, x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(((uint64(fiatFqUint1(x114)) + uint64(fiatFqUint1(x92))) + (uint64(fiatFqUint1(x106)) + x94)), (uint64(fiatFqUint1(x130)) + x118), uint64(fiatFqUint1(x138)))
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, 0x66e12d94f3d95620)
        var x143 uint64
        var x144 uint64
        x144, x143 = bits.Mul64(x3, 0x2845b2392b6bec59)
        var x145 uint64
        var x146 uint64
        x146, x145 = bits.Mul64(x3, 0x4699799c49bd6fa6)
        var x147 uint64
        var x148 uint64
        x148, x147 = bits.Mul64(x3, 0x83244c95be79eea2)
        var x149 uint64
        var x150 uint64
        x149, x150 = bits.Add64(x148, x145, uint64(0x0))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Add64(x146, x143, uint64(fiatFqUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Add64(x144, x141, uint64(fiatFqUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Add64(x133, x147, uint64(0x0))
        var x157 uint64
        var x158 uint64
        x157, x158 = bits.Add64(x135, x149, uint64(fiatFqUint1(x156)))
        var x159 uint64
        var x160 uint64
        x159, x160 = bits.Add64(x137, x151, uint64(fiatFqUint1(x158)))
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x139, x153, uint64(fiatFqUint1(x160)))
        var x163 uint64
        _, x163 = bits.Mul64(x155, 0xccd1c8aaee00bc4f)
        var x165 uint64
        var x166 uint64
        x166, x165 = bits.Mul64(x163, 0xffffffff00000000)
        var x167 uint64
        var x168 uint64
        x168, x167 = bits.Mul64(x163, 0xffffffffffffffff)
        var x169 uint64
        var x170 uint64
        x170, x169 = bits.Mul64(x163, 0xbce6faada7179e84)
        var x171 uint64
        var x172 uint64
        x172, x171 = bits.Mul64(x163, 0xf3b9cac2fc632551)
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x172, x169, uint64(0x0))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x170, x167, uint64(fiatFqUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x168, x165, uint64(fiatFqUint1(x176)))
        var x180 uint64
        _, x180 = bits.Add64(x155, x171, uint64(0x0))
        var x181 uint64
        var x182 uint64
        x181, x182 = bits.Add64(x157, x173, uint64(fiatFqUint1(x180)))
        var x183 uint64
        var x184 uint64
        x183, x184 = bits.Add64(x159, x175, uint64(fiatFqUint1(x182)))
        var x185 uint64
        var x186 uint64
        x185, x186 = bits.Add64(x161, x177, uint64(fiatFqUint1(x184)))
        var x187 uint64
        var x188 uint64
        x187, x188 = bits.Add64(((uint64(fiatFqUint1(x162)) + uint64(fiatFqUint1(x140))) + (uint64(fiatFqUint1(x154)) + x142)), (uint64(fiatFqUint1(x178)) + x166), uint64(fiatFqUint1(x186)))
        var x189 uint64
        var x190 uint64
        x189, x190 = bits.Sub64(x181, 0xf3b9cac2fc632551, uint64(0x0))
        var x191 uint64
        var x192 uint64
        x191, x192 = bits.Sub64(x183, 0xbce6faada7179e84, uint64(fiatFqUint1(x190)))
        var x193 uint64
        var x194 uint64
        x193, x194 = bits.Sub64(x185, 0xffffffffffffffff, uint64(fiatFqUint1(x192)))
        var x195 uint64
        var x196 uint64
        x195, x196 = bits.Sub64(x187, 0xffffffff00000000, uint64(fiatFqUint1(x194)))
        var x198 uint64
        _, x198 = bits.Sub64(uint64(fiatFqUint1(x188)), uint64(0x0), uint64(fiatFqUint1(x196)))
        var x199 uint64
        fiatFqCmovznzU64(&amp;x199, fiatFqUint1(x198), x189, x181)
        var x200 uint64
        fiatFqCmovznzU64(&amp;x200, fiatFqUint1(x198), x191, x183)
        var x201 uint64
        fiatFqCmovznzU64(&amp;x201, fiatFqUint1(x198), x193, x185)
        var x202 uint64
        fiatFqCmovznzU64(&amp;x202, fiatFqUint1(x198), x195, x187)
        out1[0] = x199
        out1[1] = x200
        out1[2] = x201
        out1[3] = x202
}</span>

// fiatFqNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqNonzero(out1 *uint64, arg1 *[4]uint64) <span class="cov0" title="0">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | arg1[3])))
        *out1 = x1
}</span>

// fiatFqSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqSelectznz(out1 *[4]uint64, arg1 fiatFqUint1, arg2 *[4]uint64, arg3 *[4]uint64) <span class="cov0" title="0">{
        var x1 uint64
        fiatFqCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFqCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFqCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFqCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
}</span>

// fiatFqToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff]]
func fiatFqToBytes(out1 *[32]uint8, arg1 *[4]uint64) <span class="cov0" title="0">{
        x1 := arg1[3]
        x2 := arg1[2]
        x3 := arg1[1]
        x4 := arg1[0]
        x5 := (uint8(x4) &amp; 0xff)
        x6 := (x4 &gt;&gt; 8)
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := uint8((x16 &gt;&gt; 8))
        x19 := (uint8(x3) &amp; 0xff)
        x20 := (x3 &gt;&gt; 8)
        x21 := (uint8(x20) &amp; 0xff)
        x22 := (x20 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := uint8((x30 &gt;&gt; 8))
        x33 := (uint8(x2) &amp; 0xff)
        x34 := (x2 &gt;&gt; 8)
        x35 := (uint8(x34) &amp; 0xff)
        x36 := (x34 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := uint8((x44 &gt;&gt; 8))
        x47 := (uint8(x1) &amp; 0xff)
        x48 := (x1 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := (x48 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := uint8((x58 &gt;&gt; 8))
        out1[0] = x5
        out1[1] = x7
        out1[2] = x9
        out1[3] = x11
        out1[4] = x13
        out1[5] = x15
        out1[6] = x17
        out1[7] = x18
        out1[8] = x19
        out1[9] = x21
        out1[10] = x23
        out1[11] = x25
        out1[12] = x27
        out1[13] = x29
        out1[14] = x31
        out1[15] = x32
        out1[16] = x33
        out1[17] = x35
        out1[18] = x37
        out1[19] = x39
        out1[20] = x41
        out1[21] = x43
        out1[22] = x45
        out1[23] = x46
        out1[24] = x47
        out1[25] = x49
        out1[26] = x51
        out1[27] = x53
        out1[28] = x55
        out1[29] = x57
        out1[30] = x59
        out1[31] = x60
}</span>

// fiatFqFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqFromBytes(out1 *[4]uint64, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 56)
        x2 := (uint64(arg1[30]) &lt;&lt; 48)
        x3 := (uint64(arg1[29]) &lt;&lt; 40)
        x4 := (uint64(arg1[28]) &lt;&lt; 32)
        x5 := (uint64(arg1[27]) &lt;&lt; 24)
        x6 := (uint64(arg1[26]) &lt;&lt; 16)
        x7 := (uint64(arg1[25]) &lt;&lt; 8)
        x8 := arg1[24]
        x9 := (uint64(arg1[23]) &lt;&lt; 56)
        x10 := (uint64(arg1[22]) &lt;&lt; 48)
        x11 := (uint64(arg1[21]) &lt;&lt; 40)
        x12 := (uint64(arg1[20]) &lt;&lt; 32)
        x13 := (uint64(arg1[19]) &lt;&lt; 24)
        x14 := (uint64(arg1[18]) &lt;&lt; 16)
        x15 := (uint64(arg1[17]) &lt;&lt; 8)
        x16 := arg1[16]
        x17 := (uint64(arg1[15]) &lt;&lt; 56)
        x18 := (uint64(arg1[14]) &lt;&lt; 48)
        x19 := (uint64(arg1[13]) &lt;&lt; 40)
        x20 := (uint64(arg1[12]) &lt;&lt; 32)
        x21 := (uint64(arg1[11]) &lt;&lt; 24)
        x22 := (uint64(arg1[10]) &lt;&lt; 16)
        x23 := (uint64(arg1[9]) &lt;&lt; 8)
        x24 := arg1[8]
        x25 := (uint64(arg1[7]) &lt;&lt; 56)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x25 + x38)
        x40 := (x23 + uint64(x24))
        x41 := (x22 + x40)
        x42 := (x21 + x41)
        x43 := (x20 + x42)
        x44 := (x19 + x43)
        x45 := (x18 + x44)
        x46 := (x17 + x45)
        x47 := (x15 + uint64(x16))
        x48 := (x14 + x47)
        x49 := (x13 + x48)
        x50 := (x12 + x49)
        x51 := (x11 + x50)
        x52 := (x10 + x51)
        x53 := (x9 + x52)
        x54 := (x7 + uint64(x8))
        x55 := (x6 + x54)
        x56 := (x5 + x55)
        x57 := (x4 + x56)
        x58 := (x3 + x57)
        x59 := (x2 + x58)
        x60 := (x1 + x59)
        out1[0] = x39
        out1[1] = x46
        out1[2] = x53
        out1[3] = x60
}</span>

// fiatFqSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFqSetOne(out1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        out1[0] = 0xc46353d039cdaaf
        out1[1] = 0x4319055258e8617b
        out1[2] = uint64(0x0)
        out1[3] = 0xffffffff
}</span>

// fiatFqMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqMsat(out1 *[5]uint64) <span class="cov0" title="0">{
        out1[0] = 0xf3b9cac2fc632551
        out1[1] = 0xbce6faada7179e84
        out1[2] = 0xffffffffffffffff
        out1[3] = 0xffffffff00000000
        out1[4] = uint64(0x0)
}</span>

// fiatFqDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstepPrecomp(out1 *[4]uint64) <span class="cov0" title="0">{
        out1[0] = 0xd739262fb7fcfbb5
        out1[1] = 0x8ac6f75d20074414
        out1[2] = 0xc67428bfb5e3c256
        out1[3] = 0x444962f2eda7aedf
}</span>

// fiatFqDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstep(out1 *uint64, out2 *[5]uint64, out3 *[5]uint64, out4 *[4]uint64, out5 *[4]uint64, arg1 uint64, arg2 *[5]uint64, arg3 *[5]uint64, arg4 *[4]uint64, arg5 *[4]uint64) <span class="cov0" title="0">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFqUint1((x1 &gt;&gt; 63)) &amp; (fiatFqUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFqCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFqCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFqCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFqCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFqCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFqUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFqUint1(x17)))
        var x20 uint64
        x20, _ = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFqUint1(x19)))
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, x3, arg3[0], x12)
        var x23 uint64
        fiatFqCmovznzU64(&amp;x23, x3, arg3[1], x14)
        var x24 uint64
        fiatFqCmovznzU64(&amp;x24, x3, arg3[2], x16)
        var x25 uint64
        fiatFqCmovznzU64(&amp;x25, x3, arg3[3], x18)
        var x26 uint64
        fiatFqCmovznzU64(&amp;x26, x3, arg3[4], x20)
        var x27 uint64
        fiatFqCmovznzU64(&amp;x27, x3, arg4[0], arg5[0])
        var x28 uint64
        fiatFqCmovznzU64(&amp;x28, x3, arg4[1], arg5[1])
        var x29 uint64
        fiatFqCmovznzU64(&amp;x29, x3, arg4[2], arg5[2])
        var x30 uint64
        fiatFqCmovznzU64(&amp;x30, x3, arg4[3], arg5[3])
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x27, x27, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x28, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x29, x29, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x30, x30, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Sub64(x31, 0xf3b9cac2fc632551, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Sub64(x33, 0xbce6faada7179e84, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Sub64(x35, 0xffffffffffffffff, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Sub64(x37, 0xffffffff00000000, uint64(fiatFqUint1(x44)))
        var x48 uint64
        _, x48 = bits.Sub64(uint64(fiatFqUint1(x38)), uint64(0x0), uint64(fiatFqUint1(x46)))
        x49 := arg4[3]
        x50 := arg4[2]
        x51 := arg4[1]
        x52 := arg4[0]
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(uint64(0x0), x52, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(uint64(0x0), x51, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(uint64(0x0), x50, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(uint64(0x0), x49, uint64(fiatFqUint1(x58)))
        var x61 uint64
        fiatFqCmovznzU64(&amp;x61, fiatFqUint1(x60), uint64(0x0), 0xffffffffffffffff)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x53, (x61 &amp; 0xf3b9cac2fc632551), uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x55, (x61 &amp; 0xbce6faada7179e84), uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, x61, uint64(fiatFqUint1(x65)))
        var x68 uint64
        x68, _ = bits.Add64(x59, (x61 &amp; 0xffffffff00000000), uint64(fiatFqUint1(x67)))
        var x70 uint64
        fiatFqCmovznzU64(&amp;x70, x3, arg5[0], x62)
        var x71 uint64
        fiatFqCmovznzU64(&amp;x71, x3, arg5[1], x64)
        var x72 uint64
        fiatFqCmovznzU64(&amp;x72, x3, arg5[2], x66)
        var x73 uint64
        fiatFqCmovznzU64(&amp;x73, x3, arg5[3], x68)
        x74 := (fiatFqUint1(x22) &amp; 0x1)
        var x75 uint64
        fiatFqCmovznzU64(&amp;x75, x74, uint64(0x0), x7)
        var x76 uint64
        fiatFqCmovznzU64(&amp;x76, x74, uint64(0x0), x8)
        var x77 uint64
        fiatFqCmovznzU64(&amp;x77, x74, uint64(0x0), x9)
        var x78 uint64
        fiatFqCmovznzU64(&amp;x78, x74, uint64(0x0), x10)
        var x79 uint64
        fiatFqCmovznzU64(&amp;x79, x74, uint64(0x0), x11)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x22, x75, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x23, x76, uint64(fiatFqUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x24, x77, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x25, x78, uint64(fiatFqUint1(x85)))
        var x88 uint64
        x88, _ = bits.Add64(x26, x79, uint64(fiatFqUint1(x87)))
        var x90 uint64
        fiatFqCmovznzU64(&amp;x90, x74, uint64(0x0), x27)
        var x91 uint64
        fiatFqCmovznzU64(&amp;x91, x74, uint64(0x0), x28)
        var x92 uint64
        fiatFqCmovznzU64(&amp;x92, x74, uint64(0x0), x29)
        var x93 uint64
        fiatFqCmovznzU64(&amp;x93, x74, uint64(0x0), x30)
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x70, x90, uint64(0x0))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x71, x91, uint64(fiatFqUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x72, x92, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x73, x93, uint64(fiatFqUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Sub64(x94, 0xf3b9cac2fc632551, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Sub64(x96, 0xbce6faada7179e84, uint64(fiatFqUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Sub64(x98, 0xffffffffffffffff, uint64(fiatFqUint1(x105)))
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Sub64(x100, 0xffffffff00000000, uint64(fiatFqUint1(x107)))
        var x111 uint64
        _, x111 = bits.Sub64(uint64(fiatFqUint1(x101)), uint64(0x0), uint64(fiatFqUint1(x109)))
        var x112 uint64
        x112, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x114 := ((x80 &gt;&gt; 1) | ((x82 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x115 := ((x82 &gt;&gt; 1) | ((x84 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x116 := ((x84 &gt;&gt; 1) | ((x86 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x117 := ((x86 &gt;&gt; 1) | ((x88 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x118 := ((x88 &amp; 0x8000000000000000) | (x88 &gt;&gt; 1))
        var x119 uint64
        fiatFqCmovznzU64(&amp;x119, fiatFqUint1(x48), x39, x31)
        var x120 uint64
        fiatFqCmovznzU64(&amp;x120, fiatFqUint1(x48), x41, x33)
        var x121 uint64
        fiatFqCmovznzU64(&amp;x121, fiatFqUint1(x48), x43, x35)
        var x122 uint64
        fiatFqCmovznzU64(&amp;x122, fiatFqUint1(x48), x45, x37)
        var x123 uint64
        fiatFqCmovznzU64(&amp;x123, fiatFqUint1(x111), x102, x94)
        var x124 uint64
        fiatFqCmovznzU64(&amp;x124, fiatFqUint1(x111), x104, x96)
        var x125 uint64
        fiatFqCmovznzU64(&amp;x125, fiatFqUint1(x111), x106, x98)
        var x126 uint64
        fiatFqCmovznzU64(&amp;x126, fiatFqUint1(x111), x108, x100)
        *out1 = x112
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out3[0] = x114
        out3[1] = x115
        out3[2] = x116
        out3[3] = x117
        out3[4] = x118
        out4[0] = x119
        out4[1] = x120
        out4[2] = x121
        out4[3] = x122
        out5[0] = x123
        out5[1] = x124
        out5[2] = x125
        out5[3] = x126
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "2^256 - 2^224 + 2^192 + 2^96 - 1" --type Fp --sqrt sqrt
//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "2^256 - 2^224 + 2^192 - 89188191075325690597107910205041859247" --type Fq --sqrt sqrt
package impl

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func sqrt[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any](out, x, rootOfUnity *F, e uint64, progenitorExp []uint8) (ok ct.Bool) <span class="cov0" title="0">{
        return fieldsImpl.TonelliShanks[FP, F](out, x, rootOfUnity, e, progenitorExp)
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FpLimbs     = 4
        FpSatLimbs  = FpLimbs + 1
        FpBits      = 256
        FpBytes     = 8 * (((FpBits - 1) / 64) + 1)
        FpWideBytes = 2 * FpBytes
        FpDivSteps  = ((49 * FpBits) + 57) / 17
        FpE         = 1
)

var (
        FpProgenitorExp = [...]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0x3f}
        FpModulus       = [...]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff}
        FpRootOfUnity   Fp
)

func init() <span class="cov8" title="1">{
        FpRootOfUnity.MustSetHex("ffffffff00000001000000000000000000000000fffffffffffffffffffffffe")
}</span>

type Fp struct {
        fiatFpMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fp) Set(v *Fp) <span class="cov8" title="1">{
        *f = *v
}</span>

func (f *Fp) SetZero() <span class="cov8" title="1">{
        *f = Fp{}
}</span>

func (f *Fp) SetOne() <span class="cov8" title="1">{
        fiatFpSetOne(&amp;f.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FpLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fp) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFpToMontgomery(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fp) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FpBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromBytes((*[FpLimbs]uint64)(&amp;nonMonty), (*[FpBytes]uint8)(data))
        fiatFpToMontgomery(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fp) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) &gt; FpWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var wideData [FpWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FpLimbs]uint64
        fiatFpFromBytes(&amp;d0, (*[FpBytes]uint8)(wideData[:FpBytes]))
        fiatFpFromBytes(&amp;d1, (*[FpBytes]uint8)(wideData[FpBytes:]))

        // d0*r2 + d1*r3
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d0), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d1), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d1), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&amp;d0), (*fiatFpMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fp) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fp) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FpBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fp) Select(choice ct.Choice, z, nz *Fp) <span class="cov8" title="1">{
        fiatFpSelectznz((*[FpLimbs]uint64)(&amp;f.fiatFpMontgomeryDomainFieldElement),fiatFpUint1(choice), (*[FpLimbs]uint64)(&amp;z.fiatFpMontgomeryDomainFieldElement), (*[FpLimbs]uint64)(&amp;nz.fiatFpMontgomeryDomainFieldElement))
}</span>

func (f *Fp) Add(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Double(x *Fp) <span class="cov0" title="0">{
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;x.fiatFpMontgomeryDomainFieldElement, &amp;x.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Sub(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpSub(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Neg(v *Fp) <span class="cov8" title="1">{
        fiatFpOpp(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;v.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Mul(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpMul(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Square(v *Fp) <span class="cov8" title="1">{
        fiatFpSquare(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;v.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Inv(a *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var precomp, h, v, r, out4, out5 [FpLimbs]uint64
        var ff, g, out2, out3 [FpSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFpDivstepPrecomp(&amp;precomp)
        fiatFpFromMontgomery((*fiatFpNonMontgomeryDomainFieldElement)(g[:FpLimbs]), &amp;a.fiatFpMontgomeryDomainFieldElement)
        fiatFpMsat(&amp;ff)
        fiatFpSetOne((*fiatFpMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FpDivSteps-(FpDivSteps%2); i += 2 </span><span class="cov8" title="1">{
                fiatFpDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFpDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov8" title="1">if (FpDivSteps % 2) != 0 </span><span class="cov8" title="1">{ // compile time if - always true
                fiatFpDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov8" title="1">fiatFpOpp((*fiatFpMontgomeryDomainFieldElement)(&amp;h), (*fiatFpMontgomeryDomainFieldElement)(&amp;v))
        fiatFpSelectznz(&amp;v, fiatFpUint1(ff[FpLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFpMul(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&amp;v), (*fiatFpMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFpNonzero(&amp;inverted, (*[FpLimbs]uint64)(&amp;f.fiatFpMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fp) Div(lhs, rhs *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var rhsInv Fp
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fp) Sqrt(x *Fp) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(sqrt(f, x, &amp;FpRootOfUnity, FpE, FpProgenitorExp[:]))
}</span>

func (f *Fp) IsNonZero() ct.Bool <span class="cov8" title="1">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFpNonzero(&amp;nonZero, (*[FpLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fp) IsZero() ct.Bool <span class="cov8" title="1">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fp) IsOne() ct.Bool <span class="cov0" title="0">{
        var one Fp
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fp) Equal(v *Fp) ct.Bool <span class="cov8" title="1">{
        var diff Fp
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fp) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fp) Bytes() []byte <span class="cov8" title="1">{
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)
        var data [FpBytes]byte
        fiatFpToBytes(&amp;data, (*[FpLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fp) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fp) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fp) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fp) Degree() uint64 <span class="cov8" title="1">{
        return 1
}</span>

func (f *Fp) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fp) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FqLimbs     = 4
        FqSatLimbs  = FqLimbs + 1
        FqBits      = 256
        FqBytes     = 8 * (((FqBits - 1) / 64) + 1)
        FqWideBytes = 2 * FqBytes
        FqDivSteps  = ((49 * FqBits) + 57) / 17
        FqE         = 4
)

var (
        FqProgenitorExp = [...]byte{0x2a, 0x19, 0xe3, 0x17, 0x56, 0xce, 0x9d, 0x27, 0xf4, 0xbc, 0x38, 0x6d, 0xd5, 0x37, 0xe7, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x07}
        FqModulus       = [...]byte{0x51, 0x25, 0x63, 0xfc, 0xc2, 0xca, 0xb9, 0xf3, 0x84, 0x9e, 0x17, 0xa7, 0xad, 0xfa, 0xe6, 0xbc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff}
        FqRootOfUnity   Fq
)

func init() <span class="cov8" title="1">{
        FqRootOfUnity.MustSetHex("ffc97f062a770992ba807ace842a3dfc1546cad004378daf0592d7fbb41e6602")
}</span>

type Fq struct {
        fiatFqMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fq) Set(v *Fq) <span class="cov0" title="0">{
        *f = *v
}</span>

func (f *Fq) SetZero() <span class="cov0" title="0">{
        *f = Fq{}
}</span>

func (f *Fq) SetOne() <span class="cov0" title="0">{
        fiatFqSetOne(&amp;f.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FqLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fq) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fq) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FqBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromBytes((*[FqLimbs]uint64)(&amp;nonMonty), (*[FqBytes]uint8)(data))
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fq) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(data) &gt; FqWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var wideData [FqWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FqLimbs]uint64
        fiatFqFromBytes(&amp;d0, (*[FqBytes]uint8)(wideData[:FqBytes]))
        fiatFqFromBytes(&amp;d1, (*[FqBytes]uint8)(wideData[FqBytes:]))

        // d0*r2 + d1*r3
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fq) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fq) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FqBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fq) Select(choice ct.Choice, z, nz *Fq) <span class="cov0" title="0">{
        fiatFqSelectznz((*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement),fiatFqUint1(choice), (*[FqLimbs]uint64)(&amp;z.fiatFqMontgomeryDomainFieldElement), (*[FqLimbs]uint64)(&amp;nz.fiatFqMontgomeryDomainFieldElement))
}</span>

func (f *Fq) Add(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Double(x *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Sub(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqSub(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Neg(v *Fq) <span class="cov0" title="0">{
        fiatFqOpp(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Mul(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Square(v *Fq) <span class="cov0" title="0">{
        fiatFqSquare(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Inv(a *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        var precomp, h, v, r, out4, out5 [FqLimbs]uint64
        var ff, g, out2, out3 [FqSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFqDivstepPrecomp(&amp;precomp)
        fiatFqFromMontgomery((*fiatFqNonMontgomeryDomainFieldElement)(g[:FqLimbs]), &amp;a.fiatFqMontgomeryDomainFieldElement)
        fiatFqMsat(&amp;ff)
        fiatFqSetOne((*fiatFqMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FqDivSteps-(FqDivSteps%2); i += 2 </span><span class="cov0" title="0">{
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFqDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov0" title="0">if (FqDivSteps % 2) != 0 </span><span class="cov0" title="0">{ // compile time if - always true
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov0" title="0">fiatFqOpp((*fiatFqMontgomeryDomainFieldElement)(&amp;h), (*fiatFqMontgomeryDomainFieldElement)(&amp;v))
        fiatFqSelectznz(&amp;v, fiatFqUint1(ff[FqLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;v), (*fiatFqMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFqNonzero(&amp;inverted, (*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fq) Div(lhs, rhs *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        var rhsInv Fq
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fq) Sqrt(x *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(sqrt(f, x, &amp;FqRootOfUnity, FqE, FqProgenitorExp[:]))
}</span>

func (f *Fq) IsNonZero() ct.Bool <span class="cov0" title="0">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFqNonzero(&amp;nonZero, (*[FqLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fq) IsZero() ct.Bool <span class="cov0" title="0">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fq) IsOne() ct.Bool <span class="cov0" title="0">{
        var one Fq
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fq) Equal(v *Fq) ct.Bool <span class="cov0" title="0">{
        var diff Fq
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fq) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fq) Bytes() []byte <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        var data [FqBytes]byte
        fiatFqToBytes(&amp;data, (*[FqLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fq) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fq) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fq) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fq) Degree() uint64 <span class="cov0" title="0">{
        return 1
}</span>

func (f *Fq) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fq) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package impl

import (
        "crypto/sha256"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        pointsImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu"
)

var (
        _ pointsImpl.ShortWeierstrassCurveParams[*Fp] = curveParams{}
        _ h2c.HasherParams                            = CurveHasherParams{}
        _ sswu.NonZeroPointMapperParams[*Fp]          = curveMapperParams{}
        _ h2c.PointMapper[*Fp]                        = curveMapper{}
)

var (
        curveA               Fp
        curveB               Fp
        curveB3              Fp
        curveGx              Fp
        curveGy              Fp
        curveMessageExpander = h2c.NewXMDMessageExpander(sha256.New)

        sqrtRatioC1 = [...]uint8{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0x3f}
        sqrtRatioC2 Fp

        sswuZ Fp
)

type curveParams struct{}

// CurveHasherParams defines hash-to-curve parameters.
type CurveHasherParams struct{}
type curveMapperParams struct{}
type curveMapper = sswu.NonZeroPointMapper[*Fp, curveMapperParams, Fp]

//nolint:gochecknoinits // curve params initialization
func init() <span class="cov8" title="1">{
        curveA.MustSetHex("ffffffff00000001000000000000000000000000fffffffffffffffffffffffc")
        curveB.MustSetHex("5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b")
        curveB3.MustSetHex("1052a18afeafbbb61bc3380063c994352f57141164fb12e2b36ab4ba777720e2")
        curveGx.MustSetHex("6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296")
        curveGy.MustSetHex("4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")

        sqrtRatioC2.MustSetHex("25ac71c31e27646736870398ae7f554d8472e008b3aa2a49d332cbd81bcc3b80")

        sswuZ.MustSetHex("ffffffff00000001000000000000000000000000fffffffffffffffffffffff5")
}</span>

// ClearCofactor clears the cofactor of the input point.
func (curveParams) ClearCofactor(xOut, yOut, zOut, xIn, yIn, zIn *Fp) <span class="cov8" title="1">{
        xOut.Set(xIn)
        yOut.Set(yIn)
        zOut.Set(zIn)
}</span>

// SetGenerator sets generator coordinates.
func (curveParams) SetGenerator(xOut, yOut, zOut *Fp) <span class="cov8" title="1">{
        xOut.Set(&amp;curveGx)
        yOut.Set(&amp;curveGy)
        zOut.SetOne()
}</span>

// AddA adds the curve A parameter to in.
func (curveParams) AddA(out, in *Fp) <span class="cov0" title="0">{
        out.Add(in, &amp;curveA)
}</span>

// AddB adds the curve B parameter to in.
func (curveParams) AddB(out, in *Fp) <span class="cov0" title="0">{
        out.Add(in, &amp;curveB)
}</span>

// MulByA multiples provided element by -3 (p256 a=-3).
func (curveParams) MulByA(out *Fp, in *Fp) <span class="cov8" title="1">{
        var n1, n2 Fp
        n1.Neg(in)        // -1
        n2.Add(&amp;n1, &amp;n1)  // -2
        out.Add(&amp;n1, &amp;n2) // -3
}</span>

// MulBy3B multiples provided element by 3*b.
func (curveParams) MulBy3B(out *Fp, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;curveB3)
}</span>

// L returns the hash-to-field length in bytes.
func (CurveHasherParams) L() uint64 <span class="cov8" title="1">{
        return 48
}</span>

// MessageExpander returns the RFC 9380 message expander.
func (CurveHasherParams) MessageExpander() h2c.MessageExpander <span class="cov8" title="1">{
        return curveMessageExpander
}</span>

// MulByA multiplies by the curve A parameter.
func (curveMapperParams) MulByA(out, in *Fp) <span class="cov8" title="1">{
        var n1, n2 Fp
        n1.Neg(in)        // -1
        n2.Add(&amp;n1, &amp;n1)  // -2
        out.Add(&amp;n1, &amp;n2) // -3
}</span>

// MulByB multiplies by the curve B parameter.
func (curveMapperParams) MulByB(out, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;curveB)
}</span>

// SetZ sets the SSWU Z parameter.
func (curveMapperParams) SetZ(out *Fp) <span class="cov8" title="1">{
        out.Set(&amp;sswuZ)
}</span>

// SqrtRatio computes sqrt(u/v) with curve-specific parameters.
func (curveMapperParams) SqrtRatio(y, u, v *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        return sswu.SqrtRatio3Mod4(y, sqrtRatioC1[:], &amp;sqrtRatioC2, u, v)
}</span>

// Sgn0 returns the sign bit per RFC 9380.
func (curveMapperParams) Sgn0(v *Fp) ct.Bool <span class="cov8" title="1">{
        return ct.Bool(uint64(v.Bytes()[0] &amp; 0b1))
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package p256

import (
        "encoding"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        p256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

const (
        // ScalarFieldName is the scalar field name.
        ScalarFieldName = "P256Fq"
)

var (
        _ algebra.PrimeField[*Scalar]        = (*ScalarField)(nil)
        _ algebra.PrimeFieldElement[*Scalar] = (*Scalar)(nil)
        _ encoding.BinaryMarshaler           = (*Scalar)(nil)
        _ encoding.BinaryUnmarshaler         = (*Scalar)(nil)

        scalarFieldInitOnce sync.Once
        scalarFieldInstance *ScalarField
        scalarFieldOrder    *numct.Modulus
)

func scalarFieldInit() <span class="cov8" title="1">{
        orderBytes := make([]byte, len(p256Impl.FqModulus))
        copy(orderBytes, p256Impl.FqModulus[:])
        slices.Reverse(orderBytes)
        var ok ct.Bool
        v := numct.NewNatFromBytes(orderBytes)
        scalarFieldOrder, ok = numct.NewModulus(v)
        if ok == ct.False </span><span class="cov0" title="0">{
                panic("failed to create scalar field modulus")</span>
        }
        //nolint:exhaustruct // no need for a trait
        <span class="cov8" title="1">scalarFieldInstance = &amp;ScalarField{}</span>
}

// ScalarField represents the scalar field.
type ScalarField struct {
        traits.PrimeFieldTrait[*p256Impl.Fq, *Scalar, Scalar]
}

// NewScalarField returns the scalar field instance.
func NewScalarField() *ScalarField <span class="cov8" title="1">{
        scalarFieldInitOnce.Do(scalarFieldInit)
        return scalarFieldInstance
}</span>

// Name returns the name of the structure.
func (*ScalarField) Name() string <span class="cov0" title="0">{
        return ScalarFieldName
}</span>

// Order returns the group or field order.
func (*ScalarField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder.Nat())
}</span>

// Characteristic returns the field characteristic.
func (*ScalarField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder.Nat())
}</span>

// Hash maps input bytes to an element or point.
func (*ScalarField) Hash(bytes []byte) (*Scalar, error) <span class="cov0" title="0">{
        var e [1]p256Impl.Fq
        h2c.HashToField(e[:], p256Impl.CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveScalarSuite, bytes)

        var s Scalar
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *ScalarField) FromBytesBEReduce(input []byte) (*Scalar, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        scalarFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// ElementSize returns the element size in bytes.
func (*ScalarField) ElementSize() int <span class="cov0" title="0">{
        return p256Impl.FqBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*ScalarField) WideElementSize() int <span class="cov0" title="0">{
        return p256Impl.FqWideBytes
}</span>

// BitLen returns the field modulus bit length.
func (*ScalarField) BitLen() int <span class="cov0" title="0">{
        return p256Impl.FqBits
}</span>

// Scalar represents a scalar field element.
type Scalar struct {
        traits.PrimeFieldElementTrait[*p256Impl.Fq, p256Impl.Fq, *Scalar, Scalar]
}

// Structure returns the algebraic structure for the receiver.
func (*Scalar) Structure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *Scalar) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *Scalar) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("failed to unmarshal field element")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package bls12381

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
)

// FamilyName is the BLS12-381 family name.
const FamilyName = "BLS12381"

// FamilyTrait provides traits for the BLS12-381 family.
type FamilyTrait struct{}

// Name returns the name of the structure.
func (*FamilyTrait) Name() string <span class="cov0" title="0">{
        return FamilyName
}</span>

// SourceSubGroup returns the source subgroup.
func (*FamilyTrait) SourceSubGroup() curves.PairingFriendlyCurve[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar] <span class="cov0" title="0">{
        return NewG1()
}</span>

// TwistedSubGroup returns the twisted subgroup.
func (*FamilyTrait) TwistedSubGroup() curves.PairingFriendlyCurve[*PointG2, *BaseFieldElementG2, *PointG1, *BaseFieldElementG1, *GtElement, *Scalar] <span class="cov0" title="0">{
        return NewG2()
}</span>

// TargetSubGroup returns the target subgroup.
func (*FamilyTrait) TargetSubGroup() algebra.MultiplicativeGroup[*GtElement] <span class="cov0" title="0">{
        return NewGt()
}</span>

// GetPPE returns a pairing engine by algorithm name.
func (*FamilyTrait) GetPPE(name curves.PairingAlgorithm) (out curves.PPE[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar], exists bool) <span class="cov0" title="0">{
        switch name </span>{
        case OptimalAteAlgorithm:<span class="cov0" title="0">
                return NewOptimalAtePPE(), true</span>
        default:<span class="cov0" title="0">
                return nil, false</span>
        }
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package bls12381

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*BaseFieldElementG1)(nil)
        _ cbor.Unmarshaler = (*BaseFieldElementG1)(nil)
        _ cbor.Marshaler   = (*BaseFieldElementG2)(nil)
        _ cbor.Unmarshaler = (*BaseFieldElementG2)(nil)
        _ cbor.Marshaler   = (*Scalar)(nil)
        _ cbor.Unmarshaler = (*Scalar)(nil)
        _ cbor.Marshaler   = (*PointG1)(nil)
        _ cbor.Unmarshaler = (*PointG1)(nil)
        _ cbor.Marshaler   = (*PointG2)(nil)
        _ cbor.Unmarshaler = (*PointG2)(nil)
)

type baseFieldElementG1DTO struct {
        FieldBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *BaseFieldElementG1) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;baseFieldElementG1DTO{FieldBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *BaseFieldElementG1) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*baseFieldElementG1DTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">e, err := NewG1BaseField().FromBytes(dto.FieldBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize base field element")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;e.V)
        return nil</span>
}

type baseFieldElementG2DTO struct {
        FieldBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *BaseFieldElementG2) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;baseFieldElementG2DTO{FieldBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *BaseFieldElementG2) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*baseFieldElementG2DTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">e, err := NewG2BaseField().FromBytes(dto.FieldBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize base field element")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;e.V)
        return nil</span>
}

type scalarDTO struct {
        FieldBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (s *Scalar) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;scalarDTO{FieldBytes: s.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (s *Scalar) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*scalarDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">e, err := NewScalarField().FromBytes(dto.FieldBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize scalar")
        }</span>
        <span class="cov8" title="1">s.V.Set(&amp;e.V)
        return nil</span>
}

type pointG1DTO struct {
        AffineCompressedBytes []byte `cbor:"compressedBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (p *PointG1) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;pointG1DTO{AffineCompressedBytes: p.ToCompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *PointG1) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*pointG1DTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">e, err := NewG1().FromCompressed(dto.AffineCompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize scalar")
        }</span>
        <span class="cov8" title="1">p.V.Set(&amp;e.V)
        return nil</span>
}

type pointG2DTO struct {
        AffineCompressedBytes []byte `cbor:"compressedBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (p *PointG2) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;pointG2DTO{AffineCompressedBytes: p.ToCompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *PointG2) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*pointG2DTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">e, err := NewG2().FromCompressed(dto.AffineCompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize scalar")
        }</span>
        <span class="cov8" title="1">p.V.Set(&amp;e.V)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package bls12381

import (
        "encoding"
        "fmt"
        "hash/fnv"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // CurveNameG1 is the G1 curve name.
        CurveNameG1 = "BLS12381G1"
        // Hash2CurveSuiteG1 is the hash-to-curve suite string for G1.
        Hash2CurveSuiteG1 = "BLS12381G1_XMD:SHA-256_SSWU_RO_"
)

var (
        _ curves.Curve[*PointG1, *BaseFieldElementG1, *Scalar]                                                           = (*G1)(nil)
        _ curves.PairingFriendlyCurve[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar] = (*G1)(nil)
        _ curves.Point[*PointG1, *BaseFieldElementG1, *Scalar]                                                           = (*PointG1)(nil)
        _ encoding.BinaryMarshaler                                                                                       = (*PointG1)(nil)
        _ encoding.BinaryUnmarshaler                                                                                     = (*PointG1)(nil)

        curveInstanceG1 *G1
        curveInitOnceG1 sync.Once
)

// G1 represents the BLS12-381 G1 group.
type G1 struct {
        traits.PrimeCurveTrait[*bls12381Impl.Fp, *bls12381Impl.G1Point, *PointG1, PointG1]
}

// NewG1 returns the BLS12-381 G1 group instance.
func NewG1() *G1 <span class="cov8" title="1">{
        curveInitOnceG1.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for a trait
                curveInstanceG1 = &amp;G1{}
        }</span>)

        <span class="cov8" title="1">return curveInstanceG1</span>
}

// Name returns the name of the structure.
func (*G1) Name() string <span class="cov0" title="0">{
        return CurveNameG1
}</span>

// ElementSize returns the element size in bytes.
func (*G1) ElementSize() int <span class="cov0" title="0">{
        return bls12381Impl.FpBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*G1) WideElementSize() int <span class="cov0" title="0">{
        return int(^uint(0) &gt;&gt; 1)
}</span>

// FromWideBytes decodes an element from wide bytes.
func (c *G1) FromWideBytes(input []byte) (*PointG1, error) <span class="cov0" title="0">{
        return c.Hash(input)
}</span>

// DualStructure returns the dual group structure.
func (*G1) DualStructure() curves.PairingFriendlyCurve[*PointG2, *BaseFieldElementG2, *PointG1, *BaseFieldElementG1, *GtElement, *Scalar] <span class="cov0" title="0">{
        return NewG2()
}</span>

// PairingAlgorithm returns the pairing algorithm identifier.
func (*G1) PairingAlgorithm() curves.PairingAlgorithm <span class="cov0" title="0">{
        return OptimalAteAlgorithm
}</span>

// MultiPair computes a multi-pairing.
func (*G1) MultiPair(these []*PointG1, with []*PointG2) (*GtElement, error) <span class="cov0" title="0">{
        if len(these) != len(with) </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("number of G1 and G2 points must match")
        }</span>

        <span class="cov0" title="0">ppe := NewOptimalAtePPE()

        for i, p1 := range these </span><span class="cov0" title="0">{
                if err := ppe.Add(p1, with[i]); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine at index %d", i)
                }</span>
        }
        <span class="cov0" title="0">return ppe.Result(), nil</span>
}

// MultiPairAndInvertDuals computes a multi-pairing and inverts dual points.
func (*G1) MultiPairAndInvertDuals(these []*PointG1, with []*PointG2) (*GtElement, error) <span class="cov0" title="0">{
        if len(these) != len(with) </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("number of G1 and G2 points must match")
        }</span>

        <span class="cov0" title="0">ppe := NewOptimalAtePPE()

        for i, p1 := range these </span><span class="cov0" title="0">{
                if err := ppe.AddAndInvG2(p1, with[i]); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine at index %d", i)
                }</span>
        }
        <span class="cov0" title="0">result := ppe.Result()
        return result, nil</span>
}

// Cofactor returns the curve cofactor.
func (*G1) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(1)
}</span>

// Order returns the group or field order.
func (*G1) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder.Nat())
}</span>

// FromCompressed decodes a compressed point.
func (*G1) FromCompressed(input []byte) (*PointG1, error) <span class="cov8" title="1">{
        if len(input) != bls12381Impl.FpBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov8" title="1">var xFp, yFp, yNegFp bls12381Impl.Fp
        var xBytes [bls12381Impl.FpBytes]byte
        pp := new(PointG1)
        compressedFlag := ct.Bool((input[0] &gt;&gt; 7) &amp; 1)
        infinityFlag := ct.Bool((input[0] &gt;&gt; 6) &amp; 1)
        sortFlag := ct.Bool((input[0] &gt;&gt; 5) &amp; 1)

        if compressedFlag != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("compressed flag must be set")
        }</span>

        <span class="cov8" title="1">if infinityFlag == 1 </span><span class="cov0" title="0">{
                if sortFlag == 1 </span><span class="cov0" title="0">{
                        return nil, curves.ErrFailed.WithMessage("infinity flag and sort flag are both set")
                }</span>
                // Check that all other bytes are zero when infinity flag is set
                <span class="cov0" title="0">for i := range input </span><span class="cov0" title="0">{
                        mask := byte(0xff)
                        if i == 0 </span><span class="cov0" title="0">{
                                mask = 0x1f // Ignore the flag bits
                        }</span>
                        <span class="cov0" title="0">if input[i]&amp;mask != 0 </span><span class="cov0" title="0">{
                                return nil, curves.ErrFailed.WithMessage("non-zero x coordinate with infinity flag set")
                        }</span>
                }
                <span class="cov0" title="0">pp.V.SetZero()
                return pp, nil</span>
        }

        <span class="cov8" title="1">copy(xBytes[:], input)
        // Mask away the flag bits
        xBytes[0] &amp;= 0x1f
        slices.Reverse(xBytes[:])
        if valid := xFp.SetBytes(xBytes[:]); valid != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid bytes - not in field")
        }</span>

        <span class="cov8" title="1">if wasSquare := pp.V.SetFromAffineX(&amp;xFp); wasSquare != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not on the curve")
        }</span>
        <span class="cov8" title="1">if ok := pp.V.ToAffine(&amp;xFp, &amp;yFp); ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov8" title="1">yNegFp.Neg(&amp;pp.V.Y)
        pp.V.Y.Select(fieldsImpl.IsNegative(&amp;yFp)^sortFlag, &amp;pp.V.Y, &amp;yNegFp)

        if !pp.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not in correct subgroup")
        }</span>

        <span class="cov8" title="1">return pp, nil</span>
}

// FromAffineX builds a point from an affine x-coordinate.
func (*G1) FromAffineX(x *BaseFieldElementG1, b bool) (*PointG1, error) <span class="cov0" title="0">{
        var p PointG1
        ok := p.V.SetFromAffineX(&amp;x.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov0" title="0">y, err := p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // should never happen
        }
        <span class="cov0" title="0">if y.IsOdd() != b </span><span class="cov0" title="0">{
                return p.Neg(), nil
        }</span> else<span class="cov0" title="0"> {
                return &amp;p, nil
        }</span>
}

// FromBytes decodes an element from bytes.
func (c *G1) FromBytes(input []byte) (*PointG1, error) <span class="cov0" title="0">{
        return c.FromCompressed(input)
}</span>

// FromUncompressed decodes an uncompressed point.
func (*G1) FromUncompressed(input []byte) (*PointG1, error) <span class="cov0" title="0">{
        if len(input) != 2*bls12381Impl.FpBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov0" title="0">var xFp, yFp bls12381Impl.Fp
        var t [2 * bls12381Impl.FpBytes]byte
        pp := new(PointG1)
        infinityFlag := uint64((input[0] &gt;&gt; 6) &amp; 1)

        if infinityFlag == 1 </span><span class="cov0" title="0">{
                pp.V.SetZero()
                return pp, nil
        }</span>

        <span class="cov0" title="0">copy(t[:], input)
        // Mask away top bits
        t[0] &amp;= 0x1f
        xBytes := t[:bls12381Impl.FpBytes]
        slices.Reverse(xBytes)
        yBytes := t[bls12381Impl.FpBytes:]
        slices.Reverse(yBytes)

        if valid := xFp.SetBytes(xBytes); valid != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid bytes - x not in field")
        }</span>
        <span class="cov0" title="0">if valid := yFp.SetBytes(yBytes); valid != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid bytes - y not in field")
        }</span>
        <span class="cov0" title="0">if valid := pp.V.SetAffine(&amp;xFp, &amp;yFp); valid != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not on the curve")
        }</span>
        <span class="cov0" title="0">if !pp.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not in correct subgroup")
        }</span>

        <span class="cov0" title="0">return pp, nil</span>
}

// FromAffine builds a point from affine coordinates.
func (*G1) FromAffine(x, y *BaseFieldElementG1) (*PointG1, error) <span class="cov0" title="0">{
        var p PointG1
        ok := p.V.SetAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

// Hash maps input bytes to an element or point.
func (c *G1) Hash(bytes []byte) (*PointG1, error) <span class="cov0" title="0">{
        return c.HashWithDst(base.Hash2CurveAppTag+Hash2CurveSuiteG1, bytes)
}</span>

// HashWithDst maps input bytes to a point with a custom DST.
func (*G1) HashWithDst(dst string, bytes []byte) (*PointG1, error) <span class="cov0" title="0">{
        var p PointG1
        p.V.Hash(dst, bytes)
        return &amp;p, nil
}</span>

// ScalarStructure returns the scalar structure.
func (*G1) ScalarStructure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseStructure returns the base field structure.
func (*G1) BaseStructure() algebra.Structure[*BaseFieldElementG1] <span class="cov0" title="0">{
        return NewG1BaseField()
}</span>

// ScalarRing returns the scalar ring.
func (*G1) ScalarRing() algebra.ZModLike[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarField returns the scalar field.
func (*G1) ScalarField() algebra.PrimeField[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseField returns the base field.
func (*G1) BaseField() algebra.FiniteField[*BaseFieldElementG1] <span class="cov0" title="0">{
        return NewG1BaseField()
}</span>

// ScalarBaseOp adds a scalar multiple of the generator.
func (c *G1) ScalarBaseOp(sc *Scalar) *PointG1 <span class="cov0" title="0">{
        if sc.IsZero() </span><span class="cov0" title="0">{
                return c.OpIdentity()
        }</span>
        <span class="cov0" title="0">return c.ScalarBaseMul(sc)</span>
}

// ScalarBaseMul multiplies the generator by a scalar.
func (c *G1) ScalarBaseMul(sc *Scalar) *PointG1 <span class="cov0" title="0">{
        return c.Generator().ScalarMul(sc)
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *G1) MultiScalarOp(scalars []*Scalar, points []*PointG1) (*PointG1, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*G1) MultiScalarMul(scalars []*Scalar, points []*PointG1) (*PointG1, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result PointG1
        scs := make([][]byte, len(scalars))
        pts := make([]*bls12381Impl.G1Point, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// PointG1 represents a point in G1.
type PointG1 struct {
        traits.PrimePointTrait[*bls12381Impl.Fp, *bls12381Impl.G1Point, bls12381Impl.G1Point, *PointG1, PointG1]
}

// Pair computes the pairing of p and q.
func (p *PointG1) Pair(p2 *PointG2) (*GtElement, error) <span class="cov0" title="0">{
        if p2 == nil </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidArgument.WithMessage("cannot pair with nil G2 point")
        }</span>
        <span class="cov0" title="0">ppe := NewOptimalAtePPE()
        if err := ppe.Add(p, p2); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine")
        }</span>
        <span class="cov0" title="0">return ppe.Result(), nil</span>
}

// MultiPair computes a multi-pairing.
func (p *PointG1) MultiPair(with ...*PointG2) (*GtElement, error) <span class="cov0" title="0">{
        if len(with) == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidArgument.WithMessage("cannot pair with empty G2 points")
        }</span>

        <span class="cov0" title="0">ppe := NewOptimalAtePPE()
        for _, p2 := range with </span><span class="cov0" title="0">{
                if err := ppe.Add(p, p2); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine")
                }</span>
        }
        <span class="cov0" title="0">return ppe.Result(), nil</span>
}

// MultiPairAndInvertDuals computes a multi-pairing and inverts dual points.
func (p *PointG1) MultiPairAndInvertDuals(with ...*PointG2) (*GtElement, error) <span class="cov0" title="0">{
        if len(with) == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidArgument.WithMessage("cannot pair with empty G2 points")
        }</span>

        <span class="cov0" title="0">ppe := NewOptimalAtePPE()
        for _, p2 := range with </span><span class="cov0" title="0">{
                if err := ppe.AddAndInvG2(p, p2); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine")
                }</span>
        }
        <span class="cov0" title="0">return ppe.Result(), nil</span>
}

// InSourceGroup reports whether p is in the source group.
func (*PointG1) InSourceGroup() bool <span class="cov0" title="0">{
        return true
}</span>

// HashCode returns a hash code for the receiver.
func (p *PointG1) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(p.ToCompressed())
        return base.HashCode(h.Sum64())
}</span>

// Structure returns the algebraic structure for the receiver.
func (*PointG1) Structure() algebra.Structure[*PointG1] <span class="cov0" title="0">{
        return NewG1()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (p *PointG1) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return p.ToCompressed(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (p *PointG1) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        pp, err := NewG1().FromCompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}

// ToCompressed encodes the point in compressed form.
func (p *PointG1) ToCompressed() []byte <span class="cov8" title="1">{
        var x, y bls12381Impl.Fp
        x.SetZero()
        y.SetZero()
        p.V.ToAffine(&amp;x, &amp;y)

        bitC := ct.Bool(1)
        bitI := p.V.IsZero()
        bitS := fieldsImpl.IsNegative(&amp;y) &amp; (bitI ^ 1)
        m := byte((bitC &lt;&lt; 7) | (bitI &lt;&lt; 6) | (bitS &lt;&lt; 5))

        xBytes := x.Bytes()
        slices.Reverse(xBytes)
        xBytes[0] |= m
        return xBytes
}</span>

// ToUncompressed encodes the point in uncompressed form.
func (p *PointG1) ToUncompressed() []byte <span class="cov0" title="0">{
        var x, y bls12381Impl.Fp
        x.SetZero()
        y.SetZero()
        p.V.ToAffine(&amp;x, &amp;y)

        bitC := ct.Bool(0)
        bitI := p.V.IsZero()
        bitS := ct.Bool(0)
        m := byte((bitC &lt;&lt; 7) | (bitI &lt;&lt; 6) | (bitS &lt;&lt; 5))

        xBytes := x.Bytes()
        slices.Reverse(xBytes)
        yBytes := y.Bytes()
        slices.Reverse(yBytes)

        result := slices.Concat(xBytes, yBytes)
        result[0] |= m
        return result
}</span>

// AffineX returns the affine x-coordinate.
func (p *PointG1) AffineX() (*BaseFieldElementG1, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElementG1
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;x, nil</span>
}

// AffineY returns the affine y-coordinate.
func (p *PointG1) AffineY() (*BaseFieldElementG1, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElementG1
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;y, nil</span>
}

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *PointG1) ScalarOp(sc *Scalar) *PointG1 <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *PointG1) ScalarMul(actor *Scalar) *PointG1 <span class="cov0" title="0">{
        var result PointG1
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (p *PointG1) IsTorsionFree() bool <span class="cov8" title="1">{
        // Ensure scalar field is initialised
        _ = NewScalarField()
        orderBytes := scalarFieldOrder.Bytes()
        slices.Reverse(orderBytes)
        var e bls12381Impl.G1Point
        aimpl.ScalarMulLowLevel(&amp;e, &amp;p.V, orderBytes)
        return e.IsZero() == 1
}</span>

// Bytes returns the canonical byte encoding.
func (p *PointG1) Bytes() []byte <span class="cov0" title="0">{
        return p.ToCompressed()
}</span>

// String returns the string form of the receiver.
func (p *PointG1) String() string <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return "(0, 1, 0)"
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("(%s, %s, %s)", p.V.X.String(), p.V.Y.String(), p.V.Z.String())
        }</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package bls12381

import (
        "encoding"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

const (
        // BaseFieldNameG1 is the G1 base field name.
        BaseFieldNameG1 = "BLS12381Fp"
)

var (
        _ algebra.PrimeField[*BaseFieldElementG1]        = (*BaseFieldG1)(nil)
        _ algebra.PrimeFieldElement[*BaseFieldElementG1] = (*BaseFieldElementG1)(nil)
        _ encoding.BinaryMarshaler                       = (*BaseFieldElementG1)(nil)
        _ encoding.BinaryUnmarshaler                     = (*BaseFieldElementG1)(nil)

        baseFieldInstanceG1 *BaseFieldG1
        baseFieldInitOnceG1 sync.Once
        baseFieldOrderG1    *numct.Modulus
)

// BaseFieldG1 represents the base field for G1.
type BaseFieldG1 struct {
        traits.PrimeFieldTrait[*bls12381Impl.Fp, *BaseFieldElementG1, BaseFieldElementG1]
}

// NewG1BaseField returns a new instance.
func NewG1BaseField() *BaseFieldG1 <span class="cov8" title="1">{
        baseFieldInitOnceG1.Do(func() </span><span class="cov8" title="1">{
                baseFieldOrderG1, _ = numct.NewModulusFromBytesBE(sliceutils.Reversed(bls12381Impl.FpModulus[:]))
                //nolint:exhaustruct // no need for a trait
                baseFieldInstanceG1 = &amp;BaseFieldG1{}
        }</span>)

        <span class="cov8" title="1">return baseFieldInstanceG1</span>
}

// Name returns the name of the structure.
func (*BaseFieldG1) Name() string <span class="cov0" title="0">{
        return BaseFieldNameG1
}</span>

// Order returns the group or field order.
func (*BaseFieldG1) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(baseFieldOrderG1.Nat())
}</span>

// Characteristic returns the field characteristic.
func (*BaseFieldG1) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(baseFieldOrderG1.Nat())
}</span>

// Hash maps input bytes to an element or point.
func (*BaseFieldG1) Hash(bytes []byte) (*BaseFieldElementG1, error) <span class="cov0" title="0">{
        var e [1]bls12381Impl.Fp
        h2c.HashToField(e[:], bls12381Impl.G1CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveSuiteG1, bytes)

        var s BaseFieldElementG1
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// ElementSize returns the element size in bytes.
func (*BaseFieldG1) ElementSize() int <span class="cov0" title="0">{
        return bls12381Impl.FpBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*BaseFieldG1) WideElementSize() int <span class="cov0" title="0">{
        return bls12381Impl.FpWideBytes
}</span>

// BitLen returns the field modulus bit length.
func (*BaseFieldG1) BitLen() int <span class="cov0" title="0">{
        return bls12381Impl.FpBits
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *BaseFieldG1) FromBytesBEReduce(input []byte) (*BaseFieldElementG1, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        baseFieldOrderG1.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// BaseFieldElementG1 represents an element of the G1 base field.
type BaseFieldElementG1 struct {
        traits.PrimeFieldElementTrait[*bls12381Impl.Fp, bls12381Impl.Fp, *BaseFieldElementG1, BaseFieldElementG1]
}

// Structure returns the algebraic structure for the receiver.
func (*BaseFieldElementG1) Structure() algebra.Structure[*BaseFieldElementG1] <span class="cov0" title="0">{
        return NewG1BaseField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *BaseFieldElementG1) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *BaseFieldElementG1) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("failed to unmarshal field element")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package bls12381

import (
        "encoding"
        "fmt"
        "hash/fnv"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // CurveNameG2 is the G2 curve name.
        CurveNameG2 = "BLS12381G2"
        // Hash2CurveSuiteG2 is the hash-to-curve suite string for G2.
        Hash2CurveSuiteG2 = "BLS12381G2_XMD:SHA-256_SSWU_RO_"
)

var (
        _ curves.Curve[*PointG2, *BaseFieldElementG2, *Scalar]                                                           = (*G2)(nil)
        _ curves.PairingFriendlyCurve[*PointG2, *BaseFieldElementG2, *PointG1, *BaseFieldElementG1, *GtElement, *Scalar] = (*G2)(nil)
        _ curves.Point[*PointG2, *BaseFieldElementG2, *Scalar]                                                           = (*PointG2)(nil)
        _ encoding.BinaryMarshaler                                                                                       = (*PointG2)(nil)
        _ encoding.BinaryUnmarshaler                                                                                     = (*PointG2)(nil)

        curveInstanceG2 *G2
        curveInitOnceG2 sync.Once
)

// G2 represents the BLS12-381 G2 group.
type G2 struct {
        traits.PrimeCurveTrait[*bls12381Impl.Fp2, *bls12381Impl.G2Point, *PointG2, PointG2]
}

// NewG2 returns the BLS12-381 G2 group instance.
func NewG2() *G2 <span class="cov8" title="1">{
        curveInitOnceG2.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for a trait
                curveInstanceG2 = &amp;G2{}
        }</span>)

        <span class="cov8" title="1">return curveInstanceG2</span>
}

// Name returns the name of the structure.
func (*G2) Name() string <span class="cov0" title="0">{
        return CurveNameG2
}</span>

// ElementSize returns the element size in bytes.
func (*G2) ElementSize() int <span class="cov0" title="0">{
        return 2 * bls12381Impl.FpBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*G2) WideElementSize() int <span class="cov0" title="0">{
        return int(^uint(0) &gt;&gt; 1)
}</span>

// FromWideBytes decodes an element from wide bytes.
func (c *G2) FromWideBytes(input []byte) (*PointG2, error) <span class="cov0" title="0">{
        return c.Hash(input)
}</span>

// FromBytes decodes an element from bytes.
func (c *G2) FromBytes(input []byte) (*PointG2, error) <span class="cov0" title="0">{
        return c.FromCompressed(input)
}</span>

// DualStructure returns the dual group structure.
func (*G2) DualStructure() curves.PairingFriendlyCurve[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar] <span class="cov0" title="0">{
        return NewG1()
}</span>

// PairingAlgorithm returns the pairing algorithm identifier.
func (*G2) PairingAlgorithm() curves.PairingAlgorithm <span class="cov0" title="0">{
        return OptimalAteAlgorithm
}</span>

// MultiPair computes a multi-pairing.
func (*G2) MultiPair(these []*PointG2, with []*PointG1) (*GtElement, error) <span class="cov0" title="0">{
        if len(these) != len(with) </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("number of G1 and G2 points must match")
        }</span>

        <span class="cov0" title="0">ppe := NewOptimalAtePPE()

        for i, p2 := range these </span><span class="cov0" title="0">{
                if err := ppe.Add(with[i], p2); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine at index %d", i)
                }</span>
        }
        <span class="cov0" title="0">return ppe.Result(), nil</span>
}

// MultiPairAndInvertDuals computes a multi-pairing and inverts dual points.
func (*G2) MultiPairAndInvertDuals(these []*PointG2, with []*PointG1) (*GtElement, error) <span class="cov0" title="0">{
        if len(these) != len(with) </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("number of G1 and G2 points must match")
        }</span>

        <span class="cov0" title="0">ppe := NewOptimalAtePPE()

        for i, p2 := range these </span><span class="cov0" title="0">{
                if err := ppe.AddAndInvG2(with[i], p2); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine at index %d", i)
                }</span>
        }
        <span class="cov0" title="0">result := ppe.Result()
        return result, nil</span>
}

// Cofactor returns the curve cofactor.
func (*G2) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(1)
}</span>

// Order returns the group or field order.
func (*G2) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder.Nat())
}</span>

// FromCompressed decodes a compressed point.
func (*G2) FromCompressed(input []byte) (*PointG2, error) <span class="cov8" title="1">{
        if len(input) != 2*bls12381Impl.FpBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov8" title="1">var buffer [2 * bls12381Impl.FpBytes]byte
        copy(buffer[:], input)

        result := new(PointG2)
        compressedFlag := ct.Bool((input[0] &gt;&gt; 7) &amp; 1)
        infinityFlag := ct.Bool((input[0] &gt;&gt; 6) &amp; 1)
        sortFlag := ct.Bool((input[0] &gt;&gt; 5) &amp; 1)
        if compressedFlag != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("compressed flag must be set")
        }</span>
        <span class="cov8" title="1">if infinityFlag == 1 </span><span class="cov0" title="0">{
                if sortFlag == 1 </span><span class="cov0" title="0">{
                        return nil, curves.ErrFailed.WithMessage("infinity flag and sort flag are both set")
                }</span>
                // Check that all other bytes are zero when an infinity flag is set
                <span class="cov0" title="0">for i := range input </span><span class="cov0" title="0">{
                        mask := byte(0xff)
                        if i == 0 </span><span class="cov0" title="0">{
                                mask = 0x1f // Ignore the flag bits
                        }</span>
                        <span class="cov0" title="0">if input[i]&amp;mask != 0 </span><span class="cov0" title="0">{
                                return nil, curves.ErrFailed.WithMessage("non-zero x coordinate with infinity flag set")
                        }</span>
                }
                <span class="cov0" title="0">result.V.SetZero()
                return result, nil</span>
        }

        <span class="cov8" title="1">buffer[0] &amp;= 0x1f
        x1Bytes := buffer[:bls12381Impl.FpBytes]
        slices.Reverse(x1Bytes)
        x0Bytes := buffer[bls12381Impl.FpBytes : 2*bls12381Impl.FpBytes]
        slices.Reverse(x0Bytes)

        var x, y, yNeg bls12381Impl.Fp2
        if ok := x.U1.SetBytes(x1Bytes); ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("x is not an Fp2")
        }</span>
        <span class="cov8" title="1">if ok := x.U0.SetBytes(x0Bytes); ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("x is not an Fp2")
        }</span>

        // Recover a y-coordinate given x by y = sqrt(x^3 + 4)
        <span class="cov8" title="1">pp := new(PointG2)
        if wasSquare := pp.V.SetFromAffineX(&amp;x); wasSquare != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not on the curve")
        }</span>
        <span class="cov8" title="1">pp.V.ToAffine(&amp;x, &amp;y)
        yNeg.Neg(&amp;pp.V.Y)
        pp.V.Y.Select(isNegative(&amp;y)^sortFlag, &amp;pp.V.Y, &amp;yNeg)

        if !pp.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not in correct subgroup")
        }</span>
        <span class="cov8" title="1">return pp, nil</span>
}

// FromUncompressed decodes an uncompressed point.
func (*G2) FromUncompressed(input []byte) (*PointG2, error) <span class="cov0" title="0">{
        if len(input) != 4*bls12381Impl.FpBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov0" title="0">var buffer [4 * bls12381Impl.FpBytes]byte
        copy(buffer[:], input)
        pp := new(PointG2)

        infinityFlag := uint64((input[0] &gt;&gt; 6) &amp; 1)
        if infinityFlag == 1 </span><span class="cov0" title="0">{
                pp.V.SetZero()
                return pp, nil
        }</span>

        // Mask away top bits
        <span class="cov0" title="0">buffer[0] &amp;= 0x1f
        x1Bytes := buffer[:bls12381Impl.FpBytes]
        slices.Reverse(x1Bytes)
        x0Bytes := buffer[bls12381Impl.FpBytes : 2*bls12381Impl.FpBytes]
        slices.Reverse(x0Bytes)
        y1Bytes := buffer[2*bls12381Impl.FpBytes : 3*bls12381Impl.FpBytes]
        slices.Reverse(y1Bytes)
        y0Bytes := buffer[3*bls12381Impl.FpBytes:]
        slices.Reverse(y0Bytes)

        var x, y bls12381Impl.Fp2
        if ok := x.U1.SetBytes(x1Bytes); ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("x is not an Fp2")
        }</span>
        <span class="cov0" title="0">if ok := x.U0.SetBytes(x0Bytes); ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("x is not an Fp2")
        }</span>
        <span class="cov0" title="0">if ok := y.U1.SetBytes(y1Bytes); ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("y is not an Fp2")
        }</span>
        <span class="cov0" title="0">if ok := y.U0.SetBytes(y0Bytes); ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("y is not an Fp2")
        }</span>
        <span class="cov0" title="0">if valid := pp.V.SetAffine(&amp;x, &amp;y); valid != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not on the curve")
        }</span>
        <span class="cov0" title="0">if !pp.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is not in correct subgroup")
        }</span>

        <span class="cov0" title="0">return pp, nil</span>
}

// FromAffine builds a point from affine coordinates.
func (*G2) FromAffine(x, y *BaseFieldElementG2) (*PointG2, error) <span class="cov0" title="0">{
        var p PointG2
        ok := p.V.SetAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

// Hash maps input bytes to an element or point.
func (c *G2) Hash(bytes []byte) (*PointG2, error) <span class="cov0" title="0">{
        return c.HashWithDst(base.Hash2CurveAppTag+Hash2CurveSuiteG2, bytes)
}</span>

// HashWithDst maps input bytes to a point with a custom DST.
func (*G2) HashWithDst(dst string, bytes []byte) (*PointG2, error) <span class="cov0" title="0">{
        var p PointG2
        p.V.Hash(dst, bytes)
        return &amp;p, nil
}</span>

// ScalarStructure returns the scalar structure.
func (*G2) ScalarStructure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseStructure returns the base field structure.
func (*G2) BaseStructure() algebra.Structure[*BaseFieldElementG2] <span class="cov0" title="0">{
        return NewG2BaseField()
}</span>

// ScalarRing returns the scalar ring.
func (*G2) ScalarRing() algebra.ZModLike[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// ScalarField returns the scalar field.
func (*G2) ScalarField() algebra.PrimeField[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// BaseField returns the base field.
func (*G2) BaseField() algebra.FiniteField[*BaseFieldElementG2] <span class="cov0" title="0">{
        return NewG2BaseField()
}</span>

// ScalarBaseOp adds a scalar multiple of the generator.
func (c *G2) ScalarBaseOp(sc *Scalar) *PointG2 <span class="cov0" title="0">{
        if sc.IsZero() </span><span class="cov0" title="0">{
                return c.OpIdentity()
        }</span>
        <span class="cov0" title="0">return c.ScalarBaseMul(sc)</span>
}

// ScalarBaseMul multiplies the generator by a scalar.
func (c *G2) ScalarBaseMul(sc *Scalar) *PointG2 <span class="cov0" title="0">{
        return c.Generator().ScalarMul(sc)
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *G2) MultiScalarOp(scalars []*Scalar, points []*PointG2) (*PointG2, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*G2) MultiScalarMul(scalars []*Scalar, points []*PointG2) (*PointG2, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result PointG2
        scs := make([][]byte, len(scalars))
        pts := make([]*bls12381Impl.G2Point, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// PointG2 represents a point in G2.
type PointG2 struct {
        traits.PrimePointTrait[*bls12381Impl.Fp2, *bls12381Impl.G2Point, bls12381Impl.G2Point, *PointG2, PointG2]
}

// InSourceGroup reports whether p is in the source group.
func (*PointG2) InSourceGroup() bool <span class="cov0" title="0">{
        return false
}</span>

// Pair computes the pairing of p and q.
func (p *PointG2) Pair(p1 *PointG1) (*GtElement, error) <span class="cov0" title="0">{
        if p1 == nil </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidArgument.WithMessage("cannot pair with nil G2 point")
        }</span>
        <span class="cov0" title="0">ppe := NewOptimalAtePPE()
        if err := ppe.Add(p1, p); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine")
        }</span>
        <span class="cov0" title="0">return ppe.Result(), nil</span>
}

// MultiPair computes a multi-pairing.
func (p *PointG2) MultiPair(with ...*PointG1) (*GtElement, error) <span class="cov0" title="0">{
        if len(with) == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidArgument.WithMessage("cannot pair with empty G2 points")
        }</span>

        <span class="cov0" title="0">ppe := NewOptimalAtePPE()
        for _, p1 := range with </span><span class="cov0" title="0">{
                if err := ppe.Add(p1, p); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine")
                }</span>
        }
        <span class="cov0" title="0">return ppe.Result(), nil</span>
}

// MultiPairAndInvertDuals computes a multi-pairing and inverts dual points.
func (p *PointG2) MultiPairAndInvertDuals(with ...*PointG1) (*GtElement, error) <span class="cov0" title="0">{
        if len(with) == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidArgument.WithMessage("cannot pair with empty G2 points")
        }</span>

        <span class="cov0" title="0">ppe := NewOptimalAtePPE()
        for _, p1 := range with </span><span class="cov0" title="0">{
                if err := ppe.AddAndInvG2(p1, p); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot add G1 and G2 points to pairing engine")
                }</span>
        }
        <span class="cov0" title="0">return ppe.Result(), nil</span>
}

// HashCode returns a hash code for the receiver.
func (p *PointG2) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(p.ToCompressed())
        return base.HashCode(h.Sum64())
}</span>

// Structure returns the algebraic structure for the receiver.
func (*PointG2) Structure() algebra.Structure[*PointG2] <span class="cov0" title="0">{
        return NewG2()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (p *PointG2) MarshalBinary() (data []byte, err error) <span class="cov0" title="0">{
        return p.ToCompressed(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (p *PointG2) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        pp, err := NewG2().FromCompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}

// ToCompressed encodes the point in compressed form.
func (p *PointG2) ToCompressed() []byte <span class="cov8" title="1">{
        var x, y bls12381Impl.Fp2
        x.SetZero()
        y.SetZero()
        p.V.ToAffine(&amp;x, &amp;y)
        isInfinity := p.V.IsZero()

        x1Bytes := x.U1.Bytes()
        slices.Reverse(x1Bytes)
        x0Bytes := x.U0.Bytes()
        slices.Reverse(x0Bytes)

        out := slices.Concat(x1Bytes, x0Bytes)
        // Compressed flag
        out[0] |= 1 &lt;&lt; 7
        // Is infinity
        out[0] |= byte(isInfinity &lt;&lt; 6)
        // Sign of y only set if not infinity
        out[0] |= byte((isNegative(&amp;y) &amp; (isInfinity ^ 1)) &lt;&lt; 5)
        return out
}</span>

// ToUncompressed encodes the point in uncompressed form.
func (p *PointG2) ToUncompressed() []byte <span class="cov0" title="0">{
        var x, y bls12381Impl.Fp2
        x.SetZero()
        y.SetZero()
        isInfinity := p.V.IsZero()
        p.V.ToAffine(&amp;x, &amp;y)

        x1Bytes := x.U1.Bytes()
        slices.Reverse(x1Bytes[:])
        x0Bytes := x.U0.Bytes()
        slices.Reverse(x0Bytes[:])
        y1Bytes := y.U1.Bytes()
        slices.Reverse(y1Bytes[:])
        y0Bytes := y.U0.Bytes()
        slices.Reverse(y0Bytes[:])

        out := slices.Concat(x1Bytes, x0Bytes, y1Bytes, y0Bytes)
        out[0] |= byte(isInfinity &lt;&lt; 6)
        return out
}</span>

// AffineX returns the affine x-coordinate.
func (p *PointG2) AffineX() (*BaseFieldElementG2, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is at infinity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElementG2
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;x, nil</span>
}

// AffineY returns the affine y-coordinate.
func (p *PointG2) AffineY() (*BaseFieldElementG2, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is at infinity")
        }</span>

        <span class="cov0" title="0">var x, y BaseFieldElementG2
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;y, nil</span>
}

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *PointG2) ScalarOp(sc *Scalar) *PointG2 <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *PointG2) ScalarMul(actor *Scalar) *PointG2 <span class="cov0" title="0">{
        var result PointG2
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (p *PointG2) IsTorsionFree() bool <span class="cov8" title="1">{
        // Ensure scalar field is initialised
        _ = NewScalarField()
        orderBytes := scalarFieldOrder.Bytes()
        slices.Reverse(orderBytes)
        var e bls12381Impl.G2Point
        aimpl.ScalarMulLowLevel(&amp;e, &amp;p.V, orderBytes)
        return e.IsZero() == 1
}</span>

func isNegative(v *bls12381Impl.Fp2) ct.Bool <span class="cov8" title="1">{
        c1Neg := fieldsImpl.IsNegative(&amp;v.U1)
        c0Neg := fieldsImpl.IsNegative(&amp;v.U0)
        c1Zero := v.U1.IsZero()

        return c1Neg | (c1Zero &amp; c0Neg)
}</span>

// Bytes returns the canonical byte encoding.
func (p *PointG2) Bytes() []byte <span class="cov0" title="0">{
        return p.ToCompressed()
}</span>

// String returns the string form of the receiver.
func (p *PointG2) String() string <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return "(0x + 0, 0x + 1, 0x + 0)"
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("(%sx + %s, %sx + %s, %sx + %s)", p.V.X.U1.String(), p.V.X.U0.String(), p.V.Y.U1.String(), p.V.Y.U0.String(), p.V.Z.U1.String(), p.V.Z.U0.String())
        }</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package bls12381

import (
        "encoding"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // BaseFieldNameG2 is the G2 base field name.
        BaseFieldNameG2 = "BLS12381Fp2"
)

var (
        _ algebra.Field[*BaseFieldElementG2]        = (*BaseFieldG2)(nil)
        _ algebra.FieldElement[*BaseFieldElementG2] = (*BaseFieldElementG2)(nil)
        _ encoding.BinaryMarshaler                  = (*BaseFieldElementG2)(nil)
        _ encoding.BinaryUnmarshaler                = (*BaseFieldElementG2)(nil)

        baseFieldInstanceG2 *BaseFieldG2
        baseFieldInitOnceG2 sync.Once
)

// BaseFieldG2 represents the base field for G2.
type BaseFieldG2 struct {
        traits.FiniteFieldTrait[*bls12381Impl.Fp2, *BaseFieldElementG2, BaseFieldElementG2]
}

// NewG2BaseField returns a new instance.
func NewG2BaseField() *BaseFieldG2 <span class="cov8" title="1">{
        baseFieldInitOnceG2.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for a trait
                baseFieldInstanceG2 = &amp;BaseFieldG2{}
        }</span>)

        <span class="cov8" title="1">return baseFieldInstanceG2</span>
}

// Hash maps input bytes to an element or point.
func (*BaseFieldG2) Hash(bytes []byte) (*BaseFieldElementG2, error) <span class="cov0" title="0">{
        var e [1]bls12381Impl.Fp2
        h2c.HashToField(e[:], bls12381Impl.G2CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveSuiteG2, bytes)

        var s BaseFieldElementG2
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// Name returns the name of the structure.
func (*BaseFieldG2) Name() string <span class="cov0" title="0">{
        return BaseFieldNameG2
}</span>

// IsDomain reports whether the field forms an integral domain.
func (*BaseFieldG2) IsDomain() bool <span class="cov0" title="0">{
        return true
}</span>

// Order returns the group or field order.
func (*BaseFieldG2) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewG1BaseField().Order().Add(NewG1BaseField().Order())
}</span>

// Characteristic returns the field characteristic.
func (*BaseFieldG2) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return NewG1BaseField().Characteristic()
}</span>

// ExtensionDegree returns the field extension degree.
func (*BaseFieldG2) ExtensionDegree() uint <span class="cov0" title="0">{
        return 2
}</span>

// FromBytes decodes an element from bytes.
func (f *BaseFieldG2) FromBytes(data []byte) (*BaseFieldElementG2, error) <span class="cov8" title="1">{
        if len(data) != f.ElementSize() </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid data, Length is %d", len(data))
        }</span>
        <span class="cov8" title="1">components := make([][]byte, 2)
        componentSize := f.ElementSize() / 2
        components[0] = data[:componentSize]
        components[1] = data[componentSize:]
        out, err := f.FromComponentsBytes(components)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert bytes into field element")
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// FromWideBytes decodes an element from wide bytes.
func (*BaseFieldG2) FromWideBytes(data []byte) (*BaseFieldElementG2, error) <span class="cov0" title="0">{
        // TODO
        panic("implement me")</span>
}

// ElementSize returns the element size in bytes.
func (*BaseFieldG2) ElementSize() int <span class="cov8" title="1">{
        return 2 * bls12381Impl.FpBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*BaseFieldG2) WideElementSize() int <span class="cov0" title="0">{
        return 2 * bls12381Impl.FpWideBytes
}</span>

// BaseFieldElementG2 represents an element of the G2 base field.
type BaseFieldElementG2 struct {
        traits.FiniteFieldElementTrait[*bls12381Impl.Fp2, bls12381Impl.Fp2, *BaseFieldElementG2, BaseFieldElementG2]
}

// Structure returns the algebraic structure for the receiver.
func (*BaseFieldElementG2) Structure() algebra.Structure[*BaseFieldElementG2] <span class="cov0" title="0">{
        return NewG2BaseField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *BaseFieldElementG2) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        return slices.Concat(fe.V.U1.Bytes(), fe.V.U0.Bytes()), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *BaseFieldElementG2) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.U1.SetBytes(data[:bls12381Impl.FpBytes]); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("invalid data")
        }</span>
        <span class="cov0" title="0">if ok := fe.V.U0.SetBytes(data[bls12381Impl.FpBytes:]); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("invalid data")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package bls12381

import (
        "encoding"
        "hash/fnv"
        "io"
        "iter"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

const (
        // GtName is the target group name.
        GtName = "BLS12381Fp12Mul"
)

var (
        _ algebra.MultiplicativeGroup[*GtElement]        = (*Gt)(nil)
        _ algebra.MultiplicativeGroupElement[*GtElement] = (*GtElement)(nil)
        _ encoding.BinaryMarshaler                       = (*GtElement)(nil)
        _ encoding.BinaryUnmarshaler                     = (*GtElement)(nil)

        gtInstance *Gt
        gtInitOnce sync.Once
)

// Gt represents the BLS12-381 GT group.
type Gt struct{}

// NewGt returns the BLS12-381 GT group instance.
func NewGt() *Gt <span class="cov0" title="0">{
        gtInitOnce.Do(func() </span><span class="cov0" title="0">{
                gtInstance = &amp;Gt{}
        }</span>)
        <span class="cov0" title="0">return gtInstance</span>
}

// Name returns the name of the structure.
func (*Gt) Name() string <span class="cov0" title="0">{
        return GtName
}</span>

// ElementSize returns the element size in bytes.
func (*Gt) ElementSize() int <span class="cov0" title="0">{
        return 96
}</span>

// Order returns the group or field order.
func (*Gt) Order() cardinal.Cardinal <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// Hash maps input bytes to an element or point.
func (*Gt) Hash(bytes []byte) (*GtElement, error) <span class="cov0" title="0">{
        panic("Hashing not implemented for Gt")</span>
}

// Random samples a random element.
func (*Gt) Random(prng io.Reader) (*GtElement, error) <span class="cov0" title="0">{
        panic("Random sampling not implemented for Gt")</span>
}

// Iter returns an iterator over elements.
func (*Gt) Iter() iter.Seq[*GtElement] <span class="cov0" title="0">{
        panic("implement me")</span>
}

// One returns the multiplicative identity.
func (*Gt) One() *GtElement <span class="cov0" title="0">{
        var one GtElement
        one.V.SetOne()
        return &amp;one
}</span>

// OpIdentity returns the group identity.
func (g *Gt) OpIdentity() *GtElement <span class="cov0" title="0">{
        return g.One()
}</span>

// FromBytes decodes an element from bytes.
func (*Gt) FromBytes(inBytes []byte) (*GtElement, error) <span class="cov0" title="0">{
        if len(inBytes) != 96 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("input must be 96 bytes long")
        }</span>

        <span class="cov0" title="0">var element GtElement
        if ok := element.V.SetUniformBytes(inBytes); ok == 0 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("failed to set bytes")
        }</span>

        <span class="cov0" title="0">return &amp;element, nil</span>
}

// GtElement represents an element of the target group.
type GtElement struct {
        V bls12381Impl.Gt
}

// Clone returns a copy of the element.
func (ge *GtElement) Clone() *GtElement <span class="cov0" title="0">{
        var clone GtElement
        clone.V.Set(&amp;ge.V.Fp12)
        return &amp;clone
}</span>

// Equal reports whether the receiver equals v.
func (ge *GtElement) Equal(rhs *GtElement) bool <span class="cov0" title="0">{
        return ge.V.Equal(&amp;rhs.V.Fp12) == 1
}</span>

// HashCode returns a hash code for the receiver.
func (ge *GtElement) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(ge.V.Bytes())
        return base.HashCode(h.Sum64())
}</span>

// Bytes returns the canonical byte encoding.
func (ge *GtElement) Bytes() []byte <span class="cov0" title="0">{
        return ge.V.Bytes()
}</span>

// Structure returns the algebraic structure for the receiver.
func (*GtElement) Structure() algebra.Structure[*GtElement] <span class="cov0" title="0">{
        return NewGt()
}</span>

// Mul sets the receiver to lhs * rhs.
func (ge *GtElement) Mul(e *GtElement) *GtElement <span class="cov0" title="0">{
        var product GtElement
        product.V.Mul(&amp;ge.V.Fp12, &amp;e.V.Fp12)
        return &amp;product
}</span>

// Square sets the receiver to v^2.
func (ge *GtElement) Square() *GtElement <span class="cov0" title="0">{
        var square GtElement
        square.V.Square(&amp;ge.V.Fp12)
        return &amp;square
}</span>

// IsOne reports whether the receiver is one.
func (ge *GtElement) IsOne() bool <span class="cov0" title="0">{
        return ge.V.IsOne() == 1
}</span>

// Inv sets the receiver to the inverse of a, if it exists.
func (ge *GtElement) Inv() *GtElement <span class="cov0" title="0">{
        var inv GtElement
        _ = inv.V.Inv(&amp;ge.V.Fp12)
        return &amp;inv
}</span>

// Div sets the receiver to lhs / rhs, if rhs is nonzero.
func (ge *GtElement) Div(e *GtElement) *GtElement <span class="cov0" title="0">{
        var quotient GtElement
        _ = quotient.V.Div(&amp;ge.V.Fp12, &amp;e.V.Fp12)
        return &amp;quotient
}</span>

// TryInv returns the multiplicative inverse.
func (ge *GtElement) TryInv() (*GtElement, error) <span class="cov0" title="0">{
        return ge.Inv(), nil
}</span>

// TryDiv divides by the given element.
func (ge *GtElement) TryDiv(e *GtElement) (*GtElement, error) <span class="cov0" title="0">{
        return ge.Div(e), nil
}</span>

// Op applies the group operation.
func (ge *GtElement) Op(e *GtElement) *GtElement <span class="cov0" title="0">{
        return ge.Mul(e)
}</span>

// IsOpIdentity reports whether the element is the identity.
func (ge *GtElement) IsOpIdentity() bool <span class="cov0" title="0">{
        return ge.IsOne()
}</span>

// TryOpInv returns the group inverse.
func (ge *GtElement) TryOpInv() (*GtElement, error) <span class="cov0" title="0">{
        return ge.OpInv(), nil
}</span>

// OpInv returns the group inverse.
func (ge *GtElement) OpInv() *GtElement <span class="cov0" title="0">{
        return ge.Inv()
}</span>

// String returns the string form of the receiver.
func (*GtElement) String() string <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// MarshalBinary implements encoding.BinaryMarshaler.
func (ge *GtElement) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        return ge.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (ge *GtElement) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        pp, err := NewGt().FromBytes(data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot decode element")
        }</span>
        <span class="cov0" title="0">ge.V.Set(&amp;pp.V.Fp12)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fp 64 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
//
// curve description: Fp
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab (from "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) + (z[4] &lt;&lt; 256) + (z[5] &lt;&lt; 0x140)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248) + (z[32] &lt;&lt; 256) + (z[33] &lt;&lt; 0x108) + (z[34] &lt;&lt; 0x110) + (z[35] &lt;&lt; 0x118) + (z[36] &lt;&lt; 0x120) + (z[37] &lt;&lt; 0x128) + (z[38] &lt;&lt; 0x130) + (z[39] &lt;&lt; 0x138) + (z[40] &lt;&lt; 0x140) + (z[41] &lt;&lt; 0x148) + (z[42] &lt;&lt; 0x150) + (z[43] &lt;&lt; 0x158) + (z[44] &lt;&lt; 0x160) + (z[45] &lt;&lt; 0x168) + (z[46] &lt;&lt; 0x170) + (z[47] &lt;&lt; 0x178)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) + (z[4] &lt;&lt; 256) + (z[5] &lt;&lt; 0x140) in
//
//                            if x1 &amp; (2^384-1) &lt; 2^383 then x1 &amp; (2^384-1) else (x1 &amp; (2^384-1)) - 2^384
package impl

import "math/bits"

type fiatFpUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFpInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFpMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFpMontgomeryDomainFieldElement [6]uint64

// fiatFpNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFpNonMontgomeryDomainFieldElement [6]uint64

// fiatFpCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpCmovznzU64(out1 *uint64, arg1 fiatFpUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFpMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpMul(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[4]
        x5 := arg1[5]
        x6 := arg1[0]
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x6, arg2[5])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x6, arg2[4])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x6, arg2[3])
        var x13 uint64
        var x14 uint64
        x14, x13 = bits.Mul64(x6, arg2[2])
        var x15 uint64
        var x16 uint64
        x16, x15 = bits.Mul64(x6, arg2[1])
        var x17 uint64
        var x18 uint64
        x18, x17 = bits.Mul64(x6, arg2[0])
        var x19 uint64
        var x20 uint64
        x19, x20 = bits.Add64(x18, x15, uint64(0x0))
        var x21 uint64
        var x22 uint64
        x21, x22 = bits.Add64(x16, x13, uint64(fiatFpUint1(x20)))
        var x23 uint64
        var x24 uint64
        x23, x24 = bits.Add64(x14, x11, uint64(fiatFpUint1(x22)))
        var x25 uint64
        var x26 uint64
        x25, x26 = bits.Add64(x12, x9, uint64(fiatFpUint1(x24)))
        var x27 uint64
        var x28 uint64
        x27, x28 = bits.Add64(x10, x7, uint64(fiatFpUint1(x26)))
        x29 := (uint64(fiatFpUint1(x28)) + x8)
        var x30 uint64
        _, x30 = bits.Mul64(x17, 0x89f3fffcfffcfffd)
        var x32 uint64
        var x33 uint64
        x33, x32 = bits.Mul64(x30, 0x1a0111ea397fe69a)
        var x34 uint64
        var x35 uint64
        x35, x34 = bits.Mul64(x30, 0x4b1ba7b6434bacd7)
        var x36 uint64
        var x37 uint64
        x37, x36 = bits.Mul64(x30, 0x64774b84f38512bf)
        var x38 uint64
        var x39 uint64
        x39, x38 = bits.Mul64(x30, 0x6730d2a0f6b0f624)
        var x40 uint64
        var x41 uint64
        x41, x40 = bits.Mul64(x30, 0x1eabfffeb153ffff)
        var x42 uint64
        var x43 uint64
        x43, x42 = bits.Mul64(x30, 0xb9feffffffffaaab)
        var x44 uint64
        var x45 uint64
        x44, x45 = bits.Add64(x43, x40, uint64(0x0))
        var x46 uint64
        var x47 uint64
        x46, x47 = bits.Add64(x41, x38, uint64(fiatFpUint1(x45)))
        var x48 uint64
        var x49 uint64
        x48, x49 = bits.Add64(x39, x36, uint64(fiatFpUint1(x47)))
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x37, x34, uint64(fiatFpUint1(x49)))
        var x52 uint64
        var x53 uint64
        x52, x53 = bits.Add64(x35, x32, uint64(fiatFpUint1(x51)))
        x54 := (uint64(fiatFpUint1(x53)) + x33)
        var x56 uint64
        _, x56 = bits.Add64(x17, x42, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x19, x44, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x21, x46, uint64(fiatFpUint1(x58)))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Add64(x23, x48, uint64(fiatFpUint1(x60)))
        var x63 uint64
        var x64 uint64
        x63, x64 = bits.Add64(x25, x50, uint64(fiatFpUint1(x62)))
        var x65 uint64
        var x66 uint64
        x65, x66 = bits.Add64(x27, x52, uint64(fiatFpUint1(x64)))
        var x67 uint64
        var x68 uint64
        x67, x68 = bits.Add64(x29, x54, uint64(fiatFpUint1(x66)))
        var x69 uint64
        var x70 uint64
        x70, x69 = bits.Mul64(x1, arg2[5])
        var x71 uint64
        var x72 uint64
        x72, x71 = bits.Mul64(x1, arg2[4])
        var x73 uint64
        var x74 uint64
        x74, x73 = bits.Mul64(x1, arg2[3])
        var x75 uint64
        var x76 uint64
        x76, x75 = bits.Mul64(x1, arg2[2])
        var x77 uint64
        var x78 uint64
        x78, x77 = bits.Mul64(x1, arg2[1])
        var x79 uint64
        var x80 uint64
        x80, x79 = bits.Mul64(x1, arg2[0])
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x80, x77, uint64(0x0))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x78, x75, uint64(fiatFpUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x76, x73, uint64(fiatFpUint1(x84)))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x74, x71, uint64(fiatFpUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x72, x69, uint64(fiatFpUint1(x88)))
        x91 := (uint64(fiatFpUint1(x90)) + x70)
        var x92 uint64
        var x93 uint64
        x92, x93 = bits.Add64(x57, x79, uint64(0x0))
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x59, x81, uint64(fiatFpUint1(x93)))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x61, x83, uint64(fiatFpUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x63, x85, uint64(fiatFpUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x65, x87, uint64(fiatFpUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Add64(x67, x89, uint64(fiatFpUint1(x101)))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Add64(uint64(fiatFpUint1(x68)), x91, uint64(fiatFpUint1(x103)))
        var x106 uint64
        _, x106 = bits.Mul64(x92, 0x89f3fffcfffcfffd)
        var x108 uint64
        var x109 uint64
        x109, x108 = bits.Mul64(x106, 0x1a0111ea397fe69a)
        var x110 uint64
        var x111 uint64
        x111, x110 = bits.Mul64(x106, 0x4b1ba7b6434bacd7)
        var x112 uint64
        var x113 uint64
        x113, x112 = bits.Mul64(x106, 0x64774b84f38512bf)
        var x114 uint64
        var x115 uint64
        x115, x114 = bits.Mul64(x106, 0x6730d2a0f6b0f624)
        var x116 uint64
        var x117 uint64
        x117, x116 = bits.Mul64(x106, 0x1eabfffeb153ffff)
        var x118 uint64
        var x119 uint64
        x119, x118 = bits.Mul64(x106, 0xb9feffffffffaaab)
        var x120 uint64
        var x121 uint64
        x120, x121 = bits.Add64(x119, x116, uint64(0x0))
        var x122 uint64
        var x123 uint64
        x122, x123 = bits.Add64(x117, x114, uint64(fiatFpUint1(x121)))
        var x124 uint64
        var x125 uint64
        x124, x125 = bits.Add64(x115, x112, uint64(fiatFpUint1(x123)))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x113, x110, uint64(fiatFpUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64(x111, x108, uint64(fiatFpUint1(x127)))
        x130 := (uint64(fiatFpUint1(x129)) + x109)
        var x132 uint64
        _, x132 = bits.Add64(x92, x118, uint64(0x0))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x94, x120, uint64(fiatFpUint1(x132)))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x96, x122, uint64(fiatFpUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x98, x124, uint64(fiatFpUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x100, x126, uint64(fiatFpUint1(x138)))
        var x141 uint64
        var x142 uint64
        x141, x142 = bits.Add64(x102, x128, uint64(fiatFpUint1(x140)))
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x104, x130, uint64(fiatFpUint1(x142)))
        x145 := (uint64(fiatFpUint1(x144)) + uint64(fiatFpUint1(x105)))
        var x146 uint64
        var x147 uint64
        x147, x146 = bits.Mul64(x2, arg2[5])
        var x148 uint64
        var x149 uint64
        x149, x148 = bits.Mul64(x2, arg2[4])
        var x150 uint64
        var x151 uint64
        x151, x150 = bits.Mul64(x2, arg2[3])
        var x152 uint64
        var x153 uint64
        x153, x152 = bits.Mul64(x2, arg2[2])
        var x154 uint64
        var x155 uint64
        x155, x154 = bits.Mul64(x2, arg2[1])
        var x156 uint64
        var x157 uint64
        x157, x156 = bits.Mul64(x2, arg2[0])
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x157, x154, uint64(0x0))
        var x160 uint64
        var x161 uint64
        x160, x161 = bits.Add64(x155, x152, uint64(fiatFpUint1(x159)))
        var x162 uint64
        var x163 uint64
        x162, x163 = bits.Add64(x153, x150, uint64(fiatFpUint1(x161)))
        var x164 uint64
        var x165 uint64
        x164, x165 = bits.Add64(x151, x148, uint64(fiatFpUint1(x163)))
        var x166 uint64
        var x167 uint64
        x166, x167 = bits.Add64(x149, x146, uint64(fiatFpUint1(x165)))
        x168 := (uint64(fiatFpUint1(x167)) + x147)
        var x169 uint64
        var x170 uint64
        x169, x170 = bits.Add64(x133, x156, uint64(0x0))
        var x171 uint64
        var x172 uint64
        x171, x172 = bits.Add64(x135, x158, uint64(fiatFpUint1(x170)))
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x137, x160, uint64(fiatFpUint1(x172)))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x139, x162, uint64(fiatFpUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x141, x164, uint64(fiatFpUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x143, x166, uint64(fiatFpUint1(x178)))
        var x181 uint64
        var x182 uint64
        x181, x182 = bits.Add64(x145, x168, uint64(fiatFpUint1(x180)))
        var x183 uint64
        _, x183 = bits.Mul64(x169, 0x89f3fffcfffcfffd)
        var x185 uint64
        var x186 uint64
        x186, x185 = bits.Mul64(x183, 0x1a0111ea397fe69a)
        var x187 uint64
        var x188 uint64
        x188, x187 = bits.Mul64(x183, 0x4b1ba7b6434bacd7)
        var x189 uint64
        var x190 uint64
        x190, x189 = bits.Mul64(x183, 0x64774b84f38512bf)
        var x191 uint64
        var x192 uint64
        x192, x191 = bits.Mul64(x183, 0x6730d2a0f6b0f624)
        var x193 uint64
        var x194 uint64
        x194, x193 = bits.Mul64(x183, 0x1eabfffeb153ffff)
        var x195 uint64
        var x196 uint64
        x196, x195 = bits.Mul64(x183, 0xb9feffffffffaaab)
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x196, x193, uint64(0x0))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x194, x191, uint64(fiatFpUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x192, x189, uint64(fiatFpUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x190, x187, uint64(fiatFpUint1(x202)))
        var x205 uint64
        var x206 uint64
        x205, x206 = bits.Add64(x188, x185, uint64(fiatFpUint1(x204)))
        x207 := (uint64(fiatFpUint1(x206)) + x186)
        var x209 uint64
        _, x209 = bits.Add64(x169, x195, uint64(0x0))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Add64(x171, x197, uint64(fiatFpUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Add64(x173, x199, uint64(fiatFpUint1(x211)))
        var x214 uint64
        var x215 uint64
        x214, x215 = bits.Add64(x175, x201, uint64(fiatFpUint1(x213)))
        var x216 uint64
        var x217 uint64
        x216, x217 = bits.Add64(x177, x203, uint64(fiatFpUint1(x215)))
        var x218 uint64
        var x219 uint64
        x218, x219 = bits.Add64(x179, x205, uint64(fiatFpUint1(x217)))
        var x220 uint64
        var x221 uint64
        x220, x221 = bits.Add64(x181, x207, uint64(fiatFpUint1(x219)))
        x222 := (uint64(fiatFpUint1(x221)) + uint64(fiatFpUint1(x182)))
        var x223 uint64
        var x224 uint64
        x224, x223 = bits.Mul64(x3, arg2[5])
        var x225 uint64
        var x226 uint64
        x226, x225 = bits.Mul64(x3, arg2[4])
        var x227 uint64
        var x228 uint64
        x228, x227 = bits.Mul64(x3, arg2[3])
        var x229 uint64
        var x230 uint64
        x230, x229 = bits.Mul64(x3, arg2[2])
        var x231 uint64
        var x232 uint64
        x232, x231 = bits.Mul64(x3, arg2[1])
        var x233 uint64
        var x234 uint64
        x234, x233 = bits.Mul64(x3, arg2[0])
        var x235 uint64
        var x236 uint64
        x235, x236 = bits.Add64(x234, x231, uint64(0x0))
        var x237 uint64
        var x238 uint64
        x237, x238 = bits.Add64(x232, x229, uint64(fiatFpUint1(x236)))
        var x239 uint64
        var x240 uint64
        x239, x240 = bits.Add64(x230, x227, uint64(fiatFpUint1(x238)))
        var x241 uint64
        var x242 uint64
        x241, x242 = bits.Add64(x228, x225, uint64(fiatFpUint1(x240)))
        var x243 uint64
        var x244 uint64
        x243, x244 = bits.Add64(x226, x223, uint64(fiatFpUint1(x242)))
        x245 := (uint64(fiatFpUint1(x244)) + x224)
        var x246 uint64
        var x247 uint64
        x246, x247 = bits.Add64(x210, x233, uint64(0x0))
        var x248 uint64
        var x249 uint64
        x248, x249 = bits.Add64(x212, x235, uint64(fiatFpUint1(x247)))
        var x250 uint64
        var x251 uint64
        x250, x251 = bits.Add64(x214, x237, uint64(fiatFpUint1(x249)))
        var x252 uint64
        var x253 uint64
        x252, x253 = bits.Add64(x216, x239, uint64(fiatFpUint1(x251)))
        var x254 uint64
        var x255 uint64
        x254, x255 = bits.Add64(x218, x241, uint64(fiatFpUint1(x253)))
        var x256 uint64
        var x257 uint64
        x256, x257 = bits.Add64(x220, x243, uint64(fiatFpUint1(x255)))
        var x258 uint64
        var x259 uint64
        x258, x259 = bits.Add64(x222, x245, uint64(fiatFpUint1(x257)))
        var x260 uint64
        _, x260 = bits.Mul64(x246, 0x89f3fffcfffcfffd)
        var x262 uint64
        var x263 uint64
        x263, x262 = bits.Mul64(x260, 0x1a0111ea397fe69a)
        var x264 uint64
        var x265 uint64
        x265, x264 = bits.Mul64(x260, 0x4b1ba7b6434bacd7)
        var x266 uint64
        var x267 uint64
        x267, x266 = bits.Mul64(x260, 0x64774b84f38512bf)
        var x268 uint64
        var x269 uint64
        x269, x268 = bits.Mul64(x260, 0x6730d2a0f6b0f624)
        var x270 uint64
        var x271 uint64
        x271, x270 = bits.Mul64(x260, 0x1eabfffeb153ffff)
        var x272 uint64
        var x273 uint64
        x273, x272 = bits.Mul64(x260, 0xb9feffffffffaaab)
        var x274 uint64
        var x275 uint64
        x274, x275 = bits.Add64(x273, x270, uint64(0x0))
        var x276 uint64
        var x277 uint64
        x276, x277 = bits.Add64(x271, x268, uint64(fiatFpUint1(x275)))
        var x278 uint64
        var x279 uint64
        x278, x279 = bits.Add64(x269, x266, uint64(fiatFpUint1(x277)))
        var x280 uint64
        var x281 uint64
        x280, x281 = bits.Add64(x267, x264, uint64(fiatFpUint1(x279)))
        var x282 uint64
        var x283 uint64
        x282, x283 = bits.Add64(x265, x262, uint64(fiatFpUint1(x281)))
        x284 := (uint64(fiatFpUint1(x283)) + x263)
        var x286 uint64
        _, x286 = bits.Add64(x246, x272, uint64(0x0))
        var x287 uint64
        var x288 uint64
        x287, x288 = bits.Add64(x248, x274, uint64(fiatFpUint1(x286)))
        var x289 uint64
        var x290 uint64
        x289, x290 = bits.Add64(x250, x276, uint64(fiatFpUint1(x288)))
        var x291 uint64
        var x292 uint64
        x291, x292 = bits.Add64(x252, x278, uint64(fiatFpUint1(x290)))
        var x293 uint64
        var x294 uint64
        x293, x294 = bits.Add64(x254, x280, uint64(fiatFpUint1(x292)))
        var x295 uint64
        var x296 uint64
        x295, x296 = bits.Add64(x256, x282, uint64(fiatFpUint1(x294)))
        var x297 uint64
        var x298 uint64
        x297, x298 = bits.Add64(x258, x284, uint64(fiatFpUint1(x296)))
        x299 := (uint64(fiatFpUint1(x298)) + uint64(fiatFpUint1(x259)))
        var x300 uint64
        var x301 uint64
        x301, x300 = bits.Mul64(x4, arg2[5])
        var x302 uint64
        var x303 uint64
        x303, x302 = bits.Mul64(x4, arg2[4])
        var x304 uint64
        var x305 uint64
        x305, x304 = bits.Mul64(x4, arg2[3])
        var x306 uint64
        var x307 uint64
        x307, x306 = bits.Mul64(x4, arg2[2])
        var x308 uint64
        var x309 uint64
        x309, x308 = bits.Mul64(x4, arg2[1])
        var x310 uint64
        var x311 uint64
        x311, x310 = bits.Mul64(x4, arg2[0])
        var x312 uint64
        var x313 uint64
        x312, x313 = bits.Add64(x311, x308, uint64(0x0))
        var x314 uint64
        var x315 uint64
        x314, x315 = bits.Add64(x309, x306, uint64(fiatFpUint1(x313)))
        var x316 uint64
        var x317 uint64
        x316, x317 = bits.Add64(x307, x304, uint64(fiatFpUint1(x315)))
        var x318 uint64
        var x319 uint64
        x318, x319 = bits.Add64(x305, x302, uint64(fiatFpUint1(x317)))
        var x320 uint64
        var x321 uint64
        x320, x321 = bits.Add64(x303, x300, uint64(fiatFpUint1(x319)))
        x322 := (uint64(fiatFpUint1(x321)) + x301)
        var x323 uint64
        var x324 uint64
        x323, x324 = bits.Add64(x287, x310, uint64(0x0))
        var x325 uint64
        var x326 uint64
        x325, x326 = bits.Add64(x289, x312, uint64(fiatFpUint1(x324)))
        var x327 uint64
        var x328 uint64
        x327, x328 = bits.Add64(x291, x314, uint64(fiatFpUint1(x326)))
        var x329 uint64
        var x330 uint64
        x329, x330 = bits.Add64(x293, x316, uint64(fiatFpUint1(x328)))
        var x331 uint64
        var x332 uint64
        x331, x332 = bits.Add64(x295, x318, uint64(fiatFpUint1(x330)))
        var x333 uint64
        var x334 uint64
        x333, x334 = bits.Add64(x297, x320, uint64(fiatFpUint1(x332)))
        var x335 uint64
        var x336 uint64
        x335, x336 = bits.Add64(x299, x322, uint64(fiatFpUint1(x334)))
        var x337 uint64
        _, x337 = bits.Mul64(x323, 0x89f3fffcfffcfffd)
        var x339 uint64
        var x340 uint64
        x340, x339 = bits.Mul64(x337, 0x1a0111ea397fe69a)
        var x341 uint64
        var x342 uint64
        x342, x341 = bits.Mul64(x337, 0x4b1ba7b6434bacd7)
        var x343 uint64
        var x344 uint64
        x344, x343 = bits.Mul64(x337, 0x64774b84f38512bf)
        var x345 uint64
        var x346 uint64
        x346, x345 = bits.Mul64(x337, 0x6730d2a0f6b0f624)
        var x347 uint64
        var x348 uint64
        x348, x347 = bits.Mul64(x337, 0x1eabfffeb153ffff)
        var x349 uint64
        var x350 uint64
        x350, x349 = bits.Mul64(x337, 0xb9feffffffffaaab)
        var x351 uint64
        var x352 uint64
        x351, x352 = bits.Add64(x350, x347, uint64(0x0))
        var x353 uint64
        var x354 uint64
        x353, x354 = bits.Add64(x348, x345, uint64(fiatFpUint1(x352)))
        var x355 uint64
        var x356 uint64
        x355, x356 = bits.Add64(x346, x343, uint64(fiatFpUint1(x354)))
        var x357 uint64
        var x358 uint64
        x357, x358 = bits.Add64(x344, x341, uint64(fiatFpUint1(x356)))
        var x359 uint64
        var x360 uint64
        x359, x360 = bits.Add64(x342, x339, uint64(fiatFpUint1(x358)))
        x361 := (uint64(fiatFpUint1(x360)) + x340)
        var x363 uint64
        _, x363 = bits.Add64(x323, x349, uint64(0x0))
        var x364 uint64
        var x365 uint64
        x364, x365 = bits.Add64(x325, x351, uint64(fiatFpUint1(x363)))
        var x366 uint64
        var x367 uint64
        x366, x367 = bits.Add64(x327, x353, uint64(fiatFpUint1(x365)))
        var x368 uint64
        var x369 uint64
        x368, x369 = bits.Add64(x329, x355, uint64(fiatFpUint1(x367)))
        var x370 uint64
        var x371 uint64
        x370, x371 = bits.Add64(x331, x357, uint64(fiatFpUint1(x369)))
        var x372 uint64
        var x373 uint64
        x372, x373 = bits.Add64(x333, x359, uint64(fiatFpUint1(x371)))
        var x374 uint64
        var x375 uint64
        x374, x375 = bits.Add64(x335, x361, uint64(fiatFpUint1(x373)))
        x376 := (uint64(fiatFpUint1(x375)) + uint64(fiatFpUint1(x336)))
        var x377 uint64
        var x378 uint64
        x378, x377 = bits.Mul64(x5, arg2[5])
        var x379 uint64
        var x380 uint64
        x380, x379 = bits.Mul64(x5, arg2[4])
        var x381 uint64
        var x382 uint64
        x382, x381 = bits.Mul64(x5, arg2[3])
        var x383 uint64
        var x384 uint64
        x384, x383 = bits.Mul64(x5, arg2[2])
        var x385 uint64
        var x386 uint64
        x386, x385 = bits.Mul64(x5, arg2[1])
        var x387 uint64
        var x388 uint64
        x388, x387 = bits.Mul64(x5, arg2[0])
        var x389 uint64
        var x390 uint64
        x389, x390 = bits.Add64(x388, x385, uint64(0x0))
        var x391 uint64
        var x392 uint64
        x391, x392 = bits.Add64(x386, x383, uint64(fiatFpUint1(x390)))
        var x393 uint64
        var x394 uint64
        x393, x394 = bits.Add64(x384, x381, uint64(fiatFpUint1(x392)))
        var x395 uint64
        var x396 uint64
        x395, x396 = bits.Add64(x382, x379, uint64(fiatFpUint1(x394)))
        var x397 uint64
        var x398 uint64
        x397, x398 = bits.Add64(x380, x377, uint64(fiatFpUint1(x396)))
        x399 := (uint64(fiatFpUint1(x398)) + x378)
        var x400 uint64
        var x401 uint64
        x400, x401 = bits.Add64(x364, x387, uint64(0x0))
        var x402 uint64
        var x403 uint64
        x402, x403 = bits.Add64(x366, x389, uint64(fiatFpUint1(x401)))
        var x404 uint64
        var x405 uint64
        x404, x405 = bits.Add64(x368, x391, uint64(fiatFpUint1(x403)))
        var x406 uint64
        var x407 uint64
        x406, x407 = bits.Add64(x370, x393, uint64(fiatFpUint1(x405)))
        var x408 uint64
        var x409 uint64
        x408, x409 = bits.Add64(x372, x395, uint64(fiatFpUint1(x407)))
        var x410 uint64
        var x411 uint64
        x410, x411 = bits.Add64(x374, x397, uint64(fiatFpUint1(x409)))
        var x412 uint64
        var x413 uint64
        x412, x413 = bits.Add64(x376, x399, uint64(fiatFpUint1(x411)))
        var x414 uint64
        _, x414 = bits.Mul64(x400, 0x89f3fffcfffcfffd)
        var x416 uint64
        var x417 uint64
        x417, x416 = bits.Mul64(x414, 0x1a0111ea397fe69a)
        var x418 uint64
        var x419 uint64
        x419, x418 = bits.Mul64(x414, 0x4b1ba7b6434bacd7)
        var x420 uint64
        var x421 uint64
        x421, x420 = bits.Mul64(x414, 0x64774b84f38512bf)
        var x422 uint64
        var x423 uint64
        x423, x422 = bits.Mul64(x414, 0x6730d2a0f6b0f624)
        var x424 uint64
        var x425 uint64
        x425, x424 = bits.Mul64(x414, 0x1eabfffeb153ffff)
        var x426 uint64
        var x427 uint64
        x427, x426 = bits.Mul64(x414, 0xb9feffffffffaaab)
        var x428 uint64
        var x429 uint64
        x428, x429 = bits.Add64(x427, x424, uint64(0x0))
        var x430 uint64
        var x431 uint64
        x430, x431 = bits.Add64(x425, x422, uint64(fiatFpUint1(x429)))
        var x432 uint64
        var x433 uint64
        x432, x433 = bits.Add64(x423, x420, uint64(fiatFpUint1(x431)))
        var x434 uint64
        var x435 uint64
        x434, x435 = bits.Add64(x421, x418, uint64(fiatFpUint1(x433)))
        var x436 uint64
        var x437 uint64
        x436, x437 = bits.Add64(x419, x416, uint64(fiatFpUint1(x435)))
        x438 := (uint64(fiatFpUint1(x437)) + x417)
        var x440 uint64
        _, x440 = bits.Add64(x400, x426, uint64(0x0))
        var x441 uint64
        var x442 uint64
        x441, x442 = bits.Add64(x402, x428, uint64(fiatFpUint1(x440)))
        var x443 uint64
        var x444 uint64
        x443, x444 = bits.Add64(x404, x430, uint64(fiatFpUint1(x442)))
        var x445 uint64
        var x446 uint64
        x445, x446 = bits.Add64(x406, x432, uint64(fiatFpUint1(x444)))
        var x447 uint64
        var x448 uint64
        x447, x448 = bits.Add64(x408, x434, uint64(fiatFpUint1(x446)))
        var x449 uint64
        var x450 uint64
        x449, x450 = bits.Add64(x410, x436, uint64(fiatFpUint1(x448)))
        var x451 uint64
        var x452 uint64
        x451, x452 = bits.Add64(x412, x438, uint64(fiatFpUint1(x450)))
        x453 := (uint64(fiatFpUint1(x452)) + uint64(fiatFpUint1(x413)))
        var x454 uint64
        var x455 uint64
        x454, x455 = bits.Sub64(x441, 0xb9feffffffffaaab, uint64(0x0))
        var x456 uint64
        var x457 uint64
        x456, x457 = bits.Sub64(x443, 0x1eabfffeb153ffff, uint64(fiatFpUint1(x455)))
        var x458 uint64
        var x459 uint64
        x458, x459 = bits.Sub64(x445, 0x6730d2a0f6b0f624, uint64(fiatFpUint1(x457)))
        var x460 uint64
        var x461 uint64
        x460, x461 = bits.Sub64(x447, 0x64774b84f38512bf, uint64(fiatFpUint1(x459)))
        var x462 uint64
        var x463 uint64
        x462, x463 = bits.Sub64(x449, 0x4b1ba7b6434bacd7, uint64(fiatFpUint1(x461)))
        var x464 uint64
        var x465 uint64
        x464, x465 = bits.Sub64(x451, 0x1a0111ea397fe69a, uint64(fiatFpUint1(x463)))
        var x467 uint64
        _, x467 = bits.Sub64(x453, uint64(0x0), uint64(fiatFpUint1(x465)))
        var x468 uint64
        fiatFpCmovznzU64(&amp;x468, fiatFpUint1(x467), x454, x441)
        var x469 uint64
        fiatFpCmovznzU64(&amp;x469, fiatFpUint1(x467), x456, x443)
        var x470 uint64
        fiatFpCmovznzU64(&amp;x470, fiatFpUint1(x467), x458, x445)
        var x471 uint64
        fiatFpCmovznzU64(&amp;x471, fiatFpUint1(x467), x460, x447)
        var x472 uint64
        fiatFpCmovznzU64(&amp;x472, fiatFpUint1(x467), x462, x449)
        var x473 uint64
        fiatFpCmovznzU64(&amp;x473, fiatFpUint1(x467), x464, x451)
        out1[0] = x468
        out1[1] = x469
        out1[2] = x470
        out1[3] = x471
        out1[4] = x472
        out1[5] = x473
}</span>

// fiatFpSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFpSquare(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[4]
        x5 := arg1[5]
        x6 := arg1[0]
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x6, arg1[5])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x6, arg1[4])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x6, arg1[3])
        var x13 uint64
        var x14 uint64
        x14, x13 = bits.Mul64(x6, arg1[2])
        var x15 uint64
        var x16 uint64
        x16, x15 = bits.Mul64(x6, arg1[1])
        var x17 uint64
        var x18 uint64
        x18, x17 = bits.Mul64(x6, arg1[0])
        var x19 uint64
        var x20 uint64
        x19, x20 = bits.Add64(x18, x15, uint64(0x0))
        var x21 uint64
        var x22 uint64
        x21, x22 = bits.Add64(x16, x13, uint64(fiatFpUint1(x20)))
        var x23 uint64
        var x24 uint64
        x23, x24 = bits.Add64(x14, x11, uint64(fiatFpUint1(x22)))
        var x25 uint64
        var x26 uint64
        x25, x26 = bits.Add64(x12, x9, uint64(fiatFpUint1(x24)))
        var x27 uint64
        var x28 uint64
        x27, x28 = bits.Add64(x10, x7, uint64(fiatFpUint1(x26)))
        x29 := (uint64(fiatFpUint1(x28)) + x8)
        var x30 uint64
        _, x30 = bits.Mul64(x17, 0x89f3fffcfffcfffd)
        var x32 uint64
        var x33 uint64
        x33, x32 = bits.Mul64(x30, 0x1a0111ea397fe69a)
        var x34 uint64
        var x35 uint64
        x35, x34 = bits.Mul64(x30, 0x4b1ba7b6434bacd7)
        var x36 uint64
        var x37 uint64
        x37, x36 = bits.Mul64(x30, 0x64774b84f38512bf)
        var x38 uint64
        var x39 uint64
        x39, x38 = bits.Mul64(x30, 0x6730d2a0f6b0f624)
        var x40 uint64
        var x41 uint64
        x41, x40 = bits.Mul64(x30, 0x1eabfffeb153ffff)
        var x42 uint64
        var x43 uint64
        x43, x42 = bits.Mul64(x30, 0xb9feffffffffaaab)
        var x44 uint64
        var x45 uint64
        x44, x45 = bits.Add64(x43, x40, uint64(0x0))
        var x46 uint64
        var x47 uint64
        x46, x47 = bits.Add64(x41, x38, uint64(fiatFpUint1(x45)))
        var x48 uint64
        var x49 uint64
        x48, x49 = bits.Add64(x39, x36, uint64(fiatFpUint1(x47)))
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x37, x34, uint64(fiatFpUint1(x49)))
        var x52 uint64
        var x53 uint64
        x52, x53 = bits.Add64(x35, x32, uint64(fiatFpUint1(x51)))
        x54 := (uint64(fiatFpUint1(x53)) + x33)
        var x56 uint64
        _, x56 = bits.Add64(x17, x42, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x19, x44, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x21, x46, uint64(fiatFpUint1(x58)))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Add64(x23, x48, uint64(fiatFpUint1(x60)))
        var x63 uint64
        var x64 uint64
        x63, x64 = bits.Add64(x25, x50, uint64(fiatFpUint1(x62)))
        var x65 uint64
        var x66 uint64
        x65, x66 = bits.Add64(x27, x52, uint64(fiatFpUint1(x64)))
        var x67 uint64
        var x68 uint64
        x67, x68 = bits.Add64(x29, x54, uint64(fiatFpUint1(x66)))
        var x69 uint64
        var x70 uint64
        x70, x69 = bits.Mul64(x1, arg1[5])
        var x71 uint64
        var x72 uint64
        x72, x71 = bits.Mul64(x1, arg1[4])
        var x73 uint64
        var x74 uint64
        x74, x73 = bits.Mul64(x1, arg1[3])
        var x75 uint64
        var x76 uint64
        x76, x75 = bits.Mul64(x1, arg1[2])
        var x77 uint64
        var x78 uint64
        x78, x77 = bits.Mul64(x1, arg1[1])
        var x79 uint64
        var x80 uint64
        x80, x79 = bits.Mul64(x1, arg1[0])
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x80, x77, uint64(0x0))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x78, x75, uint64(fiatFpUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x76, x73, uint64(fiatFpUint1(x84)))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x74, x71, uint64(fiatFpUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x72, x69, uint64(fiatFpUint1(x88)))
        x91 := (uint64(fiatFpUint1(x90)) + x70)
        var x92 uint64
        var x93 uint64
        x92, x93 = bits.Add64(x57, x79, uint64(0x0))
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x59, x81, uint64(fiatFpUint1(x93)))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x61, x83, uint64(fiatFpUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x63, x85, uint64(fiatFpUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x65, x87, uint64(fiatFpUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Add64(x67, x89, uint64(fiatFpUint1(x101)))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Add64(uint64(fiatFpUint1(x68)), x91, uint64(fiatFpUint1(x103)))
        var x106 uint64
        _, x106 = bits.Mul64(x92, 0x89f3fffcfffcfffd)
        var x108 uint64
        var x109 uint64
        x109, x108 = bits.Mul64(x106, 0x1a0111ea397fe69a)
        var x110 uint64
        var x111 uint64
        x111, x110 = bits.Mul64(x106, 0x4b1ba7b6434bacd7)
        var x112 uint64
        var x113 uint64
        x113, x112 = bits.Mul64(x106, 0x64774b84f38512bf)
        var x114 uint64
        var x115 uint64
        x115, x114 = bits.Mul64(x106, 0x6730d2a0f6b0f624)
        var x116 uint64
        var x117 uint64
        x117, x116 = bits.Mul64(x106, 0x1eabfffeb153ffff)
        var x118 uint64
        var x119 uint64
        x119, x118 = bits.Mul64(x106, 0xb9feffffffffaaab)
        var x120 uint64
        var x121 uint64
        x120, x121 = bits.Add64(x119, x116, uint64(0x0))
        var x122 uint64
        var x123 uint64
        x122, x123 = bits.Add64(x117, x114, uint64(fiatFpUint1(x121)))
        var x124 uint64
        var x125 uint64
        x124, x125 = bits.Add64(x115, x112, uint64(fiatFpUint1(x123)))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x113, x110, uint64(fiatFpUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64(x111, x108, uint64(fiatFpUint1(x127)))
        x130 := (uint64(fiatFpUint1(x129)) + x109)
        var x132 uint64
        _, x132 = bits.Add64(x92, x118, uint64(0x0))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x94, x120, uint64(fiatFpUint1(x132)))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x96, x122, uint64(fiatFpUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x98, x124, uint64(fiatFpUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x100, x126, uint64(fiatFpUint1(x138)))
        var x141 uint64
        var x142 uint64
        x141, x142 = bits.Add64(x102, x128, uint64(fiatFpUint1(x140)))
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x104, x130, uint64(fiatFpUint1(x142)))
        x145 := (uint64(fiatFpUint1(x144)) + uint64(fiatFpUint1(x105)))
        var x146 uint64
        var x147 uint64
        x147, x146 = bits.Mul64(x2, arg1[5])
        var x148 uint64
        var x149 uint64
        x149, x148 = bits.Mul64(x2, arg1[4])
        var x150 uint64
        var x151 uint64
        x151, x150 = bits.Mul64(x2, arg1[3])
        var x152 uint64
        var x153 uint64
        x153, x152 = bits.Mul64(x2, arg1[2])
        var x154 uint64
        var x155 uint64
        x155, x154 = bits.Mul64(x2, arg1[1])
        var x156 uint64
        var x157 uint64
        x157, x156 = bits.Mul64(x2, arg1[0])
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x157, x154, uint64(0x0))
        var x160 uint64
        var x161 uint64
        x160, x161 = bits.Add64(x155, x152, uint64(fiatFpUint1(x159)))
        var x162 uint64
        var x163 uint64
        x162, x163 = bits.Add64(x153, x150, uint64(fiatFpUint1(x161)))
        var x164 uint64
        var x165 uint64
        x164, x165 = bits.Add64(x151, x148, uint64(fiatFpUint1(x163)))
        var x166 uint64
        var x167 uint64
        x166, x167 = bits.Add64(x149, x146, uint64(fiatFpUint1(x165)))
        x168 := (uint64(fiatFpUint1(x167)) + x147)
        var x169 uint64
        var x170 uint64
        x169, x170 = bits.Add64(x133, x156, uint64(0x0))
        var x171 uint64
        var x172 uint64
        x171, x172 = bits.Add64(x135, x158, uint64(fiatFpUint1(x170)))
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x137, x160, uint64(fiatFpUint1(x172)))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x139, x162, uint64(fiatFpUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x141, x164, uint64(fiatFpUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x143, x166, uint64(fiatFpUint1(x178)))
        var x181 uint64
        var x182 uint64
        x181, x182 = bits.Add64(x145, x168, uint64(fiatFpUint1(x180)))
        var x183 uint64
        _, x183 = bits.Mul64(x169, 0x89f3fffcfffcfffd)
        var x185 uint64
        var x186 uint64
        x186, x185 = bits.Mul64(x183, 0x1a0111ea397fe69a)
        var x187 uint64
        var x188 uint64
        x188, x187 = bits.Mul64(x183, 0x4b1ba7b6434bacd7)
        var x189 uint64
        var x190 uint64
        x190, x189 = bits.Mul64(x183, 0x64774b84f38512bf)
        var x191 uint64
        var x192 uint64
        x192, x191 = bits.Mul64(x183, 0x6730d2a0f6b0f624)
        var x193 uint64
        var x194 uint64
        x194, x193 = bits.Mul64(x183, 0x1eabfffeb153ffff)
        var x195 uint64
        var x196 uint64
        x196, x195 = bits.Mul64(x183, 0xb9feffffffffaaab)
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x196, x193, uint64(0x0))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x194, x191, uint64(fiatFpUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x192, x189, uint64(fiatFpUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x190, x187, uint64(fiatFpUint1(x202)))
        var x205 uint64
        var x206 uint64
        x205, x206 = bits.Add64(x188, x185, uint64(fiatFpUint1(x204)))
        x207 := (uint64(fiatFpUint1(x206)) + x186)
        var x209 uint64
        _, x209 = bits.Add64(x169, x195, uint64(0x0))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Add64(x171, x197, uint64(fiatFpUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Add64(x173, x199, uint64(fiatFpUint1(x211)))
        var x214 uint64
        var x215 uint64
        x214, x215 = bits.Add64(x175, x201, uint64(fiatFpUint1(x213)))
        var x216 uint64
        var x217 uint64
        x216, x217 = bits.Add64(x177, x203, uint64(fiatFpUint1(x215)))
        var x218 uint64
        var x219 uint64
        x218, x219 = bits.Add64(x179, x205, uint64(fiatFpUint1(x217)))
        var x220 uint64
        var x221 uint64
        x220, x221 = bits.Add64(x181, x207, uint64(fiatFpUint1(x219)))
        x222 := (uint64(fiatFpUint1(x221)) + uint64(fiatFpUint1(x182)))
        var x223 uint64
        var x224 uint64
        x224, x223 = bits.Mul64(x3, arg1[5])
        var x225 uint64
        var x226 uint64
        x226, x225 = bits.Mul64(x3, arg1[4])
        var x227 uint64
        var x228 uint64
        x228, x227 = bits.Mul64(x3, arg1[3])
        var x229 uint64
        var x230 uint64
        x230, x229 = bits.Mul64(x3, arg1[2])
        var x231 uint64
        var x232 uint64
        x232, x231 = bits.Mul64(x3, arg1[1])
        var x233 uint64
        var x234 uint64
        x234, x233 = bits.Mul64(x3, arg1[0])
        var x235 uint64
        var x236 uint64
        x235, x236 = bits.Add64(x234, x231, uint64(0x0))
        var x237 uint64
        var x238 uint64
        x237, x238 = bits.Add64(x232, x229, uint64(fiatFpUint1(x236)))
        var x239 uint64
        var x240 uint64
        x239, x240 = bits.Add64(x230, x227, uint64(fiatFpUint1(x238)))
        var x241 uint64
        var x242 uint64
        x241, x242 = bits.Add64(x228, x225, uint64(fiatFpUint1(x240)))
        var x243 uint64
        var x244 uint64
        x243, x244 = bits.Add64(x226, x223, uint64(fiatFpUint1(x242)))
        x245 := (uint64(fiatFpUint1(x244)) + x224)
        var x246 uint64
        var x247 uint64
        x246, x247 = bits.Add64(x210, x233, uint64(0x0))
        var x248 uint64
        var x249 uint64
        x248, x249 = bits.Add64(x212, x235, uint64(fiatFpUint1(x247)))
        var x250 uint64
        var x251 uint64
        x250, x251 = bits.Add64(x214, x237, uint64(fiatFpUint1(x249)))
        var x252 uint64
        var x253 uint64
        x252, x253 = bits.Add64(x216, x239, uint64(fiatFpUint1(x251)))
        var x254 uint64
        var x255 uint64
        x254, x255 = bits.Add64(x218, x241, uint64(fiatFpUint1(x253)))
        var x256 uint64
        var x257 uint64
        x256, x257 = bits.Add64(x220, x243, uint64(fiatFpUint1(x255)))
        var x258 uint64
        var x259 uint64
        x258, x259 = bits.Add64(x222, x245, uint64(fiatFpUint1(x257)))
        var x260 uint64
        _, x260 = bits.Mul64(x246, 0x89f3fffcfffcfffd)
        var x262 uint64
        var x263 uint64
        x263, x262 = bits.Mul64(x260, 0x1a0111ea397fe69a)
        var x264 uint64
        var x265 uint64
        x265, x264 = bits.Mul64(x260, 0x4b1ba7b6434bacd7)
        var x266 uint64
        var x267 uint64
        x267, x266 = bits.Mul64(x260, 0x64774b84f38512bf)
        var x268 uint64
        var x269 uint64
        x269, x268 = bits.Mul64(x260, 0x6730d2a0f6b0f624)
        var x270 uint64
        var x271 uint64
        x271, x270 = bits.Mul64(x260, 0x1eabfffeb153ffff)
        var x272 uint64
        var x273 uint64
        x273, x272 = bits.Mul64(x260, 0xb9feffffffffaaab)
        var x274 uint64
        var x275 uint64
        x274, x275 = bits.Add64(x273, x270, uint64(0x0))
        var x276 uint64
        var x277 uint64
        x276, x277 = bits.Add64(x271, x268, uint64(fiatFpUint1(x275)))
        var x278 uint64
        var x279 uint64
        x278, x279 = bits.Add64(x269, x266, uint64(fiatFpUint1(x277)))
        var x280 uint64
        var x281 uint64
        x280, x281 = bits.Add64(x267, x264, uint64(fiatFpUint1(x279)))
        var x282 uint64
        var x283 uint64
        x282, x283 = bits.Add64(x265, x262, uint64(fiatFpUint1(x281)))
        x284 := (uint64(fiatFpUint1(x283)) + x263)
        var x286 uint64
        _, x286 = bits.Add64(x246, x272, uint64(0x0))
        var x287 uint64
        var x288 uint64
        x287, x288 = bits.Add64(x248, x274, uint64(fiatFpUint1(x286)))
        var x289 uint64
        var x290 uint64
        x289, x290 = bits.Add64(x250, x276, uint64(fiatFpUint1(x288)))
        var x291 uint64
        var x292 uint64
        x291, x292 = bits.Add64(x252, x278, uint64(fiatFpUint1(x290)))
        var x293 uint64
        var x294 uint64
        x293, x294 = bits.Add64(x254, x280, uint64(fiatFpUint1(x292)))
        var x295 uint64
        var x296 uint64
        x295, x296 = bits.Add64(x256, x282, uint64(fiatFpUint1(x294)))
        var x297 uint64
        var x298 uint64
        x297, x298 = bits.Add64(x258, x284, uint64(fiatFpUint1(x296)))
        x299 := (uint64(fiatFpUint1(x298)) + uint64(fiatFpUint1(x259)))
        var x300 uint64
        var x301 uint64
        x301, x300 = bits.Mul64(x4, arg1[5])
        var x302 uint64
        var x303 uint64
        x303, x302 = bits.Mul64(x4, arg1[4])
        var x304 uint64
        var x305 uint64
        x305, x304 = bits.Mul64(x4, arg1[3])
        var x306 uint64
        var x307 uint64
        x307, x306 = bits.Mul64(x4, arg1[2])
        var x308 uint64
        var x309 uint64
        x309, x308 = bits.Mul64(x4, arg1[1])
        var x310 uint64
        var x311 uint64
        x311, x310 = bits.Mul64(x4, arg1[0])
        var x312 uint64
        var x313 uint64
        x312, x313 = bits.Add64(x311, x308, uint64(0x0))
        var x314 uint64
        var x315 uint64
        x314, x315 = bits.Add64(x309, x306, uint64(fiatFpUint1(x313)))
        var x316 uint64
        var x317 uint64
        x316, x317 = bits.Add64(x307, x304, uint64(fiatFpUint1(x315)))
        var x318 uint64
        var x319 uint64
        x318, x319 = bits.Add64(x305, x302, uint64(fiatFpUint1(x317)))
        var x320 uint64
        var x321 uint64
        x320, x321 = bits.Add64(x303, x300, uint64(fiatFpUint1(x319)))
        x322 := (uint64(fiatFpUint1(x321)) + x301)
        var x323 uint64
        var x324 uint64
        x323, x324 = bits.Add64(x287, x310, uint64(0x0))
        var x325 uint64
        var x326 uint64
        x325, x326 = bits.Add64(x289, x312, uint64(fiatFpUint1(x324)))
        var x327 uint64
        var x328 uint64
        x327, x328 = bits.Add64(x291, x314, uint64(fiatFpUint1(x326)))
        var x329 uint64
        var x330 uint64
        x329, x330 = bits.Add64(x293, x316, uint64(fiatFpUint1(x328)))
        var x331 uint64
        var x332 uint64
        x331, x332 = bits.Add64(x295, x318, uint64(fiatFpUint1(x330)))
        var x333 uint64
        var x334 uint64
        x333, x334 = bits.Add64(x297, x320, uint64(fiatFpUint1(x332)))
        var x335 uint64
        var x336 uint64
        x335, x336 = bits.Add64(x299, x322, uint64(fiatFpUint1(x334)))
        var x337 uint64
        _, x337 = bits.Mul64(x323, 0x89f3fffcfffcfffd)
        var x339 uint64
        var x340 uint64
        x340, x339 = bits.Mul64(x337, 0x1a0111ea397fe69a)
        var x341 uint64
        var x342 uint64
        x342, x341 = bits.Mul64(x337, 0x4b1ba7b6434bacd7)
        var x343 uint64
        var x344 uint64
        x344, x343 = bits.Mul64(x337, 0x64774b84f38512bf)
        var x345 uint64
        var x346 uint64
        x346, x345 = bits.Mul64(x337, 0x6730d2a0f6b0f624)
        var x347 uint64
        var x348 uint64
        x348, x347 = bits.Mul64(x337, 0x1eabfffeb153ffff)
        var x349 uint64
        var x350 uint64
        x350, x349 = bits.Mul64(x337, 0xb9feffffffffaaab)
        var x351 uint64
        var x352 uint64
        x351, x352 = bits.Add64(x350, x347, uint64(0x0))
        var x353 uint64
        var x354 uint64
        x353, x354 = bits.Add64(x348, x345, uint64(fiatFpUint1(x352)))
        var x355 uint64
        var x356 uint64
        x355, x356 = bits.Add64(x346, x343, uint64(fiatFpUint1(x354)))
        var x357 uint64
        var x358 uint64
        x357, x358 = bits.Add64(x344, x341, uint64(fiatFpUint1(x356)))
        var x359 uint64
        var x360 uint64
        x359, x360 = bits.Add64(x342, x339, uint64(fiatFpUint1(x358)))
        x361 := (uint64(fiatFpUint1(x360)) + x340)
        var x363 uint64
        _, x363 = bits.Add64(x323, x349, uint64(0x0))
        var x364 uint64
        var x365 uint64
        x364, x365 = bits.Add64(x325, x351, uint64(fiatFpUint1(x363)))
        var x366 uint64
        var x367 uint64
        x366, x367 = bits.Add64(x327, x353, uint64(fiatFpUint1(x365)))
        var x368 uint64
        var x369 uint64
        x368, x369 = bits.Add64(x329, x355, uint64(fiatFpUint1(x367)))
        var x370 uint64
        var x371 uint64
        x370, x371 = bits.Add64(x331, x357, uint64(fiatFpUint1(x369)))
        var x372 uint64
        var x373 uint64
        x372, x373 = bits.Add64(x333, x359, uint64(fiatFpUint1(x371)))
        var x374 uint64
        var x375 uint64
        x374, x375 = bits.Add64(x335, x361, uint64(fiatFpUint1(x373)))
        x376 := (uint64(fiatFpUint1(x375)) + uint64(fiatFpUint1(x336)))
        var x377 uint64
        var x378 uint64
        x378, x377 = bits.Mul64(x5, arg1[5])
        var x379 uint64
        var x380 uint64
        x380, x379 = bits.Mul64(x5, arg1[4])
        var x381 uint64
        var x382 uint64
        x382, x381 = bits.Mul64(x5, arg1[3])
        var x383 uint64
        var x384 uint64
        x384, x383 = bits.Mul64(x5, arg1[2])
        var x385 uint64
        var x386 uint64
        x386, x385 = bits.Mul64(x5, arg1[1])
        var x387 uint64
        var x388 uint64
        x388, x387 = bits.Mul64(x5, arg1[0])
        var x389 uint64
        var x390 uint64
        x389, x390 = bits.Add64(x388, x385, uint64(0x0))
        var x391 uint64
        var x392 uint64
        x391, x392 = bits.Add64(x386, x383, uint64(fiatFpUint1(x390)))
        var x393 uint64
        var x394 uint64
        x393, x394 = bits.Add64(x384, x381, uint64(fiatFpUint1(x392)))
        var x395 uint64
        var x396 uint64
        x395, x396 = bits.Add64(x382, x379, uint64(fiatFpUint1(x394)))
        var x397 uint64
        var x398 uint64
        x397, x398 = bits.Add64(x380, x377, uint64(fiatFpUint1(x396)))
        x399 := (uint64(fiatFpUint1(x398)) + x378)
        var x400 uint64
        var x401 uint64
        x400, x401 = bits.Add64(x364, x387, uint64(0x0))
        var x402 uint64
        var x403 uint64
        x402, x403 = bits.Add64(x366, x389, uint64(fiatFpUint1(x401)))
        var x404 uint64
        var x405 uint64
        x404, x405 = bits.Add64(x368, x391, uint64(fiatFpUint1(x403)))
        var x406 uint64
        var x407 uint64
        x406, x407 = bits.Add64(x370, x393, uint64(fiatFpUint1(x405)))
        var x408 uint64
        var x409 uint64
        x408, x409 = bits.Add64(x372, x395, uint64(fiatFpUint1(x407)))
        var x410 uint64
        var x411 uint64
        x410, x411 = bits.Add64(x374, x397, uint64(fiatFpUint1(x409)))
        var x412 uint64
        var x413 uint64
        x412, x413 = bits.Add64(x376, x399, uint64(fiatFpUint1(x411)))
        var x414 uint64
        _, x414 = bits.Mul64(x400, 0x89f3fffcfffcfffd)
        var x416 uint64
        var x417 uint64
        x417, x416 = bits.Mul64(x414, 0x1a0111ea397fe69a)
        var x418 uint64
        var x419 uint64
        x419, x418 = bits.Mul64(x414, 0x4b1ba7b6434bacd7)
        var x420 uint64
        var x421 uint64
        x421, x420 = bits.Mul64(x414, 0x64774b84f38512bf)
        var x422 uint64
        var x423 uint64
        x423, x422 = bits.Mul64(x414, 0x6730d2a0f6b0f624)
        var x424 uint64
        var x425 uint64
        x425, x424 = bits.Mul64(x414, 0x1eabfffeb153ffff)
        var x426 uint64
        var x427 uint64
        x427, x426 = bits.Mul64(x414, 0xb9feffffffffaaab)
        var x428 uint64
        var x429 uint64
        x428, x429 = bits.Add64(x427, x424, uint64(0x0))
        var x430 uint64
        var x431 uint64
        x430, x431 = bits.Add64(x425, x422, uint64(fiatFpUint1(x429)))
        var x432 uint64
        var x433 uint64
        x432, x433 = bits.Add64(x423, x420, uint64(fiatFpUint1(x431)))
        var x434 uint64
        var x435 uint64
        x434, x435 = bits.Add64(x421, x418, uint64(fiatFpUint1(x433)))
        var x436 uint64
        var x437 uint64
        x436, x437 = bits.Add64(x419, x416, uint64(fiatFpUint1(x435)))
        x438 := (uint64(fiatFpUint1(x437)) + x417)
        var x440 uint64
        _, x440 = bits.Add64(x400, x426, uint64(0x0))
        var x441 uint64
        var x442 uint64
        x441, x442 = bits.Add64(x402, x428, uint64(fiatFpUint1(x440)))
        var x443 uint64
        var x444 uint64
        x443, x444 = bits.Add64(x404, x430, uint64(fiatFpUint1(x442)))
        var x445 uint64
        var x446 uint64
        x445, x446 = bits.Add64(x406, x432, uint64(fiatFpUint1(x444)))
        var x447 uint64
        var x448 uint64
        x447, x448 = bits.Add64(x408, x434, uint64(fiatFpUint1(x446)))
        var x449 uint64
        var x450 uint64
        x449, x450 = bits.Add64(x410, x436, uint64(fiatFpUint1(x448)))
        var x451 uint64
        var x452 uint64
        x451, x452 = bits.Add64(x412, x438, uint64(fiatFpUint1(x450)))
        x453 := (uint64(fiatFpUint1(x452)) + uint64(fiatFpUint1(x413)))
        var x454 uint64
        var x455 uint64
        x454, x455 = bits.Sub64(x441, 0xb9feffffffffaaab, uint64(0x0))
        var x456 uint64
        var x457 uint64
        x456, x457 = bits.Sub64(x443, 0x1eabfffeb153ffff, uint64(fiatFpUint1(x455)))
        var x458 uint64
        var x459 uint64
        x458, x459 = bits.Sub64(x445, 0x6730d2a0f6b0f624, uint64(fiatFpUint1(x457)))
        var x460 uint64
        var x461 uint64
        x460, x461 = bits.Sub64(x447, 0x64774b84f38512bf, uint64(fiatFpUint1(x459)))
        var x462 uint64
        var x463 uint64
        x462, x463 = bits.Sub64(x449, 0x4b1ba7b6434bacd7, uint64(fiatFpUint1(x461)))
        var x464 uint64
        var x465 uint64
        x464, x465 = bits.Sub64(x451, 0x1a0111ea397fe69a, uint64(fiatFpUint1(x463)))
        var x467 uint64
        _, x467 = bits.Sub64(x453, uint64(0x0), uint64(fiatFpUint1(x465)))
        var x468 uint64
        fiatFpCmovznzU64(&amp;x468, fiatFpUint1(x467), x454, x441)
        var x469 uint64
        fiatFpCmovznzU64(&amp;x469, fiatFpUint1(x467), x456, x443)
        var x470 uint64
        fiatFpCmovznzU64(&amp;x470, fiatFpUint1(x467), x458, x445)
        var x471 uint64
        fiatFpCmovznzU64(&amp;x471, fiatFpUint1(x467), x460, x447)
        var x472 uint64
        fiatFpCmovznzU64(&amp;x472, fiatFpUint1(x467), x462, x449)
        var x473 uint64
        fiatFpCmovznzU64(&amp;x473, fiatFpUint1(x467), x464, x451)
        out1[0] = x468
        out1[1] = x469
        out1[2] = x470
        out1[3] = x471
        out1[4] = x472
        out1[5] = x473
}</span>

// fiatFpAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpAdd(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Add64(arg1[4], arg2[4], uint64(fiatFpUint1(x8)))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Add64(arg1[5], arg2[5], uint64(fiatFpUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x1, 0xb9feffffffffaaab, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x3, 0x1eabfffeb153ffff, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Sub64(x5, 0x6730d2a0f6b0f624, uint64(fiatFpUint1(x16)))
        var x19 uint64
        var x20 uint64
        x19, x20 = bits.Sub64(x7, 0x64774b84f38512bf, uint64(fiatFpUint1(x18)))
        var x21 uint64
        var x22 uint64
        x21, x22 = bits.Sub64(x9, 0x4b1ba7b6434bacd7, uint64(fiatFpUint1(x20)))
        var x23 uint64
        var x24 uint64
        x23, x24 = bits.Sub64(x11, 0x1a0111ea397fe69a, uint64(fiatFpUint1(x22)))
        var x26 uint64
        _, x26 = bits.Sub64(uint64(fiatFpUint1(x12)), uint64(0x0), uint64(fiatFpUint1(x24)))
        var x27 uint64
        fiatFpCmovznzU64(&amp;x27, fiatFpUint1(x26), x13, x1)
        var x28 uint64
        fiatFpCmovznzU64(&amp;x28, fiatFpUint1(x26), x15, x3)
        var x29 uint64
        fiatFpCmovznzU64(&amp;x29, fiatFpUint1(x26), x17, x5)
        var x30 uint64
        fiatFpCmovznzU64(&amp;x30, fiatFpUint1(x26), x19, x7)
        var x31 uint64
        fiatFpCmovznzU64(&amp;x31, fiatFpUint1(x26), x21, x9)
        var x32 uint64
        fiatFpCmovznzU64(&amp;x32, fiatFpUint1(x26), x23, x11)
        out1[0] = x27
        out1[1] = x28
        out1[2] = x29
        out1[3] = x30
        out1[4] = x31
        out1[5] = x32
}</span>

// fiatFpSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpSub(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(arg1[4], arg2[4], uint64(fiatFpUint1(x8)))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(arg1[5], arg2[5], uint64(fiatFpUint1(x10)))
        var x13 uint64
        fiatFpCmovznzU64(&amp;x13, fiatFpUint1(x12), uint64(0x0), 0xffffffffffffffff)
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x1, (x13 &amp; 0xb9feffffffffaaab), uint64(0x0))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x3, (x13 &amp; 0x1eabfffeb153ffff), uint64(fiatFpUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(x5, (x13 &amp; 0x6730d2a0f6b0f624), uint64(fiatFpUint1(x17)))
        var x20 uint64
        var x21 uint64
        x20, x21 = bits.Add64(x7, (x13 &amp; 0x64774b84f38512bf), uint64(fiatFpUint1(x19)))
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(x9, (x13 &amp; 0x4b1ba7b6434bacd7), uint64(fiatFpUint1(x21)))
        var x24 uint64
        x24, _ = bits.Add64(x11, (x13 &amp; 0x1a0111ea397fe69a), uint64(fiatFpUint1(x23)))
        out1[0] = x14
        out1[1] = x16
        out1[2] = x18
        out1[3] = x20
        out1[4] = x22
        out1[5] = x24
}</span>

// fiatFpOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFpOpp(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(uint64(0x0), arg1[4], uint64(fiatFpUint1(x8)))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(uint64(0x0), arg1[5], uint64(fiatFpUint1(x10)))
        var x13 uint64
        fiatFpCmovznzU64(&amp;x13, fiatFpUint1(x12), uint64(0x0), 0xffffffffffffffff)
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x1, (x13 &amp; 0xb9feffffffffaaab), uint64(0x0))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x3, (x13 &amp; 0x1eabfffeb153ffff), uint64(fiatFpUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(x5, (x13 &amp; 0x6730d2a0f6b0f624), uint64(fiatFpUint1(x17)))
        var x20 uint64
        var x21 uint64
        x20, x21 = bits.Add64(x7, (x13 &amp; 0x64774b84f38512bf), uint64(fiatFpUint1(x19)))
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(x9, (x13 &amp; 0x4b1ba7b6434bacd7), uint64(fiatFpUint1(x21)))
        var x24 uint64
        x24, _ = bits.Add64(x11, (x13 &amp; 0x1a0111ea397fe69a), uint64(fiatFpUint1(x23)))
        out1[0] = x14
        out1[1] = x16
        out1[2] = x18
        out1[3] = x20
        out1[4] = x22
        out1[5] = x24
}</span>

// fiatFpFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^6) mod m
//   0  eval out1 &lt; m
//
func fiatFpFromMontgomery(out1 *fiatFpNonMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[0]
        var x2 uint64
        _, x2 = bits.Mul64(x1, 0x89f3fffcfffcfffd)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x2, 0x1a0111ea397fe69a)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x2, 0x4b1ba7b6434bacd7)
        var x8 uint64
        var x9 uint64
        x9, x8 = bits.Mul64(x2, 0x64774b84f38512bf)
        var x10 uint64
        var x11 uint64
        x11, x10 = bits.Mul64(x2, 0x6730d2a0f6b0f624)
        var x12 uint64
        var x13 uint64
        x13, x12 = bits.Mul64(x2, 0x1eabfffeb153ffff)
        var x14 uint64
        var x15 uint64
        x15, x14 = bits.Mul64(x2, 0xb9feffffffffaaab)
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x15, x12, uint64(0x0))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(x13, x10, uint64(fiatFpUint1(x17)))
        var x20 uint64
        var x21 uint64
        x20, x21 = bits.Add64(x11, x8, uint64(fiatFpUint1(x19)))
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(x9, x6, uint64(fiatFpUint1(x21)))
        var x24 uint64
        var x25 uint64
        x24, x25 = bits.Add64(x7, x4, uint64(fiatFpUint1(x23)))
        var x27 uint64
        _, x27 = bits.Add64(x1, x14, uint64(0x0))
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(uint64(0x0), x16, uint64(fiatFpUint1(x27)))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(uint64(0x0), x18, uint64(fiatFpUint1(x29)))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(uint64(0x0), x20, uint64(fiatFpUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(uint64(0x0), x22, uint64(fiatFpUint1(x33)))
        var x36 uint64
        var x37 uint64
        x36, x37 = bits.Add64(uint64(0x0), x24, uint64(fiatFpUint1(x35)))
        var x38 uint64
        var x39 uint64
        x38, x39 = bits.Add64(x28, arg1[1], uint64(0x0))
        var x40 uint64
        var x41 uint64
        x40, x41 = bits.Add64(x30, uint64(0x0), uint64(fiatFpUint1(x39)))
        var x42 uint64
        var x43 uint64
        x42, x43 = bits.Add64(x32, uint64(0x0), uint64(fiatFpUint1(x41)))
        var x44 uint64
        var x45 uint64
        x44, x45 = bits.Add64(x34, uint64(0x0), uint64(fiatFpUint1(x43)))
        var x46 uint64
        var x47 uint64
        x46, x47 = bits.Add64(x36, uint64(0x0), uint64(fiatFpUint1(x45)))
        var x48 uint64
        _, x48 = bits.Mul64(x38, 0x89f3fffcfffcfffd)
        var x50 uint64
        var x51 uint64
        x51, x50 = bits.Mul64(x48, 0x1a0111ea397fe69a)
        var x52 uint64
        var x53 uint64
        x53, x52 = bits.Mul64(x48, 0x4b1ba7b6434bacd7)
        var x54 uint64
        var x55 uint64
        x55, x54 = bits.Mul64(x48, 0x64774b84f38512bf)
        var x56 uint64
        var x57 uint64
        x57, x56 = bits.Mul64(x48, 0x6730d2a0f6b0f624)
        var x58 uint64
        var x59 uint64
        x59, x58 = bits.Mul64(x48, 0x1eabfffeb153ffff)
        var x60 uint64
        var x61 uint64
        x61, x60 = bits.Mul64(x48, 0xb9feffffffffaaab)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x61, x58, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x59, x56, uint64(fiatFpUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, x54, uint64(fiatFpUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x55, x52, uint64(fiatFpUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(x53, x50, uint64(fiatFpUint1(x69)))
        var x73 uint64
        _, x73 = bits.Add64(x38, x60, uint64(0x0))
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x40, x62, uint64(fiatFpUint1(x73)))
        var x76 uint64
        var x77 uint64
        x76, x77 = bits.Add64(x42, x64, uint64(fiatFpUint1(x75)))
        var x78 uint64
        var x79 uint64
        x78, x79 = bits.Add64(x44, x66, uint64(fiatFpUint1(x77)))
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x46, x68, uint64(fiatFpUint1(x79)))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64((uint64(fiatFpUint1(x47)) + (uint64(fiatFpUint1(x37)) + (uint64(fiatFpUint1(x25)) + x5))), x70, uint64(fiatFpUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x74, arg1[2], uint64(0x0))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x76, uint64(0x0), uint64(fiatFpUint1(x85)))
        var x88 uint64
        var x89 uint64
        x88, x89 = bits.Add64(x78, uint64(0x0), uint64(fiatFpUint1(x87)))
        var x90 uint64
        var x91 uint64
        x90, x91 = bits.Add64(x80, uint64(0x0), uint64(fiatFpUint1(x89)))
        var x92 uint64
        var x93 uint64
        x92, x93 = bits.Add64(x82, uint64(0x0), uint64(fiatFpUint1(x91)))
        var x94 uint64
        _, x94 = bits.Mul64(x84, 0x89f3fffcfffcfffd)
        var x96 uint64
        var x97 uint64
        x97, x96 = bits.Mul64(x94, 0x1a0111ea397fe69a)
        var x98 uint64
        var x99 uint64
        x99, x98 = bits.Mul64(x94, 0x4b1ba7b6434bacd7)
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x94, 0x64774b84f38512bf)
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x94, 0x6730d2a0f6b0f624)
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x94, 0x1eabfffeb153ffff)
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x94, 0xb9feffffffffaaab)
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFpUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFpUint1(x111)))
        var x114 uint64
        var x115 uint64
        x114, x115 = bits.Add64(x101, x98, uint64(fiatFpUint1(x113)))
        var x116 uint64
        var x117 uint64
        x116, x117 = bits.Add64(x99, x96, uint64(fiatFpUint1(x115)))
        var x119 uint64
        _, x119 = bits.Add64(x84, x106, uint64(0x0))
        var x120 uint64
        var x121 uint64
        x120, x121 = bits.Add64(x86, x108, uint64(fiatFpUint1(x119)))
        var x122 uint64
        var x123 uint64
        x122, x123 = bits.Add64(x88, x110, uint64(fiatFpUint1(x121)))
        var x124 uint64
        var x125 uint64
        x124, x125 = bits.Add64(x90, x112, uint64(fiatFpUint1(x123)))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x92, x114, uint64(fiatFpUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64((uint64(fiatFpUint1(x93)) + (uint64(fiatFpUint1(x83)) + (uint64(fiatFpUint1(x71)) + x51))), x116, uint64(fiatFpUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Add64(x120, arg1[3], uint64(0x0))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Add64(x122, uint64(0x0), uint64(fiatFpUint1(x131)))
        var x134 uint64
        var x135 uint64
        x134, x135 = bits.Add64(x124, uint64(0x0), uint64(fiatFpUint1(x133)))
        var x136 uint64
        var x137 uint64
        x136, x137 = bits.Add64(x126, uint64(0x0), uint64(fiatFpUint1(x135)))
        var x138 uint64
        var x139 uint64
        x138, x139 = bits.Add64(x128, uint64(0x0), uint64(fiatFpUint1(x137)))
        var x140 uint64
        _, x140 = bits.Mul64(x130, 0x89f3fffcfffcfffd)
        var x142 uint64
        var x143 uint64
        x143, x142 = bits.Mul64(x140, 0x1a0111ea397fe69a)
        var x144 uint64
        var x145 uint64
        x145, x144 = bits.Mul64(x140, 0x4b1ba7b6434bacd7)
        var x146 uint64
        var x147 uint64
        x147, x146 = bits.Mul64(x140, 0x64774b84f38512bf)
        var x148 uint64
        var x149 uint64
        x149, x148 = bits.Mul64(x140, 0x6730d2a0f6b0f624)
        var x150 uint64
        var x151 uint64
        x151, x150 = bits.Mul64(x140, 0x1eabfffeb153ffff)
        var x152 uint64
        var x153 uint64
        x153, x152 = bits.Mul64(x140, 0xb9feffffffffaaab)
        var x154 uint64
        var x155 uint64
        x154, x155 = bits.Add64(x153, x150, uint64(0x0))
        var x156 uint64
        var x157 uint64
        x156, x157 = bits.Add64(x151, x148, uint64(fiatFpUint1(x155)))
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x149, x146, uint64(fiatFpUint1(x157)))
        var x160 uint64
        var x161 uint64
        x160, x161 = bits.Add64(x147, x144, uint64(fiatFpUint1(x159)))
        var x162 uint64
        var x163 uint64
        x162, x163 = bits.Add64(x145, x142, uint64(fiatFpUint1(x161)))
        var x165 uint64
        _, x165 = bits.Add64(x130, x152, uint64(0x0))
        var x166 uint64
        var x167 uint64
        x166, x167 = bits.Add64(x132, x154, uint64(fiatFpUint1(x165)))
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x134, x156, uint64(fiatFpUint1(x167)))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x136, x158, uint64(fiatFpUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x138, x160, uint64(fiatFpUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64((uint64(fiatFpUint1(x139)) + (uint64(fiatFpUint1(x129)) + (uint64(fiatFpUint1(x117)) + x97))), x162, uint64(fiatFpUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x166, arg1[4], uint64(0x0))
        var x178 uint64
        var x179 uint64
        x178, x179 = bits.Add64(x168, uint64(0x0), uint64(fiatFpUint1(x177)))
        var x180 uint64
        var x181 uint64
        x180, x181 = bits.Add64(x170, uint64(0x0), uint64(fiatFpUint1(x179)))
        var x182 uint64
        var x183 uint64
        x182, x183 = bits.Add64(x172, uint64(0x0), uint64(fiatFpUint1(x181)))
        var x184 uint64
        var x185 uint64
        x184, x185 = bits.Add64(x174, uint64(0x0), uint64(fiatFpUint1(x183)))
        var x186 uint64
        _, x186 = bits.Mul64(x176, 0x89f3fffcfffcfffd)
        var x188 uint64
        var x189 uint64
        x189, x188 = bits.Mul64(x186, 0x1a0111ea397fe69a)
        var x190 uint64
        var x191 uint64
        x191, x190 = bits.Mul64(x186, 0x4b1ba7b6434bacd7)
        var x192 uint64
        var x193 uint64
        x193, x192 = bits.Mul64(x186, 0x64774b84f38512bf)
        var x194 uint64
        var x195 uint64
        x195, x194 = bits.Mul64(x186, 0x6730d2a0f6b0f624)
        var x196 uint64
        var x197 uint64
        x197, x196 = bits.Mul64(x186, 0x1eabfffeb153ffff)
        var x198 uint64
        var x199 uint64
        x199, x198 = bits.Mul64(x186, 0xb9feffffffffaaab)
        var x200 uint64
        var x201 uint64
        x200, x201 = bits.Add64(x199, x196, uint64(0x0))
        var x202 uint64
        var x203 uint64
        x202, x203 = bits.Add64(x197, x194, uint64(fiatFpUint1(x201)))
        var x204 uint64
        var x205 uint64
        x204, x205 = bits.Add64(x195, x192, uint64(fiatFpUint1(x203)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Add64(x193, x190, uint64(fiatFpUint1(x205)))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Add64(x191, x188, uint64(fiatFpUint1(x207)))
        var x211 uint64
        _, x211 = bits.Add64(x176, x198, uint64(0x0))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Add64(x178, x200, uint64(fiatFpUint1(x211)))
        var x214 uint64
        var x215 uint64
        x214, x215 = bits.Add64(x180, x202, uint64(fiatFpUint1(x213)))
        var x216 uint64
        var x217 uint64
        x216, x217 = bits.Add64(x182, x204, uint64(fiatFpUint1(x215)))
        var x218 uint64
        var x219 uint64
        x218, x219 = bits.Add64(x184, x206, uint64(fiatFpUint1(x217)))
        var x220 uint64
        var x221 uint64
        x220, x221 = bits.Add64((uint64(fiatFpUint1(x185)) + (uint64(fiatFpUint1(x175)) + (uint64(fiatFpUint1(x163)) + x143))), x208, uint64(fiatFpUint1(x219)))
        var x222 uint64
        var x223 uint64
        x222, x223 = bits.Add64(x212, arg1[5], uint64(0x0))
        var x224 uint64
        var x225 uint64
        x224, x225 = bits.Add64(x214, uint64(0x0), uint64(fiatFpUint1(x223)))
        var x226 uint64
        var x227 uint64
        x226, x227 = bits.Add64(x216, uint64(0x0), uint64(fiatFpUint1(x225)))
        var x228 uint64
        var x229 uint64
        x228, x229 = bits.Add64(x218, uint64(0x0), uint64(fiatFpUint1(x227)))
        var x230 uint64
        var x231 uint64
        x230, x231 = bits.Add64(x220, uint64(0x0), uint64(fiatFpUint1(x229)))
        var x232 uint64
        _, x232 = bits.Mul64(x222, 0x89f3fffcfffcfffd)
        var x234 uint64
        var x235 uint64
        x235, x234 = bits.Mul64(x232, 0x1a0111ea397fe69a)
        var x236 uint64
        var x237 uint64
        x237, x236 = bits.Mul64(x232, 0x4b1ba7b6434bacd7)
        var x238 uint64
        var x239 uint64
        x239, x238 = bits.Mul64(x232, 0x64774b84f38512bf)
        var x240 uint64
        var x241 uint64
        x241, x240 = bits.Mul64(x232, 0x6730d2a0f6b0f624)
        var x242 uint64
        var x243 uint64
        x243, x242 = bits.Mul64(x232, 0x1eabfffeb153ffff)
        var x244 uint64
        var x245 uint64
        x245, x244 = bits.Mul64(x232, 0xb9feffffffffaaab)
        var x246 uint64
        var x247 uint64
        x246, x247 = bits.Add64(x245, x242, uint64(0x0))
        var x248 uint64
        var x249 uint64
        x248, x249 = bits.Add64(x243, x240, uint64(fiatFpUint1(x247)))
        var x250 uint64
        var x251 uint64
        x250, x251 = bits.Add64(x241, x238, uint64(fiatFpUint1(x249)))
        var x252 uint64
        var x253 uint64
        x252, x253 = bits.Add64(x239, x236, uint64(fiatFpUint1(x251)))
        var x254 uint64
        var x255 uint64
        x254, x255 = bits.Add64(x237, x234, uint64(fiatFpUint1(x253)))
        var x257 uint64
        _, x257 = bits.Add64(x222, x244, uint64(0x0))
        var x258 uint64
        var x259 uint64
        x258, x259 = bits.Add64(x224, x246, uint64(fiatFpUint1(x257)))
        var x260 uint64
        var x261 uint64
        x260, x261 = bits.Add64(x226, x248, uint64(fiatFpUint1(x259)))
        var x262 uint64
        var x263 uint64
        x262, x263 = bits.Add64(x228, x250, uint64(fiatFpUint1(x261)))
        var x264 uint64
        var x265 uint64
        x264, x265 = bits.Add64(x230, x252, uint64(fiatFpUint1(x263)))
        var x266 uint64
        var x267 uint64
        x266, x267 = bits.Add64((uint64(fiatFpUint1(x231)) + (uint64(fiatFpUint1(x221)) + (uint64(fiatFpUint1(x209)) + x189))), x254, uint64(fiatFpUint1(x265)))
        x268 := (uint64(fiatFpUint1(x267)) + (uint64(fiatFpUint1(x255)) + x235))
        var x269 uint64
        var x270 uint64
        x269, x270 = bits.Sub64(x258, 0xb9feffffffffaaab, uint64(0x0))
        var x271 uint64
        var x272 uint64
        x271, x272 = bits.Sub64(x260, 0x1eabfffeb153ffff, uint64(fiatFpUint1(x270)))
        var x273 uint64
        var x274 uint64
        x273, x274 = bits.Sub64(x262, 0x6730d2a0f6b0f624, uint64(fiatFpUint1(x272)))
        var x275 uint64
        var x276 uint64
        x275, x276 = bits.Sub64(x264, 0x64774b84f38512bf, uint64(fiatFpUint1(x274)))
        var x277 uint64
        var x278 uint64
        x277, x278 = bits.Sub64(x266, 0x4b1ba7b6434bacd7, uint64(fiatFpUint1(x276)))
        var x279 uint64
        var x280 uint64
        x279, x280 = bits.Sub64(x268, 0x1a0111ea397fe69a, uint64(fiatFpUint1(x278)))
        var x282 uint64
        _, x282 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFpUint1(x280)))
        var x283 uint64
        fiatFpCmovznzU64(&amp;x283, fiatFpUint1(x282), x269, x258)
        var x284 uint64
        fiatFpCmovznzU64(&amp;x284, fiatFpUint1(x282), x271, x260)
        var x285 uint64
        fiatFpCmovznzU64(&amp;x285, fiatFpUint1(x282), x273, x262)
        var x286 uint64
        fiatFpCmovznzU64(&amp;x286, fiatFpUint1(x282), x275, x264)
        var x287 uint64
        fiatFpCmovznzU64(&amp;x287, fiatFpUint1(x282), x277, x266)
        var x288 uint64
        fiatFpCmovznzU64(&amp;x288, fiatFpUint1(x282), x279, x268)
        out1[0] = x283
        out1[1] = x284
        out1[2] = x285
        out1[3] = x286
        out1[4] = x287
        out1[5] = x288
}</span>

// fiatFpToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFpToMontgomery(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[4]
        x5 := arg1[5]
        x6 := arg1[0]
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x6, 0x11988fe592cae3aa)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x6, 0x9a793e85b519952d)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x6, 0x67eb88a9939d83c0)
        var x13 uint64
        var x14 uint64
        x14, x13 = bits.Mul64(x6, 0x8de5476c4c95b6d5)
        var x15 uint64
        var x16 uint64
        x16, x15 = bits.Mul64(x6, 0xa76e6a609d104f1)
        var x17 uint64
        var x18 uint64
        x18, x17 = bits.Mul64(x6, 0xf4df1f341c341746)
        var x19 uint64
        var x20 uint64
        x19, x20 = bits.Add64(x18, x15, uint64(0x0))
        var x21 uint64
        var x22 uint64
        x21, x22 = bits.Add64(x16, x13, uint64(fiatFpUint1(x20)))
        var x23 uint64
        var x24 uint64
        x23, x24 = bits.Add64(x14, x11, uint64(fiatFpUint1(x22)))
        var x25 uint64
        var x26 uint64
        x25, x26 = bits.Add64(x12, x9, uint64(fiatFpUint1(x24)))
        var x27 uint64
        var x28 uint64
        x27, x28 = bits.Add64(x10, x7, uint64(fiatFpUint1(x26)))
        var x29 uint64
        _, x29 = bits.Mul64(x17, 0x89f3fffcfffcfffd)
        var x31 uint64
        var x32 uint64
        x32, x31 = bits.Mul64(x29, 0x1a0111ea397fe69a)
        var x33 uint64
        var x34 uint64
        x34, x33 = bits.Mul64(x29, 0x4b1ba7b6434bacd7)
        var x35 uint64
        var x36 uint64
        x36, x35 = bits.Mul64(x29, 0x64774b84f38512bf)
        var x37 uint64
        var x38 uint64
        x38, x37 = bits.Mul64(x29, 0x6730d2a0f6b0f624)
        var x39 uint64
        var x40 uint64
        x40, x39 = bits.Mul64(x29, 0x1eabfffeb153ffff)
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x29, 0xb9feffffffffaaab)
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x42, x39, uint64(0x0))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x40, x37, uint64(fiatFpUint1(x44)))
        var x47 uint64
        var x48 uint64
        x47, x48 = bits.Add64(x38, x35, uint64(fiatFpUint1(x46)))
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x36, x33, uint64(fiatFpUint1(x48)))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x34, x31, uint64(fiatFpUint1(x50)))
        var x54 uint64
        _, x54 = bits.Add64(x17, x41, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x19, x43, uint64(fiatFpUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x21, x45, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x23, x47, uint64(fiatFpUint1(x58)))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Add64(x25, x49, uint64(fiatFpUint1(x60)))
        var x63 uint64
        var x64 uint64
        x63, x64 = bits.Add64(x27, x51, uint64(fiatFpUint1(x62)))
        var x65 uint64
        var x66 uint64
        x66, x65 = bits.Mul64(x1, 0x11988fe592cae3aa)
        var x67 uint64
        var x68 uint64
        x68, x67 = bits.Mul64(x1, 0x9a793e85b519952d)
        var x69 uint64
        var x70 uint64
        x70, x69 = bits.Mul64(x1, 0x67eb88a9939d83c0)
        var x71 uint64
        var x72 uint64
        x72, x71 = bits.Mul64(x1, 0x8de5476c4c95b6d5)
        var x73 uint64
        var x74 uint64
        x74, x73 = bits.Mul64(x1, 0xa76e6a609d104f1)
        var x75 uint64
        var x76 uint64
        x76, x75 = bits.Mul64(x1, 0xf4df1f341c341746)
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x76, x73, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x74, x71, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x72, x69, uint64(fiatFpUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x70, x67, uint64(fiatFpUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x68, x65, uint64(fiatFpUint1(x84)))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x55, x75, uint64(0x0))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x57, x77, uint64(fiatFpUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x59, x79, uint64(fiatFpUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x61, x81, uint64(fiatFpUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x63, x83, uint64(fiatFpUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(((uint64(fiatFpUint1(x64)) + (uint64(fiatFpUint1(x28)) + x8)) + (uint64(fiatFpUint1(x52)) + x32)), x85, uint64(fiatFpUint1(x96)))
        var x99 uint64
        _, x99 = bits.Mul64(x87, 0x89f3fffcfffcfffd)
        var x101 uint64
        var x102 uint64
        x102, x101 = bits.Mul64(x99, 0x1a0111ea397fe69a)
        var x103 uint64
        var x104 uint64
        x104, x103 = bits.Mul64(x99, 0x4b1ba7b6434bacd7)
        var x105 uint64
        var x106 uint64
        x106, x105 = bits.Mul64(x99, 0x64774b84f38512bf)
        var x107 uint64
        var x108 uint64
        x108, x107 = bits.Mul64(x99, 0x6730d2a0f6b0f624)
        var x109 uint64
        var x110 uint64
        x110, x109 = bits.Mul64(x99, 0x1eabfffeb153ffff)
        var x111 uint64
        var x112 uint64
        x112, x111 = bits.Mul64(x99, 0xb9feffffffffaaab)
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x112, x109, uint64(0x0))
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x110, x107, uint64(fiatFpUint1(x114)))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x108, x105, uint64(fiatFpUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x106, x103, uint64(fiatFpUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x104, x101, uint64(fiatFpUint1(x120)))
        var x124 uint64
        _, x124 = bits.Add64(x87, x111, uint64(0x0))
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x89, x113, uint64(fiatFpUint1(x124)))
        var x127 uint64
        var x128 uint64
        x127, x128 = bits.Add64(x91, x115, uint64(fiatFpUint1(x126)))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x93, x117, uint64(fiatFpUint1(x128)))
        var x131 uint64
        var x132 uint64
        x131, x132 = bits.Add64(x95, x119, uint64(fiatFpUint1(x130)))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x97, x121, uint64(fiatFpUint1(x132)))
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x2, 0x11988fe592cae3aa)
        var x137 uint64
        var x138 uint64
        x138, x137 = bits.Mul64(x2, 0x9a793e85b519952d)
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x2, 0x67eb88a9939d83c0)
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x2, 0x8de5476c4c95b6d5)
        var x143 uint64
        var x144 uint64
        x144, x143 = bits.Mul64(x2, 0xa76e6a609d104f1)
        var x145 uint64
        var x146 uint64
        x146, x145 = bits.Mul64(x2, 0xf4df1f341c341746)
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x146, x143, uint64(0x0))
        var x149 uint64
        var x150 uint64
        x149, x150 = bits.Add64(x144, x141, uint64(fiatFpUint1(x148)))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Add64(x142, x139, uint64(fiatFpUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Add64(x140, x137, uint64(fiatFpUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Add64(x138, x135, uint64(fiatFpUint1(x154)))
        var x157 uint64
        var x158 uint64
        x157, x158 = bits.Add64(x125, x145, uint64(0x0))
        var x159 uint64
        var x160 uint64
        x159, x160 = bits.Add64(x127, x147, uint64(fiatFpUint1(x158)))
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x129, x149, uint64(fiatFpUint1(x160)))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x131, x151, uint64(fiatFpUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x133, x153, uint64(fiatFpUint1(x164)))
        var x167 uint64
        var x168 uint64
        x167, x168 = bits.Add64(((uint64(fiatFpUint1(x134)) + (uint64(fiatFpUint1(x98)) + (uint64(fiatFpUint1(x86)) + x66))) + (uint64(fiatFpUint1(x122)) + x102)), x155, uint64(fiatFpUint1(x166)))
        var x169 uint64
        _, x169 = bits.Mul64(x157, 0x89f3fffcfffcfffd)
        var x171 uint64
        var x172 uint64
        x172, x171 = bits.Mul64(x169, 0x1a0111ea397fe69a)
        var x173 uint64
        var x174 uint64
        x174, x173 = bits.Mul64(x169, 0x4b1ba7b6434bacd7)
        var x175 uint64
        var x176 uint64
        x176, x175 = bits.Mul64(x169, 0x64774b84f38512bf)
        var x177 uint64
        var x178 uint64
        x178, x177 = bits.Mul64(x169, 0x6730d2a0f6b0f624)
        var x179 uint64
        var x180 uint64
        x180, x179 = bits.Mul64(x169, 0x1eabfffeb153ffff)
        var x181 uint64
        var x182 uint64
        x182, x181 = bits.Mul64(x169, 0xb9feffffffffaaab)
        var x183 uint64
        var x184 uint64
        x183, x184 = bits.Add64(x182, x179, uint64(0x0))
        var x185 uint64
        var x186 uint64
        x185, x186 = bits.Add64(x180, x177, uint64(fiatFpUint1(x184)))
        var x187 uint64
        var x188 uint64
        x187, x188 = bits.Add64(x178, x175, uint64(fiatFpUint1(x186)))
        var x189 uint64
        var x190 uint64
        x189, x190 = bits.Add64(x176, x173, uint64(fiatFpUint1(x188)))
        var x191 uint64
        var x192 uint64
        x191, x192 = bits.Add64(x174, x171, uint64(fiatFpUint1(x190)))
        var x194 uint64
        _, x194 = bits.Add64(x157, x181, uint64(0x0))
        var x195 uint64
        var x196 uint64
        x195, x196 = bits.Add64(x159, x183, uint64(fiatFpUint1(x194)))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x161, x185, uint64(fiatFpUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x163, x187, uint64(fiatFpUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x165, x189, uint64(fiatFpUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x167, x191, uint64(fiatFpUint1(x202)))
        var x205 uint64
        var x206 uint64
        x206, x205 = bits.Mul64(x3, 0x11988fe592cae3aa)
        var x207 uint64
        var x208 uint64
        x208, x207 = bits.Mul64(x3, 0x9a793e85b519952d)
        var x209 uint64
        var x210 uint64
        x210, x209 = bits.Mul64(x3, 0x67eb88a9939d83c0)
        var x211 uint64
        var x212 uint64
        x212, x211 = bits.Mul64(x3, 0x8de5476c4c95b6d5)
        var x213 uint64
        var x214 uint64
        x214, x213 = bits.Mul64(x3, 0xa76e6a609d104f1)
        var x215 uint64
        var x216 uint64
        x216, x215 = bits.Mul64(x3, 0xf4df1f341c341746)
        var x217 uint64
        var x218 uint64
        x217, x218 = bits.Add64(x216, x213, uint64(0x0))
        var x219 uint64
        var x220 uint64
        x219, x220 = bits.Add64(x214, x211, uint64(fiatFpUint1(x218)))
        var x221 uint64
        var x222 uint64
        x221, x222 = bits.Add64(x212, x209, uint64(fiatFpUint1(x220)))
        var x223 uint64
        var x224 uint64
        x223, x224 = bits.Add64(x210, x207, uint64(fiatFpUint1(x222)))
        var x225 uint64
        var x226 uint64
        x225, x226 = bits.Add64(x208, x205, uint64(fiatFpUint1(x224)))
        var x227 uint64
        var x228 uint64
        x227, x228 = bits.Add64(x195, x215, uint64(0x0))
        var x229 uint64
        var x230 uint64
        x229, x230 = bits.Add64(x197, x217, uint64(fiatFpUint1(x228)))
        var x231 uint64
        var x232 uint64
        x231, x232 = bits.Add64(x199, x219, uint64(fiatFpUint1(x230)))
        var x233 uint64
        var x234 uint64
        x233, x234 = bits.Add64(x201, x221, uint64(fiatFpUint1(x232)))
        var x235 uint64
        var x236 uint64
        x235, x236 = bits.Add64(x203, x223, uint64(fiatFpUint1(x234)))
        var x237 uint64
        var x238 uint64
        x237, x238 = bits.Add64(((uint64(fiatFpUint1(x204)) + (uint64(fiatFpUint1(x168)) + (uint64(fiatFpUint1(x156)) + x136))) + (uint64(fiatFpUint1(x192)) + x172)), x225, uint64(fiatFpUint1(x236)))
        var x239 uint64
        _, x239 = bits.Mul64(x227, 0x89f3fffcfffcfffd)
        var x241 uint64
        var x242 uint64
        x242, x241 = bits.Mul64(x239, 0x1a0111ea397fe69a)
        var x243 uint64
        var x244 uint64
        x244, x243 = bits.Mul64(x239, 0x4b1ba7b6434bacd7)
        var x245 uint64
        var x246 uint64
        x246, x245 = bits.Mul64(x239, 0x64774b84f38512bf)
        var x247 uint64
        var x248 uint64
        x248, x247 = bits.Mul64(x239, 0x6730d2a0f6b0f624)
        var x249 uint64
        var x250 uint64
        x250, x249 = bits.Mul64(x239, 0x1eabfffeb153ffff)
        var x251 uint64
        var x252 uint64
        x252, x251 = bits.Mul64(x239, 0xb9feffffffffaaab)
        var x253 uint64
        var x254 uint64
        x253, x254 = bits.Add64(x252, x249, uint64(0x0))
        var x255 uint64
        var x256 uint64
        x255, x256 = bits.Add64(x250, x247, uint64(fiatFpUint1(x254)))
        var x257 uint64
        var x258 uint64
        x257, x258 = bits.Add64(x248, x245, uint64(fiatFpUint1(x256)))
        var x259 uint64
        var x260 uint64
        x259, x260 = bits.Add64(x246, x243, uint64(fiatFpUint1(x258)))
        var x261 uint64
        var x262 uint64
        x261, x262 = bits.Add64(x244, x241, uint64(fiatFpUint1(x260)))
        var x264 uint64
        _, x264 = bits.Add64(x227, x251, uint64(0x0))
        var x265 uint64
        var x266 uint64
        x265, x266 = bits.Add64(x229, x253, uint64(fiatFpUint1(x264)))
        var x267 uint64
        var x268 uint64
        x267, x268 = bits.Add64(x231, x255, uint64(fiatFpUint1(x266)))
        var x269 uint64
        var x270 uint64
        x269, x270 = bits.Add64(x233, x257, uint64(fiatFpUint1(x268)))
        var x271 uint64
        var x272 uint64
        x271, x272 = bits.Add64(x235, x259, uint64(fiatFpUint1(x270)))
        var x273 uint64
        var x274 uint64
        x273, x274 = bits.Add64(x237, x261, uint64(fiatFpUint1(x272)))
        var x275 uint64
        var x276 uint64
        x276, x275 = bits.Mul64(x4, 0x11988fe592cae3aa)
        var x277 uint64
        var x278 uint64
        x278, x277 = bits.Mul64(x4, 0x9a793e85b519952d)
        var x279 uint64
        var x280 uint64
        x280, x279 = bits.Mul64(x4, 0x67eb88a9939d83c0)
        var x281 uint64
        var x282 uint64
        x282, x281 = bits.Mul64(x4, 0x8de5476c4c95b6d5)
        var x283 uint64
        var x284 uint64
        x284, x283 = bits.Mul64(x4, 0xa76e6a609d104f1)
        var x285 uint64
        var x286 uint64
        x286, x285 = bits.Mul64(x4, 0xf4df1f341c341746)
        var x287 uint64
        var x288 uint64
        x287, x288 = bits.Add64(x286, x283, uint64(0x0))
        var x289 uint64
        var x290 uint64
        x289, x290 = bits.Add64(x284, x281, uint64(fiatFpUint1(x288)))
        var x291 uint64
        var x292 uint64
        x291, x292 = bits.Add64(x282, x279, uint64(fiatFpUint1(x290)))
        var x293 uint64
        var x294 uint64
        x293, x294 = bits.Add64(x280, x277, uint64(fiatFpUint1(x292)))
        var x295 uint64
        var x296 uint64
        x295, x296 = bits.Add64(x278, x275, uint64(fiatFpUint1(x294)))
        var x297 uint64
        var x298 uint64
        x297, x298 = bits.Add64(x265, x285, uint64(0x0))
        var x299 uint64
        var x300 uint64
        x299, x300 = bits.Add64(x267, x287, uint64(fiatFpUint1(x298)))
        var x301 uint64
        var x302 uint64
        x301, x302 = bits.Add64(x269, x289, uint64(fiatFpUint1(x300)))
        var x303 uint64
        var x304 uint64
        x303, x304 = bits.Add64(x271, x291, uint64(fiatFpUint1(x302)))
        var x305 uint64
        var x306 uint64
        x305, x306 = bits.Add64(x273, x293, uint64(fiatFpUint1(x304)))
        var x307 uint64
        var x308 uint64
        x307, x308 = bits.Add64(((uint64(fiatFpUint1(x274)) + (uint64(fiatFpUint1(x238)) + (uint64(fiatFpUint1(x226)) + x206))) + (uint64(fiatFpUint1(x262)) + x242)), x295, uint64(fiatFpUint1(x306)))
        var x309 uint64
        _, x309 = bits.Mul64(x297, 0x89f3fffcfffcfffd)
        var x311 uint64
        var x312 uint64
        x312, x311 = bits.Mul64(x309, 0x1a0111ea397fe69a)
        var x313 uint64
        var x314 uint64
        x314, x313 = bits.Mul64(x309, 0x4b1ba7b6434bacd7)
        var x315 uint64
        var x316 uint64
        x316, x315 = bits.Mul64(x309, 0x64774b84f38512bf)
        var x317 uint64
        var x318 uint64
        x318, x317 = bits.Mul64(x309, 0x6730d2a0f6b0f624)
        var x319 uint64
        var x320 uint64
        x320, x319 = bits.Mul64(x309, 0x1eabfffeb153ffff)
        var x321 uint64
        var x322 uint64
        x322, x321 = bits.Mul64(x309, 0xb9feffffffffaaab)
        var x323 uint64
        var x324 uint64
        x323, x324 = bits.Add64(x322, x319, uint64(0x0))
        var x325 uint64
        var x326 uint64
        x325, x326 = bits.Add64(x320, x317, uint64(fiatFpUint1(x324)))
        var x327 uint64
        var x328 uint64
        x327, x328 = bits.Add64(x318, x315, uint64(fiatFpUint1(x326)))
        var x329 uint64
        var x330 uint64
        x329, x330 = bits.Add64(x316, x313, uint64(fiatFpUint1(x328)))
        var x331 uint64
        var x332 uint64
        x331, x332 = bits.Add64(x314, x311, uint64(fiatFpUint1(x330)))
        var x334 uint64
        _, x334 = bits.Add64(x297, x321, uint64(0x0))
        var x335 uint64
        var x336 uint64
        x335, x336 = bits.Add64(x299, x323, uint64(fiatFpUint1(x334)))
        var x337 uint64
        var x338 uint64
        x337, x338 = bits.Add64(x301, x325, uint64(fiatFpUint1(x336)))
        var x339 uint64
        var x340 uint64
        x339, x340 = bits.Add64(x303, x327, uint64(fiatFpUint1(x338)))
        var x341 uint64
        var x342 uint64
        x341, x342 = bits.Add64(x305, x329, uint64(fiatFpUint1(x340)))
        var x343 uint64
        var x344 uint64
        x343, x344 = bits.Add64(x307, x331, uint64(fiatFpUint1(x342)))
        var x345 uint64
        var x346 uint64
        x346, x345 = bits.Mul64(x5, 0x11988fe592cae3aa)
        var x347 uint64
        var x348 uint64
        x348, x347 = bits.Mul64(x5, 0x9a793e85b519952d)
        var x349 uint64
        var x350 uint64
        x350, x349 = bits.Mul64(x5, 0x67eb88a9939d83c0)
        var x351 uint64
        var x352 uint64
        x352, x351 = bits.Mul64(x5, 0x8de5476c4c95b6d5)
        var x353 uint64
        var x354 uint64
        x354, x353 = bits.Mul64(x5, 0xa76e6a609d104f1)
        var x355 uint64
        var x356 uint64
        x356, x355 = bits.Mul64(x5, 0xf4df1f341c341746)
        var x357 uint64
        var x358 uint64
        x357, x358 = bits.Add64(x356, x353, uint64(0x0))
        var x359 uint64
        var x360 uint64
        x359, x360 = bits.Add64(x354, x351, uint64(fiatFpUint1(x358)))
        var x361 uint64
        var x362 uint64
        x361, x362 = bits.Add64(x352, x349, uint64(fiatFpUint1(x360)))
        var x363 uint64
        var x364 uint64
        x363, x364 = bits.Add64(x350, x347, uint64(fiatFpUint1(x362)))
        var x365 uint64
        var x366 uint64
        x365, x366 = bits.Add64(x348, x345, uint64(fiatFpUint1(x364)))
        var x367 uint64
        var x368 uint64
        x367, x368 = bits.Add64(x335, x355, uint64(0x0))
        var x369 uint64
        var x370 uint64
        x369, x370 = bits.Add64(x337, x357, uint64(fiatFpUint1(x368)))
        var x371 uint64
        var x372 uint64
        x371, x372 = bits.Add64(x339, x359, uint64(fiatFpUint1(x370)))
        var x373 uint64
        var x374 uint64
        x373, x374 = bits.Add64(x341, x361, uint64(fiatFpUint1(x372)))
        var x375 uint64
        var x376 uint64
        x375, x376 = bits.Add64(x343, x363, uint64(fiatFpUint1(x374)))
        var x377 uint64
        var x378 uint64
        x377, x378 = bits.Add64(((uint64(fiatFpUint1(x344)) + (uint64(fiatFpUint1(x308)) + (uint64(fiatFpUint1(x296)) + x276))) + (uint64(fiatFpUint1(x332)) + x312)), x365, uint64(fiatFpUint1(x376)))
        var x379 uint64
        _, x379 = bits.Mul64(x367, 0x89f3fffcfffcfffd)
        var x381 uint64
        var x382 uint64
        x382, x381 = bits.Mul64(x379, 0x1a0111ea397fe69a)
        var x383 uint64
        var x384 uint64
        x384, x383 = bits.Mul64(x379, 0x4b1ba7b6434bacd7)
        var x385 uint64
        var x386 uint64
        x386, x385 = bits.Mul64(x379, 0x64774b84f38512bf)
        var x387 uint64
        var x388 uint64
        x388, x387 = bits.Mul64(x379, 0x6730d2a0f6b0f624)
        var x389 uint64
        var x390 uint64
        x390, x389 = bits.Mul64(x379, 0x1eabfffeb153ffff)
        var x391 uint64
        var x392 uint64
        x392, x391 = bits.Mul64(x379, 0xb9feffffffffaaab)
        var x393 uint64
        var x394 uint64
        x393, x394 = bits.Add64(x392, x389, uint64(0x0))
        var x395 uint64
        var x396 uint64
        x395, x396 = bits.Add64(x390, x387, uint64(fiatFpUint1(x394)))
        var x397 uint64
        var x398 uint64
        x397, x398 = bits.Add64(x388, x385, uint64(fiatFpUint1(x396)))
        var x399 uint64
        var x400 uint64
        x399, x400 = bits.Add64(x386, x383, uint64(fiatFpUint1(x398)))
        var x401 uint64
        var x402 uint64
        x401, x402 = bits.Add64(x384, x381, uint64(fiatFpUint1(x400)))
        var x404 uint64
        _, x404 = bits.Add64(x367, x391, uint64(0x0))
        var x405 uint64
        var x406 uint64
        x405, x406 = bits.Add64(x369, x393, uint64(fiatFpUint1(x404)))
        var x407 uint64
        var x408 uint64
        x407, x408 = bits.Add64(x371, x395, uint64(fiatFpUint1(x406)))
        var x409 uint64
        var x410 uint64
        x409, x410 = bits.Add64(x373, x397, uint64(fiatFpUint1(x408)))
        var x411 uint64
        var x412 uint64
        x411, x412 = bits.Add64(x375, x399, uint64(fiatFpUint1(x410)))
        var x413 uint64
        var x414 uint64
        x413, x414 = bits.Add64(x377, x401, uint64(fiatFpUint1(x412)))
        x415 := ((uint64(fiatFpUint1(x414)) + (uint64(fiatFpUint1(x378)) + (uint64(fiatFpUint1(x366)) + x346))) + (uint64(fiatFpUint1(x402)) + x382))
        var x416 uint64
        var x417 uint64
        x416, x417 = bits.Sub64(x405, 0xb9feffffffffaaab, uint64(0x0))
        var x418 uint64
        var x419 uint64
        x418, x419 = bits.Sub64(x407, 0x1eabfffeb153ffff, uint64(fiatFpUint1(x417)))
        var x420 uint64
        var x421 uint64
        x420, x421 = bits.Sub64(x409, 0x6730d2a0f6b0f624, uint64(fiatFpUint1(x419)))
        var x422 uint64
        var x423 uint64
        x422, x423 = bits.Sub64(x411, 0x64774b84f38512bf, uint64(fiatFpUint1(x421)))
        var x424 uint64
        var x425 uint64
        x424, x425 = bits.Sub64(x413, 0x4b1ba7b6434bacd7, uint64(fiatFpUint1(x423)))
        var x426 uint64
        var x427 uint64
        x426, x427 = bits.Sub64(x415, 0x1a0111ea397fe69a, uint64(fiatFpUint1(x425)))
        var x429 uint64
        _, x429 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFpUint1(x427)))
        var x430 uint64
        fiatFpCmovznzU64(&amp;x430, fiatFpUint1(x429), x416, x405)
        var x431 uint64
        fiatFpCmovznzU64(&amp;x431, fiatFpUint1(x429), x418, x407)
        var x432 uint64
        fiatFpCmovznzU64(&amp;x432, fiatFpUint1(x429), x420, x409)
        var x433 uint64
        fiatFpCmovznzU64(&amp;x433, fiatFpUint1(x429), x422, x411)
        var x434 uint64
        fiatFpCmovznzU64(&amp;x434, fiatFpUint1(x429), x424, x413)
        var x435 uint64
        fiatFpCmovznzU64(&amp;x435, fiatFpUint1(x429), x426, x415)
        out1[0] = x430
        out1[1] = x431
        out1[2] = x432
        out1[3] = x433
        out1[4] = x434
        out1[5] = x435
}</span>

// fiatFpNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpNonzero(out1 *uint64, arg1 *[6]uint64) <span class="cov8" title="1">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | (arg1[3] | (arg1[4] | arg1[5])))))
        *out1 = x1
}</span>

// fiatFpSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpSelectznz(out1 *[6]uint64, arg1 fiatFpUint1, arg2 *[6]uint64, arg3 *[6]uint64) <span class="cov8" title="1">{
        var x1 uint64
        fiatFpCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFpCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFpCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFpCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        var x5 uint64
        fiatFpCmovznzU64(&amp;x5, arg1, arg2[4], arg3[4])
        var x6 uint64
        fiatFpCmovznzU64(&amp;x6, arg1, arg2[5], arg3[5])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
        out1[4] = x5
        out1[5] = x6
}</span>

// fiatFpToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..47]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x1fffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x1f]]
func fiatFpToBytes(out1 *[48]uint8, arg1 *[6]uint64) <span class="cov8" title="1">{
        x1 := arg1[5]
        x2 := arg1[4]
        x3 := arg1[3]
        x4 := arg1[2]
        x5 := arg1[1]
        x6 := arg1[0]
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := (x16 &gt;&gt; 8)
        x19 := (uint8(x18) &amp; 0xff)
        x20 := uint8((x18 &gt;&gt; 8))
        x21 := (uint8(x5) &amp; 0xff)
        x22 := (x5 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := (x30 &gt;&gt; 8)
        x33 := (uint8(x32) &amp; 0xff)
        x34 := uint8((x32 &gt;&gt; 8))
        x35 := (uint8(x4) &amp; 0xff)
        x36 := (x4 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := (x44 &gt;&gt; 8)
        x47 := (uint8(x46) &amp; 0xff)
        x48 := uint8((x46 &gt;&gt; 8))
        x49 := (uint8(x3) &amp; 0xff)
        x50 := (x3 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := (x58 &gt;&gt; 8)
        x61 := (uint8(x60) &amp; 0xff)
        x62 := uint8((x60 &gt;&gt; 8))
        x63 := (uint8(x2) &amp; 0xff)
        x64 := (x2 &gt;&gt; 8)
        x65 := (uint8(x64) &amp; 0xff)
        x66 := (x64 &gt;&gt; 8)
        x67 := (uint8(x66) &amp; 0xff)
        x68 := (x66 &gt;&gt; 8)
        x69 := (uint8(x68) &amp; 0xff)
        x70 := (x68 &gt;&gt; 8)
        x71 := (uint8(x70) &amp; 0xff)
        x72 := (x70 &gt;&gt; 8)
        x73 := (uint8(x72) &amp; 0xff)
        x74 := (x72 &gt;&gt; 8)
        x75 := (uint8(x74) &amp; 0xff)
        x76 := uint8((x74 &gt;&gt; 8))
        x77 := (uint8(x1) &amp; 0xff)
        x78 := (x1 &gt;&gt; 8)
        x79 := (uint8(x78) &amp; 0xff)
        x80 := (x78 &gt;&gt; 8)
        x81 := (uint8(x80) &amp; 0xff)
        x82 := (x80 &gt;&gt; 8)
        x83 := (uint8(x82) &amp; 0xff)
        x84 := (x82 &gt;&gt; 8)
        x85 := (uint8(x84) &amp; 0xff)
        x86 := (x84 &gt;&gt; 8)
        x87 := (uint8(x86) &amp; 0xff)
        x88 := (x86 &gt;&gt; 8)
        x89 := (uint8(x88) &amp; 0xff)
        x90 := uint8((x88 &gt;&gt; 8))
        out1[0] = x7
        out1[1] = x9
        out1[2] = x11
        out1[3] = x13
        out1[4] = x15
        out1[5] = x17
        out1[6] = x19
        out1[7] = x20
        out1[8] = x21
        out1[9] = x23
        out1[10] = x25
        out1[11] = x27
        out1[12] = x29
        out1[13] = x31
        out1[14] = x33
        out1[15] = x34
        out1[16] = x35
        out1[17] = x37
        out1[18] = x39
        out1[19] = x41
        out1[20] = x43
        out1[21] = x45
        out1[22] = x47
        out1[23] = x48
        out1[24] = x49
        out1[25] = x51
        out1[26] = x53
        out1[27] = x55
        out1[28] = x57
        out1[29] = x59
        out1[30] = x61
        out1[31] = x62
        out1[32] = x63
        out1[33] = x65
        out1[34] = x67
        out1[35] = x69
        out1[36] = x71
        out1[37] = x73
        out1[38] = x75
        out1[39] = x76
        out1[40] = x77
        out1[41] = x79
        out1[42] = x81
        out1[43] = x83
        out1[44] = x85
        out1[45] = x87
        out1[46] = x89
        out1[47] = x90
}</span>

// fiatFpFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x1f]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x1fffffffffffffff]]
func fiatFpFromBytes(out1 *[6]uint64, arg1 *[48]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[47]) &lt;&lt; 56)
        x2 := (uint64(arg1[46]) &lt;&lt; 48)
        x3 := (uint64(arg1[45]) &lt;&lt; 40)
        x4 := (uint64(arg1[44]) &lt;&lt; 32)
        x5 := (uint64(arg1[43]) &lt;&lt; 24)
        x6 := (uint64(arg1[42]) &lt;&lt; 16)
        x7 := (uint64(arg1[41]) &lt;&lt; 8)
        x8 := arg1[40]
        x9 := (uint64(arg1[39]) &lt;&lt; 56)
        x10 := (uint64(arg1[38]) &lt;&lt; 48)
        x11 := (uint64(arg1[37]) &lt;&lt; 40)
        x12 := (uint64(arg1[36]) &lt;&lt; 32)
        x13 := (uint64(arg1[35]) &lt;&lt; 24)
        x14 := (uint64(arg1[34]) &lt;&lt; 16)
        x15 := (uint64(arg1[33]) &lt;&lt; 8)
        x16 := arg1[32]
        x17 := (uint64(arg1[31]) &lt;&lt; 56)
        x18 := (uint64(arg1[30]) &lt;&lt; 48)
        x19 := (uint64(arg1[29]) &lt;&lt; 40)
        x20 := (uint64(arg1[28]) &lt;&lt; 32)
        x21 := (uint64(arg1[27]) &lt;&lt; 24)
        x22 := (uint64(arg1[26]) &lt;&lt; 16)
        x23 := (uint64(arg1[25]) &lt;&lt; 8)
        x24 := arg1[24]
        x25 := (uint64(arg1[23]) &lt;&lt; 56)
        x26 := (uint64(arg1[22]) &lt;&lt; 48)
        x27 := (uint64(arg1[21]) &lt;&lt; 40)
        x28 := (uint64(arg1[20]) &lt;&lt; 32)
        x29 := (uint64(arg1[19]) &lt;&lt; 24)
        x30 := (uint64(arg1[18]) &lt;&lt; 16)
        x31 := (uint64(arg1[17]) &lt;&lt; 8)
        x32 := arg1[16]
        x33 := (uint64(arg1[15]) &lt;&lt; 56)
        x34 := (uint64(arg1[14]) &lt;&lt; 48)
        x35 := (uint64(arg1[13]) &lt;&lt; 40)
        x36 := (uint64(arg1[12]) &lt;&lt; 32)
        x37 := (uint64(arg1[11]) &lt;&lt; 24)
        x38 := (uint64(arg1[10]) &lt;&lt; 16)
        x39 := (uint64(arg1[9]) &lt;&lt; 8)
        x40 := arg1[8]
        x41 := (uint64(arg1[7]) &lt;&lt; 56)
        x42 := (uint64(arg1[6]) &lt;&lt; 48)
        x43 := (uint64(arg1[5]) &lt;&lt; 40)
        x44 := (uint64(arg1[4]) &lt;&lt; 32)
        x45 := (uint64(arg1[3]) &lt;&lt; 24)
        x46 := (uint64(arg1[2]) &lt;&lt; 16)
        x47 := (uint64(arg1[1]) &lt;&lt; 8)
        x48 := arg1[0]
        x49 := (x47 + uint64(x48))
        x50 := (x46 + x49)
        x51 := (x45 + x50)
        x52 := (x44 + x51)
        x53 := (x43 + x52)
        x54 := (x42 + x53)
        x55 := (x41 + x54)
        x56 := (x39 + uint64(x40))
        x57 := (x38 + x56)
        x58 := (x37 + x57)
        x59 := (x36 + x58)
        x60 := (x35 + x59)
        x61 := (x34 + x60)
        x62 := (x33 + x61)
        x63 := (x31 + uint64(x32))
        x64 := (x30 + x63)
        x65 := (x29 + x64)
        x66 := (x28 + x65)
        x67 := (x27 + x66)
        x68 := (x26 + x67)
        x69 := (x25 + x68)
        x70 := (x23 + uint64(x24))
        x71 := (x22 + x70)
        x72 := (x21 + x71)
        x73 := (x20 + x72)
        x74 := (x19 + x73)
        x75 := (x18 + x74)
        x76 := (x17 + x75)
        x77 := (x15 + uint64(x16))
        x78 := (x14 + x77)
        x79 := (x13 + x78)
        x80 := (x12 + x79)
        x81 := (x11 + x80)
        x82 := (x10 + x81)
        x83 := (x9 + x82)
        x84 := (x7 + uint64(x8))
        x85 := (x6 + x84)
        x86 := (x5 + x85)
        x87 := (x4 + x86)
        x88 := (x3 + x87)
        x89 := (x2 + x88)
        x90 := (x1 + x89)
        out1[0] = x55
        out1[1] = x62
        out1[2] = x69
        out1[3] = x76
        out1[4] = x83
        out1[5] = x90
}</span>

// fiatFpSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFpSetOne(out1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        out1[0] = 0x760900000002fffd
        out1[1] = 0xebf4000bc40c0002
        out1[2] = 0x5f48985753c758ba
        out1[3] = 0x77ce585370525745
        out1[4] = 0x5c071a97a256ec6d
        out1[5] = 0x15f65ec3fa80e493
}</span>

// fiatFpMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpMsat(out1 *[7]uint64) <span class="cov8" title="1">{
        out1[0] = 0xb9feffffffffaaab
        out1[1] = 0x1eabfffeb153ffff
        out1[2] = 0x6730d2a0f6b0f624
        out1[3] = 0x64774b84f38512bf
        out1[4] = 0x4b1ba7b6434bacd7
        out1[5] = 0x1a0111ea397fe69a
        out1[6] = uint64(0x0)
}</span>

// fiatFpDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpDivstepPrecomp(out1 *[6]uint64) <span class="cov8" title="1">{
        out1[0] = 0x58b20fbd4742924f
        out1[1] = 0x60dc92e7f4c2f437
        out1[2] = 0x3f4fac6a70c73c60
        out1[3] = 0xed47d0696c7bf023
        out1[4] = 0x2a13c3e0fd09a8cb
        out1[5] = 0x1397424c770094ff
}</span>

// fiatFpDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpDivstep(out1 *uint64, out2 *[7]uint64, out3 *[7]uint64, out4 *[6]uint64, out5 *[6]uint64, arg1 uint64, arg2 *[7]uint64, arg3 *[7]uint64, arg4 *[6]uint64, arg5 *[6]uint64) <span class="cov8" title="1">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFpUint1((x1 &gt;&gt; 63)) &amp; (fiatFpUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFpCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFpCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFpCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFpCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFpCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        fiatFpCmovznzU64(&amp;x12, x3, arg2[5], arg3[5])
        var x13 uint64
        fiatFpCmovznzU64(&amp;x13, x3, arg2[6], arg3[6])
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFpUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFpUint1(x17)))
        var x20 uint64
        var x21 uint64
        x20, x21 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFpUint1(x19)))
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFpUint1(x21)))
        var x24 uint64
        var x25 uint64
        x24, x25 = bits.Add64(uint64(0x0), (^arg2[5]), uint64(fiatFpUint1(x23)))
        var x26 uint64
        x26, _ = bits.Add64(uint64(0x0), (^arg2[6]), uint64(fiatFpUint1(x25)))
        var x28 uint64
        fiatFpCmovznzU64(&amp;x28, x3, arg3[0], x14)
        var x29 uint64
        fiatFpCmovznzU64(&amp;x29, x3, arg3[1], x16)
        var x30 uint64
        fiatFpCmovznzU64(&amp;x30, x3, arg3[2], x18)
        var x31 uint64
        fiatFpCmovznzU64(&amp;x31, x3, arg3[3], x20)
        var x32 uint64
        fiatFpCmovznzU64(&amp;x32, x3, arg3[4], x22)
        var x33 uint64
        fiatFpCmovznzU64(&amp;x33, x3, arg3[5], x24)
        var x34 uint64
        fiatFpCmovznzU64(&amp;x34, x3, arg3[6], x26)
        var x35 uint64
        fiatFpCmovznzU64(&amp;x35, x3, arg4[0], arg5[0])
        var x36 uint64
        fiatFpCmovznzU64(&amp;x36, x3, arg4[1], arg5[1])
        var x37 uint64
        fiatFpCmovznzU64(&amp;x37, x3, arg4[2], arg5[2])
        var x38 uint64
        fiatFpCmovznzU64(&amp;x38, x3, arg4[3], arg5[3])
        var x39 uint64
        fiatFpCmovznzU64(&amp;x39, x3, arg4[4], arg5[4])
        var x40 uint64
        fiatFpCmovznzU64(&amp;x40, x3, arg4[5], arg5[5])
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x35, x35, uint64(0x0))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x36, x36, uint64(fiatFpUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x37, x37, uint64(fiatFpUint1(x44)))
        var x47 uint64
        var x48 uint64
        x47, x48 = bits.Add64(x38, x38, uint64(fiatFpUint1(x46)))
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x39, x39, uint64(fiatFpUint1(x48)))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x40, x40, uint64(fiatFpUint1(x50)))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(x41, 0xb9feffffffffaaab, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(x43, 0x1eabfffeb153ffff, uint64(fiatFpUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(x45, 0x6730d2a0f6b0f624, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(x47, 0x64774b84f38512bf, uint64(fiatFpUint1(x58)))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Sub64(x49, 0x4b1ba7b6434bacd7, uint64(fiatFpUint1(x60)))
        var x63 uint64
        var x64 uint64
        x63, x64 = bits.Sub64(x51, 0x1a0111ea397fe69a, uint64(fiatFpUint1(x62)))
        var x66 uint64
        _, x66 = bits.Sub64(uint64(fiatFpUint1(x52)), uint64(0x0), uint64(fiatFpUint1(x64)))
        x67 := arg4[5]
        x68 := arg4[4]
        x69 := arg4[3]
        x70 := arg4[2]
        x71 := arg4[1]
        x72 := arg4[0]
        var x73 uint64
        var x74 uint64
        x73, x74 = bits.Sub64(uint64(0x0), x72, uint64(0x0))
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Sub64(uint64(0x0), x71, uint64(fiatFpUint1(x74)))
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Sub64(uint64(0x0), x70, uint64(fiatFpUint1(x76)))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Sub64(uint64(0x0), x69, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Sub64(uint64(0x0), x68, uint64(fiatFpUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Sub64(uint64(0x0), x67, uint64(fiatFpUint1(x82)))
        var x85 uint64
        fiatFpCmovznzU64(&amp;x85, fiatFpUint1(x84), uint64(0x0), 0xffffffffffffffff)
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x73, (x85 &amp; 0xb9feffffffffaaab), uint64(0x0))
        var x88 uint64
        var x89 uint64
        x88, x89 = bits.Add64(x75, (x85 &amp; 0x1eabfffeb153ffff), uint64(fiatFpUint1(x87)))
        var x90 uint64
        var x91 uint64
        x90, x91 = bits.Add64(x77, (x85 &amp; 0x6730d2a0f6b0f624), uint64(fiatFpUint1(x89)))
        var x92 uint64
        var x93 uint64
        x92, x93 = bits.Add64(x79, (x85 &amp; 0x64774b84f38512bf), uint64(fiatFpUint1(x91)))
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x81, (x85 &amp; 0x4b1ba7b6434bacd7), uint64(fiatFpUint1(x93)))
        var x96 uint64
        x96, _ = bits.Add64(x83, (x85 &amp; 0x1a0111ea397fe69a), uint64(fiatFpUint1(x95)))
        var x98 uint64
        fiatFpCmovznzU64(&amp;x98, x3, arg5[0], x86)
        var x99 uint64
        fiatFpCmovznzU64(&amp;x99, x3, arg5[1], x88)
        var x100 uint64
        fiatFpCmovznzU64(&amp;x100, x3, arg5[2], x90)
        var x101 uint64
        fiatFpCmovznzU64(&amp;x101, x3, arg5[3], x92)
        var x102 uint64
        fiatFpCmovznzU64(&amp;x102, x3, arg5[4], x94)
        var x103 uint64
        fiatFpCmovznzU64(&amp;x103, x3, arg5[5], x96)
        x104 := (fiatFpUint1(x28) &amp; 0x1)
        var x105 uint64
        fiatFpCmovznzU64(&amp;x105, x104, uint64(0x0), x7)
        var x106 uint64
        fiatFpCmovznzU64(&amp;x106, x104, uint64(0x0), x8)
        var x107 uint64
        fiatFpCmovznzU64(&amp;x107, x104, uint64(0x0), x9)
        var x108 uint64
        fiatFpCmovznzU64(&amp;x108, x104, uint64(0x0), x10)
        var x109 uint64
        fiatFpCmovznzU64(&amp;x109, x104, uint64(0x0), x11)
        var x110 uint64
        fiatFpCmovznzU64(&amp;x110, x104, uint64(0x0), x12)
        var x111 uint64
        fiatFpCmovznzU64(&amp;x111, x104, uint64(0x0), x13)
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x28, x105, uint64(0x0))
        var x114 uint64
        var x115 uint64
        x114, x115 = bits.Add64(x29, x106, uint64(fiatFpUint1(x113)))
        var x116 uint64
        var x117 uint64
        x116, x117 = bits.Add64(x30, x107, uint64(fiatFpUint1(x115)))
        var x118 uint64
        var x119 uint64
        x118, x119 = bits.Add64(x31, x108, uint64(fiatFpUint1(x117)))
        var x120 uint64
        var x121 uint64
        x120, x121 = bits.Add64(x32, x109, uint64(fiatFpUint1(x119)))
        var x122 uint64
        var x123 uint64
        x122, x123 = bits.Add64(x33, x110, uint64(fiatFpUint1(x121)))
        var x124 uint64
        x124, _ = bits.Add64(x34, x111, uint64(fiatFpUint1(x123)))
        var x126 uint64
        fiatFpCmovznzU64(&amp;x126, x104, uint64(0x0), x35)
        var x127 uint64
        fiatFpCmovznzU64(&amp;x127, x104, uint64(0x0), x36)
        var x128 uint64
        fiatFpCmovznzU64(&amp;x128, x104, uint64(0x0), x37)
        var x129 uint64
        fiatFpCmovznzU64(&amp;x129, x104, uint64(0x0), x38)
        var x130 uint64
        fiatFpCmovznzU64(&amp;x130, x104, uint64(0x0), x39)
        var x131 uint64
        fiatFpCmovznzU64(&amp;x131, x104, uint64(0x0), x40)
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Add64(x98, x126, uint64(0x0))
        var x134 uint64
        var x135 uint64
        x134, x135 = bits.Add64(x99, x127, uint64(fiatFpUint1(x133)))
        var x136 uint64
        var x137 uint64
        x136, x137 = bits.Add64(x100, x128, uint64(fiatFpUint1(x135)))
        var x138 uint64
        var x139 uint64
        x138, x139 = bits.Add64(x101, x129, uint64(fiatFpUint1(x137)))
        var x140 uint64
        var x141 uint64
        x140, x141 = bits.Add64(x102, x130, uint64(fiatFpUint1(x139)))
        var x142 uint64
        var x143 uint64
        x142, x143 = bits.Add64(x103, x131, uint64(fiatFpUint1(x141)))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Sub64(x132, 0xb9feffffffffaaab, uint64(0x0))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Sub64(x134, 0x1eabfffeb153ffff, uint64(fiatFpUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Sub64(x136, 0x6730d2a0f6b0f624, uint64(fiatFpUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Sub64(x138, 0x64774b84f38512bf, uint64(fiatFpUint1(x149)))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Sub64(x140, 0x4b1ba7b6434bacd7, uint64(fiatFpUint1(x151)))
        var x154 uint64
        var x155 uint64
        x154, x155 = bits.Sub64(x142, 0x1a0111ea397fe69a, uint64(fiatFpUint1(x153)))
        var x157 uint64
        _, x157 = bits.Sub64(uint64(fiatFpUint1(x143)), uint64(0x0), uint64(fiatFpUint1(x155)))
        var x158 uint64
        x158, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x160 := ((x112 &gt;&gt; 1) | ((x114 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x161 := ((x114 &gt;&gt; 1) | ((x116 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x162 := ((x116 &gt;&gt; 1) | ((x118 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x163 := ((x118 &gt;&gt; 1) | ((x120 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x164 := ((x120 &gt;&gt; 1) | ((x122 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x165 := ((x122 &gt;&gt; 1) | ((x124 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x166 := ((x124 &amp; 0x8000000000000000) | (x124 &gt;&gt; 1))
        var x167 uint64
        fiatFpCmovznzU64(&amp;x167, fiatFpUint1(x66), x53, x41)
        var x168 uint64
        fiatFpCmovznzU64(&amp;x168, fiatFpUint1(x66), x55, x43)
        var x169 uint64
        fiatFpCmovznzU64(&amp;x169, fiatFpUint1(x66), x57, x45)
        var x170 uint64
        fiatFpCmovznzU64(&amp;x170, fiatFpUint1(x66), x59, x47)
        var x171 uint64
        fiatFpCmovznzU64(&amp;x171, fiatFpUint1(x66), x61, x49)
        var x172 uint64
        fiatFpCmovznzU64(&amp;x172, fiatFpUint1(x66), x63, x51)
        var x173 uint64
        fiatFpCmovznzU64(&amp;x173, fiatFpUint1(x157), x144, x132)
        var x174 uint64
        fiatFpCmovznzU64(&amp;x174, fiatFpUint1(x157), x146, x134)
        var x175 uint64
        fiatFpCmovznzU64(&amp;x175, fiatFpUint1(x157), x148, x136)
        var x176 uint64
        fiatFpCmovznzU64(&amp;x176, fiatFpUint1(x157), x150, x138)
        var x177 uint64
        fiatFpCmovznzU64(&amp;x177, fiatFpUint1(x157), x152, x140)
        var x178 uint64
        fiatFpCmovznzU64(&amp;x178, fiatFpUint1(x157), x154, x142)
        *out1 = x158
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out2[5] = x12
        out2[6] = x13
        out3[0] = x160
        out3[1] = x161
        out3[2] = x162
        out3[3] = x163
        out3[4] = x164
        out3[5] = x165
        out3[6] = x166
        out4[0] = x167
        out4[1] = x168
        out4[2] = x169
        out4[3] = x170
        out4[4] = x171
        out4[5] = x172
        out5[0] = x173
        out5[1] = x174
        out5[2] = x175
        out5[3] = x176
        out5[4] = x177
        out5[5] = x178
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fq 64 0x73EDA753299D7D483339D80809A1D80553BDA402FFFE5BFEFFFFFFFF00000001
//
// curve description: Fq
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001 (from "0x73EDA753299D7D483339D80809A1D80553BDA402FFFE5BFEFFFFFFFF00000001")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) in
//
//                            if x1 &amp; (2^256-1) &lt; 2^255 then x1 &amp; (2^256-1) else (x1 &amp; (2^256-1)) - 2^256
package impl

import "math/bits"

type fiatFqUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFqInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFqMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqMontgomeryDomainFieldElement [4]uint64

// fiatFqNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqNonMontgomeryDomainFieldElement [4]uint64

// fiatFqCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqCmovznzU64(out1 *uint64, arg1 fiatFqUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFqMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqMul(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg2[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg2[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg2[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg2[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0xfffffffeffffffff)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0x73eda753299d7d48)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0x3339d80809a1d805)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0x53bda402fffe5bfe)
        var x28 uint64
        var x29 uint64
        x29, x28 = bits.Mul64(x20, 0xffffffff00000001)
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x29, x26, uint64(0x0))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x27, x24, uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x25, x22, uint64(fiatFqUint1(x33)))
        x36 := (uint64(fiatFqUint1(x35)) + x23)
        var x38 uint64
        _, x38 = bits.Add64(x11, x28, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x13, x30, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x15, x32, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x17, x34, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x19, x36, uint64(fiatFqUint1(x44)))
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg2[3])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, arg2[2])
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, arg2[1])
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x1, arg2[0])
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x54, x51, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x52, x49, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x50, x47, uint64(fiatFqUint1(x58)))
        x61 := (uint64(fiatFqUint1(x60)) + x48)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x41, x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x43, x57, uint64(fiatFqUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x45, x59, uint64(fiatFqUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(uint64(fiatFqUint1(x46)), x61, uint64(fiatFqUint1(x69)))
        var x72 uint64
        _, x72 = bits.Mul64(x62, 0xfffffffeffffffff)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x72, 0x73eda753299d7d48)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x72, 0x3339d80809a1d805)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x72, 0x53bda402fffe5bfe)
        var x80 uint64
        var x81 uint64
        x81, x80 = bits.Mul64(x72, 0xffffffff00000001)
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x81, x78, uint64(0x0))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x79, x76, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x77, x74, uint64(fiatFqUint1(x85)))
        x88 := (uint64(fiatFqUint1(x87)) + x75)
        var x90 uint64
        _, x90 = bits.Add64(x62, x80, uint64(0x0))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x64, x82, uint64(fiatFqUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x66, x84, uint64(fiatFqUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x68, x86, uint64(fiatFqUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x70, x88, uint64(fiatFqUint1(x96)))
        x99 := (uint64(fiatFqUint1(x98)) + uint64(fiatFqUint1(x71)))
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x2, arg2[3])
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x2, arg2[2])
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x2, arg2[1])
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x2, arg2[0])
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFqUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFqUint1(x111)))
        x114 := (uint64(fiatFqUint1(x113)) + x101)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x91, x106, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x93, x108, uint64(fiatFqUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x95, x110, uint64(fiatFqUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x97, x112, uint64(fiatFqUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x99, x114, uint64(fiatFqUint1(x122)))
        var x125 uint64
        _, x125 = bits.Mul64(x115, 0xfffffffeffffffff)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x125, 0x73eda753299d7d48)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x125, 0x3339d80809a1d805)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x125, 0x53bda402fffe5bfe)
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x125, 0xffffffff00000001)
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x134, x131, uint64(0x0))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x132, x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x130, x127, uint64(fiatFqUint1(x138)))
        x141 := (uint64(fiatFqUint1(x140)) + x128)
        var x143 uint64
        _, x143 = bits.Add64(x115, x133, uint64(0x0))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x117, x135, uint64(fiatFqUint1(x143)))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x119, x137, uint64(fiatFqUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x121, x139, uint64(fiatFqUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x123, x141, uint64(fiatFqUint1(x149)))
        x152 := (uint64(fiatFqUint1(x151)) + uint64(fiatFqUint1(x124)))
        var x153 uint64
        var x154 uint64
        x154, x153 = bits.Mul64(x3, arg2[3])
        var x155 uint64
        var x156 uint64
        x156, x155 = bits.Mul64(x3, arg2[2])
        var x157 uint64
        var x158 uint64
        x158, x157 = bits.Mul64(x3, arg2[1])
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x3, arg2[0])
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x160, x157, uint64(0x0))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x158, x155, uint64(fiatFqUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x156, x153, uint64(fiatFqUint1(x164)))
        x167 := (uint64(fiatFqUint1(x166)) + x154)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x144, x159, uint64(0x0))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x146, x161, uint64(fiatFqUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x148, x163, uint64(fiatFqUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64(x150, x165, uint64(fiatFqUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x152, x167, uint64(fiatFqUint1(x175)))
        var x178 uint64
        _, x178 = bits.Mul64(x168, 0xfffffffeffffffff)
        var x180 uint64
        var x181 uint64
        x181, x180 = bits.Mul64(x178, 0x73eda753299d7d48)
        var x182 uint64
        var x183 uint64
        x183, x182 = bits.Mul64(x178, 0x3339d80809a1d805)
        var x184 uint64
        var x185 uint64
        x185, x184 = bits.Mul64(x178, 0x53bda402fffe5bfe)
        var x186 uint64
        var x187 uint64
        x187, x186 = bits.Mul64(x178, 0xffffffff00000001)
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Add64(x187, x184, uint64(0x0))
        var x190 uint64
        var x191 uint64
        x190, x191 = bits.Add64(x185, x182, uint64(fiatFqUint1(x189)))
        var x192 uint64
        var x193 uint64
        x192, x193 = bits.Add64(x183, x180, uint64(fiatFqUint1(x191)))
        x194 := (uint64(fiatFqUint1(x193)) + x181)
        var x196 uint64
        _, x196 = bits.Add64(x168, x186, uint64(0x0))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x170, x188, uint64(fiatFqUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x172, x190, uint64(fiatFqUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x174, x192, uint64(fiatFqUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x176, x194, uint64(fiatFqUint1(x202)))
        x205 := (uint64(fiatFqUint1(x204)) + uint64(fiatFqUint1(x177)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Sub64(x197, 0xffffffff00000001, uint64(0x0))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Sub64(x199, 0x53bda402fffe5bfe, uint64(fiatFqUint1(x207)))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Sub64(x201, 0x3339d80809a1d805, uint64(fiatFqUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Sub64(x203, 0x73eda753299d7d48, uint64(fiatFqUint1(x211)))
        var x215 uint64
        _, x215 = bits.Sub64(x205, uint64(0x0), uint64(fiatFqUint1(x213)))
        var x216 uint64
        fiatFqCmovznzU64(&amp;x216, fiatFqUint1(x215), x206, x197)
        var x217 uint64
        fiatFqCmovznzU64(&amp;x217, fiatFqUint1(x215), x208, x199)
        var x218 uint64
        fiatFqCmovznzU64(&amp;x218, fiatFqUint1(x215), x210, x201)
        var x219 uint64
        fiatFqCmovznzU64(&amp;x219, fiatFqUint1(x215), x212, x203)
        out1[0] = x216
        out1[1] = x217
        out1[2] = x218
        out1[3] = x219
}</span>

// fiatFqSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSquare(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg1[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg1[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg1[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg1[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0xfffffffeffffffff)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0x73eda753299d7d48)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0x3339d80809a1d805)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0x53bda402fffe5bfe)
        var x28 uint64
        var x29 uint64
        x29, x28 = bits.Mul64(x20, 0xffffffff00000001)
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x29, x26, uint64(0x0))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x27, x24, uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x25, x22, uint64(fiatFqUint1(x33)))
        x36 := (uint64(fiatFqUint1(x35)) + x23)
        var x38 uint64
        _, x38 = bits.Add64(x11, x28, uint64(0x0))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x13, x30, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x15, x32, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Add64(x17, x34, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x19, x36, uint64(fiatFqUint1(x44)))
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg1[3])
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, arg1[2])
        var x51 uint64
        var x52 uint64
        x52, x51 = bits.Mul64(x1, arg1[1])
        var x53 uint64
        var x54 uint64
        x54, x53 = bits.Mul64(x1, arg1[0])
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x54, x51, uint64(0x0))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x52, x49, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x50, x47, uint64(fiatFqUint1(x58)))
        x61 := (uint64(fiatFqUint1(x60)) + x48)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x41, x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x43, x57, uint64(fiatFqUint1(x65)))
        var x68 uint64
        var x69 uint64
        x68, x69 = bits.Add64(x45, x59, uint64(fiatFqUint1(x67)))
        var x70 uint64
        var x71 uint64
        x70, x71 = bits.Add64(uint64(fiatFqUint1(x46)), x61, uint64(fiatFqUint1(x69)))
        var x72 uint64
        _, x72 = bits.Mul64(x62, 0xfffffffeffffffff)
        var x74 uint64
        var x75 uint64
        x75, x74 = bits.Mul64(x72, 0x73eda753299d7d48)
        var x76 uint64
        var x77 uint64
        x77, x76 = bits.Mul64(x72, 0x3339d80809a1d805)
        var x78 uint64
        var x79 uint64
        x79, x78 = bits.Mul64(x72, 0x53bda402fffe5bfe)
        var x80 uint64
        var x81 uint64
        x81, x80 = bits.Mul64(x72, 0xffffffff00000001)
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x81, x78, uint64(0x0))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x79, x76, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x77, x74, uint64(fiatFqUint1(x85)))
        x88 := (uint64(fiatFqUint1(x87)) + x75)
        var x90 uint64
        _, x90 = bits.Add64(x62, x80, uint64(0x0))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x64, x82, uint64(fiatFqUint1(x90)))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x66, x84, uint64(fiatFqUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x68, x86, uint64(fiatFqUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x70, x88, uint64(fiatFqUint1(x96)))
        x99 := (uint64(fiatFqUint1(x98)) + uint64(fiatFqUint1(x71)))
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x2, arg1[3])
        var x102 uint64
        var x103 uint64
        x103, x102 = bits.Mul64(x2, arg1[2])
        var x104 uint64
        var x105 uint64
        x105, x104 = bits.Mul64(x2, arg1[1])
        var x106 uint64
        var x107 uint64
        x107, x106 = bits.Mul64(x2, arg1[0])
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Add64(x107, x104, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x105, x102, uint64(fiatFqUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x103, x100, uint64(fiatFqUint1(x111)))
        x114 := (uint64(fiatFqUint1(x113)) + x101)
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x91, x106, uint64(0x0))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Add64(x93, x108, uint64(fiatFqUint1(x116)))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Add64(x95, x110, uint64(fiatFqUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x97, x112, uint64(fiatFqUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x99, x114, uint64(fiatFqUint1(x122)))
        var x125 uint64
        _, x125 = bits.Mul64(x115, 0xfffffffeffffffff)
        var x127 uint64
        var x128 uint64
        x128, x127 = bits.Mul64(x125, 0x73eda753299d7d48)
        var x129 uint64
        var x130 uint64
        x130, x129 = bits.Mul64(x125, 0x3339d80809a1d805)
        var x131 uint64
        var x132 uint64
        x132, x131 = bits.Mul64(x125, 0x53bda402fffe5bfe)
        var x133 uint64
        var x134 uint64
        x134, x133 = bits.Mul64(x125, 0xffffffff00000001)
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x134, x131, uint64(0x0))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(x132, x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        var x140 uint64
        x139, x140 = bits.Add64(x130, x127, uint64(fiatFqUint1(x138)))
        x141 := (uint64(fiatFqUint1(x140)) + x128)
        var x143 uint64
        _, x143 = bits.Add64(x115, x133, uint64(0x0))
        var x144 uint64
        var x145 uint64
        x144, x145 = bits.Add64(x117, x135, uint64(fiatFqUint1(x143)))
        var x146 uint64
        var x147 uint64
        x146, x147 = bits.Add64(x119, x137, uint64(fiatFqUint1(x145)))
        var x148 uint64
        var x149 uint64
        x148, x149 = bits.Add64(x121, x139, uint64(fiatFqUint1(x147)))
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x123, x141, uint64(fiatFqUint1(x149)))
        x152 := (uint64(fiatFqUint1(x151)) + uint64(fiatFqUint1(x124)))
        var x153 uint64
        var x154 uint64
        x154, x153 = bits.Mul64(x3, arg1[3])
        var x155 uint64
        var x156 uint64
        x156, x155 = bits.Mul64(x3, arg1[2])
        var x157 uint64
        var x158 uint64
        x158, x157 = bits.Mul64(x3, arg1[1])
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x3, arg1[0])
        var x161 uint64
        var x162 uint64
        x161, x162 = bits.Add64(x160, x157, uint64(0x0))
        var x163 uint64
        var x164 uint64
        x163, x164 = bits.Add64(x158, x155, uint64(fiatFqUint1(x162)))
        var x165 uint64
        var x166 uint64
        x165, x166 = bits.Add64(x156, x153, uint64(fiatFqUint1(x164)))
        x167 := (uint64(fiatFqUint1(x166)) + x154)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x144, x159, uint64(0x0))
        var x170 uint64
        var x171 uint64
        x170, x171 = bits.Add64(x146, x161, uint64(fiatFqUint1(x169)))
        var x172 uint64
        var x173 uint64
        x172, x173 = bits.Add64(x148, x163, uint64(fiatFqUint1(x171)))
        var x174 uint64
        var x175 uint64
        x174, x175 = bits.Add64(x150, x165, uint64(fiatFqUint1(x173)))
        var x176 uint64
        var x177 uint64
        x176, x177 = bits.Add64(x152, x167, uint64(fiatFqUint1(x175)))
        var x178 uint64
        _, x178 = bits.Mul64(x168, 0xfffffffeffffffff)
        var x180 uint64
        var x181 uint64
        x181, x180 = bits.Mul64(x178, 0x73eda753299d7d48)
        var x182 uint64
        var x183 uint64
        x183, x182 = bits.Mul64(x178, 0x3339d80809a1d805)
        var x184 uint64
        var x185 uint64
        x185, x184 = bits.Mul64(x178, 0x53bda402fffe5bfe)
        var x186 uint64
        var x187 uint64
        x187, x186 = bits.Mul64(x178, 0xffffffff00000001)
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Add64(x187, x184, uint64(0x0))
        var x190 uint64
        var x191 uint64
        x190, x191 = bits.Add64(x185, x182, uint64(fiatFqUint1(x189)))
        var x192 uint64
        var x193 uint64
        x192, x193 = bits.Add64(x183, x180, uint64(fiatFqUint1(x191)))
        x194 := (uint64(fiatFqUint1(x193)) + x181)
        var x196 uint64
        _, x196 = bits.Add64(x168, x186, uint64(0x0))
        var x197 uint64
        var x198 uint64
        x197, x198 = bits.Add64(x170, x188, uint64(fiatFqUint1(x196)))
        var x199 uint64
        var x200 uint64
        x199, x200 = bits.Add64(x172, x190, uint64(fiatFqUint1(x198)))
        var x201 uint64
        var x202 uint64
        x201, x202 = bits.Add64(x174, x192, uint64(fiatFqUint1(x200)))
        var x203 uint64
        var x204 uint64
        x203, x204 = bits.Add64(x176, x194, uint64(fiatFqUint1(x202)))
        x205 := (uint64(fiatFqUint1(x204)) + uint64(fiatFqUint1(x177)))
        var x206 uint64
        var x207 uint64
        x206, x207 = bits.Sub64(x197, 0xffffffff00000001, uint64(0x0))
        var x208 uint64
        var x209 uint64
        x208, x209 = bits.Sub64(x199, 0x53bda402fffe5bfe, uint64(fiatFqUint1(x207)))
        var x210 uint64
        var x211 uint64
        x210, x211 = bits.Sub64(x201, 0x3339d80809a1d805, uint64(fiatFqUint1(x209)))
        var x212 uint64
        var x213 uint64
        x212, x213 = bits.Sub64(x203, 0x73eda753299d7d48, uint64(fiatFqUint1(x211)))
        var x215 uint64
        _, x215 = bits.Sub64(x205, uint64(0x0), uint64(fiatFqUint1(x213)))
        var x216 uint64
        fiatFqCmovznzU64(&amp;x216, fiatFqUint1(x215), x206, x197)
        var x217 uint64
        fiatFqCmovznzU64(&amp;x217, fiatFqUint1(x215), x208, x199)
        var x218 uint64
        fiatFqCmovznzU64(&amp;x218, fiatFqUint1(x215), x210, x201)
        var x219 uint64
        fiatFqCmovznzU64(&amp;x219, fiatFqUint1(x215), x212, x203)
        out1[0] = x216
        out1[1] = x217
        out1[2] = x218
        out1[3] = x219
}</span>

// fiatFqAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqAdd(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(x1, 0xffffffff00000001, uint64(0x0))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(x3, 0x53bda402fffe5bfe, uint64(fiatFqUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x5, 0x3339d80809a1d805, uint64(fiatFqUint1(x12)))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x7, 0x73eda753299d7d48, uint64(fiatFqUint1(x14)))
        var x18 uint64
        _, x18 = bits.Sub64(uint64(fiatFqUint1(x8)), uint64(0x0), uint64(fiatFqUint1(x16)))
        var x19 uint64
        fiatFqCmovznzU64(&amp;x19, fiatFqUint1(x18), x9, x1)
        var x20 uint64
        fiatFqCmovznzU64(&amp;x20, fiatFqUint1(x18), x11, x3)
        var x21 uint64
        fiatFqCmovznzU64(&amp;x21, fiatFqUint1(x18), x13, x5)
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, fiatFqUint1(x18), x15, x7)
        out1[0] = x19
        out1[1] = x20
        out1[2] = x21
        out1[3] = x22
}</span>

// fiatFqSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSub(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0xffffffff00000001), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0x53bda402fffe5bfe), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, (x9 &amp; 0x3339d80809a1d805), uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0x73eda753299d7d48), uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFqOpp(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0xffffffff00000001), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0x53bda402fffe5bfe), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, (x9 &amp; 0x3339d80809a1d805), uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0x73eda753299d7d48), uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^4) mod m
//   0  eval out1 &lt; m
//
func fiatFqFromMontgomery(out1 *fiatFqNonMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        x1 := arg1[0]
        var x2 uint64
        _, x2 = bits.Mul64(x1, 0xfffffffeffffffff)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x2, 0x73eda753299d7d48)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x2, 0x3339d80809a1d805)
        var x8 uint64
        var x9 uint64
        x9, x8 = bits.Mul64(x2, 0x53bda402fffe5bfe)
        var x10 uint64
        var x11 uint64
        x11, x10 = bits.Mul64(x2, 0xffffffff00000001)
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x11, x8, uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x9, x6, uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x7, x4, uint64(fiatFqUint1(x15)))
        var x19 uint64
        _, x19 = bits.Add64(x1, x10, uint64(0x0))
        var x20 uint64
        var x21 uint64
        x20, x21 = bits.Add64(uint64(0x0), x12, uint64(fiatFqUint1(x19)))
        var x22 uint64
        var x23 uint64
        x22, x23 = bits.Add64(uint64(0x0), x14, uint64(fiatFqUint1(x21)))
        var x24 uint64
        var x25 uint64
        x24, x25 = bits.Add64(uint64(0x0), x16, uint64(fiatFqUint1(x23)))
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(x20, arg1[1], uint64(0x0))
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x22, uint64(0x0), uint64(fiatFqUint1(x27)))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64(x24, uint64(0x0), uint64(fiatFqUint1(x29)))
        var x32 uint64
        _, x32 = bits.Mul64(x26, 0xfffffffeffffffff)
        var x34 uint64
        var x35 uint64
        x35, x34 = bits.Mul64(x32, 0x73eda753299d7d48)
        var x36 uint64
        var x37 uint64
        x37, x36 = bits.Mul64(x32, 0x3339d80809a1d805)
        var x38 uint64
        var x39 uint64
        x39, x38 = bits.Mul64(x32, 0x53bda402fffe5bfe)
        var x40 uint64
        var x41 uint64
        x41, x40 = bits.Mul64(x32, 0xffffffff00000001)
        var x42 uint64
        var x43 uint64
        x42, x43 = bits.Add64(x41, x38, uint64(0x0))
        var x44 uint64
        var x45 uint64
        x44, x45 = bits.Add64(x39, x36, uint64(fiatFqUint1(x43)))
        var x46 uint64
        var x47 uint64
        x46, x47 = bits.Add64(x37, x34, uint64(fiatFqUint1(x45)))
        var x49 uint64
        _, x49 = bits.Add64(x26, x40, uint64(0x0))
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x28, x42, uint64(fiatFqUint1(x49)))
        var x52 uint64
        var x53 uint64
        x52, x53 = bits.Add64(x30, x44, uint64(fiatFqUint1(x51)))
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64((uint64(fiatFqUint1(x31)) + (uint64(fiatFqUint1(x25)) + (uint64(fiatFqUint1(x17)) + x5))), x46, uint64(fiatFqUint1(x53)))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x50, arg1[2], uint64(0x0))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x52, uint64(0x0), uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x54, uint64(0x0), uint64(fiatFqUint1(x59)))
        var x62 uint64
        _, x62 = bits.Mul64(x56, 0xfffffffeffffffff)
        var x64 uint64
        var x65 uint64
        x65, x64 = bits.Mul64(x62, 0x73eda753299d7d48)
        var x66 uint64
        var x67 uint64
        x67, x66 = bits.Mul64(x62, 0x3339d80809a1d805)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x62, 0x53bda402fffe5bfe)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x62, 0xffffffff00000001)
        var x72 uint64
        var x73 uint64
        x72, x73 = bits.Add64(x71, x68, uint64(0x0))
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x69, x66, uint64(fiatFqUint1(x73)))
        var x76 uint64
        var x77 uint64
        x76, x77 = bits.Add64(x67, x64, uint64(fiatFqUint1(x75)))
        var x79 uint64
        _, x79 = bits.Add64(x56, x70, uint64(0x0))
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x58, x72, uint64(fiatFqUint1(x79)))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x60, x74, uint64(fiatFqUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64((uint64(fiatFqUint1(x61)) + (uint64(fiatFqUint1(x55)) + (uint64(fiatFqUint1(x47)) + x35))), x76, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x80, arg1[3], uint64(0x0))
        var x88 uint64
        var x89 uint64
        x88, x89 = bits.Add64(x82, uint64(0x0), uint64(fiatFqUint1(x87)))
        var x90 uint64
        var x91 uint64
        x90, x91 = bits.Add64(x84, uint64(0x0), uint64(fiatFqUint1(x89)))
        var x92 uint64
        _, x92 = bits.Mul64(x86, 0xfffffffeffffffff)
        var x94 uint64
        var x95 uint64
        x95, x94 = bits.Mul64(x92, 0x73eda753299d7d48)
        var x96 uint64
        var x97 uint64
        x97, x96 = bits.Mul64(x92, 0x3339d80809a1d805)
        var x98 uint64
        var x99 uint64
        x99, x98 = bits.Mul64(x92, 0x53bda402fffe5bfe)
        var x100 uint64
        var x101 uint64
        x101, x100 = bits.Mul64(x92, 0xffffffff00000001)
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Add64(x101, x98, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Add64(x99, x96, uint64(fiatFqUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Add64(x97, x94, uint64(fiatFqUint1(x105)))
        var x109 uint64
        _, x109 = bits.Add64(x86, x100, uint64(0x0))
        var x110 uint64
        var x111 uint64
        x110, x111 = bits.Add64(x88, x102, uint64(fiatFqUint1(x109)))
        var x112 uint64
        var x113 uint64
        x112, x113 = bits.Add64(x90, x104, uint64(fiatFqUint1(x111)))
        var x114 uint64
        var x115 uint64
        x114, x115 = bits.Add64((uint64(fiatFqUint1(x91)) + (uint64(fiatFqUint1(x85)) + (uint64(fiatFqUint1(x77)) + x65))), x106, uint64(fiatFqUint1(x113)))
        x116 := (uint64(fiatFqUint1(x115)) + (uint64(fiatFqUint1(x107)) + x95))
        var x117 uint64
        var x118 uint64
        x117, x118 = bits.Sub64(x110, 0xffffffff00000001, uint64(0x0))
        var x119 uint64
        var x120 uint64
        x119, x120 = bits.Sub64(x112, 0x53bda402fffe5bfe, uint64(fiatFqUint1(x118)))
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Sub64(x114, 0x3339d80809a1d805, uint64(fiatFqUint1(x120)))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Sub64(x116, 0x73eda753299d7d48, uint64(fiatFqUint1(x122)))
        var x126 uint64
        _, x126 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFqUint1(x124)))
        var x127 uint64
        fiatFqCmovznzU64(&amp;x127, fiatFqUint1(x126), x117, x110)
        var x128 uint64
        fiatFqCmovznzU64(&amp;x128, fiatFqUint1(x126), x119, x112)
        var x129 uint64
        fiatFqCmovznzU64(&amp;x129, fiatFqUint1(x126), x121, x114)
        var x130 uint64
        fiatFqCmovznzU64(&amp;x130, fiatFqUint1(x126), x123, x116)
        out1[0] = x127
        out1[1] = x128
        out1[2] = x129
        out1[3] = x130
}</span>

// fiatFqToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFqToMontgomery(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, 0x748d9d99f59ff11)
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, 0x5d314967254398f)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, 0x2b6cedcb87925c23)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, 0xc999e990f3f29c6d)
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        var x19 uint64
        _, x19 = bits.Mul64(x11, 0xfffffffeffffffff)
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(x19, 0x73eda753299d7d48)
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(x19, 0x3339d80809a1d805)
        var x25 uint64
        var x26 uint64
        x26, x25 = bits.Mul64(x19, 0x53bda402fffe5bfe)
        var x27 uint64
        var x28 uint64
        x28, x27 = bits.Mul64(x19, 0xffffffff00000001)
        var x29 uint64
        var x30 uint64
        x29, x30 = bits.Add64(x28, x25, uint64(0x0))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x26, x23, uint64(fiatFqUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x24, x21, uint64(fiatFqUint1(x32)))
        var x36 uint64
        _, x36 = bits.Add64(x11, x27, uint64(0x0))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x13, x29, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x15, x31, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Add64(x17, x33, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, 0x748d9d99f59ff11)
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, 0x5d314967254398f)
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, 0x2b6cedcb87925c23)
        var x49 uint64
        var x50 uint64
        x50, x49 = bits.Mul64(x1, 0xc999e990f3f29c6d)
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x50, x47, uint64(0x0))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x48, x45, uint64(fiatFqUint1(x52)))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x46, x43, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(x37, x49, uint64(0x0))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Add64(x39, x51, uint64(fiatFqUint1(x58)))
        var x61 uint64
        var x62 uint64
        x61, x62 = bits.Add64(x41, x53, uint64(fiatFqUint1(x60)))
        var x63 uint64
        var x64 uint64
        x63, x64 = bits.Add64(((uint64(fiatFqUint1(x42)) + (uint64(fiatFqUint1(x18)) + x6)) + (uint64(fiatFqUint1(x34)) + x22)), x55, uint64(fiatFqUint1(x62)))
        var x65 uint64
        _, x65 = bits.Mul64(x57, 0xfffffffeffffffff)
        var x67 uint64
        var x68 uint64
        x68, x67 = bits.Mul64(x65, 0x73eda753299d7d48)
        var x69 uint64
        var x70 uint64
        x70, x69 = bits.Mul64(x65, 0x3339d80809a1d805)
        var x71 uint64
        var x72 uint64
        x72, x71 = bits.Mul64(x65, 0x53bda402fffe5bfe)
        var x73 uint64
        var x74 uint64
        x74, x73 = bits.Mul64(x65, 0xffffffff00000001)
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Add64(x74, x71, uint64(0x0))
        var x77 uint64
        var x78 uint64
        x77, x78 = bits.Add64(x72, x69, uint64(fiatFqUint1(x76)))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x70, x67, uint64(fiatFqUint1(x78)))
        var x82 uint64
        _, x82 = bits.Add64(x57, x73, uint64(0x0))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x59, x75, uint64(fiatFqUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x61, x77, uint64(fiatFqUint1(x84)))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x63, x79, uint64(fiatFqUint1(x86)))
        var x89 uint64
        var x90 uint64
        x90, x89 = bits.Mul64(x2, 0x748d9d99f59ff11)
        var x91 uint64
        var x92 uint64
        x92, x91 = bits.Mul64(x2, 0x5d314967254398f)
        var x93 uint64
        var x94 uint64
        x94, x93 = bits.Mul64(x2, 0x2b6cedcb87925c23)
        var x95 uint64
        var x96 uint64
        x96, x95 = bits.Mul64(x2, 0xc999e990f3f29c6d)
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(x96, x93, uint64(0x0))
        var x99 uint64
        var x100 uint64
        x99, x100 = bits.Add64(x94, x91, uint64(fiatFqUint1(x98)))
        var x101 uint64
        var x102 uint64
        x101, x102 = bits.Add64(x92, x89, uint64(fiatFqUint1(x100)))
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x83, x95, uint64(0x0))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x85, x97, uint64(fiatFqUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x87, x99, uint64(fiatFqUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(((uint64(fiatFqUint1(x88)) + (uint64(fiatFqUint1(x64)) + (uint64(fiatFqUint1(x56)) + x44))) + (uint64(fiatFqUint1(x80)) + x68)), x101, uint64(fiatFqUint1(x108)))
        var x111 uint64
        _, x111 = bits.Mul64(x103, 0xfffffffeffffffff)
        var x113 uint64
        var x114 uint64
        x114, x113 = bits.Mul64(x111, 0x73eda753299d7d48)
        var x115 uint64
        var x116 uint64
        x116, x115 = bits.Mul64(x111, 0x3339d80809a1d805)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x111, 0x53bda402fffe5bfe)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x111, 0xffffffff00000001)
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x120, x117, uint64(0x0))
        var x123 uint64
        var x124 uint64
        x123, x124 = bits.Add64(x118, x115, uint64(fiatFqUint1(x122)))
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x116, x113, uint64(fiatFqUint1(x124)))
        var x128 uint64
        _, x128 = bits.Add64(x103, x119, uint64(0x0))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x105, x121, uint64(fiatFqUint1(x128)))
        var x131 uint64
        var x132 uint64
        x131, x132 = bits.Add64(x107, x123, uint64(fiatFqUint1(x130)))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x109, x125, uint64(fiatFqUint1(x132)))
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, 0x748d9d99f59ff11)
        var x137 uint64
        var x138 uint64
        x138, x137 = bits.Mul64(x3, 0x5d314967254398f)
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x3, 0x2b6cedcb87925c23)
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, 0xc999e990f3f29c6d)
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x142, x139, uint64(0x0))
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x140, x137, uint64(fiatFqUint1(x144)))
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x138, x135, uint64(fiatFqUint1(x146)))
        var x149 uint64
        var x150 uint64
        x149, x150 = bits.Add64(x129, x141, uint64(0x0))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Add64(x131, x143, uint64(fiatFqUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Add64(x133, x145, uint64(fiatFqUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Add64(((uint64(fiatFqUint1(x134)) + (uint64(fiatFqUint1(x110)) + (uint64(fiatFqUint1(x102)) + x90))) + (uint64(fiatFqUint1(x126)) + x114)), x147, uint64(fiatFqUint1(x154)))
        var x157 uint64
        _, x157 = bits.Mul64(x149, 0xfffffffeffffffff)
        var x159 uint64
        var x160 uint64
        x160, x159 = bits.Mul64(x157, 0x73eda753299d7d48)
        var x161 uint64
        var x162 uint64
        x162, x161 = bits.Mul64(x157, 0x3339d80809a1d805)
        var x163 uint64
        var x164 uint64
        x164, x163 = bits.Mul64(x157, 0x53bda402fffe5bfe)
        var x165 uint64
        var x166 uint64
        x166, x165 = bits.Mul64(x157, 0xffffffff00000001)
        var x167 uint64
        var x168 uint64
        x167, x168 = bits.Add64(x166, x163, uint64(0x0))
        var x169 uint64
        var x170 uint64
        x169, x170 = bits.Add64(x164, x161, uint64(fiatFqUint1(x168)))
        var x171 uint64
        var x172 uint64
        x171, x172 = bits.Add64(x162, x159, uint64(fiatFqUint1(x170)))
        var x174 uint64
        _, x174 = bits.Add64(x149, x165, uint64(0x0))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x151, x167, uint64(fiatFqUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x153, x169, uint64(fiatFqUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x155, x171, uint64(fiatFqUint1(x178)))
        x181 := ((uint64(fiatFqUint1(x180)) + (uint64(fiatFqUint1(x156)) + (uint64(fiatFqUint1(x148)) + x136))) + (uint64(fiatFqUint1(x172)) + x160))
        var x182 uint64
        var x183 uint64
        x182, x183 = bits.Sub64(x175, 0xffffffff00000001, uint64(0x0))
        var x184 uint64
        var x185 uint64
        x184, x185 = bits.Sub64(x177, 0x53bda402fffe5bfe, uint64(fiatFqUint1(x183)))
        var x186 uint64
        var x187 uint64
        x186, x187 = bits.Sub64(x179, 0x3339d80809a1d805, uint64(fiatFqUint1(x185)))
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Sub64(x181, 0x73eda753299d7d48, uint64(fiatFqUint1(x187)))
        var x191 uint64
        _, x191 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFqUint1(x189)))
        var x192 uint64
        fiatFqCmovznzU64(&amp;x192, fiatFqUint1(x191), x182, x175)
        var x193 uint64
        fiatFqCmovznzU64(&amp;x193, fiatFqUint1(x191), x184, x177)
        var x194 uint64
        fiatFqCmovznzU64(&amp;x194, fiatFqUint1(x191), x186, x179)
        var x195 uint64
        fiatFqCmovznzU64(&amp;x195, fiatFqUint1(x191), x188, x181)
        out1[0] = x192
        out1[1] = x193
        out1[2] = x194
        out1[3] = x195
}</span>

// fiatFqNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqNonzero(out1 *uint64, arg1 *[4]uint64) <span class="cov0" title="0">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | arg1[3])))
        *out1 = x1
}</span>

// fiatFqSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqSelectznz(out1 *[4]uint64, arg1 fiatFqUint1, arg2 *[4]uint64, arg3 *[4]uint64) <span class="cov0" title="0">{
        var x1 uint64
        fiatFqCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFqCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFqCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFqCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
}</span>

// fiatFqToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x7fffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x7f]]
func fiatFqToBytes(out1 *[32]uint8, arg1 *[4]uint64) <span class="cov0" title="0">{
        x1 := arg1[3]
        x2 := arg1[2]
        x3 := arg1[1]
        x4 := arg1[0]
        x5 := (uint8(x4) &amp; 0xff)
        x6 := (x4 &gt;&gt; 8)
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := uint8((x16 &gt;&gt; 8))
        x19 := (uint8(x3) &amp; 0xff)
        x20 := (x3 &gt;&gt; 8)
        x21 := (uint8(x20) &amp; 0xff)
        x22 := (x20 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := uint8((x30 &gt;&gt; 8))
        x33 := (uint8(x2) &amp; 0xff)
        x34 := (x2 &gt;&gt; 8)
        x35 := (uint8(x34) &amp; 0xff)
        x36 := (x34 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := uint8((x44 &gt;&gt; 8))
        x47 := (uint8(x1) &amp; 0xff)
        x48 := (x1 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := (x48 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := uint8((x58 &gt;&gt; 8))
        out1[0] = x5
        out1[1] = x7
        out1[2] = x9
        out1[3] = x11
        out1[4] = x13
        out1[5] = x15
        out1[6] = x17
        out1[7] = x18
        out1[8] = x19
        out1[9] = x21
        out1[10] = x23
        out1[11] = x25
        out1[12] = x27
        out1[13] = x29
        out1[14] = x31
        out1[15] = x32
        out1[16] = x33
        out1[17] = x35
        out1[18] = x37
        out1[19] = x39
        out1[20] = x41
        out1[21] = x43
        out1[22] = x45
        out1[23] = x46
        out1[24] = x47
        out1[25] = x49
        out1[26] = x51
        out1[27] = x53
        out1[28] = x55
        out1[29] = x57
        out1[30] = x59
        out1[31] = x60
}</span>

// fiatFqFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x7f]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x7fffffffffffffff]]
func fiatFqFromBytes(out1 *[4]uint64, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 56)
        x2 := (uint64(arg1[30]) &lt;&lt; 48)
        x3 := (uint64(arg1[29]) &lt;&lt; 40)
        x4 := (uint64(arg1[28]) &lt;&lt; 32)
        x5 := (uint64(arg1[27]) &lt;&lt; 24)
        x6 := (uint64(arg1[26]) &lt;&lt; 16)
        x7 := (uint64(arg1[25]) &lt;&lt; 8)
        x8 := arg1[24]
        x9 := (uint64(arg1[23]) &lt;&lt; 56)
        x10 := (uint64(arg1[22]) &lt;&lt; 48)
        x11 := (uint64(arg1[21]) &lt;&lt; 40)
        x12 := (uint64(arg1[20]) &lt;&lt; 32)
        x13 := (uint64(arg1[19]) &lt;&lt; 24)
        x14 := (uint64(arg1[18]) &lt;&lt; 16)
        x15 := (uint64(arg1[17]) &lt;&lt; 8)
        x16 := arg1[16]
        x17 := (uint64(arg1[15]) &lt;&lt; 56)
        x18 := (uint64(arg1[14]) &lt;&lt; 48)
        x19 := (uint64(arg1[13]) &lt;&lt; 40)
        x20 := (uint64(arg1[12]) &lt;&lt; 32)
        x21 := (uint64(arg1[11]) &lt;&lt; 24)
        x22 := (uint64(arg1[10]) &lt;&lt; 16)
        x23 := (uint64(arg1[9]) &lt;&lt; 8)
        x24 := arg1[8]
        x25 := (uint64(arg1[7]) &lt;&lt; 56)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x25 + x38)
        x40 := (x23 + uint64(x24))
        x41 := (x22 + x40)
        x42 := (x21 + x41)
        x43 := (x20 + x42)
        x44 := (x19 + x43)
        x45 := (x18 + x44)
        x46 := (x17 + x45)
        x47 := (x15 + uint64(x16))
        x48 := (x14 + x47)
        x49 := (x13 + x48)
        x50 := (x12 + x49)
        x51 := (x11 + x50)
        x52 := (x10 + x51)
        x53 := (x9 + x52)
        x54 := (x7 + uint64(x8))
        x55 := (x6 + x54)
        x56 := (x5 + x55)
        x57 := (x4 + x56)
        x58 := (x3 + x57)
        x59 := (x2 + x58)
        x60 := (x1 + x59)
        out1[0] = x39
        out1[1] = x46
        out1[2] = x53
        out1[3] = x60
}</span>

// fiatFqSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFqSetOne(out1 *fiatFqMontgomeryDomainFieldElement) <span class="cov0" title="0">{
        out1[0] = 0x1fffffffe
        out1[1] = 0x5884b7fa00034802
        out1[2] = 0x998c4fefecbc4ff5
        out1[3] = 0x1824b159acc5056f
}</span>

// fiatFqMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqMsat(out1 *[5]uint64) <span class="cov0" title="0">{
        out1[0] = 0xffffffff00000001
        out1[1] = 0x53bda402fffe5bfe
        out1[2] = 0x3339d80809a1d805
        out1[3] = 0x73eda753299d7d48
        out1[4] = uint64(0x0)
}</span>

// fiatFqDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstepPrecomp(out1 *[4]uint64) <span class="cov0" title="0">{
        out1[0] = 0xcf0a288ddcbf896b
        out1[1] = 0x95eb83c82e9ceed6
        out1[2] = 0x41308645589e8e16
        out1[3] = 0x94d43542bc1b13c
}</span>

// fiatFqDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstep(out1 *uint64, out2 *[5]uint64, out3 *[5]uint64, out4 *[4]uint64, out5 *[4]uint64, arg1 uint64, arg2 *[5]uint64, arg3 *[5]uint64, arg4 *[4]uint64, arg5 *[4]uint64) <span class="cov0" title="0">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFqUint1((x1 &gt;&gt; 63)) &amp; (fiatFqUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFqCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFqCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFqCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFqCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFqCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFqUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFqUint1(x17)))
        var x20 uint64
        x20, _ = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFqUint1(x19)))
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, x3, arg3[0], x12)
        var x23 uint64
        fiatFqCmovznzU64(&amp;x23, x3, arg3[1], x14)
        var x24 uint64
        fiatFqCmovznzU64(&amp;x24, x3, arg3[2], x16)
        var x25 uint64
        fiatFqCmovznzU64(&amp;x25, x3, arg3[3], x18)
        var x26 uint64
        fiatFqCmovznzU64(&amp;x26, x3, arg3[4], x20)
        var x27 uint64
        fiatFqCmovznzU64(&amp;x27, x3, arg4[0], arg5[0])
        var x28 uint64
        fiatFqCmovznzU64(&amp;x28, x3, arg4[1], arg5[1])
        var x29 uint64
        fiatFqCmovznzU64(&amp;x29, x3, arg4[2], arg5[2])
        var x30 uint64
        fiatFqCmovznzU64(&amp;x30, x3, arg4[3], arg5[3])
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x27, x27, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x28, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x29, x29, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x30, x30, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Sub64(x31, 0xffffffff00000001, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Sub64(x33, 0x53bda402fffe5bfe, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Sub64(x35, 0x3339d80809a1d805, uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Sub64(x37, 0x73eda753299d7d48, uint64(fiatFqUint1(x44)))
        var x48 uint64
        _, x48 = bits.Sub64(uint64(fiatFqUint1(x38)), uint64(0x0), uint64(fiatFqUint1(x46)))
        x49 := arg4[3]
        x50 := arg4[2]
        x51 := arg4[1]
        x52 := arg4[0]
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(uint64(0x0), x52, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(uint64(0x0), x51, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(uint64(0x0), x50, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(uint64(0x0), x49, uint64(fiatFqUint1(x58)))
        var x61 uint64
        fiatFqCmovznzU64(&amp;x61, fiatFqUint1(x60), uint64(0x0), 0xffffffffffffffff)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x53, (x61 &amp; 0xffffffff00000001), uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x55, (x61 &amp; 0x53bda402fffe5bfe), uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, (x61 &amp; 0x3339d80809a1d805), uint64(fiatFqUint1(x65)))
        var x68 uint64
        x68, _ = bits.Add64(x59, (x61 &amp; 0x73eda753299d7d48), uint64(fiatFqUint1(x67)))
        var x70 uint64
        fiatFqCmovznzU64(&amp;x70, x3, arg5[0], x62)
        var x71 uint64
        fiatFqCmovznzU64(&amp;x71, x3, arg5[1], x64)
        var x72 uint64
        fiatFqCmovznzU64(&amp;x72, x3, arg5[2], x66)
        var x73 uint64
        fiatFqCmovznzU64(&amp;x73, x3, arg5[3], x68)
        x74 := (fiatFqUint1(x22) &amp; 0x1)
        var x75 uint64
        fiatFqCmovznzU64(&amp;x75, x74, uint64(0x0), x7)
        var x76 uint64
        fiatFqCmovznzU64(&amp;x76, x74, uint64(0x0), x8)
        var x77 uint64
        fiatFqCmovznzU64(&amp;x77, x74, uint64(0x0), x9)
        var x78 uint64
        fiatFqCmovznzU64(&amp;x78, x74, uint64(0x0), x10)
        var x79 uint64
        fiatFqCmovznzU64(&amp;x79, x74, uint64(0x0), x11)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x22, x75, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x23, x76, uint64(fiatFqUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x24, x77, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x25, x78, uint64(fiatFqUint1(x85)))
        var x88 uint64
        x88, _ = bits.Add64(x26, x79, uint64(fiatFqUint1(x87)))
        var x90 uint64
        fiatFqCmovznzU64(&amp;x90, x74, uint64(0x0), x27)
        var x91 uint64
        fiatFqCmovznzU64(&amp;x91, x74, uint64(0x0), x28)
        var x92 uint64
        fiatFqCmovznzU64(&amp;x92, x74, uint64(0x0), x29)
        var x93 uint64
        fiatFqCmovznzU64(&amp;x93, x74, uint64(0x0), x30)
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x70, x90, uint64(0x0))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x71, x91, uint64(fiatFqUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x72, x92, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x73, x93, uint64(fiatFqUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Sub64(x94, 0xffffffff00000001, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Sub64(x96, 0x53bda402fffe5bfe, uint64(fiatFqUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Sub64(x98, 0x3339d80809a1d805, uint64(fiatFqUint1(x105)))
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Sub64(x100, 0x73eda753299d7d48, uint64(fiatFqUint1(x107)))
        var x111 uint64
        _, x111 = bits.Sub64(uint64(fiatFqUint1(x101)), uint64(0x0), uint64(fiatFqUint1(x109)))
        var x112 uint64
        x112, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x114 := ((x80 &gt;&gt; 1) | ((x82 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x115 := ((x82 &gt;&gt; 1) | ((x84 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x116 := ((x84 &gt;&gt; 1) | ((x86 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x117 := ((x86 &gt;&gt; 1) | ((x88 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x118 := ((x88 &amp; 0x8000000000000000) | (x88 &gt;&gt; 1))
        var x119 uint64
        fiatFqCmovznzU64(&amp;x119, fiatFqUint1(x48), x39, x31)
        var x120 uint64
        fiatFqCmovznzU64(&amp;x120, fiatFqUint1(x48), x41, x33)
        var x121 uint64
        fiatFqCmovznzU64(&amp;x121, fiatFqUint1(x48), x43, x35)
        var x122 uint64
        fiatFqCmovznzU64(&amp;x122, fiatFqUint1(x48), x45, x37)
        var x123 uint64
        fiatFqCmovznzU64(&amp;x123, fiatFqUint1(x111), x102, x94)
        var x124 uint64
        fiatFqCmovznzU64(&amp;x124, fiatFqUint1(x111), x104, x96)
        var x125 uint64
        fiatFqCmovznzU64(&amp;x125, fiatFqUint1(x111), x106, x98)
        var x126 uint64
        fiatFqCmovznzU64(&amp;x126, fiatFqUint1(x111), x108, x100)
        *out1 = x112
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out3[0] = x114
        out3[1] = x115
        out3[2] = x116
        out3[3] = x117
        out3[4] = x118
        out4[0] = x119
        out4[1] = x120
        out4[2] = x121
        out4[3] = x122
        out5[0] = x123
        out5[1] = x124
        out5[2] = x125
        out5[3] = x126
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab" --type Fp --sqrt sqrt
//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "0x73EDA753299D7D483339D80809A1D80553BDA402FFFE5BFEFFFFFFFF00000001" --type Fq --sqrt sqrt
package impl

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

var (
        _ fieldsImpl.QuadraticFieldExtensionArithmetic[*Fp]  = fp2Params{}
        _ fieldsImpl.CubicFieldExtensionArithmetic[*Fp2]     = fp6Params{}
        _ fieldsImpl.QuadraticFieldExtensionArithmetic[*Fp6] = fp12Params{}
)

// Fp2 represents a quadratic extension field element.
type Fp2 = fieldsImpl.QuadraticFieldExtensionImpl[*Fp, fp2Params, Fp]

// Fp6 represents a sextic extension field element.
type Fp6 = fieldsImpl.CubicFieldExtensionImpl[*Fp2, fp6Params, Fp2]

// Fp12 represents a 12-degree extension field element.
type Fp12 = fieldsImpl.QuadraticFieldExtensionImpl[*Fp6, fp12Params, Fp6]

type fp2Params struct{}
type fp6Params struct{}
type fp12Params struct{}

// MulByQuadraticNonResidue multiplies by the quadratic non-residue.
func (fp2Params) MulByQuadraticNonResidue(out, in *Fp) <span class="cov8" title="1">{
        out.Neg(in)
}</span>

// MulByCubicNonResidue multiplies by the cubic non-residue.
func (fp6Params) MulByCubicNonResidue(out, in *Fp2) <span class="cov8" title="1">{
        var params fp2Params
        var c Fp2

        c.U1.Add(&amp;in.U0, &amp;in.U1)
        params.MulByQuadraticNonResidue(&amp;c.U0, &amp;in.U1)
        c.U0.Add(&amp;c.U0, &amp;in.U0)

        out.Set(&amp;c)
}</span>

// RootOfUnity returns the field root of unity.
func (fp6Params) RootOfUnity(out *Fp2) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// ProgenitorExponent returns the progenitor exponent.
func (fp6Params) ProgenitorExponent() []uint8 <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// E returns the exponent parameter for square roots.
func (fp6Params) E() uint64 <span class="cov0" title="0">{
        return 6
}</span>

// MulByQuadraticNonResidue multiplies by the quadratic non-residue.
func (fp12Params) MulByQuadraticNonResidue(out, in *Fp6) <span class="cov8" title="1">{
        var params fp6Params
        var c Fp6

        c.U2.Set(&amp;in.U1)
        c.U1.Set(&amp;in.U0)
        params.MulByCubicNonResidue(&amp;c.U0, &amp;in.U2)

        out.Set(&amp;c)
}</span>

func sqrt[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any](out, x, rootOfUnity *F, e uint64, progenitorExp []uint8) (ok ct.Bool) <span class="cov0" title="0">{
        return fieldsImpl.TonelliShanks[FP, F](out, x, rootOfUnity, e, progenitorExp)
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FpLimbs     = 6
        FpSatLimbs  = FpLimbs + 1
        FpBits      = 381
        FpBytes     = 8 * (((FpBits - 1) / 64) + 1)
        FpWideBytes = 2 * FpBytes
        FpDivSteps  = ((49 * FpBits) + 57) / 17
        FpE         = 1
)

var (
        FpProgenitorExp = [...]byte{0xaa, 0xea, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0xee, 0xff, 0xff, 0x54, 0xac, 0xff, 0xff, 0xaa, 0x07, 0x89, 0x3d, 0xac, 0x3d, 0xa8, 0x34, 0xcc, 0xd9, 0xaf, 0x44, 0xe1, 0x3c, 0xe1, 0xd2, 0x1d, 0xd9, 0x35, 0xeb, 0xd2, 0x90, 0xed, 0xe9, 0xc6, 0x92, 0xa6, 0xf9, 0x5f, 0x8e, 0x7a, 0x44, 0x80, 0x06}
        FpModulus       = [...]byte{0xab, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xb9, 0xff, 0xff, 0x53, 0xb1, 0xfe, 0xff, 0xab, 0x1e, 0x24, 0xf6, 0xb0, 0xf6, 0xa0, 0xd2, 0x30, 0x67, 0xbf, 0x12, 0x85, 0xf3, 0x84, 0x4b, 0x77, 0x64, 0xd7, 0xac, 0x4b, 0x43, 0xb6, 0xa7, 0x1b, 0x4b, 0x9a, 0xe6, 0x7f, 0x39, 0xea, 0x11, 0x01, 0x1a}
        FpRootOfUnity   Fp
)

func init() <span class="cov8" title="1">{
        FpRootOfUnity.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa")
}</span>

type Fp struct {
        fiatFpMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fp) Set(v *Fp) <span class="cov8" title="1">{
        *f = *v
}</span>

func (f *Fp) SetZero() <span class="cov8" title="1">{
        *f = Fp{}
}</span>

func (f *Fp) SetOne() <span class="cov8" title="1">{
        fiatFpSetOne(&amp;f.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FpLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fp) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFpToMontgomery(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fp) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FpBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromBytes((*[FpLimbs]uint64)(&amp;nonMonty), (*[FpBytes]uint8)(data))
        fiatFpToMontgomery(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fp) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) &gt; FpWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var wideData [FpWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FpLimbs]uint64
        fiatFpFromBytes(&amp;d0, (*[FpBytes]uint8)(wideData[:FpBytes]))
        fiatFpFromBytes(&amp;d1, (*[FpBytes]uint8)(wideData[FpBytes:]))

        // d0*r2 + d1*r3
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d0), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d1), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d1), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&amp;d0), (*fiatFpMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fp) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fp) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FpBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fp) Select(choice ct.Choice, z, nz *Fp) <span class="cov8" title="1">{
        fiatFpSelectznz((*[FpLimbs]uint64)(&amp;f.fiatFpMontgomeryDomainFieldElement),fiatFpUint1(choice), (*[FpLimbs]uint64)(&amp;z.fiatFpMontgomeryDomainFieldElement), (*[FpLimbs]uint64)(&amp;nz.fiatFpMontgomeryDomainFieldElement))
}</span>

func (f *Fp) Add(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Double(x *Fp) <span class="cov0" title="0">{
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;x.fiatFpMontgomeryDomainFieldElement, &amp;x.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Sub(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpSub(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Neg(v *Fp) <span class="cov8" title="1">{
        fiatFpOpp(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;v.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Mul(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpMul(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Square(v *Fp) <span class="cov8" title="1">{
        fiatFpSquare(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;v.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Inv(a *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var precomp, h, v, r, out4, out5 [FpLimbs]uint64
        var ff, g, out2, out3 [FpSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFpDivstepPrecomp(&amp;precomp)
        fiatFpFromMontgomery((*fiatFpNonMontgomeryDomainFieldElement)(g[:FpLimbs]), &amp;a.fiatFpMontgomeryDomainFieldElement)
        fiatFpMsat(&amp;ff)
        fiatFpSetOne((*fiatFpMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FpDivSteps-(FpDivSteps%2); i += 2 </span><span class="cov8" title="1">{
                fiatFpDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFpDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov8" title="1">if (FpDivSteps % 2) != 0 </span><span class="cov8" title="1">{ // compile time if - always true
                fiatFpDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov8" title="1">fiatFpOpp((*fiatFpMontgomeryDomainFieldElement)(&amp;h), (*fiatFpMontgomeryDomainFieldElement)(&amp;v))
        fiatFpSelectznz(&amp;v, fiatFpUint1(ff[FpLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFpMul(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&amp;v), (*fiatFpMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFpNonzero(&amp;inverted, (*[FpLimbs]uint64)(&amp;f.fiatFpMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fp) Div(lhs, rhs *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var rhsInv Fp
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fp) Sqrt(x *Fp) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(sqrt(f, x, &amp;FpRootOfUnity, FpE, FpProgenitorExp[:]))
}</span>

func (f *Fp) IsNonZero() ct.Bool <span class="cov8" title="1">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFpNonzero(&amp;nonZero, (*[FpLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fp) IsZero() ct.Bool <span class="cov8" title="1">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fp) IsOne() ct.Bool <span class="cov8" title="1">{
        var one Fp
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fp) Equal(v *Fp) ct.Bool <span class="cov8" title="1">{
        var diff Fp
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fp) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fp) Bytes() []byte <span class="cov8" title="1">{
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)
        var data [FpBytes]byte
        fiatFpToBytes(&amp;data, (*[FpLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fp) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fp) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fp) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fp) Degree() uint64 <span class="cov8" title="1">{
        return 1
}</span>

func (f *Fp) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fp) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FqLimbs     = 4
        FqSatLimbs  = FqLimbs + 1
        FqBits      = 255
        FqBytes     = 8 * (((FqBits - 1) / 64) + 1)
        FqWideBytes = 2 * FqBytes
        FqDivSteps  = ((49 * FqBits) + 57) / 17
        FqE         = 32
)

var (
        FqProgenitorExp = [...]byte{0xff, 0xff, 0xff, 0x7f, 0xff, 0x2d, 0xff, 0x7f, 0x01, 0xd2, 0xde, 0xa9, 0x02, 0xec, 0xd0, 0x04, 0x04, 0xec, 0x9c, 0x19, 0xa4, 0xbe, 0xce, 0x94, 0xa9, 0xd3, 0xf6, 0x39}
        FqModulus       = [...]byte{0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x5b, 0xfe, 0xff, 0x02, 0xa4, 0xbd, 0x53, 0x05, 0xd8, 0xa1, 0x09, 0x08, 0xd8, 0x39, 0x33, 0x48, 0x7d, 0x9d, 0x29, 0x53, 0xa7, 0xed, 0x73}
        FqRootOfUnity   Fq
)

func init() <span class="cov8" title="1">{
        FqRootOfUnity.MustSetHex("16a2a19edfe81f20d09b681922c813b4b63683508c2280b93829971f439f0d2b")
}</span>

type Fq struct {
        fiatFqMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fq) Set(v *Fq) <span class="cov0" title="0">{
        *f = *v
}</span>

func (f *Fq) SetZero() <span class="cov0" title="0">{
        *f = Fq{}
}</span>

func (f *Fq) SetOne() <span class="cov0" title="0">{
        fiatFqSetOne(&amp;f.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FqLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fq) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fq) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FqBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromBytes((*[FqLimbs]uint64)(&amp;nonMonty), (*[FqBytes]uint8)(data))
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fq) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(data) &gt; FqWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var wideData [FqWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FqLimbs]uint64
        fiatFqFromBytes(&amp;d0, (*[FqBytes]uint8)(wideData[:FqBytes]))
        fiatFqFromBytes(&amp;d1, (*[FqBytes]uint8)(wideData[FqBytes:]))

        // d0*r2 + d1*r3
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fq) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov0" title="0">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fq) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FqBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fq) Select(choice ct.Choice, z, nz *Fq) <span class="cov0" title="0">{
        fiatFqSelectznz((*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement),fiatFqUint1(choice), (*[FqLimbs]uint64)(&amp;z.fiatFqMontgomeryDomainFieldElement), (*[FqLimbs]uint64)(&amp;nz.fiatFqMontgomeryDomainFieldElement))
}</span>

func (f *Fq) Add(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Double(x *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Sub(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqSub(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Neg(v *Fq) <span class="cov0" title="0">{
        fiatFqOpp(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Mul(lhs, rhs *Fq) <span class="cov0" title="0">{
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Square(v *Fq) <span class="cov0" title="0">{
        fiatFqSquare(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Inv(a *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        var precomp, h, v, r, out4, out5 [FqLimbs]uint64
        var ff, g, out2, out3 [FqSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFqDivstepPrecomp(&amp;precomp)
        fiatFqFromMontgomery((*fiatFqNonMontgomeryDomainFieldElement)(g[:FqLimbs]), &amp;a.fiatFqMontgomeryDomainFieldElement)
        fiatFqMsat(&amp;ff)
        fiatFqSetOne((*fiatFqMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FqDivSteps-(FqDivSteps%2); i += 2 </span><span class="cov0" title="0">{
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFqDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov0" title="0">if (FqDivSteps % 2) != 0 </span><span class="cov0" title="0">{ // compile time if - always true
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov0" title="0">fiatFqOpp((*fiatFqMontgomeryDomainFieldElement)(&amp;h), (*fiatFqMontgomeryDomainFieldElement)(&amp;v))
        fiatFqSelectznz(&amp;v, fiatFqUint1(ff[FqLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;v), (*fiatFqMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFqNonzero(&amp;inverted, (*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fq) Div(lhs, rhs *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        var rhsInv Fq
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fq) Sqrt(x *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(sqrt(f, x, &amp;FqRootOfUnity, FqE, FqProgenitorExp[:]))
}</span>

func (f *Fq) IsNonZero() ct.Bool <span class="cov0" title="0">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFqNonzero(&amp;nonZero, (*[FqLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fq) IsZero() ct.Bool <span class="cov0" title="0">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fq) IsOne() ct.Bool <span class="cov0" title="0">{
        var one Fq
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fq) Equal(v *Fq) ct.Bool <span class="cov0" title="0">{
        var diff Fq
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fq) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fq) Bytes() []byte <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        var data [FqBytes]byte
        fiatFqToBytes(&amp;data, (*[FqLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fq) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fq) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fq) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fq) Degree() uint64 <span class="cov0" title="0">{
        return 1
}</span>

func (f *Fq) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fq) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package impl

import (
        "crypto/sha256"
        "encoding/binary"

        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        pointsImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu"
)

var (
        _ pointsImpl.ShortWeierstrassCurveParams[*Fp] = g1CurveParams{}
        _ h2c.HasherParams                            = G1CurveHasherParams{}
        _ sswu.ZeroPointMapperParams[*Fp, Fp]         = g1CurveMapperParams{}
        _ h2c.PointMapper[*Fp]                        = g1CurveMapper{}
)

var (
        g1CurveB               Fp
        g1CurveGx              Fp
        g1CurveGy              Fp
        g1CurveMessageExpander = h2c.NewXMDMessageExpander(sha256.New)

        g1SqrtRatioC1  = [...]uint8{0xaa, 0xea, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0xee, 0xff, 0xff, 0x54, 0xac, 0xff, 0xff, 0xaa, 0x07, 0x89, 0x3d, 0xac, 0x3d, 0xa8, 0x34, 0xcc, 0xd9, 0xaf, 0x44, 0xe1, 0x3c, 0xe1, 0xd2, 0x1d, 0xd9, 0x35, 0xeb, 0xd2, 0x90, 0xed, 0xe9, 0xc6, 0x92, 0xa6, 0xf9, 0x5f, 0x8e, 0x7a, 0x44, 0x80, 0x06}
        g1SqrtRationC2 Fp

        g1SswuZ           Fp
        g1SswuIsogenyA    Fp
        g1SswuIsogenyB    Fp
        g1SswuIsogenyXNum [12]Fp
        g1SswuIsogenyXDen [11]Fp
        g1SswuIsogenyYNum [16]Fp
        g1SswuIsogenyYDen [16]Fp
)

//nolint:gochecknoinits // curve params initialization
func init() <span class="cov8" title="1">{
        g1CurveB.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004")
        g1CurveGx.MustSetHex("17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb")
        g1CurveGy.MustSetHex("08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1")

        g1SqrtRationC2.MustSetHex("04610e003bd3ac94dfa9246c390d7a78942602029175a4ca366d601f33f3946e3ed39794735c38315d874bc1d70637c3")

        g1SswuZ.MustSetHex("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b")
        g1SswuIsogenyA.MustSetHex("00144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")
        g1SswuIsogenyB.MustSetHex("12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")
        g1SswuIsogenyXNum[0].MustSetHex("11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7")
        g1SswuIsogenyXNum[1].MustSetHex("17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb")
        g1SswuIsogenyXNum[2].MustSetHex("0d54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0")
        g1SswuIsogenyXNum[3].MustSetHex("1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861")
        g1SswuIsogenyXNum[4].MustSetHex("0e99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9")
        g1SswuIsogenyXNum[5].MustSetHex("1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983")
        g1SswuIsogenyXNum[6].MustSetHex("0d6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84")
        g1SswuIsogenyXNum[7].MustSetHex("17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e")
        g1SswuIsogenyXNum[8].MustSetHex("080d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317")
        g1SswuIsogenyXNum[9].MustSetHex("169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e")
        g1SswuIsogenyXNum[10].MustSetHex("10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b")
        g1SswuIsogenyXNum[11].MustSetHex("06e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229")
        g1SswuIsogenyXDen[0].MustSetHex("08ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c")
        g1SswuIsogenyXDen[1].MustSetHex("12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff")
        g1SswuIsogenyXDen[2].MustSetHex("0b2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19")
        g1SswuIsogenyXDen[3].MustSetHex("03425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8")
        g1SswuIsogenyXDen[4].MustSetHex("13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e")
        g1SswuIsogenyXDen[5].MustSetHex("0e7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5")
        g1SswuIsogenyXDen[6].MustSetHex("0772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a")
        g1SswuIsogenyXDen[7].MustSetHex("14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e")
        g1SswuIsogenyXDen[8].MustSetHex("0a10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641")
        g1SswuIsogenyXDen[9].MustSetHex("095fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a")
        g1SswuIsogenyXDen[10].SetOne()
        g1SswuIsogenyYNum[0].MustSetHex("090d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33")
        g1SswuIsogenyYNum[1].MustSetHex("134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696")
        g1SswuIsogenyYNum[2].MustSetHex("00cc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6")
        g1SswuIsogenyYNum[3].MustSetHex("01f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb")
        g1SswuIsogenyYNum[4].MustSetHex("08cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb")
        g1SswuIsogenyYNum[5].MustSetHex("16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0")
        g1SswuIsogenyYNum[6].MustSetHex("04ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2")
        g1SswuIsogenyYNum[7].MustSetHex("0987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29")
        g1SswuIsogenyYNum[8].MustSetHex("09fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587")
        g1SswuIsogenyYNum[9].MustSetHex("0e1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30")
        g1SswuIsogenyYNum[10].MustSetHex("19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132")
        g1SswuIsogenyYNum[11].MustSetHex("18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e")
        g1SswuIsogenyYNum[12].MustSetHex("0b182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8")
        g1SswuIsogenyYNum[13].MustSetHex("0245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133")
        g1SswuIsogenyYNum[14].MustSetHex("05c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b")
        g1SswuIsogenyYNum[15].MustSetHex("15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604")
        g1SswuIsogenyYDen[0].MustSetHex("16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1")
        g1SswuIsogenyYDen[1].MustSetHex("1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d")
        g1SswuIsogenyYDen[2].MustSetHex("058df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2")
        g1SswuIsogenyYDen[3].MustSetHex("16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416")
        g1SswuIsogenyYDen[4].MustSetHex("0be0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d")
        g1SswuIsogenyYDen[5].MustSetHex("08d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac")
        g1SswuIsogenyYDen[6].MustSetHex("166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c")
        g1SswuIsogenyYDen[7].MustSetHex("16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9")
        g1SswuIsogenyYDen[8].MustSetHex("1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a")
        g1SswuIsogenyYDen[9].MustSetHex("167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55")
        g1SswuIsogenyYDen[10].MustSetHex("04d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8")
        g1SswuIsogenyYDen[11].MustSetHex("0accbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092")
        g1SswuIsogenyYDen[12].MustSetHex("0ad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc")
        g1SswuIsogenyYDen[13].MustSetHex("02660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7")
        g1SswuIsogenyYDen[14].MustSetHex("0e0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f")
        g1SswuIsogenyYDen[15].SetOne()
}</span>

type g1CurveParams struct{}

// G1CurveHasherParams defines hash-to-curve parameters.
type G1CurveHasherParams struct{}
type g1CurveMapperParams struct{}
type g1CurveMapper = sswu.ZeroPointMapper[*Fp, g1CurveMapperParams, Fp]

// AddA adds the curve A parameter to in.
func (g1CurveParams) AddA(out, in *Fp) <span class="cov8" title="1">{
        out.Set(in)
}</span>

// AddB adds the curve B parameter to in.
func (g1CurveParams) AddB(out, in *Fp) <span class="cov8" title="1">{
        out.Add(in, &amp;g1CurveB)
}</span>

// MulByA multiplies by the curve A parameter.
func (g1CurveParams) MulByA(out, _ *Fp) <span class="cov8" title="1">{
        out.SetZero()
}</span>

// MulBy3B where B = 4.
func (g1CurveParams) MulBy3B(out, in *Fp) <span class="cov8" title="1">{
        var b2, b4, b8 Fp
        b2.Add(in, in)
        b4.Add(&amp;b2, &amp;b2)
        b8.Add(&amp;b4, &amp;b4)
        out.Add(&amp;b8, &amp;b4) // b12
}</span>

// ClearCofactor clears the cofactor of the input point.
func (g1CurveParams) ClearCofactor(xOut, yOut, zOut, xIn, yIn, zIn *Fp) <span class="cov8" title="1">{
        var in G1Point
        in.X.Set(xIn)
        in.Y.Set(yIn)
        in.Z.Set(zIn)

        var out G1Point
        aimpl.ScalarMulLowLevel(&amp;out, &amp;in, binary.LittleEndian.AppendUint64(nil, X+1))
        xOut.Set(&amp;out.X)
        yOut.Set(&amp;out.Y)
        zOut.Set(&amp;out.Z)
}</span>

// SetGenerator sets generator coordinates.
func (g1CurveParams) SetGenerator(xOut, yOut, zOut *Fp) <span class="cov8" title="1">{
        xOut.Set(&amp;g1CurveGx)
        yOut.Set(&amp;g1CurveGy)
        zOut.SetOne()
}</span>

// M returns the field extension degree.
func (G1CurveHasherParams) M() uint64 <span class="cov0" title="0">{
        return 1
}</span>

// L returns the hash-to-field length in bytes.
func (G1CurveHasherParams) L() uint64 <span class="cov8" title="1">{
        return 64
}</span>

// MessageExpander returns the RFC 9380 message expander.
func (G1CurveHasherParams) MessageExpander() h2c.MessageExpander <span class="cov8" title="1">{
        return g1CurveMessageExpander
}</span>

// Suite returns the hash-to-curve suite string.
func (G1CurveHasherParams) Suite() []byte <span class="cov0" title="0">{
        return []byte("BLS12381G1_XMD:SHA-256_SSWU_RO_")
}</span>

// MulByA multiplies by the curve A parameter.
func (g1CurveMapperParams) MulByA(out, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;g1SswuIsogenyA)
}</span>

// MulByB multiplies by the curve B parameter.
func (g1CurveMapperParams) MulByB(out, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;g1SswuIsogenyB)
}</span>

// SetZ sets the SSWU Z parameter.
func (g1CurveMapperParams) SetZ(out *Fp) <span class="cov8" title="1">{
        out.Set(&amp;g1SswuZ)
}</span>

// SqrtRatio computes sqrt(u/v) with curve-specific parameters.
func (g1CurveMapperParams) SqrtRatio(out, u, v *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        return sswu.SqrtRatio3Mod4(out, g1SqrtRatioC1[:], &amp;g1SqrtRationC2, u, v)
}</span>

// Sgn0 returns the sign bit per RFC 9380.
func (g1CurveMapperParams) Sgn0(v *Fp) ct.Bool <span class="cov8" title="1">{
        return ct.Bool(uint64(v.Bytes()[0] &amp; 0b1))
}</span>

// XNum returns isogeny x numerator coefficients.
func (g1CurveMapperParams) XNum() []Fp <span class="cov8" title="1">{
        return g1SswuIsogenyXNum[:]
}</span>

// XDen returns isogeny x denominator coefficients.
func (g1CurveMapperParams) XDen() []Fp <span class="cov8" title="1">{
        return g1SswuIsogenyXDen[:]
}</span>

// YNum returns isogeny y numerator coefficients.
func (g1CurveMapperParams) YNum() []Fp <span class="cov8" title="1">{
        return g1SswuIsogenyYNum[:]
}</span>

// YDen returns isogeny y denominator coefficients.
func (g1CurveMapperParams) YDen() []Fp <span class="cov8" title="1">{
        return g1SswuIsogenyYDen[:]
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package impl

import (
        "crypto/sha256"
        "encoding/binary"

        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        pointsImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu"
)

var (
        _ pointsImpl.ShortWeierstrassCurveParams[*Fp2] = g2CurveParams{}
        _ h2c.HasherParams                             = G2CurveHasherParams{}
        _ sswu.ZeroPointMapperParams[*Fp2, Fp2]        = g2CurveMapperParams{}
)

var (
        g2CurveB               Fp2
        g2CurveGx              Fp2
        g2CurveGy              Fp2
        g2CurveMessageExpander = h2c.NewXMDMessageExpander(sha256.New)

        g2PsiC1  Fp2
        g2PsiC2  Fp2
        g2Psi2C1 Fp2

        g2SqrtRatioC1 = uint64(3)
        g2SqrtRatioC3 = [...]uint8{0xe3, 0x18, 0xc7, 0x01, 0x00, 0xa0, 0x6a, 0xb2, 0xea, 0x82, 0x63, 0xd7, 0xb1, 0xd6, 0xce, 0xd7, 0xcf, 0x13, 0x21, 0x36, 0x38, 0xc3, 0x62, 0x31, 0x74, 0x1b, 0xe7, 0xd3, 0x1e, 0xf9, 0x6b, 0x96, 0x04, 0x1a, 0x09, 0x87, 0x5a, 0xe8, 0x92, 0xb2, 0xc7, 0x85, 0x61, 0xc8, 0x19, 0x86, 0xd6, 0x11, 0xf0, 0x8e, 0x97, 0x30, 0x93, 0x14, 0x53, 0xef, 0xa6, 0xdc, 0x6d, 0xd1, 0xcf, 0x62, 0x0a, 0x05, 0xbd, 0xe8, 0x49, 0x93, 0xe4, 0x59, 0x6e, 0x46, 0x6b, 0x04, 0xe7, 0x50, 0x0e, 0xc9, 0x2d, 0x9e, 0x5e, 0xf2, 0x22, 0xaa, 0x8e, 0x27, 0xbd, 0x74, 0xfc, 0x35, 0x8c, 0x4b, 0x7a, 0x43, 0x2a}
        g2SqrtRatioC4 = uint64((1 &lt;&lt; g2SqrtRatioC1) - 1)
        g2SqrtRatioC5 = uint64(1 &lt;&lt; (g2SqrtRatioC1 - 1))
        g2SqrtRatioC6 Fp2
        g2SqrtRatioC7 Fp2

        g2SswuZ           Fp2
        g2SswuIsogenyA    Fp2
        g2SswuIsogenyB    Fp2
        g2SswuIsogenyXNum [4]Fp2
        g2SswuIsogenyXDen [3]Fp2
        g2SswuIsogenyYNum [4]Fp2
        g2SswuIsogenyYDen [4]Fp2
)

//nolint:gochecknoinits // curve params initialization
func init() <span class="cov8" title="1">{
        g2CurveB.U0.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004")
        g2CurveB.U1.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004")
        g2CurveGx.U0.MustSetHex("024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8")
        g2CurveGx.U1.MustSetHex("13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")
        g2CurveGy.U0.MustSetHex("0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801")
        g2CurveGy.U1.MustSetHex("0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")

        g2PsiC1.U0.SetZero()
        g2PsiC1.U1.MustSetHex("1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad")
        g2PsiC2.U0.MustSetHex("135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2")
        g2PsiC2.U1.MustSetHex("06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09")
        g2Psi2C1.U0.MustSetHex("1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac")
        g2Psi2C1.U1.SetZero()

        g2SqrtRatioC6.U0.MustSetHex("06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09")
        g2SqrtRatioC6.U1.MustSetHex("06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09")
        g2SqrtRatioC7.U0.MustSetHex("13dc0969311e2ba565924cb0b6f7bb9857f157e17f0c8db4e484fcb27b8be0b36dfa0340c422fb7efe9d9a3234336d5e")
        g2SqrtRatioC7.U1.MustSetHex("071d42ac9c54001a21acf9187d469d919a830a2c969128d22659dc2f8263f1ca73c5b0e02c05ec381b8684a676a81381")

        g2SswuZ.U0.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaa9")
        g2SswuZ.U1.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa")
        g2SswuIsogenyA.U0.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
        g2SswuIsogenyA.U1.MustSetHex("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f0")
        g2SswuIsogenyB.U0.MustSetHex("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f4")
        g2SswuIsogenyB.U1.MustSetHex("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003f4")
        g2SswuIsogenyXNum[0].U0.MustSetHex("05c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6")
        g2SswuIsogenyXNum[0].U1.MustSetHex("05c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6")
        g2SswuIsogenyXNum[1].U0.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
        g2SswuIsogenyXNum[1].U1.MustSetHex("11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a")
        g2SswuIsogenyXNum[2].U0.MustSetHex("11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e")
        g2SswuIsogenyXNum[2].U1.MustSetHex("08ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d")
        g2SswuIsogenyXNum[3].U0.MustSetHex("171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1")
        g2SswuIsogenyXNum[3].U1.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
        g2SswuIsogenyXDen[0].U0.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
        g2SswuIsogenyXDen[0].U1.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63")
        g2SswuIsogenyXDen[1].U0.MustSetHex("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c")
        g2SswuIsogenyXDen[1].U1.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f")
        g2SswuIsogenyXDen[2].SetOne()
        g2SswuIsogenyYNum[0].U0.MustSetHex("1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706")
        g2SswuIsogenyYNum[0].U1.MustSetHex("1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706")
        g2SswuIsogenyYNum[1].U0.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
        g2SswuIsogenyYNum[1].U1.MustSetHex("05c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be")
        g2SswuIsogenyYNum[2].U0.MustSetHex("11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c")
        g2SswuIsogenyYNum[2].U1.MustSetHex("08ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f")
        g2SswuIsogenyYNum[3].U0.MustSetHex("124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10")
        g2SswuIsogenyYNum[3].U1.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
        g2SswuIsogenyYDen[0].U0.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb")
        g2SswuIsogenyYDen[0].U1.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb")
        g2SswuIsogenyYDen[1].U0.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")
        g2SswuIsogenyYDen[1].U1.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3")
        g2SswuIsogenyYDen[2].U0.MustSetHex("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012")
        g2SswuIsogenyYDen[2].U1.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99")
        g2SswuIsogenyYDen[3].SetOne()
}</span>

type g2CurveParams struct{}

// G2CurveHasherParams defines hash-to-curve parameters.
type G2CurveHasherParams struct{}
type g2CurveMapperParams struct{}
type g2CurveMapper = sswu.ZeroPointMapper[*Fp2, g2CurveMapperParams, Fp2]

// AddA adds the curve A parameter to in.
func (g2CurveParams) AddA(out, in *Fp2) <span class="cov8" title="1">{
        out.Set(in)
}</span>

// AddB adds the curve B parameter to in.
func (g2CurveParams) AddB(out, in *Fp2) <span class="cov8" title="1">{
        out.Add(in, &amp;g2CurveB)
}</span>

// MulByA multiplies by the curve A parameter.
func (g2CurveParams) MulByA(out, _ *Fp2) <span class="cov8" title="1">{
        out.SetZero()
}</span>

// MulBy3B where B = 4(u+1).
func (g2CurveParams) MulBy3B(out, in *Fp2) <span class="cov8" title="1">{
        var params fp2Params
        var c, c2, c4, c8 Fp2
        c.U1.Add(&amp;in.U0, &amp;in.U1)
        params.MulByQuadraticNonResidue(&amp;c.U0, &amp;in.U1)
        c.U0.Add(&amp;c.U0, &amp;in.U0)
        c2.Add(&amp;c, &amp;c)
        c4.Add(&amp;c2, &amp;c2)
        c8.Add(&amp;c4, &amp;c4)

        out.Add(&amp;c4, &amp;c8) // out = 3 * 4(u+1)
}</span>

// ClearCofactor clears the cofactor of the input point.
func (g2CurveParams) ClearCofactor(xOut, yOut, zOut, xIn, yIn, zIn *Fp2) <span class="cov8" title="1">{
        var out, in G2Point
        in.X.Set(xIn)
        in.Y.Set(yIn)
        in.Z.Set(zIn)

        clearCofactorBls12381G2(&amp;out, &amp;in)
        xOut.Set(&amp;out.X)
        yOut.Set(&amp;out.Y)
        zOut.Set(&amp;out.Z)
}</span>

// SetGenerator sets generator coordinates.
func (g2CurveParams) SetGenerator(xOut, yOut, zOut *Fp2) <span class="cov8" title="1">{
        xOut.Set(&amp;g2CurveGx)
        yOut.Set(&amp;g2CurveGy)
        zOut.SetOne()
}</span>

// M returns the field extension degree.
func (G2CurveHasherParams) M() uint64 <span class="cov0" title="0">{
        return 2
}</span>

// L returns the hash-to-field length in bytes.
func (G2CurveHasherParams) L() uint64 <span class="cov8" title="1">{
        return 64
}</span>

// MessageExpander returns the RFC 9380 message expander.
func (G2CurveHasherParams) MessageExpander() h2c.MessageExpander <span class="cov8" title="1">{
        return g2CurveMessageExpander
}</span>

// Suite returns the hash-to-curve suite string.
func (G2CurveHasherParams) Suite() []byte <span class="cov0" title="0">{
        return []byte("BLS12381G2_XMD:SHA-256_SSWU_RO_")
}</span>

// MulByA multiplies by the curve A parameter.
func (g2CurveMapperParams) MulByA(out, in *Fp2) <span class="cov8" title="1">{
        out.Mul(in, &amp;g2SswuIsogenyA)
}</span>

// MulByB multiplies by the curve B parameter.
func (g2CurveMapperParams) MulByB(out, in *Fp2) <span class="cov8" title="1">{
        out.Mul(in, &amp;g2SswuIsogenyB)
}</span>

// SetZ sets the SSWU Z parameter.
func (g2CurveMapperParams) SetZ(out *Fp2) <span class="cov8" title="1">{
        out.Set(&amp;g2SswuZ)
}</span>

// SqrtRatio computes sqrt(u/v) with curve-specific parameters.
func (g2CurveMapperParams) SqrtRatio(out, u, v *Fp2) (ok ct.Bool) <span class="cov8" title="1">{
        return sswu.SqrtRatio(out, g2SqrtRatioC1, g2SqrtRatioC3[:], g2SqrtRatioC4, g2SqrtRatioC5, &amp;g2SqrtRatioC6, &amp;g2SqrtRatioC7, u, v)
}</span>

// Sgn0 returns the sign bit per RFC 9380.
func (g2CurveMapperParams) Sgn0(v *Fp2) ct.Bool <span class="cov8" title="1">{
        // 1. sign_0 = x_0 mod 2
        sign0 := ct.Bool(v.U0.Bytes()[0] &amp; 0b1)
        // 2. zero_0 = x_0 == 0
        zero0 := v.U0.IsZero()
        // 3. sign_1 = x_1 mod 2
        sign1 := ct.Bool(v.U1.Bytes()[0] &amp; 0b1)
        // 4. s = sign_0 OR (zero_0 AND sign_1) # Avoid short-circuit logic ops
        s := sign0 | (zero0 &amp; sign1)
        // 5. return s
        return s
}</span>

// XNum returns isogeny x numerator coefficients.
func (g2CurveMapperParams) XNum() []Fp2 <span class="cov8" title="1">{
        return g2SswuIsogenyXNum[:]
}</span>

// XDen returns isogeny x denominator coefficients.
func (g2CurveMapperParams) XDen() []Fp2 <span class="cov8" title="1">{
        return g2SswuIsogenyXDen[:]
}</span>

// YNum returns isogeny y numerator coefficients.
func (g2CurveMapperParams) YNum() []Fp2 <span class="cov8" title="1">{
        return g2SswuIsogenyYNum[:]
}</span>

// YDen returns isogeny y denominator coefficients.
func (g2CurveMapperParams) YDen() []Fp2 <span class="cov8" title="1">{
        return g2SswuIsogenyYDen[:]
}</span>

func frobenius(out, in *Fp2) <span class="cov8" title="1">{
        var a Fp2

        // 1. a = x0 - I * x1
        a.U0.Set(&amp;in.U0)
        a.U1.Neg(&amp;in.U1)
        // 2. return a
        out.Set(&amp;a)
}</span>

func psi(out, in *G2Point) <span class="cov8" title="1">{
        var q G2Point

        // 1. qxn = c1 * frobenius(xn)
        frobenius(&amp;q.X, &amp;in.X)
        q.X.Mul(&amp;g2PsiC1, &amp;q.X)

        // 2. qxd = frobenius(xd)
        // 4. qyd = frobenius(yd)
        frobenius(&amp;q.Z, &amp;in.Z)

        // 3. qyn = c2 * frobenius(yn)
        frobenius(&amp;q.Y, &amp;in.Y)
        q.Y.Mul(&amp;g2PsiC2, &amp;q.Y)

        // 5. return (qxn, qxd, qyn, qyd)
        out.Set(&amp;q)
}</span>

func psi2(out, in *G2Point) <span class="cov8" title="1">{
        var q G2Point

        // 1. qxn = c1 * xn
        q.X.Mul(&amp;g2Psi2C1, &amp;in.X)

        // 2. qyn = -yn
        q.Y.Neg(&amp;in.Y)

        // 3. return (qxn, xd, qyn, yd)
        q.Z.Set(&amp;in.Z)
        out.Set(&amp;q)
}</span>

func clearCofactorBls12381G2(out, in *G2Point) <span class="cov8" title="1">{
        var t1, t2, t3, q G2Point

        // 1.  t1 = c1 * P
        aimpl.ScalarMulLowLevel(&amp;t1, in, binary.LittleEndian.AppendUint64(nil, X))
        t1.Neg(&amp;t1)

        // 2.  t2 = psi(P)
        psi(&amp;t2, in)

        // 3.  t3 = 2 * P
        t3.Double(in)

        // 4.  t3 = psi2(t3)
        psi2(&amp;t3, &amp;t3)

        // 5.  t3 = t3 - t2
        t3.Sub(&amp;t3, &amp;t2)

        // 6.  t2 = t1 + t2
        t2.Add(&amp;t1, &amp;t2)

        // 7.  t2 = c1 * t2
        aimpl.ScalarMulLowLevel(&amp;t2, &amp;t2, binary.LittleEndian.AppendUint64(nil, X))
        t2.Neg(&amp;t2)

        // 8.  t3 = t3 + t2
        t3.Add(&amp;t3, &amp;t2)

        // 9.  t3 = t3 - t1
        t3.Sub(&amp;t3, &amp;t1)

        // 10.  Q = t3 - P
        q.Sub(&amp;t3, in)

        // 11. return Q
        out.Set(&amp;q)
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package impl

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

// GtBytes is the number of bytes needed to represent this field.
const GtBytes = 12 * FpBytes

// Gt is the target group.
type Gt struct {
        Fp12
}

// Bytes returns the Gt field byte representation.
func (gt *Gt) Bytes() []byte <span class="cov0" title="0">{
        var out [GtBytes]byte
        t := gt.U0.U0.U0.Bytes()
        copy(out[:FpBytes], sliceutils.Reverse(t))
        t = gt.U0.U0.U1.Bytes()
        copy(out[FpBytes:2*FpBytes], sliceutils.Reverse(t))
        t = gt.U0.U1.U0.Bytes()
        copy(out[2*FpBytes:3*FpBytes], sliceutils.Reverse(t))
        t = gt.U0.U1.U1.Bytes()
        copy(out[3*FpBytes:4*FpBytes], sliceutils.Reverse(t))
        t = gt.U0.U2.U0.Bytes()
        copy(out[4*FpBytes:5*FpBytes], sliceutils.Reverse(t))
        t = gt.U0.U2.U1.Bytes()
        copy(out[5*FpBytes:6*FpBytes], sliceutils.Reverse(t))
        t = gt.U1.U0.U0.Bytes()
        copy(out[6*FpBytes:7*FpBytes], sliceutils.Reverse(t))
        t = gt.U1.U0.U1.Bytes()
        copy(out[7*FpBytes:8*FpBytes], sliceutils.Reverse(t))
        t = gt.U1.U1.U0.Bytes()
        copy(out[8*FpBytes:9*FpBytes], sliceutils.Reverse(t))
        t = gt.U1.U1.U1.Bytes()
        copy(out[9*FpBytes:10*FpBytes], sliceutils.Reverse(t))
        t = gt.U1.U2.U0.Bytes()
        copy(out[10*FpBytes:11*FpBytes], sliceutils.Reverse(t))
        t = gt.U1.U2.U1.Bytes()
        copy(out[11*FpBytes:], sliceutils.Reverse(t))

        return out[:]
}</span>

// SetBytes attempts to convert a big-endian byte representation of
// a scalar into a `Gt`, failing if the input is not canonical.
// SetBytes sets the receiver from bytes.
func (gt *Gt) SetBytes(input []byte) (ok ct.Bool) <span class="cov0" title="0">{
        var t [FpBytes]byte
        var valid [12]ct.Bool
        copy(t[:], sliceutils.Reversed(input[:FpBytes]))
        valid[0] = gt.U0.U0.U0.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[FpBytes:2*FpBytes]))
        valid[1] = gt.U0.U0.U1.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[2*FpBytes:3*FpBytes]))
        valid[2] = gt.U0.U1.U0.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[3*FpBytes:4*FpBytes]))
        valid[3] = gt.U0.U1.U1.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[4*FpBytes:5*FpBytes]))
        valid[4] = gt.U0.U2.U0.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[5*FpBytes:6*FpBytes]))
        valid[5] = gt.U0.U2.U1.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[6*FpBytes:7*FpBytes]))
        valid[6] = gt.U1.U0.U0.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[7*FpBytes:8*FpBytes]))
        valid[7] = gt.U1.U0.U1.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[8*FpBytes:9*FpBytes]))
        valid[8] = gt.U1.U1.U0.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[9*FpBytes:10*FpBytes]))
        valid[9] = gt.U1.U1.U1.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[10*FpBytes:11*FpBytes]))
        valid[10] = gt.U1.U2.U0.SetBytes(t[:])
        copy(t[:], sliceutils.Reversed(input[11*FpBytes:12*FpBytes]))
        valid[11] = gt.U1.U2.U1.SetBytes(t[:])

        return valid[0] &amp; valid[1] &amp;
                valid[2] &amp; valid[3] &amp;
                valid[4] &amp; valid[5] &amp;
                valid[6] &amp; valid[7] &amp;
                valid[8] &amp; valid[9] &amp;
                valid[10] &amp; valid[11]
}</span>

// FinalExponentiation performs a "final exponentiation" routine to convert the result
// of a Miller loop into an element of `Gt` with help of efficient squaring
// operation in the so-called `cyclotomic subgroup` of `Fq6` so that
// it can be compared with other elements of `Gt`.
// FinalExponentiation performs the final exponentiation.
func (gt *Gt) FinalExponentiation(a *Gt) <span class="cov8" title="1">{
        var t0, t1, t2, t3, t4, t5, t6, t Fp12
        Fp12FrobeniusAutomorphism(&amp;t0, &amp;a.Fp12)
        Fp12FrobeniusAutomorphism(&amp;t0, &amp;t0)
        Fp12FrobeniusAutomorphism(&amp;t0, &amp;t0)
        Fp12FrobeniusAutomorphism(&amp;t0, &amp;t0)
        Fp12FrobeniusAutomorphism(&amp;t0, &amp;t0)
        Fp12FrobeniusAutomorphism(&amp;t0, &amp;t0)

        // Shouldn't happen since we enforce `a` to be non-zero but just in case
        wasInverted := t1.Inv(&amp;a.Fp12)
        t2.Mul(&amp;t0, &amp;t1)
        t1.Set(&amp;t2)
        Fp12FrobeniusAutomorphism(&amp;t2, &amp;t2)
        Fp12FrobeniusAutomorphism(&amp;t2, &amp;t2)
        t2.Mul(&amp;t2, &amp;t1)
        CyclotomicSquare(&amp;t1, &amp;t2)
        Conjugate(&amp;t1, &amp;t1)

        CyclotomicExp(&amp;t3, &amp;t2, X)
        CyclotomicSquare(&amp;t4, &amp;t3)
        t5.Mul(&amp;t1, &amp;t3)
        CyclotomicExp(&amp;t1, &amp;t5, X)
        CyclotomicExp(&amp;t0, &amp;t1, X)
        CyclotomicExp(&amp;t6, &amp;t0, X)
        t6.Mul(&amp;t6, &amp;t4)
        CyclotomicExp(&amp;t4, &amp;t6, X)
        Conjugate(&amp;t5, &amp;t5)
        t4.Mul(&amp;t4, &amp;t5)
        t4.Mul(&amp;t4, &amp;t2)
        Conjugate(&amp;t5, &amp;t2)
        t1.Mul(&amp;t1, &amp;t2)
        Fp12FrobeniusAutomorphism(&amp;t1, &amp;t1)
        Fp12FrobeniusAutomorphism(&amp;t1, &amp;t1)
        Fp12FrobeniusAutomorphism(&amp;t1, &amp;t1)
        t6.Mul(&amp;t6, &amp;t5)
        Fp12FrobeniusAutomorphism(&amp;t6, &amp;t6)
        t3.Mul(&amp;t3, &amp;t0)
        Fp12FrobeniusAutomorphism(&amp;t3, &amp;t3)
        Fp12FrobeniusAutomorphism(&amp;t3, &amp;t3)
        t3.Mul(&amp;t3, &amp;t1)
        t3.Mul(&amp;t3, &amp;t6)
        t.Mul(&amp;t3, &amp;t4)

        gt.Select(wasInverted, &amp;gt.Fp12, &amp;t)
}</span>

// Fp12FrobeniusAutomorphism applies the Frobenius automorphism in Fp12.
func Fp12FrobeniusAutomorphism(f, arg *Fp12) *Fp12 <span class="cov8" title="1">{
        var a, b, up1epm1div6 Fp6

        // (u + 1)^((p - 1) / 6)
        up1epm1div6.U0 = Fp2{
                //nolint:exhaustruct // no need for _ mark
                U0: Fp{
                        fiatFpMontgomeryDomainFieldElement: fiatFpMontgomeryDomainFieldElement{
                                0x07089552b319d465,
                                0xc6695f92b50a8313,
                                0x97e83cccd117228f,
                                0xa35baecab2dc29ee,
                                0x1ce393ea5daace4d,
                                0x08f2220fb0fb66eb,
                        },
                },
                //nolint:exhaustruct // no need for _ mark
                U1: Fp{
                        fiatFpMontgomeryDomainFieldElement: fiatFpMontgomeryDomainFieldElement{
                                0xb2f66aad4ce5d646,
                                0x5842a06bfc497cec,
                                0xcf4895d42599d394,
                                0xc11b9cba40a8e8d0,
                                0x2e3813cbe5a0de89,
                                0x110eefda88847faf,
                        },
                },
        }

        Fp6FrobeniusAutomorphism(&amp;a, &amp;arg.U0)
        Fp6FrobeniusAutomorphism(&amp;b, &amp;arg.U1)

        // b' = b' * (u + 1)^((p - 1) / 6)
        b.Mul(&amp;b, &amp;up1epm1div6)

        f.U0.Set(&amp;a)
        f.U1.Set(&amp;b)
        return f
}</span>

// Fp6FrobeniusAutomorphism raises this element to p.
func Fp6FrobeniusAutomorphism(f, arg *Fp6) *Fp6 <span class="cov8" title="1">{
        var a, b, c Fp2
        //nolint:exhaustruct // no need for U0
        pm1Div3 := Fp2{
                //nolint:exhaustruct // no need for _
                U1: Fp{
                        fiatFpMontgomeryDomainFieldElement: fiatFpMontgomeryDomainFieldElement{
                                0xcd03c9e48671f071,
                                0x5dab22461fcda5d2,
                                0x587042afd3851b95,
                                0x8eb60ebe01bacb9e,
                                0x03f97d6e83d050d2,
                                0x18f0206554638741,
                        },
                },
        }
        //nolint:exhaustruct // no need for U1
        p2m2Div3 := Fp2{
                //nolint:exhaustruct // no need for _
                U0: Fp{
                        fiatFpMontgomeryDomainFieldElement: fiatFpMontgomeryDomainFieldElement{
                                0x890dc9e4867545c3,
                                0x2af322533285a5d5,
                                0x50880866309b7e2c,
                                0xa20d1b8c7e881024,
                                0x14e4f04fe2db9068,
                                0x14e56d3f1564853a,
                        },
                },
        }
        Fp2FrobeniusAutomorphism(&amp;a, &amp;arg.U0)
        Fp2FrobeniusAutomorphism(&amp;b, &amp;arg.U1)
        Fp2FrobeniusAutomorphism(&amp;c, &amp;arg.U2)

        // b = b * (u + 1)^((p - 1) / 3)
        b.Mul(&amp;b, &amp;pm1Div3)

        // c = c * (u + 1)^((2p - 2) / 3)
        c.Mul(&amp;c, &amp;p2m2Div3)

        f.U0.Set(&amp;a)
        f.U1.Set(&amp;b)
        f.U2.Set(&amp;c)
        return f
}</span>

// Fp2FrobeniusAutomorphism raises this element to p.
func Fp2FrobeniusAutomorphism(f, a *Fp2) <span class="cov8" title="1">{
        // This is always just a conjugation. If you're curious why, here's
        // an article about it: https://alicebob.cryptoland.net/the-frobenius-endomorphism-with-finite-fields/
        Conjugate(f, a)
}</span>

// CyclotomicExp raises f to the given exponent in the cyclotomic subgroup.
func CyclotomicExp(f *Fp12, a *Fp12, exp uint64) <span class="cov8" title="1">{
        var t Fp12
        t.SetOne()
        foundOne := uint64(0)

        for i := 63; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                b := (exp &gt;&gt; i) &amp; 1
                if foundOne == 1 </span><span class="cov8" title="1">{
                        CyclotomicSquare(&amp;t, &amp;t)
                }</span> else<span class="cov8" title="1"> {
                        foundOne = b
                }</span>
                <span class="cov8" title="1">if b == 1 </span><span class="cov8" title="1">{
                        t.Mul(&amp;t, a)
                }</span>
        }
        <span class="cov8" title="1">Conjugate(f, &amp;t)</span>
}

// CyclotomicSquare squares f in the cyclotomic subgroup.
func CyclotomicSquare(f, a *Fp12) <span class="cov8" title="1">{
        // Adaptation of Algorithm 5.5.4, Guide to Pairing-Based Cryptography
        // Faster Squaring in the Cyclotomic Subgroup of Sixth Degree Extensions
        // https://eprint.iacr.org/2009/565.pdf
        var params fp6Params
        var z0, z1, z2, z3, z4, z5, t0, t1, t2, t3 Fp2
        z0.Set(&amp;a.U0.U0)
        z4.Set(&amp;a.U0.U1)
        z3.Set(&amp;a.U0.U2)
        z2.Set(&amp;a.U1.U0)
        z1.Set(&amp;a.U1.U1)
        z5.Set(&amp;a.U1.U2)

        fp4Square(&amp;t0, &amp;t1, &amp;z0, &amp;z1)
        z0.Sub(&amp;t0, &amp;z0)
        z0.Add(&amp;z0, &amp;z0)
        z0.Add(&amp;z0, &amp;t0)

        z1.Add(&amp;t1, &amp;z1)
        z1.Add(&amp;z1, &amp;z1)
        z1.Add(&amp;z1, &amp;t1)

        fp4Square(&amp;t0, &amp;t1, &amp;z2, &amp;z3)
        fp4Square(&amp;t2, &amp;t3, &amp;z4, &amp;z5)

        z4.Sub(&amp;t0, &amp;z4)
        z4.Add(&amp;z4, &amp;z4)
        z4.Add(&amp;z4, &amp;t0)

        z5.Add(&amp;z5, &amp;t1)
        z5.Add(&amp;z5, &amp;z5)
        z5.Add(&amp;z5, &amp;t1)

        params.MulByCubicNonResidue(&amp;t0, &amp;t3)
        z2.Add(&amp;z2, &amp;t0)
        z2.Add(&amp;z2, &amp;z2)
        z2.Add(&amp;z2, &amp;t0)

        z3.Sub(&amp;t2, &amp;z3)
        z3.Add(&amp;z3, &amp;z3)
        z3.Add(&amp;z3, &amp;t2)

        f.U0.U0.Set(&amp;z0)
        f.U0.U1.Set(&amp;z4)
        f.U0.U2.Set(&amp;z3)
        f.U1.U0.Set(&amp;z2)
        f.U1.U1.Set(&amp;z1)
        f.U1.U2.Set(&amp;z5)
}</span>

// Conjugate negates the quadratic extension's U1 component.
func Conjugate[BFP fieldsImpl.FiniteFieldElementPtr[BFP, BF], A fieldsImpl.QuadraticFieldExtensionArithmetic[BFP], BF any](f, arg *fieldsImpl.QuadraticFieldExtensionImpl[BFP, A, BF]) <span class="cov8" title="1">{
        BFP(&amp;f.U0).Set(&amp;arg.U0)
        BFP(&amp;f.U1).Neg(&amp;arg.U1)
}</span>

func fp4Square(a, b, arg1, arg2 *Fp2) <span class="cov8" title="1">{
        var params fp6Params
        var t0, t1, t2 Fp2

        t0.Square(arg1)
        t1.Square(arg2)
        params.MulByCubicNonResidue(&amp;t2, &amp;t1)
        a.Add(&amp;t2, &amp;t0)
        t2.Add(arg1, arg2)
        t2.Square(&amp;t2)
        t2.Sub(&amp;t2, &amp;t0)
        b.Sub(&amp;t2, &amp;t1)
}</span>
</pre>
		
		<pre class="file" id="file103" style="display: none">package impl

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        pointsImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
)

const coefficientsG2 = 68

// Engine implements the pairing engine state machine.
type Engine struct {
        pairs []pair
}

type pair struct {
        g1 G1Point
        g2 G2Point
}

type g2Prepared struct {
        identity     ct.Bool
        coefficients []coefficients
}

type coefficients struct {
        a, b, c Fp2
}

// Select conditionally assigns z or nz into the receiver.
func (c *coefficients) Select(choice ct.Choice, arg0, arg1 *coefficients) *coefficients <span class="cov0" title="0">{
        c.a.Select(choice, &amp;arg0.a, &amp;arg1.a)
        c.b.Select(choice, &amp;arg0.b, &amp;arg1.b)
        c.c.Select(choice, &amp;arg0.c, &amp;arg1.c)
        return c
}</span>

// AddPair adds a pair of points to be paired.
func (e *Engine) AddPair(g1 *G1Point, g2 *G2Point) *Engine <span class="cov8" title="1">{
        var p pair
        if g1.IsZero()|g2.IsZero() == 0 </span><span class="cov8" title="1">{
                affinize(&amp;p.g1, g1)
                affinize(&amp;p.g2, g2)
                e.pairs = append(e.pairs, p)
        }</span>
        <span class="cov8" title="1">return e</span>
}

// AddPairInvG1 adds a pair of points to be paired. G1 point is negated.
func (e *Engine) AddPairInvG1(g1 *G1Point, g2 *G2Point) *Engine <span class="cov8" title="1">{
        var p G1Point
        p.Neg(g1)
        return e.AddPair(&amp;p, g2)
}</span>

// AddPairInvG2 adds a pair of points to be paired. G2 point is negated.
func (e *Engine) AddPairInvG2(g1 *G1Point, g2 *G2Point) *Engine <span class="cov8" title="1">{
        var p G2Point
        p.Neg(g2)
        return e.AddPair(g1, &amp;p)
}</span>

// Reset clears the pairing engine state.
func (e *Engine) Reset() *Engine <span class="cov8" title="1">{
        e.pairs = []pair{}
        return e
}</span>

// Check verifies the accumulated pairing.
func (e *Engine) Check() bool <span class="cov0" title="0">{
        return e.pairing().IsOne() == 1
}</span>

// Result returns the accumulated pairing result.
func (e *Engine) Result() *Fp12 <span class="cov8" title="1">{
        return e.pairing()
}</span>

func (e *Engine) pairing() *Fp12 <span class="cov8" title="1">{
        f := new(Gt)
        f.SetOne()
        if len(e.pairs) == 0 </span><span class="cov0" title="0">{
                return &amp;f.Fp12
        }</span>
        <span class="cov8" title="1">coeffs := e.computeCoeffs()
        e.millerLoop(&amp;f.Fp12, coeffs)

        f.FinalExponentiation(f)
        return &amp;f.Fp12</span>
}

func (e *Engine) millerLoop(f *Fp12, coeffs []g2Prepared) <span class="cov8" title="1">{
        newF := new(Fp12)
        newF.SetZero()
        found := uint64(0)
        cIdx := 0
        for i := 63; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                x := ((X &gt;&gt; 1) &gt;&gt; i) &amp; 1
                if found == 0 </span><span class="cov8" title="1">{
                        found |= x
                        continue</span>
                }

                // doubling
                <span class="cov8" title="1">for j, terms := range coeffs </span><span class="cov8" title="1">{
                        identity := e.pairs[j].g1.IsZero() | terms.identity
                        newF.Set(f)
                        ell(newF, &amp;terms.coefficients[cIdx], &amp;e.pairs[j].g1)
                        f.Select(identity, newF, f)
                }</span>
                <span class="cov8" title="1">cIdx++

                if x == 1 </span><span class="cov8" title="1">{
                        // adding
                        for j, terms := range coeffs </span><span class="cov8" title="1">{
                                identity := e.pairs[j].g1.IsZero() | terms.identity
                                newF.Set(f)
                                ell(newF, &amp;terms.coefficients[cIdx], &amp;e.pairs[j].g1)
                                f.Select(identity, newF, f)
                        }</span>
                        <span class="cov8" title="1">cIdx++</span>
                }
                <span class="cov8" title="1">f.Square(f)</span>
        }
        <span class="cov8" title="1">for j, terms := range coeffs </span><span class="cov8" title="1">{
                identity := e.pairs[j].g1.IsZero() | terms.identity
                newF.Set(f)
                ell(newF, &amp;terms.coefficients[cIdx], &amp;e.pairs[j].g1)
                f.Select(identity, newF, f)
        }</span>
        <span class="cov8" title="1">Conjugate(f, f)</span>
}

func (e *Engine) computeCoeffs() []g2Prepared <span class="cov8" title="1">{
        coeffs := make([]g2Prepared, len(e.pairs))
        for i := range len(e.pairs) </span><span class="cov8" title="1">{
                p := e.pairs[i]
                identity := p.g2.IsZero()
                q := new(G2Point)
                q.SetGenerator()
                q.Select(identity, &amp;p.g2, q)
                c := new(G2Point)
                c.Set(q)
                cfs := make([]coefficients, coefficientsG2)
                found := 0
                k := 0

                for j := 63; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                        x := int(((X &gt;&gt; 1) &gt;&gt; j) &amp; 1)
                        if found == 0 </span><span class="cov8" title="1">{
                                found |= x
                                continue</span>
                        }
                        <span class="cov8" title="1">cfs[k] = doublingStep(c)
                        k++

                        if x == 1 </span><span class="cov8" title="1">{
                                cfs[k] = additionStep(c, q)
                                k++
                        }</span>
                }
                <span class="cov8" title="1">cfs[k] = doublingStep(c)
                coeffs[i] = g2Prepared{
                        coefficients: cfs, identity: identity,
                }</span>
        }
        <span class="cov8" title="1">return coeffs</span>
}

func ell(f *Fp12, coeffs *coefficients, p *G1Point) <span class="cov8" title="1">{
        var x, y Fp2
        x.U0.Mul(&amp;coeffs.a.U0, &amp;p.Y)
        x.U1.Mul(&amp;coeffs.a.U1, &amp;p.Y)
        y.U0.Mul(&amp;coeffs.b.U0, &amp;p.X)
        y.U1.Mul(&amp;coeffs.b.U1, &amp;p.X)
        mulByABD(f, f, &amp;coeffs.c, &amp;y, &amp;x)
}</span>

func doublingStep(p *G2Point) coefficients <span class="cov8" title="1">{
        // Adaptation of Algorithm 26, https://eprint.iacr.org/2010/354.pdf
        var t0, t1, t2, t3, t4, t5, t6, zsqr Fp2
        t0.Square(&amp;p.X)
        t1.Square(&amp;p.Y)
        t2.Square(&amp;t1)
        t3.Add(&amp;t1, &amp;p.X)
        t3.Square(&amp;t3)
        t3.Sub(&amp;t3, &amp;t0)
        t3.Sub(&amp;t3, &amp;t2)
        t3.Add(&amp;t3, &amp;t3)
        t4.Add(&amp;t0, &amp;t0)
        t4.Add(&amp;t4, &amp;t0)
        t6.Add(&amp;p.X, &amp;t4)
        t5.Square(&amp;t4)
        zsqr.Square(&amp;p.Z)
        p.X.Sub(&amp;t5, &amp;t3)
        p.X.Sub(&amp;p.X, &amp;t3)
        p.Z.Add(&amp;p.Z, &amp;p.Y)
        p.Z.Square(&amp;p.Z)
        p.Z.Sub(&amp;p.Z, &amp;t1)
        p.Z.Sub(&amp;p.Z, &amp;zsqr)
        p.Y.Sub(&amp;t3, &amp;p.X)
        p.Y.Mul(&amp;p.Y, &amp;t4)
        t2.Add(&amp;t2, &amp;t2)
        t2.Add(&amp;t2, &amp;t2)
        t2.Add(&amp;t2, &amp;t2)
        p.Y.Sub(&amp;p.Y, &amp;t2)
        t3.Mul(&amp;t4, &amp;zsqr)
        t3.Add(&amp;t3, &amp;t3)
        t3.Neg(&amp;t3)
        t6.Square(&amp;t6)
        t6.Sub(&amp;t6, &amp;t0)
        t6.Sub(&amp;t6, &amp;t5)
        t1.Add(&amp;t1, &amp;t1)
        t1.Add(&amp;t1, &amp;t1)
        t6.Sub(&amp;t6, &amp;t1)
        t0.Mul(&amp;p.Z, &amp;zsqr)
        t0.Add(&amp;t0, &amp;t0)

        return coefficients{
                a: t0, b: t3, c: t6,
        }
}</span>

func additionStep(r, q *G2Point) coefficients <span class="cov8" title="1">{
        // Adaptation of Algorithm 27, https://eprint.iacr.org/2010/354.pdf
        var zsqr, ysqr Fp2
        var t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10 Fp2
        zsqr.Square(&amp;r.Z)
        ysqr.Square(&amp;q.Y)
        t0.Mul(&amp;zsqr, &amp;q.X)
        t1.Add(&amp;q.Y, &amp;r.Z)
        t1.Square(&amp;t1)
        t1.Sub(&amp;t1, &amp;ysqr)
        t1.Sub(&amp;t1, &amp;zsqr)
        t1.Mul(&amp;t1, &amp;zsqr)
        t2.Sub(&amp;t0, &amp;r.X)
        t3.Square(&amp;t2)
        t4.Add(&amp;t3, &amp;t3)
        t4.Add(&amp;t4, &amp;t4)
        t5.Mul(&amp;t4, &amp;t2)
        t6.Sub(&amp;t1, &amp;r.Y)
        t6.Sub(&amp;t6, &amp;r.Y)
        t9.Mul(&amp;t6, &amp;q.X)
        t7.Mul(&amp;t4, &amp;r.X)
        r.X.Square(&amp;t6)
        r.X.Sub(&amp;r.X, &amp;t5)
        r.X.Sub(&amp;r.X, &amp;t7)
        r.X.Sub(&amp;r.X, &amp;t7)
        r.Z.Add(&amp;r.Z, &amp;t2)
        r.Z.Square(&amp;r.Z)
        r.Z.Sub(&amp;r.Z, &amp;zsqr)
        r.Z.Sub(&amp;r.Z, &amp;t3)
        t10.Add(&amp;q.Y, &amp;r.Z)
        t8.Sub(&amp;t7, &amp;r.X)
        t8.Mul(&amp;t8, &amp;t6)
        t0.Mul(&amp;r.Y, &amp;t5)
        t0.Add(&amp;t0, &amp;t0)
        r.Y.Sub(&amp;t8, &amp;t0)
        t10.Square(&amp;t10)
        t10.Sub(&amp;t10, &amp;ysqr)
        zsqr.Square(&amp;r.Z)
        t10.Sub(&amp;t10, &amp;zsqr)
        t9.Add(&amp;t9, &amp;t9)
        t9.Sub(&amp;t9, &amp;t10)
        t10.Add(&amp;r.Z, &amp;r.Z)
        t6.Neg(&amp;t6)
        t1.Add(&amp;t6, &amp;t6)

        return coefficients{
                a: t10, b: t1, c: t9,
        }
}</span>

// mulByABD computes arg * a * b * c.
func mulByABD(f, arg *Fp12, a, b, d *Fp2) <span class="cov8" title="1">{
        var params fp12Params
        var aa, bb, aTick, bTick Fp6
        var bd Fp2

        mulByAB(&amp;aa, &amp;arg.U0, a, b)
        mulByB(&amp;bb, &amp;arg.U1, d)
        bd.Add(b, d)

        bTick.Add(&amp;arg.U0, &amp;arg.U1)
        mulByAB(&amp;bTick, &amp;bTick, a, &amp;bd)
        bTick.Sub(&amp;bTick, &amp;aa)
        bTick.Sub(&amp;bTick, &amp;bb)

        params.MulByQuadraticNonResidue(&amp;aTick, &amp;bb)
        aTick.Add(&amp;aTick, &amp;aa)

        f.U0.Set(&amp;aTick)
        f.U1.Set(&amp;bTick)
}</span>

// MulByAB scales this field by scalars in the A and B coefficients.
func mulByAB(f, arg *Fp6, a, b *Fp2) <span class="cov8" title="1">{
        var params fp6Params
        var aA, bB, t1, t2, t3 Fp2

        aA.Mul(&amp;arg.U0, a)
        bB.Mul(&amp;arg.U1, b)

        t1.Add(&amp;arg.U1, &amp;arg.U2)
        t1.Mul(&amp;t1, b)
        t1.Sub(&amp;t1, &amp;bB)
        params.MulByCubicNonResidue(&amp;t1, &amp;t1)
        t1.Add(&amp;t1, &amp;aA)

        t2.Add(a, b)
        t3.Add(&amp;arg.U0, &amp;arg.U1)
        t2.Mul(&amp;t2, &amp;t3)
        t2.Sub(&amp;t2, &amp;aA)
        t2.Sub(&amp;t2, &amp;bB)

        t3.Add(&amp;arg.U0, &amp;arg.U2)
        t3.Mul(&amp;t3, a)
        t3.Sub(&amp;t3, &amp;aA)
        t3.Add(&amp;t3, &amp;bB)

        f.U0.Set(&amp;t1)
        f.U1.Set(&amp;t2)
        f.U2.Set(&amp;t3)
}</span>

// MulByB scales this field by a scalar in the B coefficient.
func mulByB(f, arg *Fp6, b *Fp2) <span class="cov8" title="1">{
        var params fp6Params
        var bB, t1, t2 Fp2

        bB.Mul(&amp;arg.U1, b)
        // (b + c) * arg2 - bB
        t1.Add(&amp;arg.U1, &amp;arg.U2)
        t1.Mul(&amp;t1, b)
        t1.Sub(&amp;t1, &amp;bB)
        params.MulByCubicNonResidue(&amp;t1, &amp;t1)

        t2.Add(&amp;arg.U0, &amp;arg.U1)
        t2.Mul(&amp;t2, b)
        t2.Sub(&amp;t2, &amp;bB)

        f.U0.Set(&amp;t1)
        f.U1.Set(&amp;t2)
        f.U2.Set(&amp;bB)
}</span>

func affinize[FP fieldsImpl.FiniteFieldElementPtr[FP, F], C pointsImpl.ShortWeierstrassCurveParams[FP], H h2c.HasherParams, M h2c.PointMapper[FP], F any](out, in *pointsImpl.ShortWeierstrassPointImpl[FP, C, H, M, F]) <span class="cov8" title="1">{
        var x, y, zInv F
        FP(&amp;zInv).Inv(&amp;in.Z)
        FP(&amp;x).Mul(&amp;in.X, &amp;zInv)
        FP(&amp;y).Mul(&amp;in.Y, &amp;zInv)

        FP(&amp;out.X).Set(&amp;x)
        FP(&amp;out.Y).Set(&amp;y)
        FP(&amp;out.Z).SetOne()
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package bls12381

import (
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl"
)

var (
        _ curves.PPE[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar] = (*OptimalAtePPE)(nil)
)

const (
        OptimalAteAlgorithm curves.PairingAlgorithm = "OptimalAte"
)

// NewOptimalAtePPE returns the optimal ate pairing engine.
func NewOptimalAtePPE() curves.PPE[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar] <span class="cov0" title="0">{
        p := &amp;OptimalAtePPE{
                engine: bls12381Impl.Engine{},
        }
        return p
}</span>

// OptimalAtePPE implements the optimal ate pairing engine.
type OptimalAtePPE struct {
        engine bls12381Impl.Engine
}

// Add sets the receiver to lhs + rhs.
func (p *OptimalAtePPE) Add(g1 *PointG1, g2 *PointG2) error <span class="cov0" title="0">{
        if g1 == nil || g2 == nil || g1.IsZero() || g2.IsZero() </span><span class="cov0" title="0">{
                return curves.ErrFailed.WithMessage("g1 or g2 cannot be nil/identity")
        }</span>
        <span class="cov0" title="0">p.engine.AddPair(&amp;g1.V, &amp;g2.V)
        return nil</span>
}

// AddAndInvG1 adds a pair with G1 inverted.
func (p *OptimalAtePPE) AddAndInvG1(g1 *PointG1, g2 *PointG2) error <span class="cov0" title="0">{
        if g1 == nil || g2 == nil || g1.IsZero() || g2.IsZero() </span><span class="cov0" title="0">{
                return curves.ErrFailed.WithMessage("g1 or g2 cannot be nil/identity")
        }</span>
        <span class="cov0" title="0">p.engine.AddPairInvG1(&amp;g1.V, &amp;g2.V)
        return nil</span>
}

// AddAndInvG2 adds a pair with G2 inverted.
func (p *OptimalAtePPE) AddAndInvG2(g1 *PointG1, g2 *PointG2) error <span class="cov0" title="0">{
        if g1 == nil || g2 == nil || g1.IsZero() || g2.IsZero() </span><span class="cov0" title="0">{
                return curves.ErrFailed.WithMessage("g1 or g2 cannot be nil/identity")
        }</span>
        <span class="cov0" title="0">p.engine.AddPairInvG2(&amp;g1.V, &amp;g2.V)
        return nil</span>
}

// Result returns the accumulated pairing result.
func (p *OptimalAtePPE) Result() *GtElement <span class="cov0" title="0">{
        var result GtElement
        result.V.Set(p.engine.Result())
        return &amp;result
}</span>

// Check verifies the accumulated pairing.
func (p *OptimalAtePPE) Check() bool <span class="cov0" title="0">{
        return p.engine.Check()
}</span>

// Reset clears the pairing engine state.
func (p *OptimalAtePPE) Reset() <span class="cov0" title="0">{
        p.engine.Reset()
}</span>

// Name returns the name of the structure.
func (*OptimalAtePPE) Name() curves.PairingAlgorithm <span class="cov0" title="0">{
        return OptimalAteAlgorithm
}</span>

// Equal reports whether the receiver equals v.
func (p *OptimalAtePPE) Equal(other curves.PPE[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar]) bool <span class="cov0" title="0">{
        if other == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">o, ok := other.(*OptimalAtePPE)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return p.Name() != o.Name()</span>
}

// Type returns the pairing type.
func (*OptimalAtePPE) Type() curves.PairingType <span class="cov0" title="0">{
        return curves.TypeIII
}</span>

// func NewPairing() curves.Pairing[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar] {
//         return &amp;Pairing{
//                 core: NewOptimalAtePPE().(*OptimalAtePPE),
//         }
// }.

// type Pairing struct {
//         core *OptimalAtePPE
// }.

// func (p *Pairing) Name() curves.PairingAlgorithm {
//         return OptimalAteAlgorithm
// }.

// func (p *Pairing) Type() curves.PairingType {
//         return curves.TypeIII
// }.

// func (p *Pairing) Pair(g1 *PointG1, g2 *PointG2) (*GtElement, error) {
//         defer p.core.Reset()
//         if err := p.core.Add(g1, g2); err != nil {
//                 return nil, err
//         }
//         return p.core.Result(), nil
// }.

// func (p *Pairing) MultiPair(g1 []*PointG1, g2 []*PointG2) (*GtElement, error) {
//         defer p.core.Reset()
//         if len(g1) != len(g2) {
//                 return nil, curves.ErrFailed.WithMessage("g1 and g2 must have the same length")
//         }

//         for i := range g1 {
//                 if err := p.core.Add(g1[i], g2[i]); err != nil {
//                         return nil, err
//                 }
//         }

//         return p.core.Result(), nil
// }.

// func (p *Pairing) Equal(other curves.Pairing[*PointG1, *BaseFieldElementG1, *PointG2, *BaseFieldElementG2, *GtElement, *Scalar]) bool {
//         if other == nil {
//                 return false
//         }
//         o, ok := other.(*Pairing)
//         if !ok {
//                 return false
//         }
//         return p.Name() == o.Name()
// }.
</pre>
		
		<pre class="file" id="file105" style="display: none">package bls12381

import (
        "encoding"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

const (
        // ScalarFieldName is the scalar field name.
        ScalarFieldName = "BLS12381Fq"
        // Hash2CurveScalarSuite is the hash-to-curve scalar suite string.
        Hash2CurveScalarSuite = "BLS12381G1_XMD:SHA-256_SSWU_RO_SC_"
)

var (
        _ algebra.PrimeField[*Scalar]        = (*ScalarField)(nil)
        _ algebra.PrimeFieldElement[*Scalar] = (*Scalar)(nil)
        _ encoding.BinaryMarshaler           = (*Scalar)(nil)
        _ encoding.BinaryUnmarshaler         = (*Scalar)(nil)

        scalarFieldInitOnce sync.Once
        scalarFieldInstance *ScalarField
        scalarFieldOrder    *numct.Modulus
)

func scalarFieldInit() <span class="cov8" title="1">{
        scalarFieldOrder, _ = numct.NewModulusFromBytesBE(sliceutils.Reversed(bls12381Impl.FqModulus[:]))
        //nolint:exhaustruct // no need for trait
        scalarFieldInstance = &amp;ScalarField{}
}</span>

// ScalarField represents the scalar field.
type ScalarField struct {
        traits.PrimeFieldTrait[*bls12381Impl.Fq, *Scalar, Scalar]
}

// NewScalarField returns the scalar field instance.
func NewScalarField() *ScalarField <span class="cov8" title="1">{
        scalarFieldInitOnce.Do(scalarFieldInit)
        return scalarFieldInstance
}</span>

// Name returns the name of the structure.
func (*ScalarField) Name() string <span class="cov0" title="0">{
        return ScalarFieldName
}</span>

// ElementSize returns the element size in bytes.
func (*ScalarField) ElementSize() int <span class="cov0" title="0">{
        return bls12381Impl.FqBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*ScalarField) WideElementSize() int <span class="cov0" title="0">{
        return bls12381Impl.FqWideBytes
}</span>

// Characteristic returns the field characteristic.
func (f *ScalarField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return f.Order()
}</span>

// Order returns the group or field order.
func (*ScalarField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(scalarFieldOrder)
}</span>

// Hash maps input bytes to an element or point.
func (*ScalarField) Hash(input []byte) (*Scalar, error) <span class="cov0" title="0">{
        var e [1]bls12381Impl.Fq
        h2c.HashToField(e[:], bls12381Impl.G1CurveHasherParams{}, base.Hash2CurveAppTag+Hash2CurveScalarSuite, input)

        var s Scalar
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *ScalarField) FromBytesBEReduce(input []byte) (*Scalar, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        scalarFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// BitLen returns the field modulus bit length.
func (*ScalarField) BitLen() int <span class="cov0" title="0">{
        return bls12381Impl.FqBits
}</span>

// Scalar represents a scalar field element.
type Scalar struct {
        traits.PrimeFieldElementTrait[*bls12381Impl.Fq, bls12381Impl.Fq, *Scalar, Scalar]
}

// Structure returns the algebraic structure for the receiver.
func (*Scalar) Structure() algebra.Structure[*Scalar] <span class="cov0" title="0">{
        return NewScalarField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (s *Scalar) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        return s.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (s *Scalar) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := s.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("cannot unmarshal scalar")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package pairable

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381"
)

var (
        familyInstanceBLS12381 *BLS12381
        familyInitOnceBLS12381 sync.Once
)

// NewBLS12381 returns the BLS12-381 family instance.
func NewBLS12381() curves.PairingFriendlyFamily[*bls12381.PointG1, *bls12381.BaseFieldElementG1, *bls12381.PointG2, *bls12381.BaseFieldElementG2, *bls12381.GtElement, *bls12381.Scalar] <span class="cov0" title="0">{
        //nolint:exhaustruct // no need for trait
        familyInitOnceBLS12381.Do(func() </span><span class="cov0" title="0">{ familyInstanceBLS12381 = &amp;BLS12381{} }</span>)
        <span class="cov0" title="0">return familyInstanceBLS12381</span>
}

// BLS12381 provides access to BLS12-381 groups.
type BLS12381 struct{ bls12381.FamilyTrait }
</pre>
		
		<pre class="file" id="file107" style="display: none">package pasta

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*PallasBaseFieldElement)(nil)
        _ cbor.Unmarshaler = (*PallasBaseFieldElement)(nil)
        _ cbor.Marshaler   = (*PallasScalar)(nil)
        _ cbor.Unmarshaler = (*PallasScalar)(nil)
        _ cbor.Marshaler   = (*PallasPoint)(nil)
        _ cbor.Unmarshaler = (*PallasPoint)(nil)

        _ cbor.Marshaler   = (*VestaBaseFieldElement)(nil)
        _ cbor.Unmarshaler = (*VestaBaseFieldElement)(nil)
        _ cbor.Marshaler   = (*VestaScalar)(nil)
        _ cbor.Unmarshaler = (*VestaScalar)(nil)
        _ cbor.Marshaler   = (*VestaPoint)(nil)
        _ cbor.Unmarshaler = (*VestaPoint)(nil)
)

type fpFieldElementDTO struct {
        FieldBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *FpFieldElement) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;fpFieldElementDTO{FieldBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *FpFieldElement) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*fpFieldElementDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">bfe, err := newFpField().FromBytes(dto.FieldBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize base field element")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;bfe.V)
        return nil</span>
}

type fqFieldElementDTO struct {
        FieldBytes []byte `cbor:"fieldBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (fe *FqFieldElement) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;fqFieldElementDTO{FieldBytes: fe.Bytes()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (fe *FqFieldElement) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*fqFieldElementDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s, err := newFqField().FromBytes(dto.FieldBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize scalar")
        }</span>
        <span class="cov8" title="1">fe.V.Set(&amp;s.V)
        return nil</span>
}

type pallasPointDTO struct {
        AffineCompressedBytes []byte `cbor:"compressedBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (p *PallasPoint) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;pallasPointDTO{AffineCompressedBytes: p.ToCompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *PallasPoint) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*pallasPointDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pp, err := NewPallasCurve().FromCompressed(dto.AffineCompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov8" title="1">p.V.Set(&amp;pp.V)
        return nil</span>
}

type vestaPointDTO struct {
        AffineCompressedBytes []byte `cbor:"compressedBytes"`
}

// MarshalCBOR implements cbor.Marshaler.
func (p *VestaPoint) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;vestaPointDTO{AffineCompressedBytes: p.ToCompressed()}
        return serde.MarshalCBOR(dto)
}</span>

// UnmarshalCBOR implements cbor.Unmarshaler.
func (p *VestaPoint) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*vestaPointDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pp, err := NewVestaCurve().FromCompressed(dto.AffineCompressedBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov8" title="1">p.V.Set(&amp;pp.V)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package pasta

import (
        "crypto/elliptic"
        "math/big"

        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        pastaImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

var (
        ellipticPallasParams = &amp;elliptic.CurveParams{
                P:       mustSetBigIntString("40000000000000000000000000000000224698fc094cf91b992d30ed00000001"),
                N:       mustSetBigIntString("40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001"),
                B:       mustSetBigIntString("0000000000000000000000000000000000000000000000000000000000000005"),
                Gx:      mustSetBigIntString("40000000000000000000000000000000224698fc094cf91b992d30ed00000000"),
                Gy:      mustSetBigIntString("0000000000000000000000000000000000000000000000000000000000000002"),
                BitSize: pastaImpl.FpBits,
                Name:    PallasName,
        }
        ellipticPallasInstance = &amp;ellipticPallas{}

        ellipticVestaParams = &amp;elliptic.CurveParams{
                P:       mustSetBigIntString("40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001"),
                N:       mustSetBigIntString("40000000000000000000000000000000224698fc094cf91b992d30ed00000001"),
                B:       mustSetBigIntString("0000000000000000000000000000000000000000000000000000000000000005"),
                Gx:      mustSetBigIntString("40000000000000000000000000000000224698fc0994a8dd8c46eb2100000000"),
                Gy:      mustSetBigIntString("0000000000000000000000000000000000000000000000000000000000000002"),
                BitSize: pastaImpl.FqBits,
                Name:    VestaName,
        }
        ellipticVestaInstance = &amp;ellipticVesta{}
)

type ellipticPallas struct {
}

// Params returns the curve parameters.
func (*ellipticPallas) Params() *elliptic.CurveParams <span class="cov0" title="0">{
        return ellipticPallasParams
}</span>

// IsOnCurve reports whether the point is on the curve.
func (*ellipticPallas) IsOnCurve(x, y *big.Int) bool <span class="cov0" title="0">{
        // IsOnCurve is documented to reject (0, 0), the conventional point at infinity.
        if x.Sign() == 0 &amp;&amp; y.Sign() == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, err := fromPallasAffine(x, y)
        return err != nil</span>
}

// Add sets the receiver to lhs + rhs.
func (*ellipticPallas) Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int) <span class="cov0" title="0">{
        p1, err := fromPallasAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("Add was called on an invalid point")</span>
        }
        <span class="cov0" title="0">p2, err := fromPallasAffine(x2, y2)
        if err != nil </span><span class="cov0" title="0">{
                panic("Add was called on an invalid point")</span>
        }
        <span class="cov0" title="0">return toPallasAffine(p1.Add(p2))</span>
}

// Double sets the receiver to 2*x.
func (*ellipticPallas) Double(x1, y1 *big.Int) (x, y *big.Int) <span class="cov0" title="0">{
        p, err := fromPallasAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("Double was called on an invalid point")</span>
        }
        <span class="cov0" title="0">return toPallasAffine(p.Double())</span>
}

// ScalarMult multiplies a point by a scalar.
func (*ellipticPallas) ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int) <span class="cov0" title="0">{
        p, err := fromPallasAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called on an invalid point")</span>
        }
        <span class="cov0" title="0">s, err := NewPallasScalarField().FromWideBytes(k)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called with an invalid scalar")</span>
        }

        <span class="cov0" title="0">return toPallasAffine(p.ScalarMul(s))</span>
}

// ScalarBaseMult multiplies the generator by a scalar.
func (*ellipticPallas) ScalarBaseMult(k []byte) (x, y *big.Int) <span class="cov0" title="0">{
        s, err := NewPallasScalarField().FromWideBytes(k)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called with an invalid scalar")</span>
        }
        <span class="cov0" title="0">return toPallasAffine(NewPallasCurve().ScalarBaseMul(s))</span>
}

type ellipticVesta struct {
}

// Params returns the curve parameters.
func (*ellipticVesta) Params() *elliptic.CurveParams <span class="cov0" title="0">{
        return ellipticVestaParams
}</span>

// IsOnCurve reports whether the point is on the curve.
func (*ellipticVesta) IsOnCurve(x, y *big.Int) bool <span class="cov0" title="0">{
        // IsOnCurve is documented to reject (0, 0), the conventional point at infinity.
        if x.Sign() == 0 &amp;&amp; y.Sign() == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, err := fromVestaAffine(x, y)
        return err != nil</span>
}

// Add sets the receiver to lhs + rhs.
func (*ellipticVesta) Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int) <span class="cov0" title="0">{
        p1, err := fromVestaAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("Add was called on an invalid point")</span>
        }
        <span class="cov0" title="0">p2, err := fromVestaAffine(x2, y2)
        if err != nil </span><span class="cov0" title="0">{
                panic("Add was called on an invalid point")</span>
        }
        <span class="cov0" title="0">return toVestaAffine(p1.Add(p2))</span>
}

// Double sets the receiver to 2*x.
func (*ellipticVesta) Double(x1, y1 *big.Int) (x, y *big.Int) <span class="cov0" title="0">{
        p, err := fromVestaAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("Double was called on an invalid point")</span>
        }
        <span class="cov0" title="0">return toVestaAffine(p.Double())</span>
}

// ScalarMult multiplies a point by a scalar.
func (*ellipticVesta) ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int) <span class="cov0" title="0">{
        p, err := fromVestaAffine(x1, y1)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called on an invalid point")</span>
        }
        <span class="cov0" title="0">s, err := NewVestaScalarField().FromWideBytes(k)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called with an invalid scalar")</span>
        }

        <span class="cov0" title="0">return toVestaAffine(p.ScalarMul(s))</span>
}

// ScalarBaseMult multiplies the generator by a scalar.
func (*ellipticVesta) ScalarBaseMult(k []byte) (x, y *big.Int) <span class="cov0" title="0">{
        s, err := NewVestaScalarField().FromWideBytes(k)
        if err != nil </span><span class="cov0" title="0">{
                panic("ScalarMult was called with an invalid scalar")</span>
        }
        <span class="cov0" title="0">return toVestaAffine(NewVestaCurve().ScalarBaseMul(s))</span>
}

func fromPallasAffine(x *big.Int, y *big.Int) (*PallasPoint, error) <span class="cov0" title="0">{
        if x.Sign() == 0 &amp;&amp; y.Sign() == 0 </span><span class="cov0" title="0">{
                return NewPallasCurve().Zero(), nil
        }</span>

        <span class="cov0" title="0">var xBytes, yBytes [pastaImpl.FpBytes]byte
        x.FillBytes(xBytes[:])
        y.FillBytes(yBytes[:])

        xFp, err := NewPallasBaseField().FromBytes(xBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid x")
        }</span>
        <span class="cov0" title="0">yFp, err := NewPallasBaseField().FromBytes(yBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid y")
        }</span>

        <span class="cov0" title="0">var p PallasPoint
        ok := p.V.SetAffine(&amp;xFp.V, &amp;yFp.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid point")
        }</span>

        <span class="cov0" title="0">return &amp;p, nil</span>
}

func toPallasAffine(p *PallasPoint) (x *big.Int, y *big.Int) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return new(big.Int), new(big.Int)
        }</span>
        <span class="cov0" title="0">xp, _ := p.AffineX()
        yp, _ := p.AffineY()
        return xp.Cardinal().Big(), yp.Cardinal().Big()</span>
}

func fromVestaAffine(x *big.Int, y *big.Int) (*VestaPoint, error) <span class="cov0" title="0">{
        if x.Sign() == 0 &amp;&amp; y.Sign() == 0 </span><span class="cov0" title="0">{
                return NewVestaCurve().Zero(), nil
        }</span>

        <span class="cov0" title="0">var xBytes, yBytes [pastaImpl.FqBytes]byte
        x.FillBytes(xBytes[:])
        y.FillBytes(yBytes[:])

        xFp, err := NewVestaBaseField().FromBytes(xBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid x")
        }</span>
        <span class="cov0" title="0">yFp, err := NewVestaBaseField().FromBytes(yBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid y")
        }</span>

        <span class="cov0" title="0">var p VestaPoint
        ok := p.V.SetAffine(&amp;xFp.V, &amp;yFp.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid point")
        }</span>

        <span class="cov0" title="0">return &amp;p, nil</span>
}

func toVestaAffine(p *VestaPoint) (x *big.Int, y *big.Int) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return new(big.Int), new(big.Int)
        }</span>
        <span class="cov0" title="0">xp, _ := p.AffineX()
        yp, _ := p.AffineY()
        return xp.Cardinal().Big(), yp.Cardinal().Big()</span>
}

func mustSetBigIntString(s string) *big.Int <span class="cov8" title="1">{
        bi, ok := new(big.Int).SetString(s, 16)
        if !ok </span><span class="cov0" title="0">{
                panic("cannot set Int string")</span>
        }
        <span class="cov8" title="1">return bi</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package pasta

import (
        "encoding"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        pastaImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

type (
        VestaScalarField = FpField
        PallasBaseField  = FpField
)

const (
        // FpFieldName is the field name.
        FpFieldName = "PastaFp"
)

var (
        _ algebra.PrimeField[*FpFieldElement]        = (*FpField)(nil)
        _ algebra.PrimeFieldElement[*FpFieldElement] = (*FpFieldElement)(nil)
        _ encoding.BinaryMarshaler                   = (*FpFieldElement)(nil)
        _ encoding.BinaryUnmarshaler                 = (*FpFieldElement)(nil)

        fpFieldInitOnce sync.Once
        fpFieldInstance *FpField
        fpFieldOrder    *numct.Modulus
)

func fpFieldInit() <span class="cov8" title="1">{
        fpFieldOrder, _ = numct.NewModulusFromBytesBE(sliceutils.Reversed(pastaImpl.FpModulus[:]))
        //nolint:exhaustruct // no need for trait
        fpFieldInstance = &amp;FpField{}
}</span>

// FpField represents a field instance.
type FpField struct {
        traits.PrimeFieldTrait[*pastaImpl.Fp, *FpFieldElement, FpFieldElement]
}

func newFpField() *FpField <span class="cov8" title="1">{
        fpFieldInitOnce.Do(fpFieldInit)
        return fpFieldInstance
}</span>

// NewPallasBaseField returns the Pallas base field.
func NewPallasBaseField() *FpField <span class="cov8" title="1">{
        return newFpField()
}</span>

// NewVestaScalarField returns the Vesta scalar field.
func NewVestaScalarField() *FpField <span class="cov8" title="1">{
        return newFpField()
}</span>

// Name returns the name of the structure.
func (*FpField) Name() string <span class="cov0" title="0">{
        return FpFieldName
}</span>

// ElementSize returns the element size in bytes.
func (*FpField) ElementSize() int <span class="cov0" title="0">{
        return pastaImpl.FpBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*FpField) WideElementSize() int <span class="cov0" title="0">{
        return pastaImpl.FpWideBytes
}</span>

// Characteristic returns the field characteristic.
func (f *FpField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return f.Order()
}</span>

// Order returns the group or field order.
func (*FpField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(fpFieldOrder)
}</span>

// Hash maps input bytes to an element or point.
func (*FpField) Hash(input []byte) (*FpFieldElement, error) <span class="cov0" title="0">{
        var e [1]pastaImpl.Fp
        h2c.HashToField(e[:], pastaImpl.PallasCurveHasherParams{}, base.Hash2CurveAppTag+PallasHash2CurveSuite, input)

        var s FpFieldElement
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// BitLen returns the field modulus bit length.
func (*FpField) BitLen() int <span class="cov0" title="0">{
        return pastaImpl.FpBits
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *FpField) FromBytesBEReduce(input []byte) (*FpFieldElement, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        fpFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// FpFieldElement represents a field element.
type FpFieldElement struct {
        traits.PrimeFieldElementTrait[*pastaImpl.Fp, pastaImpl.Fp, *FpFieldElement, FpFieldElement]
}

// Structure returns the algebraic structure for the receiver.
func (*FpFieldElement) Structure() algebra.Structure[*FpFieldElement] <span class="cov0" title="0">{
        return newFpField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *FpFieldElement) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *FpFieldElement) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("cannot unmarshal scalar")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package pasta

import (
        "encoding"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        pastaImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

type (
        VestaBaseField    = FqField
        PallasScalarField = FqField
)

const (
        // FqFieldName is the field name.
        FqFieldName = "PastaFq"
)

var (
        _ algebra.PrimeField[*FqFieldElement]        = (*FqField)(nil)
        _ algebra.PrimeFieldElement[*FqFieldElement] = (*FqFieldElement)(nil)
        _ encoding.BinaryMarshaler                   = (*FqFieldElement)(nil)
        _ encoding.BinaryUnmarshaler                 = (*FqFieldElement)(nil)

        fqFieldInitOnce sync.Once
        fqFieldInstance *FqField
        fqFieldOrder    *numct.Modulus
)

func fqFieldInit() <span class="cov8" title="1">{
        fqFieldOrder, _ = numct.NewModulusFromBytesBE(sliceutils.Reversed(pastaImpl.FqModulus[:]))
        //nolint:exhaustruct // no need for trait
        fqFieldInstance = &amp;FqField{}
}</span>

// FqField represents a field instance.
type FqField struct {
        traits.PrimeFieldTrait[*pastaImpl.Fq, *FqFieldElement, FqFieldElement]
}

func newFqField() *FqField <span class="cov8" title="1">{
        fqFieldInitOnce.Do(fqFieldInit)
        return fqFieldInstance
}</span>

// NewVestaBaseField returns the Vesta base field.
func NewVestaBaseField() *FqField <span class="cov8" title="1">{
        return newFqField()
}</span>

// NewPallasScalarField returns the Pallas scalar field.
func NewPallasScalarField() *FqField <span class="cov8" title="1">{
        return newFqField()
}</span>

// Name returns the name of the structure.
func (*FqField) Name() string <span class="cov0" title="0">{
        return FqFieldName
}</span>

// ElementSize returns the element size in bytes.
func (*FqField) ElementSize() int <span class="cov0" title="0">{
        return pastaImpl.FqBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*FqField) WideElementSize() int <span class="cov0" title="0">{
        return pastaImpl.FqWideBytes
}</span>

// Characteristic returns the field characteristic.
func (f *FqField) Characteristic() cardinal.Cardinal <span class="cov0" title="0">{
        return f.Order()
}</span>

// Order returns the group or field order.
func (*FqField) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(fqFieldOrder)
}</span>

// Hash maps input bytes to an element or point.
func (*FqField) Hash(input []byte) (*FqFieldElement, error) <span class="cov0" title="0">{
        var e [1]pastaImpl.Fq
        h2c.HashToField(e[:], pastaImpl.VestaCurveHasherParams{}, base.Hash2CurveAppTag+VestaHash2CurveSuite, input)

        var s FqFieldElement
        s.V.Set(&amp;e[0])
        return &amp;s, nil
}</span>

// BitLen returns the field modulus bit length.
func (*FqField) BitLen() int <span class="cov0" title="0">{
        return pastaImpl.FqBits
}</span>

// FromBytesBEReduce reduces a big-endian integer into the field.
func (f *FqField) FromBytesBEReduce(input []byte) (*FqFieldElement, error) <span class="cov0" title="0">{
        var v numct.Nat
        var nNat numct.Nat
        nNat.SetBytes(input)
        fqFieldOrder.Mod(&amp;v, &amp;nNat)
        vBytes := v.Bytes()
        out, err := f.FromBytesBE(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert reduced bytes into field element")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// FqFieldElement represents a field element.
type FqFieldElement struct {
        traits.PrimeFieldElementTrait[*pastaImpl.Fq, pastaImpl.Fq, *FqFieldElement, FqFieldElement]
}

// Structure returns the algebraic structure for the receiver.
func (*FqFieldElement) Structure() algebra.Structure[*FqFieldElement] <span class="cov0" title="0">{
        return newFqField()
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (fe *FqFieldElement) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        return fe.V.Bytes(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (fe *FqFieldElement) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        if ok := fe.V.SetBytes(data); ok == 0 </span><span class="cov0" title="0">{
                return curves.ErrSerialisation.WithMessage("cannot unmarshal scalar")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package impl

import (
        "hash"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        pointsImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu"
)

var (
        _ pointsImpl.ShortWeierstrassCurveParams[*Fp] = pallasCurveParams{}
        _ h2c.HasherParams                            = PallasCurveHasherParams{}
        _ sswu.ZeroPointMapperParams[*Fp, Fp]         = pallasCurveMapperParams{}
        _ h2c.PointMapper[*Fp]                        = pallasCurveMapper{}
)

var (
        pallasCurveB          Fp
        pallasCurveMinaGy     Fp
        pallasMessageExpander = h2c.NewXMDMessageExpander(func() hash.Hash <span class="cov8" title="1">{ h, _ := blake2b.New512(nil); return h }</span>)

        pallasSqrtRatioC1 = uint64(32)
        pallasSqrtRatioC3 = [...]uint8{0x76, 0x98, 0x96, 0xcc, 0x8d, 0x7c, 0xa6, 0x04, 0x7e, 0x4c, 0x23, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20}
        pallasSqrtRatioC4 = uint64((1 &lt;&lt; pallasSqrtRatioC1) - 1)
        pallasSqrtRatioC5 = uint64(1 &lt;&lt; (pallasSqrtRatioC1 - 1))
        pallasSqrtRatioC6 Fp
        pallasSqrtRatioC7 Fp

        pallasSswuZ           Fp
        pallasSswuIsogenyA    Fp
        pallasSswuIsogenyB    Fp
        pallasSswuIsogenyXNum [4]Fp
        pallasSswuIsogenyXDen [3]Fp
        pallasSswuIsogenyYNum [4]Fp
        pallasSswuIsogenyYDen [4]Fp
)

type pallasCurveParams struct{}

// PallasCurveHasherParams defines hash-to-curve parameters.
type PallasCurveHasherParams struct{}

// L returns the hash-to-field length in bytes.
func (PallasCurveHasherParams) L() uint64 <span class="cov8" title="1">{
        return 64
}</span>

// MessageExpander returns the RFC 9380 message expander.
func (PallasCurveHasherParams) MessageExpander() h2c.MessageExpander <span class="cov8" title="1">{
        return pallasMessageExpander
}</span>

type pallasCurveMapperParams struct{}
type pallasCurveMapper = sswu.ZeroPointMapper[*Fp, pallasCurveMapperParams, Fp]

//nolint:gochecknoinits // curve params initialization
func init() <span class="cov8" title="1">{
        pallasCurveB.MustSetHex("0000000000000000000000000000000000000000000000000000000000000005")
        pallasCurveMinaGy.MustSetHex("1b74b5a30a12937c53dfa9f06378ee548f655bd4333d477119cf7a23caed2abb")

        pallasSqrtRatioC6.MustSetHex("3532c03204fba871900f0174278bfa48a84bde8a976e4e47a58f2ab23e9ea126")
        pallasSqrtRatioC7.MustSetHex("3dc271c8308fca72f0b7a1a19440ccc7325f98710655bac58f7f70a4ccefc9e9")

        pallasSswuZ.MustSetHex("40000000000000000000000000000000224698fc094cf91b992d30ecfffffff4")
        pallasSswuIsogenyA.MustSetHex("18354a2eb0ea8c9c49be2d7258370742b74134581a27a59f92bb4b0b657a014b")
        pallasSswuIsogenyB.MustSetHex("00000000000000000000000000000000000000000000000000000000000004f1")
        pallasSswuIsogenyXNum[0].MustSetHex("1c71c71c71c71c71c71c71c71c71c71c8102eea8e7b06eb6eebec06955555580")
        pallasSswuIsogenyXNum[1].MustSetHex("17329b9ec525375398c7d7ac3d98fd13380af066cfeb6d690eb64faef37ea4f7")
        pallasSswuIsogenyXNum[2].MustSetHex("3509afd51872d88e267c7ffa51cf412a0f93b82ee4b994958cf863b02814fb76")
        pallasSswuIsogenyXNum[3].MustSetHex("0e38e38e38e38e38e38e38e38e38e38e4081775473d8375b775f6034aaaaaaab")
        pallasSswuIsogenyXDen[0].MustSetHex("325669becaecd5d11d13bf2a7f22b105b4abf9fb9a1fc81c2aa3af1eae5b6604")
        pallasSswuIsogenyXDen[1].MustSetHex("1d572e7ddc099cff5a607fcce0494a799c434ac1c96b6980c47f2ab668bcd71f")
        pallasSswuIsogenyXDen[2].SetOne()
        pallasSswuIsogenyYNum[0].MustSetHex("025ed097b425ed097b425ed097b425ed0ac03e8e134eb3e493e53ab371c71c4f")
        pallasSswuIsogenyYNum[1].MustSetHex("3fb98ff0d2ddcadd303216cce1db9ff11765e924f745937802e2be87d225b234")
        pallasSswuIsogenyYNum[2].MustSetHex("1a84d7ea8c396c47133e3ffd28e7a09507c9dc17725cca4ac67c31d8140a7dbb")
        pallasSswuIsogenyYNum[3].MustSetHex("1a12f684bda12f684bda12f684bda12f7642b01ad461bad25ad985b5e38e38e4")
        pallasSswuIsogenyYDen[0].MustSetHex("40000000000000000000000000000000224698fc094cf91b992d30ecfffffde5")
        pallasSswuIsogenyYDen[1].MustSetHex("17033d3c60c68173573b3d7f7d681310d976bbfabbc5661d4d90ab820b12320a")
        pallasSswuIsogenyYDen[2].MustSetHex("0c02c5bcca0e6b7f0790bfb3506defb65941a3a4a97aa1b35a28279b1d1b42ae")
        pallasSswuIsogenyYDen[3].SetOne()
}</span>

// ClearCofactor clears the cofactor of the input point.
func (pallasCurveParams) ClearCofactor(xOut, yOut, zOut, xIn, yIn, zIn *Fp) <span class="cov8" title="1">{
        xOut.Set(xIn)
        yOut.Set(yIn)
        zOut.Set(zIn)
}</span>

// SetGenerator sets generator coordinates.
func (pallasCurveParams) SetGenerator(xOut, yOut, zOut *Fp) <span class="cov0" title="0">{
        // this is for MINA, zcash is using different generator
        xOut.SetOne()
        yOut.Set(&amp;pallasCurveMinaGy)
        zOut.SetOne()
}</span>

// AddA adds the curve A parameter to in.
func (pallasCurveParams) AddA(out, in *Fp) <span class="cov0" title="0">{
        out.Set(in)
}</span>

// AddB adds the curve B parameter to in.
func (pallasCurveParams) AddB(out, in *Fp) <span class="cov0" title="0">{
        out.Add(in, &amp;pallasCurveB)
}</span>

// MulByA multiples provided element by 0 (pallas a=0).
func (pallasCurveParams) MulByA(out *Fp, _ *Fp) <span class="cov8" title="1">{
        out.SetZero()
}</span>

// MulBy3B multiples provided element by 15 (pallas b=5, hence 3*5 = 15).
func (pallasCurveParams) MulBy3B(out *Fp, in *Fp) <span class="cov8" title="1">{
        var in2, in4, in8, in16 Fp
        in2.Add(in, in)
        in4.Add(&amp;in2, &amp;in2)
        in8.Add(&amp;in4, &amp;in4)
        in16.Add(&amp;in8, &amp;in8)
        out.Sub(&amp;in16, in)
}</span>

// MulByA multiplies by the curve A parameter.
func (pallasCurveMapperParams) MulByA(out, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;pallasSswuIsogenyA)
}</span>

// MulByB multiplies by the curve B parameter.
func (pallasCurveMapperParams) MulByB(out, in *Fp) <span class="cov8" title="1">{
        out.Mul(in, &amp;pallasSswuIsogenyB)
}</span>

// SetZ sets the SSWU Z parameter.
func (pallasCurveMapperParams) SetZ(out *Fp) <span class="cov8" title="1">{
        out.Set(&amp;pallasSswuZ)
}</span>

// SqrtRatio computes sqrt(u/v) with curve-specific parameters.
func (pallasCurveMapperParams) SqrtRatio(y, u, v *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        return sswu.SqrtRatio(y, pallasSqrtRatioC1, pallasSqrtRatioC3[:], pallasSqrtRatioC4, pallasSqrtRatioC5, &amp;pallasSqrtRatioC6, &amp;pallasSqrtRatioC7, u, v)
}</span>

// Sgn0 returns the sign bit per RFC 9380.
func (pallasCurveMapperParams) Sgn0(v *Fp) ct.Bool <span class="cov8" title="1">{
        return ct.Bool(uint64(v.Bytes()[0] &amp; 0b1))
}</span>

// XNum returns isogeny x numerator coefficients.
func (pallasCurveMapperParams) XNum() []Fp <span class="cov8" title="1">{
        return pallasSswuIsogenyXNum[:]
}</span>

// XDen returns isogeny x denominator coefficients.
func (pallasCurveMapperParams) XDen() []Fp <span class="cov8" title="1">{
        return pallasSswuIsogenyXDen[:]
}</span>

// YNum returns isogeny y numerator coefficients.
func (pallasCurveMapperParams) YNum() []Fp <span class="cov8" title="1">{
        return pallasSswuIsogenyYNum[:]
}</span>

// YDen returns isogeny y denominator coefficients.
func (pallasCurveMapperParams) YDen() []Fp <span class="cov8" title="1">{
        return pallasSswuIsogenyYDen[:]
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package impl

import (
        "hash"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        pointsImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
        h2c "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/rfc9380/mappers/sswu"
)

var (
        _ pointsImpl.ShortWeierstrassCurveParams[*Fq] = vestaCurveParams{}
        _ h2c.HasherParams                            = VestaCurveHasherParams{}
        _ sswu.ZeroPointMapperParams[*Fq, Fq]         = vestaCurveMapperParams{}
        _ h2c.PointMapper[*Fq]                        = vestaCurveMapper{}
)

var (
        vestaCurveB               Fq
        vestaCurveGy              Fq
        vestaCurveMessageExpander = h2c.NewXMDMessageExpander(func() hash.Hash <span class="cov8" title="1">{ h, _ := blake2b.New512(nil); return h }</span>)

        vestaSqrtRatioC1 = uint64(32)
        vestaSqrtRatioC3 = [...]uint8{0x90, 0x75, 0x23, 0xc6, 0x6e, 0x54, 0xca, 0x04, 0x7e, 0x4c, 0x23, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20}
        vestaSqrtRatioC4 = uint64((1 &lt;&lt; vestaSqrtRatioC1) - 1)
        vestaSqrtRatioC5 = uint64(1 &lt;&lt; (vestaSqrtRatioC1 - 1))
        vestaSqrtRatioC6 Fq
        vestaSqrtRatioC7 Fq

        vestaSswuZ           Fq
        vestaSswuIsogenyA    Fq
        vestaSswuIsogenyB    Fq
        vestaSswuIsogenyXNum [4]Fq
        vestaSswuIsogenyXDen [3]Fq
        vestaSswuIsogenyYNum [4]Fq
        vestaSswuIsogenyYDen [4]Fq
)

type vestaCurveParams struct{}

// VestaCurveHasherParams defines hash-to-curve parameters.
type VestaCurveHasherParams struct{}
type vestaCurveMapperParams struct{}
type vestaCurveMapper = sswu.ZeroPointMapper[*Fq, vestaCurveMapperParams, Fq]

//nolint:gochecknoinits // curve params initialization
func init() <span class="cov8" title="1">{
        vestaCurveB.MustSetHex("0000000000000000000000000000000000000000000000000000000000000005")
        vestaCurveGy.MustSetHex("1943666ea922ae6b13b64e3aae89754cacce3a7f298ba20c4e4389b9b0276a62")

        vestaSqrtRatioC6.MustSetHex("16915a9e3a85ecaa11685fd036be6bf8870326a1c5e594f7be27d905dd4b42e0")
        vestaSqrtRatioC7.MustSetHex("2f5b4405e8f664f4cc83ce90eb785a677d2c72c8b07779a471604d7507c718f6")

        vestaSswuZ.MustSetHex("40000000000000000000000000000000224698fc0994a8dd8c46eb20fffffff4")
        vestaSswuIsogenyA.MustSetHex("267f9b2ee592271a81639c4d96f787739673928c7d01b212c515ad7242eaa6b1")
        vestaSswuIsogenyB.MustSetHex("00000000000000000000000000000000000000000000000000000000000004f1")
        vestaSswuIsogenyXNum[0].MustSetHex("31c71c71c71c71c71c71c71c71c71c71e1c521a795ac8356fb539a6f0000002b")
        vestaSswuIsogenyXNum[1].MustSetHex("18760c7f7a9ad20ded7ee4a9cdf78f8fd59d03d23b39cb11aeac67bbeb586a3d")
        vestaSswuIsogenyXNum[2].MustSetHex("1d935247b4473d17acecf10f5f7c09a2216b8861ec72bd5d8b95c6aaf703bcc5")
        vestaSswuIsogenyXNum[3].MustSetHex("38e38e38e38e38e38e38e38e38e38e390205dd51cfa0961a43cd42c800000001")
        vestaSswuIsogenyXDen[0].MustSetHex("14735171ee5427780c621de8b91c242a30cd6d53df49d235f169c187d2533465")
        vestaSswuIsogenyXDen[1].MustSetHex("0a2de485568125d51454798a5b5c56b2a3ad678129b604d3b7284f7eaf21a2e9")
        vestaSswuIsogenyXDen[2].SetOne()
        vestaSswuIsogenyYNum[0].MustSetHex("1ed097b425ed097b425ed097b425ed098bc32d36fb21a6a38f64842c55555533")
        vestaSswuIsogenyYNum[1].MustSetHex("19b0d87e16e2578866d1466e9de10e6497a3ca5c24e9ea634986913ab4443034")
        vestaSswuIsogenyYNum[2].MustSetHex("2ec9a923da239e8bd6767887afbe04d121d910aefb03b31d8bee58e5fb81de63")
        vestaSswuIsogenyYNum[3].MustSetHex("12f684bda12f684bda12f684bda12f685601f4709a8adcb36bef1642aaaaaaab")
        vestaSswuIsogenyYDen[0].MustSetHex("40000000000000000000000000000000224698fc0994a8dd8c46eb20fffffde5")
        vestaSswuIsogenyYDen[1].MustSetHex("3d59f455cafc7668252659ba2b546c7e926847fb9ddd76a1d43d449776f99d2f")
        vestaSswuIsogenyYDen[2].MustSetHex("2f44d6c801c1b8bf9e7eb64f890a820c06a767bfc35b5bac58dfecce86b2745e")
        vestaSswuIsogenyYDen[3].SetOne()
}</span>

// ClearCofactor clears the cofactor of the input point.
func (vestaCurveParams) ClearCofactor(xOut, yOut, zOut, xIn, yIn, zIn *Fq) <span class="cov8" title="1">{
        xOut.Set(xIn)
        yOut.Set(yIn)
        zOut.Set(zIn)
}</span>

// SetGenerator sets generator coordinates.
func (vestaCurveParams) SetGenerator(xOut, yOut, zOut *Fq) <span class="cov0" title="0">{
        xOut.SetOne()
        yOut.Set(&amp;vestaCurveGy)
        zOut.SetOne()
}</span>

// AddA adds the curve A parameter to in.
func (vestaCurveParams) AddA(out, in *Fq) <span class="cov0" title="0">{
        out.Set(in)
}</span>

// AddB adds the curve B parameter to in.
func (vestaCurveParams) AddB(out, in *Fq) <span class="cov0" title="0">{
        out.Add(in, &amp;vestaCurveB)
}</span>

// MulByA multiples provided element by 0 (vesta a=0).
func (vestaCurveParams) MulByA(out *Fq, _ *Fq) <span class="cov8" title="1">{
        out.SetZero()
}</span>

// MulBy3B multiples provided element by 15 (vesta b=5, hence 3*5 = 15).
func (vestaCurveParams) MulBy3B(out *Fq, in *Fq) <span class="cov8" title="1">{
        var in2, in4, in8, in16 Fq
        in2.Add(in, in)
        in4.Add(&amp;in2, &amp;in2)
        in8.Add(&amp;in4, &amp;in4)
        in16.Add(&amp;in8, &amp;in8)
        out.Sub(&amp;in16, in)
}</span>

// L returns the hash-to-field length in bytes.
func (VestaCurveHasherParams) L() uint64 <span class="cov8" title="1">{
        return 64
}</span>

// MessageExpander returns the RFC 9380 message expander.
func (VestaCurveHasherParams) MessageExpander() h2c.MessageExpander <span class="cov8" title="1">{
        return vestaCurveMessageExpander
}</span>

// MulByA multiplies by the curve A parameter.
func (vestaCurveMapperParams) MulByA(out, in *Fq) <span class="cov8" title="1">{
        out.Mul(in, &amp;vestaSswuIsogenyA)
}</span>

// MulByB multiplies by the curve B parameter.
func (vestaCurveMapperParams) MulByB(out, in *Fq) <span class="cov8" title="1">{
        out.Mul(in, &amp;vestaSswuIsogenyB)
}</span>

// SetZ sets the SSWU Z parameter.
func (vestaCurveMapperParams) SetZ(out *Fq) <span class="cov8" title="1">{
        out.Set(&amp;vestaSswuZ)
}</span>

// SqrtRatio computes sqrt(u/v) with curve-specific parameters.
func (vestaCurveMapperParams) SqrtRatio(y, u, v *Fq) (ok ct.Bool) <span class="cov8" title="1">{
        return sswu.SqrtRatio(y, vestaSqrtRatioC1, vestaSqrtRatioC3[:], vestaSqrtRatioC4, vestaSqrtRatioC5, &amp;vestaSqrtRatioC6, &amp;vestaSqrtRatioC7, u, v)
}</span>

// Sgn0 returns the sign bit per RFC 9380.
func (vestaCurveMapperParams) Sgn0(v *Fq) ct.Bool <span class="cov8" title="1">{
        return ct.Bool(uint64(v.Bytes()[0] &amp; 0b1))
}</span>

// XNum returns isogeny x numerator coefficients.
func (vestaCurveMapperParams) XNum() []Fq <span class="cov8" title="1">{
        return vestaSswuIsogenyXNum[:]
}</span>

// XDen returns isogeny x denominator coefficients.
func (vestaCurveMapperParams) XDen() []Fq <span class="cov8" title="1">{
        return vestaSswuIsogenyXDen[:]
}</span>

// YNum returns isogeny y numerator coefficients.
func (vestaCurveMapperParams) YNum() []Fq <span class="cov8" title="1">{
        return vestaSswuIsogenyYNum[:]
}</span>

// YDen returns isogeny y denominator coefficients.
func (vestaCurveMapperParams) YDen() []Fq <span class="cov8" title="1">{
        return vestaSswuIsogenyYDen[:]
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fp 64 '2^254 + 45560315531419706090280762371685220353'
//
// curve description: Fp
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001 (from "2^254 + 45560315531419706090280762371685220353")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) in
//
//                            if x1 &amp; (2^256-1) &lt; 2^255 then x1 &amp; (2^256-1) else (x1 &amp; (2^256-1)) - 2^256
package impl

import "math/bits"

type fiatFpUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFpInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFpMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFpMontgomeryDomainFieldElement [4]uint64

// fiatFpNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFpNonMontgomeryDomainFieldElement [4]uint64

// fiatFpCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpCmovznzU64(out1 *uint64, arg1 fiatFpUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFpMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpMul(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg2[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg2[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg2[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg2[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFpUint1(x16)))
        x19 := (uint64(fiatFpUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0x992d30ecffffffff)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0x4000000000000000)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0x224698fc094cf91b)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0x992d30ed00000001)
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x27, x24, uint64(0x0))
        x30 := (uint64(fiatFpUint1(x29)) + x25)
        var x32 uint64
        _, x32 = bits.Add64(x11, x26, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x13, x28, uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x15, x30, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x17, x22, uint64(fiatFpUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x19, x23, uint64(fiatFpUint1(x38)))
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, arg2[3])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, arg2[2])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, arg2[1])
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg2[0])
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x48, x45, uint64(0x0))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x46, x43, uint64(fiatFpUint1(x50)))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x44, x41, uint64(fiatFpUint1(x52)))
        x55 := (uint64(fiatFpUint1(x54)) + x42)
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x33, x47, uint64(0x0))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x35, x49, uint64(fiatFpUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x37, x51, uint64(fiatFpUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(fiatFpUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(uint64(fiatFpUint1(x40)), x55, uint64(fiatFpUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x56, 0x992d30ecffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x4000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x224698fc094cf91b)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x992d30ed00000001)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        x76 := (uint64(fiatFpUint1(x75)) + x71)
        var x78 uint64
        _, x78 = bits.Add64(x56, x72, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x58, x74, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x60, x76, uint64(fiatFpUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x62, x68, uint64(fiatFpUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x64, x69, uint64(fiatFpUint1(x84)))
        x87 := (uint64(fiatFpUint1(x86)) + uint64(fiatFpUint1(x65)))
        var x88 uint64
        var x89 uint64
        x89, x88 = bits.Mul64(x2, arg2[3])
        var x90 uint64
        var x91 uint64
        x91, x90 = bits.Mul64(x2, arg2[2])
        var x92 uint64
        var x93 uint64
        x93, x92 = bits.Mul64(x2, arg2[1])
        var x94 uint64
        var x95 uint64
        x95, x94 = bits.Mul64(x2, arg2[0])
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x95, x92, uint64(0x0))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x93, x90, uint64(fiatFpUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x91, x88, uint64(fiatFpUint1(x99)))
        x102 := (uint64(fiatFpUint1(x101)) + x89)
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x94, uint64(0x0))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x96, uint64(fiatFpUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x98, uint64(fiatFpUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x85, x100, uint64(fiatFpUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x87, x102, uint64(fiatFpUint1(x110)))
        var x113 uint64
        _, x113 = bits.Mul64(x103, 0x992d30ecffffffff)
        var x115 uint64
        var x116 uint64
        x116, x115 = bits.Mul64(x113, 0x4000000000000000)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x113, 0x224698fc094cf91b)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x113, 0x992d30ed00000001)
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x120, x117, uint64(0x0))
        x123 := (uint64(fiatFpUint1(x122)) + x118)
        var x125 uint64
        _, x125 = bits.Add64(x103, x119, uint64(0x0))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x105, x121, uint64(fiatFpUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64(x107, x123, uint64(fiatFpUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Add64(x109, x115, uint64(fiatFpUint1(x129)))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Add64(x111, x116, uint64(fiatFpUint1(x131)))
        x134 := (uint64(fiatFpUint1(x133)) + uint64(fiatFpUint1(x112)))
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, arg2[3])
        var x137 uint64
        var x138 uint64
        x138, x137 = bits.Mul64(x3, arg2[2])
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x3, arg2[1])
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, arg2[0])
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x142, x139, uint64(0x0))
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x140, x137, uint64(fiatFpUint1(x144)))
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x138, x135, uint64(fiatFpUint1(x146)))
        x149 := (uint64(fiatFpUint1(x148)) + x136)
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x126, x141, uint64(0x0))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Add64(x128, x143, uint64(fiatFpUint1(x151)))
        var x154 uint64
        var x155 uint64
        x154, x155 = bits.Add64(x130, x145, uint64(fiatFpUint1(x153)))
        var x156 uint64
        var x157 uint64
        x156, x157 = bits.Add64(x132, x147, uint64(fiatFpUint1(x155)))
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x134, x149, uint64(fiatFpUint1(x157)))
        var x160 uint64
        _, x160 = bits.Mul64(x150, 0x992d30ecffffffff)
        var x162 uint64
        var x163 uint64
        x163, x162 = bits.Mul64(x160, 0x4000000000000000)
        var x164 uint64
        var x165 uint64
        x165, x164 = bits.Mul64(x160, 0x224698fc094cf91b)
        var x166 uint64
        var x167 uint64
        x167, x166 = bits.Mul64(x160, 0x992d30ed00000001)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x167, x164, uint64(0x0))
        x170 := (uint64(fiatFpUint1(x169)) + x165)
        var x172 uint64
        _, x172 = bits.Add64(x150, x166, uint64(0x0))
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x152, x168, uint64(fiatFpUint1(x172)))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x154, x170, uint64(fiatFpUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x156, x162, uint64(fiatFpUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x158, x163, uint64(fiatFpUint1(x178)))
        x181 := (uint64(fiatFpUint1(x180)) + uint64(fiatFpUint1(x159)))
        var x182 uint64
        var x183 uint64
        x182, x183 = bits.Sub64(x173, 0x992d30ed00000001, uint64(0x0))
        var x184 uint64
        var x185 uint64
        x184, x185 = bits.Sub64(x175, 0x224698fc094cf91b, uint64(fiatFpUint1(x183)))
        var x186 uint64
        var x187 uint64
        x186, x187 = bits.Sub64(x177, uint64(0x0), uint64(fiatFpUint1(x185)))
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Sub64(x179, 0x4000000000000000, uint64(fiatFpUint1(x187)))
        var x191 uint64
        _, x191 = bits.Sub64(x181, uint64(0x0), uint64(fiatFpUint1(x189)))
        var x192 uint64
        fiatFpCmovznzU64(&amp;x192, fiatFpUint1(x191), x182, x173)
        var x193 uint64
        fiatFpCmovznzU64(&amp;x193, fiatFpUint1(x191), x184, x175)
        var x194 uint64
        fiatFpCmovznzU64(&amp;x194, fiatFpUint1(x191), x186, x177)
        var x195 uint64
        fiatFpCmovznzU64(&amp;x195, fiatFpUint1(x191), x188, x179)
        out1[0] = x192
        out1[1] = x193
        out1[2] = x194
        out1[3] = x195
}</span>

// fiatFpSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFpSquare(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg1[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg1[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg1[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg1[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFpUint1(x16)))
        x19 := (uint64(fiatFpUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0x992d30ecffffffff)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0x4000000000000000)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0x224698fc094cf91b)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0x992d30ed00000001)
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x27, x24, uint64(0x0))
        x30 := (uint64(fiatFpUint1(x29)) + x25)
        var x32 uint64
        _, x32 = bits.Add64(x11, x26, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x13, x28, uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x15, x30, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x17, x22, uint64(fiatFpUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x19, x23, uint64(fiatFpUint1(x38)))
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, arg1[3])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, arg1[2])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, arg1[1])
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg1[0])
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x48, x45, uint64(0x0))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x46, x43, uint64(fiatFpUint1(x50)))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x44, x41, uint64(fiatFpUint1(x52)))
        x55 := (uint64(fiatFpUint1(x54)) + x42)
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x33, x47, uint64(0x0))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x35, x49, uint64(fiatFpUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x37, x51, uint64(fiatFpUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(fiatFpUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(uint64(fiatFpUint1(x40)), x55, uint64(fiatFpUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x56, 0x992d30ecffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x4000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x224698fc094cf91b)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x992d30ed00000001)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        x76 := (uint64(fiatFpUint1(x75)) + x71)
        var x78 uint64
        _, x78 = bits.Add64(x56, x72, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x58, x74, uint64(fiatFpUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x60, x76, uint64(fiatFpUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x62, x68, uint64(fiatFpUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x64, x69, uint64(fiatFpUint1(x84)))
        x87 := (uint64(fiatFpUint1(x86)) + uint64(fiatFpUint1(x65)))
        var x88 uint64
        var x89 uint64
        x89, x88 = bits.Mul64(x2, arg1[3])
        var x90 uint64
        var x91 uint64
        x91, x90 = bits.Mul64(x2, arg1[2])
        var x92 uint64
        var x93 uint64
        x93, x92 = bits.Mul64(x2, arg1[1])
        var x94 uint64
        var x95 uint64
        x95, x94 = bits.Mul64(x2, arg1[0])
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x95, x92, uint64(0x0))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x93, x90, uint64(fiatFpUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x91, x88, uint64(fiatFpUint1(x99)))
        x102 := (uint64(fiatFpUint1(x101)) + x89)
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x94, uint64(0x0))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x96, uint64(fiatFpUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x98, uint64(fiatFpUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x85, x100, uint64(fiatFpUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x87, x102, uint64(fiatFpUint1(x110)))
        var x113 uint64
        _, x113 = bits.Mul64(x103, 0x992d30ecffffffff)
        var x115 uint64
        var x116 uint64
        x116, x115 = bits.Mul64(x113, 0x4000000000000000)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x113, 0x224698fc094cf91b)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x113, 0x992d30ed00000001)
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x120, x117, uint64(0x0))
        x123 := (uint64(fiatFpUint1(x122)) + x118)
        var x125 uint64
        _, x125 = bits.Add64(x103, x119, uint64(0x0))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x105, x121, uint64(fiatFpUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64(x107, x123, uint64(fiatFpUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Add64(x109, x115, uint64(fiatFpUint1(x129)))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Add64(x111, x116, uint64(fiatFpUint1(x131)))
        x134 := (uint64(fiatFpUint1(x133)) + uint64(fiatFpUint1(x112)))
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, arg1[3])
        var x137 uint64
        var x138 uint64
        x138, x137 = bits.Mul64(x3, arg1[2])
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x3, arg1[1])
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, arg1[0])
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x142, x139, uint64(0x0))
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x140, x137, uint64(fiatFpUint1(x144)))
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x138, x135, uint64(fiatFpUint1(x146)))
        x149 := (uint64(fiatFpUint1(x148)) + x136)
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x126, x141, uint64(0x0))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Add64(x128, x143, uint64(fiatFpUint1(x151)))
        var x154 uint64
        var x155 uint64
        x154, x155 = bits.Add64(x130, x145, uint64(fiatFpUint1(x153)))
        var x156 uint64
        var x157 uint64
        x156, x157 = bits.Add64(x132, x147, uint64(fiatFpUint1(x155)))
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x134, x149, uint64(fiatFpUint1(x157)))
        var x160 uint64
        _, x160 = bits.Mul64(x150, 0x992d30ecffffffff)
        var x162 uint64
        var x163 uint64
        x163, x162 = bits.Mul64(x160, 0x4000000000000000)
        var x164 uint64
        var x165 uint64
        x165, x164 = bits.Mul64(x160, 0x224698fc094cf91b)
        var x166 uint64
        var x167 uint64
        x167, x166 = bits.Mul64(x160, 0x992d30ed00000001)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x167, x164, uint64(0x0))
        x170 := (uint64(fiatFpUint1(x169)) + x165)
        var x172 uint64
        _, x172 = bits.Add64(x150, x166, uint64(0x0))
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x152, x168, uint64(fiatFpUint1(x172)))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x154, x170, uint64(fiatFpUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x156, x162, uint64(fiatFpUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x158, x163, uint64(fiatFpUint1(x178)))
        x181 := (uint64(fiatFpUint1(x180)) + uint64(fiatFpUint1(x159)))
        var x182 uint64
        var x183 uint64
        x182, x183 = bits.Sub64(x173, 0x992d30ed00000001, uint64(0x0))
        var x184 uint64
        var x185 uint64
        x184, x185 = bits.Sub64(x175, 0x224698fc094cf91b, uint64(fiatFpUint1(x183)))
        var x186 uint64
        var x187 uint64
        x186, x187 = bits.Sub64(x177, uint64(0x0), uint64(fiatFpUint1(x185)))
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Sub64(x179, 0x4000000000000000, uint64(fiatFpUint1(x187)))
        var x191 uint64
        _, x191 = bits.Sub64(x181, uint64(0x0), uint64(fiatFpUint1(x189)))
        var x192 uint64
        fiatFpCmovznzU64(&amp;x192, fiatFpUint1(x191), x182, x173)
        var x193 uint64
        fiatFpCmovznzU64(&amp;x193, fiatFpUint1(x191), x184, x175)
        var x194 uint64
        fiatFpCmovznzU64(&amp;x194, fiatFpUint1(x191), x186, x177)
        var x195 uint64
        fiatFpCmovznzU64(&amp;x195, fiatFpUint1(x191), x188, x179)
        out1[0] = x192
        out1[1] = x193
        out1[2] = x194
        out1[3] = x195
}</span>

// fiatFpAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpAdd(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(x1, 0x992d30ed00000001, uint64(0x0))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(x3, 0x224698fc094cf91b, uint64(fiatFpUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x5, uint64(0x0), uint64(fiatFpUint1(x12)))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x7, 0x4000000000000000, uint64(fiatFpUint1(x14)))
        var x18 uint64
        _, x18 = bits.Sub64(uint64(fiatFpUint1(x8)), uint64(0x0), uint64(fiatFpUint1(x16)))
        var x19 uint64
        fiatFpCmovznzU64(&amp;x19, fiatFpUint1(x18), x9, x1)
        var x20 uint64
        fiatFpCmovznzU64(&amp;x20, fiatFpUint1(x18), x11, x3)
        var x21 uint64
        fiatFpCmovznzU64(&amp;x21, fiatFpUint1(x18), x13, x5)
        var x22 uint64
        fiatFpCmovznzU64(&amp;x22, fiatFpUint1(x18), x15, x7)
        out1[0] = x19
        out1[1] = x20
        out1[2] = x21
        out1[3] = x22
}</span>

// fiatFpSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFpSub(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement, arg2 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, fiatFpUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0x992d30ed00000001), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0x224698fc094cf91b), uint64(fiatFpUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, uint64(0x0), uint64(fiatFpUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0x4000000000000000), uint64(fiatFpUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFpOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFpOpp(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFpUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFpUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFpUint1(x6)))
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, fiatFpUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0x992d30ed00000001), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0x224698fc094cf91b), uint64(fiatFpUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, uint64(0x0), uint64(fiatFpUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0x4000000000000000), uint64(fiatFpUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFpFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^4) mod m
//   0  eval out1 &lt; m
//
func fiatFpFromMontgomery(out1 *fiatFpNonMontgomeryDomainFieldElement, arg1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[0]
        var x2 uint64
        _, x2 = bits.Mul64(x1, 0x992d30ecffffffff)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x2, 0x4000000000000000)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x2, 0x224698fc094cf91b)
        var x8 uint64
        var x9 uint64
        x9, x8 = bits.Mul64(x2, 0x992d30ed00000001)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x9, x6, uint64(0x0))
        var x13 uint64
        _, x13 = bits.Add64(x1, x8, uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), x10, uint64(fiatFpUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x14, arg1[1], uint64(0x0))
        var x18 uint64
        _, x18 = bits.Mul64(x16, 0x992d30ecffffffff)
        var x20 uint64
        var x21 uint64
        x21, x20 = bits.Mul64(x18, 0x4000000000000000)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x18, 0x224698fc094cf91b)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x18, 0x992d30ed00000001)
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(x25, x22, uint64(0x0))
        var x29 uint64
        _, x29 = bits.Add64(x16, x24, uint64(0x0))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64((uint64(fiatFpUint1(x17)) + (uint64(fiatFpUint1(x15)) + (uint64(fiatFpUint1(x11)) + x7))), x26, uint64(fiatFpUint1(x29)))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x4, (uint64(fiatFpUint1(x27)) + x23), uint64(fiatFpUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x5, x20, uint64(fiatFpUint1(x33)))
        var x36 uint64
        var x37 uint64
        x36, x37 = bits.Add64(x30, arg1[2], uint64(0x0))
        var x38 uint64
        var x39 uint64
        x38, x39 = bits.Add64(x32, uint64(0x0), uint64(fiatFpUint1(x37)))
        var x40 uint64
        var x41 uint64
        x40, x41 = bits.Add64(x34, uint64(0x0), uint64(fiatFpUint1(x39)))
        var x42 uint64
        _, x42 = bits.Mul64(x36, 0x992d30ecffffffff)
        var x44 uint64
        var x45 uint64
        x45, x44 = bits.Mul64(x42, 0x4000000000000000)
        var x46 uint64
        var x47 uint64
        x47, x46 = bits.Mul64(x42, 0x224698fc094cf91b)
        var x48 uint64
        var x49 uint64
        x49, x48 = bits.Mul64(x42, 0x992d30ed00000001)
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x49, x46, uint64(0x0))
        var x53 uint64
        _, x53 = bits.Add64(x36, x48, uint64(0x0))
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64(x38, x50, uint64(fiatFpUint1(x53)))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x40, (uint64(fiatFpUint1(x51)) + x47), uint64(fiatFpUint1(x55)))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64((uint64(fiatFpUint1(x41)) + (uint64(fiatFpUint1(x35)) + x21)), x44, uint64(fiatFpUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x54, arg1[3], uint64(0x0))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x56, uint64(0x0), uint64(fiatFpUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x58, uint64(0x0), uint64(fiatFpUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x60, 0x992d30ecffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x4000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x224698fc094cf91b)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x992d30ed00000001)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        var x77 uint64
        _, x77 = bits.Add64(x60, x72, uint64(0x0))
        var x78 uint64
        var x79 uint64
        x78, x79 = bits.Add64(x62, x74, uint64(fiatFpUint1(x77)))
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x64, (uint64(fiatFpUint1(x75)) + x71), uint64(fiatFpUint1(x79)))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64((uint64(fiatFpUint1(x65)) + (uint64(fiatFpUint1(x59)) + x45)), x68, uint64(fiatFpUint1(x81)))
        x84 := (uint64(fiatFpUint1(x83)) + x69)
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Sub64(x78, 0x992d30ed00000001, uint64(0x0))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Sub64(x80, 0x224698fc094cf91b, uint64(fiatFpUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Sub64(x82, uint64(0x0), uint64(fiatFpUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Sub64(x84, 0x4000000000000000, uint64(fiatFpUint1(x90)))
        var x94 uint64
        _, x94 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFpUint1(x92)))
        var x95 uint64
        fiatFpCmovznzU64(&amp;x95, fiatFpUint1(x94), x85, x78)
        var x96 uint64
        fiatFpCmovznzU64(&amp;x96, fiatFpUint1(x94), x87, x80)
        var x97 uint64
        fiatFpCmovznzU64(&amp;x97, fiatFpUint1(x94), x89, x82)
        var x98 uint64
        fiatFpCmovznzU64(&amp;x98, fiatFpUint1(x94), x91, x84)
        out1[0] = x95
        out1[1] = x96
        out1[2] = x97
        out1[3] = x98
}</span>

// fiatFpToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFpToMontgomery(out1 *fiatFpMontgomeryDomainFieldElement, arg1 *fiatFpNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, 0x96d41af7b9cb714)
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, 0x7797a99bc3c95d18)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, 0xd7d30dbd8b0de0e7)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, 0x8c78ecb30000000f)
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFpUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFpUint1(x16)))
        var x19 uint64
        _, x19 = bits.Mul64(x11, 0x992d30ecffffffff)
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(x19, 0x4000000000000000)
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(x19, 0x224698fc094cf91b)
        var x25 uint64
        var x26 uint64
        x26, x25 = bits.Mul64(x19, 0x992d30ed00000001)
        var x27 uint64
        var x28 uint64
        x27, x28 = bits.Add64(x26, x23, uint64(0x0))
        var x30 uint64
        _, x30 = bits.Add64(x11, x25, uint64(0x0))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x13, x27, uint64(fiatFpUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x15, (uint64(fiatFpUint1(x28)) + x24), uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x17, x21, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x38, x37 = bits.Mul64(x1, 0x96d41af7b9cb714)
        var x39 uint64
        var x40 uint64
        x40, x39 = bits.Mul64(x1, 0x7797a99bc3c95d18)
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, 0xd7d30dbd8b0de0e7)
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, 0x8c78ecb30000000f)
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x44, x41, uint64(0x0))
        var x47 uint64
        var x48 uint64
        x47, x48 = bits.Add64(x42, x39, uint64(fiatFpUint1(x46)))
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x40, x37, uint64(fiatFpUint1(x48)))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x31, x43, uint64(0x0))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x33, x45, uint64(fiatFpUint1(x52)))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x35, x47, uint64(fiatFpUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(((uint64(fiatFpUint1(x36)) + (uint64(fiatFpUint1(x18)) + x6)) + x22), x49, uint64(fiatFpUint1(x56)))
        var x59 uint64
        _, x59 = bits.Mul64(x51, 0x992d30ecffffffff)
        var x61 uint64
        var x62 uint64
        x62, x61 = bits.Mul64(x59, 0x4000000000000000)
        var x63 uint64
        var x64 uint64
        x64, x63 = bits.Mul64(x59, 0x224698fc094cf91b)
        var x65 uint64
        var x66 uint64
        x66, x65 = bits.Mul64(x59, 0x992d30ed00000001)
        var x67 uint64
        var x68 uint64
        x67, x68 = bits.Add64(x66, x63, uint64(0x0))
        var x70 uint64
        _, x70 = bits.Add64(x51, x65, uint64(0x0))
        var x71 uint64
        var x72 uint64
        x71, x72 = bits.Add64(x53, x67, uint64(fiatFpUint1(x70)))
        var x73 uint64
        var x74 uint64
        x73, x74 = bits.Add64(x55, (uint64(fiatFpUint1(x68)) + x64), uint64(fiatFpUint1(x72)))
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Add64(x57, x61, uint64(fiatFpUint1(x74)))
        var x77 uint64
        var x78 uint64
        x78, x77 = bits.Mul64(x2, 0x96d41af7b9cb714)
        var x79 uint64
        var x80 uint64
        x80, x79 = bits.Mul64(x2, 0x7797a99bc3c95d18)
        var x81 uint64
        var x82 uint64
        x82, x81 = bits.Mul64(x2, 0xd7d30dbd8b0de0e7)
        var x83 uint64
        var x84 uint64
        x84, x83 = bits.Mul64(x2, 0x8c78ecb30000000f)
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x84, x81, uint64(0x0))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x82, x79, uint64(fiatFpUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x80, x77, uint64(fiatFpUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x71, x83, uint64(0x0))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x73, x85, uint64(fiatFpUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x75, x87, uint64(fiatFpUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(((uint64(fiatFpUint1(x76)) + (uint64(fiatFpUint1(x58)) + (uint64(fiatFpUint1(x50)) + x38))) + x62), x89, uint64(fiatFpUint1(x96)))
        var x99 uint64
        _, x99 = bits.Mul64(x91, 0x992d30ecffffffff)
        var x101 uint64
        var x102 uint64
        x102, x101 = bits.Mul64(x99, 0x4000000000000000)
        var x103 uint64
        var x104 uint64
        x104, x103 = bits.Mul64(x99, 0x224698fc094cf91b)
        var x105 uint64
        var x106 uint64
        x106, x105 = bits.Mul64(x99, 0x992d30ed00000001)
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x106, x103, uint64(0x0))
        var x110 uint64
        _, x110 = bits.Add64(x91, x105, uint64(0x0))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x93, x107, uint64(fiatFpUint1(x110)))
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x95, (uint64(fiatFpUint1(x108)) + x104), uint64(fiatFpUint1(x112)))
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x97, x101, uint64(fiatFpUint1(x114)))
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x3, 0x96d41af7b9cb714)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x3, 0x7797a99bc3c95d18)
        var x121 uint64
        var x122 uint64
        x122, x121 = bits.Mul64(x3, 0xd7d30dbd8b0de0e7)
        var x123 uint64
        var x124 uint64
        x124, x123 = bits.Mul64(x3, 0x8c78ecb30000000f)
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x124, x121, uint64(0x0))
        var x127 uint64
        var x128 uint64
        x127, x128 = bits.Add64(x122, x119, uint64(fiatFpUint1(x126)))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x120, x117, uint64(fiatFpUint1(x128)))
        var x131 uint64
        var x132 uint64
        x131, x132 = bits.Add64(x111, x123, uint64(0x0))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x113, x125, uint64(fiatFpUint1(x132)))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x115, x127, uint64(fiatFpUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(((uint64(fiatFpUint1(x116)) + (uint64(fiatFpUint1(x98)) + (uint64(fiatFpUint1(x90)) + x78))) + x102), x129, uint64(fiatFpUint1(x136)))
        var x139 uint64
        _, x139 = bits.Mul64(x131, 0x992d30ecffffffff)
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x139, 0x4000000000000000)
        var x143 uint64
        var x144 uint64
        x144, x143 = bits.Mul64(x139, 0x224698fc094cf91b)
        var x145 uint64
        var x146 uint64
        x146, x145 = bits.Mul64(x139, 0x992d30ed00000001)
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x146, x143, uint64(0x0))
        var x150 uint64
        _, x150 = bits.Add64(x131, x145, uint64(0x0))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Add64(x133, x147, uint64(fiatFpUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Add64(x135, (uint64(fiatFpUint1(x148)) + x144), uint64(fiatFpUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Add64(x137, x141, uint64(fiatFpUint1(x154)))
        x157 := ((uint64(fiatFpUint1(x156)) + (uint64(fiatFpUint1(x138)) + (uint64(fiatFpUint1(x130)) + x118))) + x142)
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Sub64(x151, 0x992d30ed00000001, uint64(0x0))
        var x160 uint64
        var x161 uint64
        x160, x161 = bits.Sub64(x153, 0x224698fc094cf91b, uint64(fiatFpUint1(x159)))
        var x162 uint64
        var x163 uint64
        x162, x163 = bits.Sub64(x155, uint64(0x0), uint64(fiatFpUint1(x161)))
        var x164 uint64
        var x165 uint64
        x164, x165 = bits.Sub64(x157, 0x4000000000000000, uint64(fiatFpUint1(x163)))
        var x167 uint64
        _, x167 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFpUint1(x165)))
        var x168 uint64
        fiatFpCmovznzU64(&amp;x168, fiatFpUint1(x167), x158, x151)
        var x169 uint64
        fiatFpCmovznzU64(&amp;x169, fiatFpUint1(x167), x160, x153)
        var x170 uint64
        fiatFpCmovznzU64(&amp;x170, fiatFpUint1(x167), x162, x155)
        var x171 uint64
        fiatFpCmovznzU64(&amp;x171, fiatFpUint1(x167), x164, x157)
        out1[0] = x168
        out1[1] = x169
        out1[2] = x170
        out1[3] = x171
}</span>

// fiatFpNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFpNonzero(out1 *uint64, arg1 *[4]uint64) <span class="cov8" title="1">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | arg1[3])))
        *out1 = x1
}</span>

// fiatFpSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpSelectznz(out1 *[4]uint64, arg1 fiatFpUint1, arg2 *[4]uint64, arg3 *[4]uint64) <span class="cov8" title="1">{
        var x1 uint64
        fiatFpCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFpCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFpCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFpCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
}</span>

// fiatFpToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x7fffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x7f]]
func fiatFpToBytes(out1 *[32]uint8, arg1 *[4]uint64) <span class="cov8" title="1">{
        x1 := arg1[3]
        x2 := arg1[2]
        x3 := arg1[1]
        x4 := arg1[0]
        x5 := (uint8(x4) &amp; 0xff)
        x6 := (x4 &gt;&gt; 8)
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := uint8((x16 &gt;&gt; 8))
        x19 := (uint8(x3) &amp; 0xff)
        x20 := (x3 &gt;&gt; 8)
        x21 := (uint8(x20) &amp; 0xff)
        x22 := (x20 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := uint8((x30 &gt;&gt; 8))
        x33 := (uint8(x2) &amp; 0xff)
        x34 := (x2 &gt;&gt; 8)
        x35 := (uint8(x34) &amp; 0xff)
        x36 := (x34 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := uint8((x44 &gt;&gt; 8))
        x47 := (uint8(x1) &amp; 0xff)
        x48 := (x1 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := (x48 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := uint8((x58 &gt;&gt; 8))
        out1[0] = x5
        out1[1] = x7
        out1[2] = x9
        out1[3] = x11
        out1[4] = x13
        out1[5] = x15
        out1[6] = x17
        out1[7] = x18
        out1[8] = x19
        out1[9] = x21
        out1[10] = x23
        out1[11] = x25
        out1[12] = x27
        out1[13] = x29
        out1[14] = x31
        out1[15] = x32
        out1[16] = x33
        out1[17] = x35
        out1[18] = x37
        out1[19] = x39
        out1[20] = x41
        out1[21] = x43
        out1[22] = x45
        out1[23] = x46
        out1[24] = x47
        out1[25] = x49
        out1[26] = x51
        out1[27] = x53
        out1[28] = x55
        out1[29] = x57
        out1[30] = x59
        out1[31] = x60
}</span>

// fiatFpFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x7f]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x7fffffffffffffff]]
func fiatFpFromBytes(out1 *[4]uint64, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 56)
        x2 := (uint64(arg1[30]) &lt;&lt; 48)
        x3 := (uint64(arg1[29]) &lt;&lt; 40)
        x4 := (uint64(arg1[28]) &lt;&lt; 32)
        x5 := (uint64(arg1[27]) &lt;&lt; 24)
        x6 := (uint64(arg1[26]) &lt;&lt; 16)
        x7 := (uint64(arg1[25]) &lt;&lt; 8)
        x8 := arg1[24]
        x9 := (uint64(arg1[23]) &lt;&lt; 56)
        x10 := (uint64(arg1[22]) &lt;&lt; 48)
        x11 := (uint64(arg1[21]) &lt;&lt; 40)
        x12 := (uint64(arg1[20]) &lt;&lt; 32)
        x13 := (uint64(arg1[19]) &lt;&lt; 24)
        x14 := (uint64(arg1[18]) &lt;&lt; 16)
        x15 := (uint64(arg1[17]) &lt;&lt; 8)
        x16 := arg1[16]
        x17 := (uint64(arg1[15]) &lt;&lt; 56)
        x18 := (uint64(arg1[14]) &lt;&lt; 48)
        x19 := (uint64(arg1[13]) &lt;&lt; 40)
        x20 := (uint64(arg1[12]) &lt;&lt; 32)
        x21 := (uint64(arg1[11]) &lt;&lt; 24)
        x22 := (uint64(arg1[10]) &lt;&lt; 16)
        x23 := (uint64(arg1[9]) &lt;&lt; 8)
        x24 := arg1[8]
        x25 := (uint64(arg1[7]) &lt;&lt; 56)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x25 + x38)
        x40 := (x23 + uint64(x24))
        x41 := (x22 + x40)
        x42 := (x21 + x41)
        x43 := (x20 + x42)
        x44 := (x19 + x43)
        x45 := (x18 + x44)
        x46 := (x17 + x45)
        x47 := (x15 + uint64(x16))
        x48 := (x14 + x47)
        x49 := (x13 + x48)
        x50 := (x12 + x49)
        x51 := (x11 + x50)
        x52 := (x10 + x51)
        x53 := (x9 + x52)
        x54 := (x7 + uint64(x8))
        x55 := (x6 + x54)
        x56 := (x5 + x55)
        x57 := (x4 + x56)
        x58 := (x3 + x57)
        x59 := (x2 + x58)
        x60 := (x1 + x59)
        out1[0] = x39
        out1[1] = x46
        out1[2] = x53
        out1[3] = x60
}</span>

// fiatFpSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFpSetOne(out1 *fiatFpMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        out1[0] = 0x34786d38fffffffd
        out1[1] = 0x992c350be41914ad
        out1[2] = 0xffffffffffffffff
        out1[3] = 0x3fffffffffffffff
}</span>

// fiatFpMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpMsat(out1 *[5]uint64) <span class="cov8" title="1">{
        out1[0] = 0x992d30ed00000001
        out1[1] = 0x224698fc094cf91b
        out1[2] = uint64(0x0)
        out1[3] = 0x4000000000000000
        out1[4] = uint64(0x0)
}</span>

// fiatFpDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpDivstepPrecomp(out1 *[4]uint64) <span class="cov8" title="1">{
        out1[0] = 0xeb9f9ebd71876582
        out1[1] = 0x61d4a765274d339b
        out1[2] = 0x4bf06d486f0671ed
        out1[3] = 0x278227fb0b195a26
}</span>

// fiatFpDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFpDivstep(out1 *uint64, out2 *[5]uint64, out3 *[5]uint64, out4 *[4]uint64, out5 *[4]uint64, arg1 uint64, arg2 *[5]uint64, arg3 *[5]uint64, arg4 *[4]uint64, arg5 *[4]uint64) <span class="cov8" title="1">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFpUint1((x1 &gt;&gt; 63)) &amp; (fiatFpUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFpCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFpCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFpCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFpCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFpCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFpCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFpUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFpUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFpUint1(x17)))
        var x20 uint64
        x20, _ = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFpUint1(x19)))
        var x22 uint64
        fiatFpCmovznzU64(&amp;x22, x3, arg3[0], x12)
        var x23 uint64
        fiatFpCmovznzU64(&amp;x23, x3, arg3[1], x14)
        var x24 uint64
        fiatFpCmovznzU64(&amp;x24, x3, arg3[2], x16)
        var x25 uint64
        fiatFpCmovznzU64(&amp;x25, x3, arg3[3], x18)
        var x26 uint64
        fiatFpCmovznzU64(&amp;x26, x3, arg3[4], x20)
        var x27 uint64
        fiatFpCmovznzU64(&amp;x27, x3, arg4[0], arg5[0])
        var x28 uint64
        fiatFpCmovznzU64(&amp;x28, x3, arg4[1], arg5[1])
        var x29 uint64
        fiatFpCmovznzU64(&amp;x29, x3, arg4[2], arg5[2])
        var x30 uint64
        fiatFpCmovznzU64(&amp;x30, x3, arg4[3], arg5[3])
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x27, x27, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x28, x28, uint64(fiatFpUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x29, x29, uint64(fiatFpUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x30, x30, uint64(fiatFpUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Sub64(x31, 0x992d30ed00000001, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Sub64(x33, 0x224698fc094cf91b, uint64(fiatFpUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Sub64(x35, uint64(0x0), uint64(fiatFpUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Sub64(x37, 0x4000000000000000, uint64(fiatFpUint1(x44)))
        var x48 uint64
        _, x48 = bits.Sub64(uint64(fiatFpUint1(x38)), uint64(0x0), uint64(fiatFpUint1(x46)))
        x49 := arg4[3]
        x50 := arg4[2]
        x51 := arg4[1]
        x52 := arg4[0]
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(uint64(0x0), x52, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(uint64(0x0), x51, uint64(fiatFpUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(uint64(0x0), x50, uint64(fiatFpUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(uint64(0x0), x49, uint64(fiatFpUint1(x58)))
        var x61 uint64
        fiatFpCmovznzU64(&amp;x61, fiatFpUint1(x60), uint64(0x0), 0xffffffffffffffff)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x53, (x61 &amp; 0x992d30ed00000001), uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x55, (x61 &amp; 0x224698fc094cf91b), uint64(fiatFpUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, uint64(0x0), uint64(fiatFpUint1(x65)))
        var x68 uint64
        x68, _ = bits.Add64(x59, (x61 &amp; 0x4000000000000000), uint64(fiatFpUint1(x67)))
        var x70 uint64
        fiatFpCmovznzU64(&amp;x70, x3, arg5[0], x62)
        var x71 uint64
        fiatFpCmovznzU64(&amp;x71, x3, arg5[1], x64)
        var x72 uint64
        fiatFpCmovznzU64(&amp;x72, x3, arg5[2], x66)
        var x73 uint64
        fiatFpCmovznzU64(&amp;x73, x3, arg5[3], x68)
        x74 := (fiatFpUint1(x22) &amp; 0x1)
        var x75 uint64
        fiatFpCmovznzU64(&amp;x75, x74, uint64(0x0), x7)
        var x76 uint64
        fiatFpCmovznzU64(&amp;x76, x74, uint64(0x0), x8)
        var x77 uint64
        fiatFpCmovznzU64(&amp;x77, x74, uint64(0x0), x9)
        var x78 uint64
        fiatFpCmovznzU64(&amp;x78, x74, uint64(0x0), x10)
        var x79 uint64
        fiatFpCmovznzU64(&amp;x79, x74, uint64(0x0), x11)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x22, x75, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x23, x76, uint64(fiatFpUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x24, x77, uint64(fiatFpUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x25, x78, uint64(fiatFpUint1(x85)))
        var x88 uint64
        x88, _ = bits.Add64(x26, x79, uint64(fiatFpUint1(x87)))
        var x90 uint64
        fiatFpCmovznzU64(&amp;x90, x74, uint64(0x0), x27)
        var x91 uint64
        fiatFpCmovznzU64(&amp;x91, x74, uint64(0x0), x28)
        var x92 uint64
        fiatFpCmovznzU64(&amp;x92, x74, uint64(0x0), x29)
        var x93 uint64
        fiatFpCmovznzU64(&amp;x93, x74, uint64(0x0), x30)
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x70, x90, uint64(0x0))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x71, x91, uint64(fiatFpUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x72, x92, uint64(fiatFpUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x73, x93, uint64(fiatFpUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Sub64(x94, 0x992d30ed00000001, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Sub64(x96, 0x224698fc094cf91b, uint64(fiatFpUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Sub64(x98, uint64(0x0), uint64(fiatFpUint1(x105)))
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Sub64(x100, 0x4000000000000000, uint64(fiatFpUint1(x107)))
        var x111 uint64
        _, x111 = bits.Sub64(uint64(fiatFpUint1(x101)), uint64(0x0), uint64(fiatFpUint1(x109)))
        var x112 uint64
        x112, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x114 := ((x80 &gt;&gt; 1) | ((x82 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x115 := ((x82 &gt;&gt; 1) | ((x84 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x116 := ((x84 &gt;&gt; 1) | ((x86 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x117 := ((x86 &gt;&gt; 1) | ((x88 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x118 := ((x88 &amp; 0x8000000000000000) | (x88 &gt;&gt; 1))
        var x119 uint64
        fiatFpCmovznzU64(&amp;x119, fiatFpUint1(x48), x39, x31)
        var x120 uint64
        fiatFpCmovznzU64(&amp;x120, fiatFpUint1(x48), x41, x33)
        var x121 uint64
        fiatFpCmovznzU64(&amp;x121, fiatFpUint1(x48), x43, x35)
        var x122 uint64
        fiatFpCmovznzU64(&amp;x122, fiatFpUint1(x48), x45, x37)
        var x123 uint64
        fiatFpCmovznzU64(&amp;x123, fiatFpUint1(x111), x102, x94)
        var x124 uint64
        fiatFpCmovznzU64(&amp;x124, fiatFpUint1(x111), x104, x96)
        var x125 uint64
        fiatFpCmovznzU64(&amp;x125, fiatFpUint1(x111), x106, x98)
        var x126 uint64
        fiatFpCmovznzU64(&amp;x126, fiatFpUint1(x111), x108, x100)
        *out1 = x112
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out3[0] = x114
        out3[1] = x115
        out3[2] = x116
        out3[3] = x117
        out3[4] = x118
        out4[0] = x119
        out4[1] = x120
        out4[2] = x121
        out4[3] = x122
        out5[0] = x123
        out5[1] = x124
        out5[2] = x125
        out5[3] = x126
}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">// Code generated by Fiat Cryptography. DO NOT EDIT.
//
// Autogenerated: '/usr/local/bin/fiat-crypto' word-by-word-montgomery --lang Go --no-wide-int --relax-primitive-carry-to-bitwidth 32,64 --cmovznz-by-mul --internal-static --package-case flatcase --public-function-case camelCase --private-function-case camelCase --public-type-case camelCase --private-type-case camelCase --doc-newline-in-typedef-bounds --doc-prepend-header 'Code generated by Fiat Cryptography. DO NOT EDIT.' --doc-text-before-function-name '' --doc-text-before-type-name '' --package-name impl Fq 64 '2^254 + 45560315531506369815346746415080538113'
//
// curve description: Fq
//
// machine_wordsize = 64 (from "64")
//
// requested operations: (all)
//
// m = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001 (from "2^254 + 45560315531506369815346746415080538113")
//
//
//
// NOTE: In addition to the bounds specified above each function, all
//
//   functions synthesized for this Montgomery arithmetic require the
//
//   input to be strictly less than the prime modulus (m), and also
//
//   require the input to be in the unique saturated representation.
//
//   All functions also ensure that these two properties are true of
//
//   return values.
//
//
//
// Computed values:
//
//   eval z = z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192)
//
//   bytes_eval z = z[0] + (z[1] &lt;&lt; 8) + (z[2] &lt;&lt; 16) + (z[3] &lt;&lt; 24) + (z[4] &lt;&lt; 32) + (z[5] &lt;&lt; 40) + (z[6] &lt;&lt; 48) + (z[7] &lt;&lt; 56) + (z[8] &lt;&lt; 64) + (z[9] &lt;&lt; 72) + (z[10] &lt;&lt; 80) + (z[11] &lt;&lt; 88) + (z[12] &lt;&lt; 96) + (z[13] &lt;&lt; 104) + (z[14] &lt;&lt; 112) + (z[15] &lt;&lt; 120) + (z[16] &lt;&lt; 128) + (z[17] &lt;&lt; 136) + (z[18] &lt;&lt; 144) + (z[19] &lt;&lt; 152) + (z[20] &lt;&lt; 160) + (z[21] &lt;&lt; 168) + (z[22] &lt;&lt; 176) + (z[23] &lt;&lt; 184) + (z[24] &lt;&lt; 192) + (z[25] &lt;&lt; 200) + (z[26] &lt;&lt; 208) + (z[27] &lt;&lt; 216) + (z[28] &lt;&lt; 224) + (z[29] &lt;&lt; 232) + (z[30] &lt;&lt; 240) + (z[31] &lt;&lt; 248)
//
//   twos_complement_eval z = let x1 := z[0] + (z[1] &lt;&lt; 64) + (z[2] &lt;&lt; 128) + (z[3] &lt;&lt; 192) in
//
//                            if x1 &amp; (2^256-1) &lt; 2^255 then x1 &amp; (2^256-1) else (x1 &amp; (2^256-1)) - 2^256
package impl

import "math/bits"

type fiatFqUint1 uint64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927
type fiatFqInt1 int64 // We use uint64 instead of a more narrow type for performance reasons; see https://github.com/mit-plv/fiat-crypto/pull/1006#issuecomment-892625927

// fiatFqMontgomeryDomainFieldElement is a field element in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqMontgomeryDomainFieldElement [4]uint64

// fiatFqNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
//
// Bounds:
//
//   [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
type fiatFqNonMontgomeryDomainFieldElement [4]uint64

// fiatFqCmovznzU64 is a single-word conditional move.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [0x0 ~&gt; 0xffffffffffffffff]
//   arg3: [0x0 ~&gt; 0xffffffffffffffff]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqCmovznzU64(out1 *uint64, arg1 fiatFqUint1, arg2 uint64, arg3 uint64) <span class="cov8" title="1">{
        x1 := (uint64(arg1) * 0xffffffffffffffff)
        x2 := ((x1 &amp; arg3) | ((^x1) &amp; arg2))
        *out1 = x2
}</span>

// fiatFqMul multiplies two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqMul(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg2[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg2[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg2[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg2[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0x8c46eb20ffffffff)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0x4000000000000000)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0x224698fc0994a8dd)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0x8c46eb2100000001)
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x27, x24, uint64(0x0))
        x30 := (uint64(fiatFqUint1(x29)) + x25)
        var x32 uint64
        _, x32 = bits.Add64(x11, x26, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x13, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x15, x30, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x17, x22, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x19, x23, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, arg2[3])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, arg2[2])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, arg2[1])
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg2[0])
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x48, x45, uint64(0x0))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x46, x43, uint64(fiatFqUint1(x50)))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x44, x41, uint64(fiatFqUint1(x52)))
        x55 := (uint64(fiatFqUint1(x54)) + x42)
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x33, x47, uint64(0x0))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x35, x49, uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x37, x51, uint64(fiatFqUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(fiatFqUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(uint64(fiatFqUint1(x40)), x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x56, 0x8c46eb20ffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x4000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x224698fc0994a8dd)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x8c46eb2100000001)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        x76 := (uint64(fiatFqUint1(x75)) + x71)
        var x78 uint64
        _, x78 = bits.Add64(x56, x72, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x58, x74, uint64(fiatFqUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x60, x76, uint64(fiatFqUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x62, x68, uint64(fiatFqUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x64, x69, uint64(fiatFqUint1(x84)))
        x87 := (uint64(fiatFqUint1(x86)) + uint64(fiatFqUint1(x65)))
        var x88 uint64
        var x89 uint64
        x89, x88 = bits.Mul64(x2, arg2[3])
        var x90 uint64
        var x91 uint64
        x91, x90 = bits.Mul64(x2, arg2[2])
        var x92 uint64
        var x93 uint64
        x93, x92 = bits.Mul64(x2, arg2[1])
        var x94 uint64
        var x95 uint64
        x95, x94 = bits.Mul64(x2, arg2[0])
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x95, x92, uint64(0x0))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x93, x90, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x91, x88, uint64(fiatFqUint1(x99)))
        x102 := (uint64(fiatFqUint1(x101)) + x89)
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x94, uint64(0x0))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x96, uint64(fiatFqUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x98, uint64(fiatFqUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x85, x100, uint64(fiatFqUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x87, x102, uint64(fiatFqUint1(x110)))
        var x113 uint64
        _, x113 = bits.Mul64(x103, 0x8c46eb20ffffffff)
        var x115 uint64
        var x116 uint64
        x116, x115 = bits.Mul64(x113, 0x4000000000000000)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x113, 0x224698fc0994a8dd)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x113, 0x8c46eb2100000001)
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x120, x117, uint64(0x0))
        x123 := (uint64(fiatFqUint1(x122)) + x118)
        var x125 uint64
        _, x125 = bits.Add64(x103, x119, uint64(0x0))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x105, x121, uint64(fiatFqUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64(x107, x123, uint64(fiatFqUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Add64(x109, x115, uint64(fiatFqUint1(x129)))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Add64(x111, x116, uint64(fiatFqUint1(x131)))
        x134 := (uint64(fiatFqUint1(x133)) + uint64(fiatFqUint1(x112)))
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, arg2[3])
        var x137 uint64
        var x138 uint64
        x138, x137 = bits.Mul64(x3, arg2[2])
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x3, arg2[1])
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, arg2[0])
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x142, x139, uint64(0x0))
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x140, x137, uint64(fiatFqUint1(x144)))
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x138, x135, uint64(fiatFqUint1(x146)))
        x149 := (uint64(fiatFqUint1(x148)) + x136)
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x126, x141, uint64(0x0))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Add64(x128, x143, uint64(fiatFqUint1(x151)))
        var x154 uint64
        var x155 uint64
        x154, x155 = bits.Add64(x130, x145, uint64(fiatFqUint1(x153)))
        var x156 uint64
        var x157 uint64
        x156, x157 = bits.Add64(x132, x147, uint64(fiatFqUint1(x155)))
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x134, x149, uint64(fiatFqUint1(x157)))
        var x160 uint64
        _, x160 = bits.Mul64(x150, 0x8c46eb20ffffffff)
        var x162 uint64
        var x163 uint64
        x163, x162 = bits.Mul64(x160, 0x4000000000000000)
        var x164 uint64
        var x165 uint64
        x165, x164 = bits.Mul64(x160, 0x224698fc0994a8dd)
        var x166 uint64
        var x167 uint64
        x167, x166 = bits.Mul64(x160, 0x8c46eb2100000001)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x167, x164, uint64(0x0))
        x170 := (uint64(fiatFqUint1(x169)) + x165)
        var x172 uint64
        _, x172 = bits.Add64(x150, x166, uint64(0x0))
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x152, x168, uint64(fiatFqUint1(x172)))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x154, x170, uint64(fiatFqUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x156, x162, uint64(fiatFqUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x158, x163, uint64(fiatFqUint1(x178)))
        x181 := (uint64(fiatFqUint1(x180)) + uint64(fiatFqUint1(x159)))
        var x182 uint64
        var x183 uint64
        x182, x183 = bits.Sub64(x173, 0x8c46eb2100000001, uint64(0x0))
        var x184 uint64
        var x185 uint64
        x184, x185 = bits.Sub64(x175, 0x224698fc0994a8dd, uint64(fiatFqUint1(x183)))
        var x186 uint64
        var x187 uint64
        x186, x187 = bits.Sub64(x177, uint64(0x0), uint64(fiatFqUint1(x185)))
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Sub64(x179, 0x4000000000000000, uint64(fiatFqUint1(x187)))
        var x191 uint64
        _, x191 = bits.Sub64(x181, uint64(0x0), uint64(fiatFqUint1(x189)))
        var x192 uint64
        fiatFqCmovznzU64(&amp;x192, fiatFqUint1(x191), x182, x173)
        var x193 uint64
        fiatFqCmovznzU64(&amp;x193, fiatFqUint1(x191), x184, x175)
        var x194 uint64
        fiatFqCmovznzU64(&amp;x194, fiatFqUint1(x191), x186, x177)
        var x195 uint64
        fiatFqCmovznzU64(&amp;x195, fiatFqUint1(x191), x188, x179)
        out1[0] = x192
        out1[1] = x193
        out1[2] = x194
        out1[3] = x195
}</span>

// fiatFqSquare squares a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSquare(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, arg1[3])
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, arg1[2])
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, arg1[1])
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, arg1[0])
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        x19 := (uint64(fiatFqUint1(x18)) + x6)
        var x20 uint64
        _, x20 = bits.Mul64(x11, 0x8c46eb20ffffffff)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x20, 0x4000000000000000)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x20, 0x224698fc0994a8dd)
        var x26 uint64
        var x27 uint64
        x27, x26 = bits.Mul64(x20, 0x8c46eb2100000001)
        var x28 uint64
        var x29 uint64
        x28, x29 = bits.Add64(x27, x24, uint64(0x0))
        x30 := (uint64(fiatFqUint1(x29)) + x25)
        var x32 uint64
        _, x32 = bits.Add64(x11, x26, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x13, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x15, x30, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x17, x22, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Add64(x19, x23, uint64(fiatFqUint1(x38)))
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, arg1[3])
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, arg1[2])
        var x45 uint64
        var x46 uint64
        x46, x45 = bits.Mul64(x1, arg1[1])
        var x47 uint64
        var x48 uint64
        x48, x47 = bits.Mul64(x1, arg1[0])
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x48, x45, uint64(0x0))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x46, x43, uint64(fiatFqUint1(x50)))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x44, x41, uint64(fiatFqUint1(x52)))
        x55 := (uint64(fiatFqUint1(x54)) + x42)
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x33, x47, uint64(0x0))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64(x35, x49, uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x37, x51, uint64(fiatFqUint1(x59)))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x39, x53, uint64(fiatFqUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(uint64(fiatFqUint1(x40)), x55, uint64(fiatFqUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x56, 0x8c46eb20ffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x4000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x224698fc0994a8dd)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x8c46eb2100000001)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        x76 := (uint64(fiatFqUint1(x75)) + x71)
        var x78 uint64
        _, x78 = bits.Add64(x56, x72, uint64(0x0))
        var x79 uint64
        var x80 uint64
        x79, x80 = bits.Add64(x58, x74, uint64(fiatFqUint1(x78)))
        var x81 uint64
        var x82 uint64
        x81, x82 = bits.Add64(x60, x76, uint64(fiatFqUint1(x80)))
        var x83 uint64
        var x84 uint64
        x83, x84 = bits.Add64(x62, x68, uint64(fiatFqUint1(x82)))
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x64, x69, uint64(fiatFqUint1(x84)))
        x87 := (uint64(fiatFqUint1(x86)) + uint64(fiatFqUint1(x65)))
        var x88 uint64
        var x89 uint64
        x89, x88 = bits.Mul64(x2, arg1[3])
        var x90 uint64
        var x91 uint64
        x91, x90 = bits.Mul64(x2, arg1[2])
        var x92 uint64
        var x93 uint64
        x93, x92 = bits.Mul64(x2, arg1[1])
        var x94 uint64
        var x95 uint64
        x95, x94 = bits.Mul64(x2, arg1[0])
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x95, x92, uint64(0x0))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x93, x90, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x91, x88, uint64(fiatFqUint1(x99)))
        x102 := (uint64(fiatFqUint1(x101)) + x89)
        var x103 uint64
        var x104 uint64
        x103, x104 = bits.Add64(x79, x94, uint64(0x0))
        var x105 uint64
        var x106 uint64
        x105, x106 = bits.Add64(x81, x96, uint64(fiatFqUint1(x104)))
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x83, x98, uint64(fiatFqUint1(x106)))
        var x109 uint64
        var x110 uint64
        x109, x110 = bits.Add64(x85, x100, uint64(fiatFqUint1(x108)))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x87, x102, uint64(fiatFqUint1(x110)))
        var x113 uint64
        _, x113 = bits.Mul64(x103, 0x8c46eb20ffffffff)
        var x115 uint64
        var x116 uint64
        x116, x115 = bits.Mul64(x113, 0x4000000000000000)
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x113, 0x224698fc0994a8dd)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x113, 0x8c46eb2100000001)
        var x121 uint64
        var x122 uint64
        x121, x122 = bits.Add64(x120, x117, uint64(0x0))
        x123 := (uint64(fiatFqUint1(x122)) + x118)
        var x125 uint64
        _, x125 = bits.Add64(x103, x119, uint64(0x0))
        var x126 uint64
        var x127 uint64
        x126, x127 = bits.Add64(x105, x121, uint64(fiatFqUint1(x125)))
        var x128 uint64
        var x129 uint64
        x128, x129 = bits.Add64(x107, x123, uint64(fiatFqUint1(x127)))
        var x130 uint64
        var x131 uint64
        x130, x131 = bits.Add64(x109, x115, uint64(fiatFqUint1(x129)))
        var x132 uint64
        var x133 uint64
        x132, x133 = bits.Add64(x111, x116, uint64(fiatFqUint1(x131)))
        x134 := (uint64(fiatFqUint1(x133)) + uint64(fiatFqUint1(x112)))
        var x135 uint64
        var x136 uint64
        x136, x135 = bits.Mul64(x3, arg1[3])
        var x137 uint64
        var x138 uint64
        x138, x137 = bits.Mul64(x3, arg1[2])
        var x139 uint64
        var x140 uint64
        x140, x139 = bits.Mul64(x3, arg1[1])
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x3, arg1[0])
        var x143 uint64
        var x144 uint64
        x143, x144 = bits.Add64(x142, x139, uint64(0x0))
        var x145 uint64
        var x146 uint64
        x145, x146 = bits.Add64(x140, x137, uint64(fiatFqUint1(x144)))
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x138, x135, uint64(fiatFqUint1(x146)))
        x149 := (uint64(fiatFqUint1(x148)) + x136)
        var x150 uint64
        var x151 uint64
        x150, x151 = bits.Add64(x126, x141, uint64(0x0))
        var x152 uint64
        var x153 uint64
        x152, x153 = bits.Add64(x128, x143, uint64(fiatFqUint1(x151)))
        var x154 uint64
        var x155 uint64
        x154, x155 = bits.Add64(x130, x145, uint64(fiatFqUint1(x153)))
        var x156 uint64
        var x157 uint64
        x156, x157 = bits.Add64(x132, x147, uint64(fiatFqUint1(x155)))
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Add64(x134, x149, uint64(fiatFqUint1(x157)))
        var x160 uint64
        _, x160 = bits.Mul64(x150, 0x8c46eb20ffffffff)
        var x162 uint64
        var x163 uint64
        x163, x162 = bits.Mul64(x160, 0x4000000000000000)
        var x164 uint64
        var x165 uint64
        x165, x164 = bits.Mul64(x160, 0x224698fc0994a8dd)
        var x166 uint64
        var x167 uint64
        x167, x166 = bits.Mul64(x160, 0x8c46eb2100000001)
        var x168 uint64
        var x169 uint64
        x168, x169 = bits.Add64(x167, x164, uint64(0x0))
        x170 := (uint64(fiatFqUint1(x169)) + x165)
        var x172 uint64
        _, x172 = bits.Add64(x150, x166, uint64(0x0))
        var x173 uint64
        var x174 uint64
        x173, x174 = bits.Add64(x152, x168, uint64(fiatFqUint1(x172)))
        var x175 uint64
        var x176 uint64
        x175, x176 = bits.Add64(x154, x170, uint64(fiatFqUint1(x174)))
        var x177 uint64
        var x178 uint64
        x177, x178 = bits.Add64(x156, x162, uint64(fiatFqUint1(x176)))
        var x179 uint64
        var x180 uint64
        x179, x180 = bits.Add64(x158, x163, uint64(fiatFqUint1(x178)))
        x181 := (uint64(fiatFqUint1(x180)) + uint64(fiatFqUint1(x159)))
        var x182 uint64
        var x183 uint64
        x182, x183 = bits.Sub64(x173, 0x8c46eb2100000001, uint64(0x0))
        var x184 uint64
        var x185 uint64
        x184, x185 = bits.Sub64(x175, 0x224698fc0994a8dd, uint64(fiatFqUint1(x183)))
        var x186 uint64
        var x187 uint64
        x186, x187 = bits.Sub64(x177, uint64(0x0), uint64(fiatFqUint1(x185)))
        var x188 uint64
        var x189 uint64
        x188, x189 = bits.Sub64(x179, 0x4000000000000000, uint64(fiatFqUint1(x187)))
        var x191 uint64
        _, x191 = bits.Sub64(x181, uint64(0x0), uint64(fiatFqUint1(x189)))
        var x192 uint64
        fiatFqCmovznzU64(&amp;x192, fiatFqUint1(x191), x182, x173)
        var x193 uint64
        fiatFqCmovznzU64(&amp;x193, fiatFqUint1(x191), x184, x175)
        var x194 uint64
        fiatFqCmovznzU64(&amp;x194, fiatFqUint1(x191), x186, x177)
        var x195 uint64
        fiatFqCmovznzU64(&amp;x195, fiatFqUint1(x191), x188, x179)
        out1[0] = x192
        out1[1] = x193
        out1[2] = x194
        out1[3] = x195
}</span>

// fiatFqAdd adds two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqAdd(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Add64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Add64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Add64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Add64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        var x10 uint64
        x9, x10 = bits.Sub64(x1, 0x8c46eb2100000001, uint64(0x0))
        var x11 uint64
        var x12 uint64
        x11, x12 = bits.Sub64(x3, 0x224698fc0994a8dd, uint64(fiatFqUint1(x10)))
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Sub64(x5, uint64(0x0), uint64(fiatFqUint1(x12)))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Sub64(x7, 0x4000000000000000, uint64(fiatFqUint1(x14)))
        var x18 uint64
        _, x18 = bits.Sub64(uint64(fiatFqUint1(x8)), uint64(0x0), uint64(fiatFqUint1(x16)))
        var x19 uint64
        fiatFqCmovznzU64(&amp;x19, fiatFqUint1(x18), x9, x1)
        var x20 uint64
        fiatFqCmovznzU64(&amp;x20, fiatFqUint1(x18), x11, x3)
        var x21 uint64
        fiatFqCmovznzU64(&amp;x21, fiatFqUint1(x18), x13, x5)
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, fiatFqUint1(x18), x15, x7)
        out1[0] = x19
        out1[1] = x20
        out1[2] = x21
        out1[3] = x22
}</span>

// fiatFqSub subtracts two field elements in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
//   0  eval arg2 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
//   0  eval out1 &lt; m
//
func fiatFqSub(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement, arg2 *fiatFqMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(arg1[0], arg2[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(arg1[1], arg2[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(arg1[2], arg2[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(arg1[3], arg2[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0x8c46eb2100000001), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0x224698fc0994a8dd), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, uint64(0x0), uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0x4000000000000000), uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqOpp negates a field element in the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
//   0  eval out1 &lt; m
//
func fiatFqOpp(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        var x1 uint64
        var x2 uint64
        x1, x2 = bits.Sub64(uint64(0x0), arg1[0], uint64(0x0))
        var x3 uint64
        var x4 uint64
        x3, x4 = bits.Sub64(uint64(0x0), arg1[1], uint64(fiatFqUint1(x2)))
        var x5 uint64
        var x6 uint64
        x5, x6 = bits.Sub64(uint64(0x0), arg1[2], uint64(fiatFqUint1(x4)))
        var x7 uint64
        var x8 uint64
        x7, x8 = bits.Sub64(uint64(0x0), arg1[3], uint64(fiatFqUint1(x6)))
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, fiatFqUint1(x8), uint64(0x0), 0xffffffffffffffff)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x1, (x9 &amp; 0x8c46eb2100000001), uint64(0x0))
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(x3, (x9 &amp; 0x224698fc0994a8dd), uint64(fiatFqUint1(x11)))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(x5, uint64(0x0), uint64(fiatFqUint1(x13)))
        var x16 uint64
        x16, _ = bits.Add64(x7, (x9 &amp; 0x4000000000000000), uint64(fiatFqUint1(x15)))
        out1[0] = x10
        out1[1] = x12
        out1[2] = x14
        out1[3] = x16
}</span>

// fiatFqFromMontgomery translates a field element out of the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = (eval arg1 * ((2^64) mod m)^4) mod m
//   0  eval out1 &lt; m
//
func fiatFqFromMontgomery(out1 *fiatFqNonMontgomeryDomainFieldElement, arg1 *fiatFqMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[0]
        var x2 uint64
        _, x2 = bits.Mul64(x1, 0x8c46eb20ffffffff)
        var x4 uint64
        var x5 uint64
        x5, x4 = bits.Mul64(x2, 0x4000000000000000)
        var x6 uint64
        var x7 uint64
        x7, x6 = bits.Mul64(x2, 0x224698fc0994a8dd)
        var x8 uint64
        var x9 uint64
        x9, x8 = bits.Mul64(x2, 0x8c46eb2100000001)
        var x10 uint64
        var x11 uint64
        x10, x11 = bits.Add64(x9, x6, uint64(0x0))
        var x13 uint64
        _, x13 = bits.Add64(x1, x8, uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), x10, uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(x14, arg1[1], uint64(0x0))
        var x18 uint64
        _, x18 = bits.Mul64(x16, 0x8c46eb20ffffffff)
        var x20 uint64
        var x21 uint64
        x21, x20 = bits.Mul64(x18, 0x4000000000000000)
        var x22 uint64
        var x23 uint64
        x23, x22 = bits.Mul64(x18, 0x224698fc0994a8dd)
        var x24 uint64
        var x25 uint64
        x25, x24 = bits.Mul64(x18, 0x8c46eb2100000001)
        var x26 uint64
        var x27 uint64
        x26, x27 = bits.Add64(x25, x22, uint64(0x0))
        var x29 uint64
        _, x29 = bits.Add64(x16, x24, uint64(0x0))
        var x30 uint64
        var x31 uint64
        x30, x31 = bits.Add64((uint64(fiatFqUint1(x17)) + (uint64(fiatFqUint1(x15)) + (uint64(fiatFqUint1(x11)) + x7))), x26, uint64(fiatFqUint1(x29)))
        var x32 uint64
        var x33 uint64
        x32, x33 = bits.Add64(x4, (uint64(fiatFqUint1(x27)) + x23), uint64(fiatFqUint1(x31)))
        var x34 uint64
        var x35 uint64
        x34, x35 = bits.Add64(x5, x20, uint64(fiatFqUint1(x33)))
        var x36 uint64
        var x37 uint64
        x36, x37 = bits.Add64(x30, arg1[2], uint64(0x0))
        var x38 uint64
        var x39 uint64
        x38, x39 = bits.Add64(x32, uint64(0x0), uint64(fiatFqUint1(x37)))
        var x40 uint64
        var x41 uint64
        x40, x41 = bits.Add64(x34, uint64(0x0), uint64(fiatFqUint1(x39)))
        var x42 uint64
        _, x42 = bits.Mul64(x36, 0x8c46eb20ffffffff)
        var x44 uint64
        var x45 uint64
        x45, x44 = bits.Mul64(x42, 0x4000000000000000)
        var x46 uint64
        var x47 uint64
        x47, x46 = bits.Mul64(x42, 0x224698fc0994a8dd)
        var x48 uint64
        var x49 uint64
        x49, x48 = bits.Mul64(x42, 0x8c46eb2100000001)
        var x50 uint64
        var x51 uint64
        x50, x51 = bits.Add64(x49, x46, uint64(0x0))
        var x53 uint64
        _, x53 = bits.Add64(x36, x48, uint64(0x0))
        var x54 uint64
        var x55 uint64
        x54, x55 = bits.Add64(x38, x50, uint64(fiatFqUint1(x53)))
        var x56 uint64
        var x57 uint64
        x56, x57 = bits.Add64(x40, (uint64(fiatFqUint1(x51)) + x47), uint64(fiatFqUint1(x55)))
        var x58 uint64
        var x59 uint64
        x58, x59 = bits.Add64((uint64(fiatFqUint1(x41)) + (uint64(fiatFqUint1(x35)) + x21)), x44, uint64(fiatFqUint1(x57)))
        var x60 uint64
        var x61 uint64
        x60, x61 = bits.Add64(x54, arg1[3], uint64(0x0))
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x56, uint64(0x0), uint64(fiatFqUint1(x61)))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x58, uint64(0x0), uint64(fiatFqUint1(x63)))
        var x66 uint64
        _, x66 = bits.Mul64(x60, 0x8c46eb20ffffffff)
        var x68 uint64
        var x69 uint64
        x69, x68 = bits.Mul64(x66, 0x4000000000000000)
        var x70 uint64
        var x71 uint64
        x71, x70 = bits.Mul64(x66, 0x224698fc0994a8dd)
        var x72 uint64
        var x73 uint64
        x73, x72 = bits.Mul64(x66, 0x8c46eb2100000001)
        var x74 uint64
        var x75 uint64
        x74, x75 = bits.Add64(x73, x70, uint64(0x0))
        var x77 uint64
        _, x77 = bits.Add64(x60, x72, uint64(0x0))
        var x78 uint64
        var x79 uint64
        x78, x79 = bits.Add64(x62, x74, uint64(fiatFqUint1(x77)))
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x64, (uint64(fiatFqUint1(x75)) + x71), uint64(fiatFqUint1(x79)))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64((uint64(fiatFqUint1(x65)) + (uint64(fiatFqUint1(x59)) + x45)), x68, uint64(fiatFqUint1(x81)))
        x84 := (uint64(fiatFqUint1(x83)) + x69)
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Sub64(x78, 0x8c46eb2100000001, uint64(0x0))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Sub64(x80, 0x224698fc0994a8dd, uint64(fiatFqUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Sub64(x82, uint64(0x0), uint64(fiatFqUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Sub64(x84, 0x4000000000000000, uint64(fiatFqUint1(x90)))
        var x94 uint64
        _, x94 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFqUint1(x92)))
        var x95 uint64
        fiatFqCmovznzU64(&amp;x95, fiatFqUint1(x94), x85, x78)
        var x96 uint64
        fiatFqCmovznzU64(&amp;x96, fiatFqUint1(x94), x87, x80)
        var x97 uint64
        fiatFqCmovznzU64(&amp;x97, fiatFqUint1(x94), x89, x82)
        var x98 uint64
        fiatFqCmovznzU64(&amp;x98, fiatFqUint1(x94), x91, x84)
        out1[0] = x95
        out1[1] = x96
        out1[2] = x97
        out1[3] = x98
}</span>

// fiatFqToMontgomery translates a field element into the Montgomery domain.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   eval (from_montgomery out1) mod m = eval arg1 mod m
//   0  eval out1 &lt; m
//
func fiatFqToMontgomery(out1 *fiatFqMontgomeryDomainFieldElement, arg1 *fiatFqNonMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        x1 := arg1[1]
        x2 := arg1[2]
        x3 := arg1[3]
        x4 := arg1[0]
        var x5 uint64
        var x6 uint64
        x6, x5 = bits.Mul64(x4, 0x96d41af7ccfdaa9)
        var x7 uint64
        var x8 uint64
        x8, x7 = bits.Mul64(x4, 0x7fae231004ccf590)
        var x9 uint64
        var x10 uint64
        x10, x9 = bits.Mul64(x4, 0x67bb433d891a16e3)
        var x11 uint64
        var x12 uint64
        x12, x11 = bits.Mul64(x4, 0xfc9678ff0000000f)
        var x13 uint64
        var x14 uint64
        x13, x14 = bits.Add64(x12, x9, uint64(0x0))
        var x15 uint64
        var x16 uint64
        x15, x16 = bits.Add64(x10, x7, uint64(fiatFqUint1(x14)))
        var x17 uint64
        var x18 uint64
        x17, x18 = bits.Add64(x8, x5, uint64(fiatFqUint1(x16)))
        var x19 uint64
        _, x19 = bits.Mul64(x11, 0x8c46eb20ffffffff)
        var x21 uint64
        var x22 uint64
        x22, x21 = bits.Mul64(x19, 0x4000000000000000)
        var x23 uint64
        var x24 uint64
        x24, x23 = bits.Mul64(x19, 0x224698fc0994a8dd)
        var x25 uint64
        var x26 uint64
        x26, x25 = bits.Mul64(x19, 0x8c46eb2100000001)
        var x27 uint64
        var x28 uint64
        x27, x28 = bits.Add64(x26, x23, uint64(0x0))
        var x30 uint64
        _, x30 = bits.Add64(x11, x25, uint64(0x0))
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x13, x27, uint64(fiatFqUint1(x30)))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x15, (uint64(fiatFqUint1(x28)) + x24), uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x17, x21, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x38, x37 = bits.Mul64(x1, 0x96d41af7ccfdaa9)
        var x39 uint64
        var x40 uint64
        x40, x39 = bits.Mul64(x1, 0x7fae231004ccf590)
        var x41 uint64
        var x42 uint64
        x42, x41 = bits.Mul64(x1, 0x67bb433d891a16e3)
        var x43 uint64
        var x44 uint64
        x44, x43 = bits.Mul64(x1, 0xfc9678ff0000000f)
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Add64(x44, x41, uint64(0x0))
        var x47 uint64
        var x48 uint64
        x47, x48 = bits.Add64(x42, x39, uint64(fiatFqUint1(x46)))
        var x49 uint64
        var x50 uint64
        x49, x50 = bits.Add64(x40, x37, uint64(fiatFqUint1(x48)))
        var x51 uint64
        var x52 uint64
        x51, x52 = bits.Add64(x31, x43, uint64(0x0))
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Add64(x33, x45, uint64(fiatFqUint1(x52)))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Add64(x35, x47, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Add64(((uint64(fiatFqUint1(x36)) + (uint64(fiatFqUint1(x18)) + x6)) + x22), x49, uint64(fiatFqUint1(x56)))
        var x59 uint64
        _, x59 = bits.Mul64(x51, 0x8c46eb20ffffffff)
        var x61 uint64
        var x62 uint64
        x62, x61 = bits.Mul64(x59, 0x4000000000000000)
        var x63 uint64
        var x64 uint64
        x64, x63 = bits.Mul64(x59, 0x224698fc0994a8dd)
        var x65 uint64
        var x66 uint64
        x66, x65 = bits.Mul64(x59, 0x8c46eb2100000001)
        var x67 uint64
        var x68 uint64
        x67, x68 = bits.Add64(x66, x63, uint64(0x0))
        var x70 uint64
        _, x70 = bits.Add64(x51, x65, uint64(0x0))
        var x71 uint64
        var x72 uint64
        x71, x72 = bits.Add64(x53, x67, uint64(fiatFqUint1(x70)))
        var x73 uint64
        var x74 uint64
        x73, x74 = bits.Add64(x55, (uint64(fiatFqUint1(x68)) + x64), uint64(fiatFqUint1(x72)))
        var x75 uint64
        var x76 uint64
        x75, x76 = bits.Add64(x57, x61, uint64(fiatFqUint1(x74)))
        var x77 uint64
        var x78 uint64
        x78, x77 = bits.Mul64(x2, 0x96d41af7ccfdaa9)
        var x79 uint64
        var x80 uint64
        x80, x79 = bits.Mul64(x2, 0x7fae231004ccf590)
        var x81 uint64
        var x82 uint64
        x82, x81 = bits.Mul64(x2, 0x67bb433d891a16e3)
        var x83 uint64
        var x84 uint64
        x84, x83 = bits.Mul64(x2, 0xfc9678ff0000000f)
        var x85 uint64
        var x86 uint64
        x85, x86 = bits.Add64(x84, x81, uint64(0x0))
        var x87 uint64
        var x88 uint64
        x87, x88 = bits.Add64(x82, x79, uint64(fiatFqUint1(x86)))
        var x89 uint64
        var x90 uint64
        x89, x90 = bits.Add64(x80, x77, uint64(fiatFqUint1(x88)))
        var x91 uint64
        var x92 uint64
        x91, x92 = bits.Add64(x71, x83, uint64(0x0))
        var x93 uint64
        var x94 uint64
        x93, x94 = bits.Add64(x73, x85, uint64(fiatFqUint1(x92)))
        var x95 uint64
        var x96 uint64
        x95, x96 = bits.Add64(x75, x87, uint64(fiatFqUint1(x94)))
        var x97 uint64
        var x98 uint64
        x97, x98 = bits.Add64(((uint64(fiatFqUint1(x76)) + (uint64(fiatFqUint1(x58)) + (uint64(fiatFqUint1(x50)) + x38))) + x62), x89, uint64(fiatFqUint1(x96)))
        var x99 uint64
        _, x99 = bits.Mul64(x91, 0x8c46eb20ffffffff)
        var x101 uint64
        var x102 uint64
        x102, x101 = bits.Mul64(x99, 0x4000000000000000)
        var x103 uint64
        var x104 uint64
        x104, x103 = bits.Mul64(x99, 0x224698fc0994a8dd)
        var x105 uint64
        var x106 uint64
        x106, x105 = bits.Mul64(x99, 0x8c46eb2100000001)
        var x107 uint64
        var x108 uint64
        x107, x108 = bits.Add64(x106, x103, uint64(0x0))
        var x110 uint64
        _, x110 = bits.Add64(x91, x105, uint64(0x0))
        var x111 uint64
        var x112 uint64
        x111, x112 = bits.Add64(x93, x107, uint64(fiatFqUint1(x110)))
        var x113 uint64
        var x114 uint64
        x113, x114 = bits.Add64(x95, (uint64(fiatFqUint1(x108)) + x104), uint64(fiatFqUint1(x112)))
        var x115 uint64
        var x116 uint64
        x115, x116 = bits.Add64(x97, x101, uint64(fiatFqUint1(x114)))
        var x117 uint64
        var x118 uint64
        x118, x117 = bits.Mul64(x3, 0x96d41af7ccfdaa9)
        var x119 uint64
        var x120 uint64
        x120, x119 = bits.Mul64(x3, 0x7fae231004ccf590)
        var x121 uint64
        var x122 uint64
        x122, x121 = bits.Mul64(x3, 0x67bb433d891a16e3)
        var x123 uint64
        var x124 uint64
        x124, x123 = bits.Mul64(x3, 0xfc9678ff0000000f)
        var x125 uint64
        var x126 uint64
        x125, x126 = bits.Add64(x124, x121, uint64(0x0))
        var x127 uint64
        var x128 uint64
        x127, x128 = bits.Add64(x122, x119, uint64(fiatFqUint1(x126)))
        var x129 uint64
        var x130 uint64
        x129, x130 = bits.Add64(x120, x117, uint64(fiatFqUint1(x128)))
        var x131 uint64
        var x132 uint64
        x131, x132 = bits.Add64(x111, x123, uint64(0x0))
        var x133 uint64
        var x134 uint64
        x133, x134 = bits.Add64(x113, x125, uint64(fiatFqUint1(x132)))
        var x135 uint64
        var x136 uint64
        x135, x136 = bits.Add64(x115, x127, uint64(fiatFqUint1(x134)))
        var x137 uint64
        var x138 uint64
        x137, x138 = bits.Add64(((uint64(fiatFqUint1(x116)) + (uint64(fiatFqUint1(x98)) + (uint64(fiatFqUint1(x90)) + x78))) + x102), x129, uint64(fiatFqUint1(x136)))
        var x139 uint64
        _, x139 = bits.Mul64(x131, 0x8c46eb20ffffffff)
        var x141 uint64
        var x142 uint64
        x142, x141 = bits.Mul64(x139, 0x4000000000000000)
        var x143 uint64
        var x144 uint64
        x144, x143 = bits.Mul64(x139, 0x224698fc0994a8dd)
        var x145 uint64
        var x146 uint64
        x146, x145 = bits.Mul64(x139, 0x8c46eb2100000001)
        var x147 uint64
        var x148 uint64
        x147, x148 = bits.Add64(x146, x143, uint64(0x0))
        var x150 uint64
        _, x150 = bits.Add64(x131, x145, uint64(0x0))
        var x151 uint64
        var x152 uint64
        x151, x152 = bits.Add64(x133, x147, uint64(fiatFqUint1(x150)))
        var x153 uint64
        var x154 uint64
        x153, x154 = bits.Add64(x135, (uint64(fiatFqUint1(x148)) + x144), uint64(fiatFqUint1(x152)))
        var x155 uint64
        var x156 uint64
        x155, x156 = bits.Add64(x137, x141, uint64(fiatFqUint1(x154)))
        x157 := ((uint64(fiatFqUint1(x156)) + (uint64(fiatFqUint1(x138)) + (uint64(fiatFqUint1(x130)) + x118))) + x142)
        var x158 uint64
        var x159 uint64
        x158, x159 = bits.Sub64(x151, 0x8c46eb2100000001, uint64(0x0))
        var x160 uint64
        var x161 uint64
        x160, x161 = bits.Sub64(x153, 0x224698fc0994a8dd, uint64(fiatFqUint1(x159)))
        var x162 uint64
        var x163 uint64
        x162, x163 = bits.Sub64(x155, uint64(0x0), uint64(fiatFqUint1(x161)))
        var x164 uint64
        var x165 uint64
        x164, x165 = bits.Sub64(x157, 0x4000000000000000, uint64(fiatFqUint1(x163)))
        var x167 uint64
        _, x167 = bits.Sub64(uint64(0x0), uint64(0x0), uint64(fiatFqUint1(x165)))
        var x168 uint64
        fiatFqCmovznzU64(&amp;x168, fiatFqUint1(x167), x158, x151)
        var x169 uint64
        fiatFqCmovznzU64(&amp;x169, fiatFqUint1(x167), x160, x153)
        var x170 uint64
        fiatFqCmovznzU64(&amp;x170, fiatFqUint1(x167), x162, x155)
        var x171 uint64
        fiatFqCmovznzU64(&amp;x171, fiatFqUint1(x167), x164, x157)
        out1[0] = x168
        out1[1] = x169
        out1[2] = x170
        out1[3] = x171
}</span>

// fiatFqNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = 0  eval (from_montgomery arg1) mod m = 0
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
func fiatFqNonzero(out1 *uint64, arg1 *[4]uint64) <span class="cov8" title="1">{
        x1 := (arg1[0] | (arg1[1] | (arg1[2] | arg1[3])))
        *out1 = x1
}</span>

// fiatFqSelectznz is a multi-limb conditional select.
//
// Postconditions:
//   out1 = (if arg1 = 0 then arg2 else arg3)
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0x1]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqSelectznz(out1 *[4]uint64, arg1 fiatFqUint1, arg2 *[4]uint64, arg3 *[4]uint64) <span class="cov8" title="1">{
        var x1 uint64
        fiatFqCmovznzU64(&amp;x1, arg1, arg2[0], arg3[0])
        var x2 uint64
        fiatFqCmovznzU64(&amp;x2, arg1, arg2[1], arg3[1])
        var x3 uint64
        fiatFqCmovznzU64(&amp;x3, arg1, arg2[2], arg3[2])
        var x4 uint64
        fiatFqCmovznzU64(&amp;x4, arg1, arg2[3], arg3[3])
        out1[0] = x1
        out1[1] = x2
        out1[2] = x3
        out1[3] = x4
}</span>

// fiatFqToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
//
// Preconditions:
//   0  eval arg1 &lt; m
// Postconditions:
//   out1 = map ( x, ((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)) [0..31]
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x7fffffffffffffff]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x7f]]
func fiatFqToBytes(out1 *[32]uint8, arg1 *[4]uint64) <span class="cov8" title="1">{
        x1 := arg1[3]
        x2 := arg1[2]
        x3 := arg1[1]
        x4 := arg1[0]
        x5 := (uint8(x4) &amp; 0xff)
        x6 := (x4 &gt;&gt; 8)
        x7 := (uint8(x6) &amp; 0xff)
        x8 := (x6 &gt;&gt; 8)
        x9 := (uint8(x8) &amp; 0xff)
        x10 := (x8 &gt;&gt; 8)
        x11 := (uint8(x10) &amp; 0xff)
        x12 := (x10 &gt;&gt; 8)
        x13 := (uint8(x12) &amp; 0xff)
        x14 := (x12 &gt;&gt; 8)
        x15 := (uint8(x14) &amp; 0xff)
        x16 := (x14 &gt;&gt; 8)
        x17 := (uint8(x16) &amp; 0xff)
        x18 := uint8((x16 &gt;&gt; 8))
        x19 := (uint8(x3) &amp; 0xff)
        x20 := (x3 &gt;&gt; 8)
        x21 := (uint8(x20) &amp; 0xff)
        x22 := (x20 &gt;&gt; 8)
        x23 := (uint8(x22) &amp; 0xff)
        x24 := (x22 &gt;&gt; 8)
        x25 := (uint8(x24) &amp; 0xff)
        x26 := (x24 &gt;&gt; 8)
        x27 := (uint8(x26) &amp; 0xff)
        x28 := (x26 &gt;&gt; 8)
        x29 := (uint8(x28) &amp; 0xff)
        x30 := (x28 &gt;&gt; 8)
        x31 := (uint8(x30) &amp; 0xff)
        x32 := uint8((x30 &gt;&gt; 8))
        x33 := (uint8(x2) &amp; 0xff)
        x34 := (x2 &gt;&gt; 8)
        x35 := (uint8(x34) &amp; 0xff)
        x36 := (x34 &gt;&gt; 8)
        x37 := (uint8(x36) &amp; 0xff)
        x38 := (x36 &gt;&gt; 8)
        x39 := (uint8(x38) &amp; 0xff)
        x40 := (x38 &gt;&gt; 8)
        x41 := (uint8(x40) &amp; 0xff)
        x42 := (x40 &gt;&gt; 8)
        x43 := (uint8(x42) &amp; 0xff)
        x44 := (x42 &gt;&gt; 8)
        x45 := (uint8(x44) &amp; 0xff)
        x46 := uint8((x44 &gt;&gt; 8))
        x47 := (uint8(x1) &amp; 0xff)
        x48 := (x1 &gt;&gt; 8)
        x49 := (uint8(x48) &amp; 0xff)
        x50 := (x48 &gt;&gt; 8)
        x51 := (uint8(x50) &amp; 0xff)
        x52 := (x50 &gt;&gt; 8)
        x53 := (uint8(x52) &amp; 0xff)
        x54 := (x52 &gt;&gt; 8)
        x55 := (uint8(x54) &amp; 0xff)
        x56 := (x54 &gt;&gt; 8)
        x57 := (uint8(x56) &amp; 0xff)
        x58 := (x56 &gt;&gt; 8)
        x59 := (uint8(x58) &amp; 0xff)
        x60 := uint8((x58 &gt;&gt; 8))
        out1[0] = x5
        out1[1] = x7
        out1[2] = x9
        out1[3] = x11
        out1[4] = x13
        out1[5] = x15
        out1[6] = x17
        out1[7] = x18
        out1[8] = x19
        out1[9] = x21
        out1[10] = x23
        out1[11] = x25
        out1[12] = x27
        out1[13] = x29
        out1[14] = x31
        out1[15] = x32
        out1[16] = x33
        out1[17] = x35
        out1[18] = x37
        out1[19] = x39
        out1[20] = x41
        out1[21] = x43
        out1[22] = x45
        out1[23] = x46
        out1[24] = x47
        out1[25] = x49
        out1[26] = x51
        out1[27] = x53
        out1[28] = x55
        out1[29] = x57
        out1[30] = x59
        out1[31] = x60
}</span>

// fiatFqFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
//
// Preconditions:
//   0  bytes_eval arg1 &lt; m
// Postconditions:
//   eval out1 mod m = bytes_eval arg1 mod m
//   0  eval out1 &lt; m
//
// Input Bounds:
//   arg1: [[0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0xff], [0x0 ~&gt; 0x7f]]
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0x7fffffffffffffff]]
func fiatFqFromBytes(out1 *[4]uint64, arg1 *[32]uint8) <span class="cov8" title="1">{
        x1 := (uint64(arg1[31]) &lt;&lt; 56)
        x2 := (uint64(arg1[30]) &lt;&lt; 48)
        x3 := (uint64(arg1[29]) &lt;&lt; 40)
        x4 := (uint64(arg1[28]) &lt;&lt; 32)
        x5 := (uint64(arg1[27]) &lt;&lt; 24)
        x6 := (uint64(arg1[26]) &lt;&lt; 16)
        x7 := (uint64(arg1[25]) &lt;&lt; 8)
        x8 := arg1[24]
        x9 := (uint64(arg1[23]) &lt;&lt; 56)
        x10 := (uint64(arg1[22]) &lt;&lt; 48)
        x11 := (uint64(arg1[21]) &lt;&lt; 40)
        x12 := (uint64(arg1[20]) &lt;&lt; 32)
        x13 := (uint64(arg1[19]) &lt;&lt; 24)
        x14 := (uint64(arg1[18]) &lt;&lt; 16)
        x15 := (uint64(arg1[17]) &lt;&lt; 8)
        x16 := arg1[16]
        x17 := (uint64(arg1[15]) &lt;&lt; 56)
        x18 := (uint64(arg1[14]) &lt;&lt; 48)
        x19 := (uint64(arg1[13]) &lt;&lt; 40)
        x20 := (uint64(arg1[12]) &lt;&lt; 32)
        x21 := (uint64(arg1[11]) &lt;&lt; 24)
        x22 := (uint64(arg1[10]) &lt;&lt; 16)
        x23 := (uint64(arg1[9]) &lt;&lt; 8)
        x24 := arg1[8]
        x25 := (uint64(arg1[7]) &lt;&lt; 56)
        x26 := (uint64(arg1[6]) &lt;&lt; 48)
        x27 := (uint64(arg1[5]) &lt;&lt; 40)
        x28 := (uint64(arg1[4]) &lt;&lt; 32)
        x29 := (uint64(arg1[3]) &lt;&lt; 24)
        x30 := (uint64(arg1[2]) &lt;&lt; 16)
        x31 := (uint64(arg1[1]) &lt;&lt; 8)
        x32 := arg1[0]
        x33 := (x31 + uint64(x32))
        x34 := (x30 + x33)
        x35 := (x29 + x34)
        x36 := (x28 + x35)
        x37 := (x27 + x36)
        x38 := (x26 + x37)
        x39 := (x25 + x38)
        x40 := (x23 + uint64(x24))
        x41 := (x22 + x40)
        x42 := (x21 + x41)
        x43 := (x20 + x42)
        x44 := (x19 + x43)
        x45 := (x18 + x44)
        x46 := (x17 + x45)
        x47 := (x15 + uint64(x16))
        x48 := (x14 + x47)
        x49 := (x13 + x48)
        x50 := (x12 + x49)
        x51 := (x11 + x50)
        x52 := (x10 + x51)
        x53 := (x9 + x52)
        x54 := (x7 + uint64(x8))
        x55 := (x6 + x54)
        x56 := (x5 + x55)
        x57 := (x4 + x56)
        x58 := (x3 + x57)
        x59 := (x2 + x58)
        x60 := (x1 + x59)
        out1[0] = x39
        out1[1] = x46
        out1[2] = x53
        out1[3] = x60
}</span>

// fiatFqSetOne returns the field element one in the Montgomery domain.
//
// Postconditions:
//   eval (from_montgomery out1) mod m = 1 mod m
//   0  eval out1 &lt; m
//
func fiatFqSetOne(out1 *fiatFqMontgomeryDomainFieldElement) <span class="cov8" title="1">{
        out1[0] = 0x5b2b3e9cfffffffd
        out1[1] = 0x992c350be3420567
        out1[2] = 0xffffffffffffffff
        out1[3] = 0x3fffffffffffffff
}</span>

// fiatFqMsat returns the saturated representation of the prime modulus.
//
// Postconditions:
//   twos_complement_eval out1 = m
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqMsat(out1 *[5]uint64) <span class="cov8" title="1">{
        out1[0] = 0x8c46eb2100000001
        out1[1] = 0x224698fc0994a8dd
        out1[2] = uint64(0x0)
        out1[3] = 0x4000000000000000
        out1[4] = uint64(0x0)
}</span>

// fiatFqDivstepPrecomp returns the precomputed value for Bernstein-Yang-inversion (in montgomery form).
//
// Postconditions:
//   eval (from_montgomery out1) = (m - 1) / 2^(if log2 m + 1 &lt; 46 then (49 * (log2 m + 1) + 80) / 17 else (49 * (log2 m + 1) + 57) / 17)
//   0  eval out1 &lt; m
//
// Output Bounds:
//   out1: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstepPrecomp(out1 *[4]uint64) <span class="cov8" title="1">{
        out1[0] = 0xe6083b32dccd2992
        out1[1] = 0x624453584f3bdab6
        out1[2] = 0xba6367a9c5d2c08e
        out1[3] = 0x1468dbacb19ab3af
}</span>

// fiatFqDivstep computes a divstep.
//
// Preconditions:
//   0  eval arg4 &lt; m
//   0  eval arg5 &lt; m
// Postconditions:
//   out1 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then 1 - arg1 else 1 + arg1)
//   twos_complement_eval out2 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then twos_complement_eval arg3 else twos_complement_eval arg2)
//   twos_complement_eval out3 = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (twos_complement_eval arg3 - twos_complement_eval arg2) / 2 else (twos_complement_eval arg3 + (twos_complement_eval arg3 mod 2) * twos_complement_eval arg2) / 2)
//   eval (from_montgomery out4) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (2 * eval (from_montgomery arg5)) mod m else (2 * eval (from_montgomery arg4)) mod m)
//   eval (from_montgomery out5) mod m = (if 0 &lt; arg1  (twos_complement_eval arg3) is odd then (eval (from_montgomery arg4) - eval (from_montgomery arg4)) mod m else (eval (from_montgomery arg5) + (twos_complement_eval arg3 mod 2) * eval (from_montgomery arg4)) mod m)
//   0  eval out5 &lt; m
//   0  eval out5 &lt; m
//   0  eval out2 &lt; m
//   0  eval out3 &lt; m
//
// Input Bounds:
//   arg1: [0x0 ~&gt; 0xffffffffffffffff]
//   arg2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   arg5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
// Output Bounds:
//   out1: [0x0 ~&gt; 0xffffffffffffffff]
//   out2: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out3: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out4: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
//   out5: [[0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff], [0x0 ~&gt; 0xffffffffffffffff]]
func fiatFqDivstep(out1 *uint64, out2 *[5]uint64, out3 *[5]uint64, out4 *[4]uint64, out5 *[4]uint64, arg1 uint64, arg2 *[5]uint64, arg3 *[5]uint64, arg4 *[4]uint64, arg5 *[4]uint64) <span class="cov8" title="1">{
        var x1 uint64
        x1, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        x3 := (fiatFqUint1((x1 &gt;&gt; 63)) &amp; (fiatFqUint1(arg3[0]) &amp; 0x1))
        var x4 uint64
        x4, _ = bits.Add64((^arg1), uint64(0x1), uint64(0x0))
        var x6 uint64
        fiatFqCmovznzU64(&amp;x6, x3, arg1, x4)
        var x7 uint64
        fiatFqCmovznzU64(&amp;x7, x3, arg2[0], arg3[0])
        var x8 uint64
        fiatFqCmovznzU64(&amp;x8, x3, arg2[1], arg3[1])
        var x9 uint64
        fiatFqCmovznzU64(&amp;x9, x3, arg2[2], arg3[2])
        var x10 uint64
        fiatFqCmovznzU64(&amp;x10, x3, arg2[3], arg3[3])
        var x11 uint64
        fiatFqCmovznzU64(&amp;x11, x3, arg2[4], arg3[4])
        var x12 uint64
        var x13 uint64
        x12, x13 = bits.Add64(uint64(0x1), (^arg2[0]), uint64(0x0))
        var x14 uint64
        var x15 uint64
        x14, x15 = bits.Add64(uint64(0x0), (^arg2[1]), uint64(fiatFqUint1(x13)))
        var x16 uint64
        var x17 uint64
        x16, x17 = bits.Add64(uint64(0x0), (^arg2[2]), uint64(fiatFqUint1(x15)))
        var x18 uint64
        var x19 uint64
        x18, x19 = bits.Add64(uint64(0x0), (^arg2[3]), uint64(fiatFqUint1(x17)))
        var x20 uint64
        x20, _ = bits.Add64(uint64(0x0), (^arg2[4]), uint64(fiatFqUint1(x19)))
        var x22 uint64
        fiatFqCmovznzU64(&amp;x22, x3, arg3[0], x12)
        var x23 uint64
        fiatFqCmovznzU64(&amp;x23, x3, arg3[1], x14)
        var x24 uint64
        fiatFqCmovznzU64(&amp;x24, x3, arg3[2], x16)
        var x25 uint64
        fiatFqCmovznzU64(&amp;x25, x3, arg3[3], x18)
        var x26 uint64
        fiatFqCmovznzU64(&amp;x26, x3, arg3[4], x20)
        var x27 uint64
        fiatFqCmovznzU64(&amp;x27, x3, arg4[0], arg5[0])
        var x28 uint64
        fiatFqCmovznzU64(&amp;x28, x3, arg4[1], arg5[1])
        var x29 uint64
        fiatFqCmovznzU64(&amp;x29, x3, arg4[2], arg5[2])
        var x30 uint64
        fiatFqCmovznzU64(&amp;x30, x3, arg4[3], arg5[3])
        var x31 uint64
        var x32 uint64
        x31, x32 = bits.Add64(x27, x27, uint64(0x0))
        var x33 uint64
        var x34 uint64
        x33, x34 = bits.Add64(x28, x28, uint64(fiatFqUint1(x32)))
        var x35 uint64
        var x36 uint64
        x35, x36 = bits.Add64(x29, x29, uint64(fiatFqUint1(x34)))
        var x37 uint64
        var x38 uint64
        x37, x38 = bits.Add64(x30, x30, uint64(fiatFqUint1(x36)))
        var x39 uint64
        var x40 uint64
        x39, x40 = bits.Sub64(x31, 0x8c46eb2100000001, uint64(0x0))
        var x41 uint64
        var x42 uint64
        x41, x42 = bits.Sub64(x33, 0x224698fc0994a8dd, uint64(fiatFqUint1(x40)))
        var x43 uint64
        var x44 uint64
        x43, x44 = bits.Sub64(x35, uint64(0x0), uint64(fiatFqUint1(x42)))
        var x45 uint64
        var x46 uint64
        x45, x46 = bits.Sub64(x37, 0x4000000000000000, uint64(fiatFqUint1(x44)))
        var x48 uint64
        _, x48 = bits.Sub64(uint64(fiatFqUint1(x38)), uint64(0x0), uint64(fiatFqUint1(x46)))
        x49 := arg4[3]
        x50 := arg4[2]
        x51 := arg4[1]
        x52 := arg4[0]
        var x53 uint64
        var x54 uint64
        x53, x54 = bits.Sub64(uint64(0x0), x52, uint64(0x0))
        var x55 uint64
        var x56 uint64
        x55, x56 = bits.Sub64(uint64(0x0), x51, uint64(fiatFqUint1(x54)))
        var x57 uint64
        var x58 uint64
        x57, x58 = bits.Sub64(uint64(0x0), x50, uint64(fiatFqUint1(x56)))
        var x59 uint64
        var x60 uint64
        x59, x60 = bits.Sub64(uint64(0x0), x49, uint64(fiatFqUint1(x58)))
        var x61 uint64
        fiatFqCmovznzU64(&amp;x61, fiatFqUint1(x60), uint64(0x0), 0xffffffffffffffff)
        var x62 uint64
        var x63 uint64
        x62, x63 = bits.Add64(x53, (x61 &amp; 0x8c46eb2100000001), uint64(0x0))
        var x64 uint64
        var x65 uint64
        x64, x65 = bits.Add64(x55, (x61 &amp; 0x224698fc0994a8dd), uint64(fiatFqUint1(x63)))
        var x66 uint64
        var x67 uint64
        x66, x67 = bits.Add64(x57, uint64(0x0), uint64(fiatFqUint1(x65)))
        var x68 uint64
        x68, _ = bits.Add64(x59, (x61 &amp; 0x4000000000000000), uint64(fiatFqUint1(x67)))
        var x70 uint64
        fiatFqCmovznzU64(&amp;x70, x3, arg5[0], x62)
        var x71 uint64
        fiatFqCmovznzU64(&amp;x71, x3, arg5[1], x64)
        var x72 uint64
        fiatFqCmovznzU64(&amp;x72, x3, arg5[2], x66)
        var x73 uint64
        fiatFqCmovznzU64(&amp;x73, x3, arg5[3], x68)
        x74 := (fiatFqUint1(x22) &amp; 0x1)
        var x75 uint64
        fiatFqCmovznzU64(&amp;x75, x74, uint64(0x0), x7)
        var x76 uint64
        fiatFqCmovznzU64(&amp;x76, x74, uint64(0x0), x8)
        var x77 uint64
        fiatFqCmovznzU64(&amp;x77, x74, uint64(0x0), x9)
        var x78 uint64
        fiatFqCmovznzU64(&amp;x78, x74, uint64(0x0), x10)
        var x79 uint64
        fiatFqCmovznzU64(&amp;x79, x74, uint64(0x0), x11)
        var x80 uint64
        var x81 uint64
        x80, x81 = bits.Add64(x22, x75, uint64(0x0))
        var x82 uint64
        var x83 uint64
        x82, x83 = bits.Add64(x23, x76, uint64(fiatFqUint1(x81)))
        var x84 uint64
        var x85 uint64
        x84, x85 = bits.Add64(x24, x77, uint64(fiatFqUint1(x83)))
        var x86 uint64
        var x87 uint64
        x86, x87 = bits.Add64(x25, x78, uint64(fiatFqUint1(x85)))
        var x88 uint64
        x88, _ = bits.Add64(x26, x79, uint64(fiatFqUint1(x87)))
        var x90 uint64
        fiatFqCmovznzU64(&amp;x90, x74, uint64(0x0), x27)
        var x91 uint64
        fiatFqCmovznzU64(&amp;x91, x74, uint64(0x0), x28)
        var x92 uint64
        fiatFqCmovznzU64(&amp;x92, x74, uint64(0x0), x29)
        var x93 uint64
        fiatFqCmovznzU64(&amp;x93, x74, uint64(0x0), x30)
        var x94 uint64
        var x95 uint64
        x94, x95 = bits.Add64(x70, x90, uint64(0x0))
        var x96 uint64
        var x97 uint64
        x96, x97 = bits.Add64(x71, x91, uint64(fiatFqUint1(x95)))
        var x98 uint64
        var x99 uint64
        x98, x99 = bits.Add64(x72, x92, uint64(fiatFqUint1(x97)))
        var x100 uint64
        var x101 uint64
        x100, x101 = bits.Add64(x73, x93, uint64(fiatFqUint1(x99)))
        var x102 uint64
        var x103 uint64
        x102, x103 = bits.Sub64(x94, 0x8c46eb2100000001, uint64(0x0))
        var x104 uint64
        var x105 uint64
        x104, x105 = bits.Sub64(x96, 0x224698fc0994a8dd, uint64(fiatFqUint1(x103)))
        var x106 uint64
        var x107 uint64
        x106, x107 = bits.Sub64(x98, uint64(0x0), uint64(fiatFqUint1(x105)))
        var x108 uint64
        var x109 uint64
        x108, x109 = bits.Sub64(x100, 0x4000000000000000, uint64(fiatFqUint1(x107)))
        var x111 uint64
        _, x111 = bits.Sub64(uint64(fiatFqUint1(x101)), uint64(0x0), uint64(fiatFqUint1(x109)))
        var x112 uint64
        x112, _ = bits.Add64(x6, uint64(0x1), uint64(0x0))
        x114 := ((x80 &gt;&gt; 1) | ((x82 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x115 := ((x82 &gt;&gt; 1) | ((x84 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x116 := ((x84 &gt;&gt; 1) | ((x86 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x117 := ((x86 &gt;&gt; 1) | ((x88 &lt;&lt; 63) &amp; 0xffffffffffffffff))
        x118 := ((x88 &amp; 0x8000000000000000) | (x88 &gt;&gt; 1))
        var x119 uint64
        fiatFqCmovznzU64(&amp;x119, fiatFqUint1(x48), x39, x31)
        var x120 uint64
        fiatFqCmovznzU64(&amp;x120, fiatFqUint1(x48), x41, x33)
        var x121 uint64
        fiatFqCmovznzU64(&amp;x121, fiatFqUint1(x48), x43, x35)
        var x122 uint64
        fiatFqCmovznzU64(&amp;x122, fiatFqUint1(x48), x45, x37)
        var x123 uint64
        fiatFqCmovznzU64(&amp;x123, fiatFqUint1(x111), x102, x94)
        var x124 uint64
        fiatFqCmovznzU64(&amp;x124, fiatFqUint1(x111), x104, x96)
        var x125 uint64
        fiatFqCmovznzU64(&amp;x125, fiatFqUint1(x111), x106, x98)
        var x126 uint64
        fiatFqCmovznzU64(&amp;x126, fiatFqUint1(x111), x108, x100)
        *out1 = x112
        out2[0] = x7
        out2[1] = x8
        out2[2] = x9
        out2[3] = x10
        out2[4] = x11
        out3[0] = x114
        out3[1] = x115
        out3[2] = x116
        out3[3] = x117
        out3[4] = x118
        out4[0] = x119
        out4[1] = x120
        out4[2] = x121
        out4[3] = x122
        out5[0] = x123
        out5[1] = x124
        out5[2] = x125
        out5[3] = x126
}</span>
</pre>
		
		<pre class="file" id="file115" style="display: none">//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "2^254 + 45560315531419706090280762371685220353" --type Fp --sqrt sqrt
//go:generate go run github.com/bronlabs/bron-crypto/tools/field-codegen --mode word-by-word-montgomery --modulus "2^254 + 45560315531506369815346746415080538113" --type Fq --sqrt sqrt
package impl

import (
        fieldsImpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl/fields"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func sqrt[FP fieldsImpl.FiniteFieldElementPtr[FP, F], F any](out, x, rootOfUnity *F, e uint64, progenitorExp []uint8) (ok ct.Bool) <span class="cov0" title="0">{
        return fieldsImpl.TonelliShanks[FP, F](out, x, rootOfUnity, e, progenitorExp)
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FpLimbs     = 4
        FpSatLimbs  = FpLimbs + 1
        FpBits      = 255
        FpBytes     = 8 * (((FpBits - 1) / 64) + 1)
        FpWideBytes = 2 * FpBytes
        FpDivSteps  = ((49 * FpBits) + 57) / 17
        FpE         = 32
)

var (
        FpProgenitorExp = [...]byte{0x76, 0x98, 0x96, 0xcc, 0x8d, 0x7c, 0xa6, 0x04, 0x7e, 0x4c, 0x23, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20}
        FpModulus       = [...]byte{0x01, 0x00, 0x00, 0x00, 0xed, 0x30, 0x2d, 0x99, 0x1b, 0xf9, 0x4c, 0x09, 0xfc, 0x98, 0x46, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40}
        FpRootOfUnity   Fp
)

func init() <span class="cov8" title="1">{
        FpRootOfUnity.MustSetHex("2bce74deac30ebda362120830561f81aea322bf2b7bb7584bdad6fabd87ea32f")
}</span>

type Fp struct {
        fiatFpMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fp) Set(v *Fp) <span class="cov8" title="1">{
        *f = *v
}</span>

func (f *Fp) SetZero() <span class="cov8" title="1">{
        *f = Fp{}
}</span>

func (f *Fp) SetOne() <span class="cov8" title="1">{
        fiatFpSetOne(&amp;f.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FpLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fp) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFpToMontgomery(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fp) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FpBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromBytes((*[FpLimbs]uint64)(&amp;nonMonty), (*[FpBytes]uint8)(data))
        fiatFpToMontgomery(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fp) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) &gt; FpWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var wideData [FpWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FpLimbs]uint64
        fiatFpFromBytes(&amp;d0, (*[FpBytes]uint8)(wideData[:FpBytes]))
        fiatFpFromBytes(&amp;d1, (*[FpBytes]uint8)(wideData[FpBytes:]))

        // d0*r2 + d1*r3
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d0), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d1), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&amp;d1), (*fiatFpNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&amp;d0), (*fiatFpMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fp) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fp) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FpBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fp) Select(choice ct.Choice, z, nz *Fp) <span class="cov8" title="1">{
        fiatFpSelectznz((*[FpLimbs]uint64)(&amp;f.fiatFpMontgomeryDomainFieldElement),fiatFpUint1(choice), (*[FpLimbs]uint64)(&amp;z.fiatFpMontgomeryDomainFieldElement), (*[FpLimbs]uint64)(&amp;nz.fiatFpMontgomeryDomainFieldElement))
}</span>

func (f *Fp) Add(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Double(x *Fp) <span class="cov0" title="0">{
        fiatFpAdd(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;x.fiatFpMontgomeryDomainFieldElement, &amp;x.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Sub(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpSub(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Neg(v *Fp) <span class="cov8" title="1">{
        fiatFpOpp(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;v.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Mul(lhs, rhs *Fp) <span class="cov8" title="1">{
        fiatFpMul(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;lhs.fiatFpMontgomeryDomainFieldElement, &amp;rhs.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Square(v *Fp) <span class="cov8" title="1">{
        fiatFpSquare(&amp;f.fiatFpMontgomeryDomainFieldElement, &amp;v.fiatFpMontgomeryDomainFieldElement)
}</span>

func (f *Fp) Inv(a *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var precomp, h, v, r, out4, out5 [FpLimbs]uint64
        var ff, g, out2, out3 [FpSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFpDivstepPrecomp(&amp;precomp)
        fiatFpFromMontgomery((*fiatFpNonMontgomeryDomainFieldElement)(g[:FpLimbs]), &amp;a.fiatFpMontgomeryDomainFieldElement)
        fiatFpMsat(&amp;ff)
        fiatFpSetOne((*fiatFpMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FpDivSteps-(FpDivSteps%2); i += 2 </span><span class="cov8" title="1">{
                fiatFpDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFpDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov8" title="1">if (FpDivSteps % 2) != 0 </span><span class="cov0" title="0">{ // compile time if - always true
                fiatFpDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov8" title="1">fiatFpOpp((*fiatFpMontgomeryDomainFieldElement)(&amp;h), (*fiatFpMontgomeryDomainFieldElement)(&amp;v))
        fiatFpSelectznz(&amp;v, fiatFpUint1(ff[FpLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFpMul(&amp;f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&amp;v), (*fiatFpMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFpNonzero(&amp;inverted, (*[FpLimbs]uint64)(&amp;f.fiatFpMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fp) Div(lhs, rhs *Fp) (ok ct.Bool) <span class="cov8" title="1">{
        var rhsInv Fp
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fp) Sqrt(x *Fp) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(sqrt(f, x, &amp;FpRootOfUnity, FpE, FpProgenitorExp[:]))
}</span>

func (f *Fp) IsNonZero() ct.Bool <span class="cov8" title="1">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFpNonzero(&amp;nonZero, (*[FpLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fp) IsZero() ct.Bool <span class="cov8" title="1">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fp) IsOne() ct.Bool <span class="cov8" title="1">{
        var one Fp
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fp) Equal(v *Fp) ct.Bool <span class="cov8" title="1">{
        var diff Fp
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fp) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fp) Bytes() []byte <span class="cov8" title="1">{
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)
        var data [FpBytes]byte
        fiatFpToBytes(&amp;data, (*[FpLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fp) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFpNonMontgomeryDomainFieldElement
        fiatFpFromMontgomery(&amp;nonMonty, &amp;f.fiatFpMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fp) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fp) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fp) Degree() uint64 <span class="cov8" title="1">{
        return 1
}</span>

func (f *Fp) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fp) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
        "encoding/hex"
        "io"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

const (
        FqLimbs     = 4
        FqSatLimbs  = FqLimbs + 1
        FqBits      = 255
        FqBytes     = 8 * (((FqBits - 1) / 64) + 1)
        FqWideBytes = 2 * FqBytes
        FqDivSteps  = ((49 * FqBits) + 57) / 17
        FqE         = 32
)

var (
        FqProgenitorExp = [...]byte{0x90, 0x75, 0x23, 0xc6, 0x6e, 0x54, 0xca, 0x04, 0x7e, 0x4c, 0x23, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20}
        FqModulus       = [...]byte{0x01, 0x00, 0x00, 0x00, 0x21, 0xeb, 0x46, 0x8c, 0xdd, 0xa8, 0x94, 0x09, 0xfc, 0x98, 0x46, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40}
        FqRootOfUnity   Fq
)

func init() <span class="cov8" title="1">{
        FqRootOfUnity.MustSetHex("2de6a9b8746d3f589e5c4dfd492ae26e9bb97ea3c106f049a70e2c1102b6d05f")
}</span>

type Fq struct {
        fiatFqMontgomeryDomainFieldElement

        _ [0]func()
}

func (f *Fq) Set(v *Fq) <span class="cov8" title="1">{
        *f = *v
}</span>

func (f *Fq) SetZero() <span class="cov8" title="1">{
        *f = Fq{}
}</span>

func (f *Fq) SetOne() <span class="cov8" title="1">{
        fiatFqSetOne(&amp;f.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) SetUint64(v uint64) <span class="cov0" title="0">{
        limbs := [FqLimbs]uint64{v}
        f.SetLimbs(limbs[:])
}</span>

func (f *Fq) SetLimbs(data []uint64) (ok ct.Bool) <span class="cov0" title="0">{
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqNonMontgomeryDomainFieldElement)(data))
        return 1
}</span>

func (f *Fq) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) != FqBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromBytes((*[FqLimbs]uint64)(&amp;nonMonty), (*[FqBytes]uint8)(data))
        fiatFqToMontgomery(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;nonMonty)
        return 1</span>
}

func (f *Fq) SetBytesWide(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(data) &gt; FqWideBytes </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var wideData [FqWideBytes]uint8
        copy(wideData[:], data)

        var d1, d0 [FqLimbs]uint64
        fiatFqFromBytes(&amp;d0, (*[FqBytes]uint8)(wideData[:FqBytes]))
        fiatFqFromBytes(&amp;d1, (*[FqBytes]uint8)(wideData[FqBytes:]))

        // d0*r2 + d1*r3
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d0))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqToMontgomery((*fiatFqMontgomeryDomainFieldElement)(&amp;d1), (*fiatFqNonMontgomeryDomainFieldElement)(&amp;d1))
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;d0), (*fiatFqMontgomeryDomainFieldElement)(&amp;d1))
        return 1</span>
}

func (f *Fq) SetUniformBytes(componentsData ...[]byte) (ok ct.Bool) <span class="cov8" title="1">{
        if len(componentsData) != 1 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return f.SetBytesWide(componentsData[0])</span>
}

func (f *Fq) SetRandom(prng io.Reader) (ok ct.Bool) <span class="cov0" title="0">{
        var uniformBytes [(FqBits + 128 + 7) / 8]byte
        _, err := io.ReadFull(prng, uniformBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return f.SetUniformBytes(uniformBytes[:])</span>
}

func (f *Fq) Select(choice ct.Choice, z, nz *Fq) <span class="cov8" title="1">{
        fiatFqSelectznz((*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement),fiatFqUint1(choice), (*[FqLimbs]uint64)(&amp;z.fiatFqMontgomeryDomainFieldElement), (*[FqLimbs]uint64)(&amp;nz.fiatFqMontgomeryDomainFieldElement))
}</span>

func (f *Fq) Add(lhs, rhs *Fq) <span class="cov8" title="1">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Double(x *Fq) <span class="cov0" title="0">{
        fiatFqAdd(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement, &amp;x.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Sub(lhs, rhs *Fq) <span class="cov8" title="1">{
        fiatFqSub(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Neg(v *Fq) <span class="cov8" title="1">{
        fiatFqOpp(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Mul(lhs, rhs *Fq) <span class="cov8" title="1">{
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;lhs.fiatFqMontgomeryDomainFieldElement, &amp;rhs.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Square(v *Fq) <span class="cov8" title="1">{
        fiatFqSquare(&amp;f.fiatFqMontgomeryDomainFieldElement, &amp;v.fiatFqMontgomeryDomainFieldElement)
}</span>

func (f *Fq) Inv(a *Fq) (ok ct.Bool) <span class="cov8" title="1">{
        var precomp, h, v, r, out4, out5 [FqLimbs]uint64
        var ff, g, out2, out3 [FqSatLimbs]uint64
        var out1, inverted uint64

        d := uint64(1)
        fiatFqDivstepPrecomp(&amp;precomp)
        fiatFqFromMontgomery((*fiatFqNonMontgomeryDomainFieldElement)(g[:FqLimbs]), &amp;a.fiatFqMontgomeryDomainFieldElement)
        fiatFqMsat(&amp;ff)
        fiatFqSetOne((*fiatFqMontgomeryDomainFieldElement)(&amp;r))

        for i := 0; i &lt; FqDivSteps-(FqDivSteps%2); i += 2 </span><span class="cov8" title="1">{
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                fiatFqDivstep(&amp;d, &amp;ff, &amp;g, &amp;v, &amp;r, out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5)
        }</span>
        <span class="cov8" title="1">if (FqDivSteps % 2) != 0 </span><span class="cov0" title="0">{ // compile time if - always true
                fiatFqDivstep(&amp;out1, &amp;out2, &amp;out3, &amp;out4, &amp;out5, d, &amp;ff, &amp;g, &amp;v, &amp;r)
                v = out4
                ff = out2
        }</span>

        <span class="cov8" title="1">fiatFqOpp((*fiatFqMontgomeryDomainFieldElement)(&amp;h), (*fiatFqMontgomeryDomainFieldElement)(&amp;v))
        fiatFqSelectznz(&amp;v, fiatFqUint1(ff[FqLimbs]&gt;&gt;63), &amp;v, &amp;h)
        fiatFqMul(&amp;f.fiatFqMontgomeryDomainFieldElement, (*fiatFqMontgomeryDomainFieldElement)(&amp;v), (*fiatFqMontgomeryDomainFieldElement)(&amp;precomp))
        fiatFqNonzero(&amp;inverted, (*[FqLimbs]uint64)(&amp;f.fiatFqMontgomeryDomainFieldElement))

        return ct.Bool((inverted | -inverted) &gt;&gt; 63)</span>
}

func (f *Fq) Div(lhs, rhs *Fq) (ok ct.Bool) <span class="cov8" title="1">{
        var rhsInv Fq
        ok = rhsInv.Inv(rhs)
        f.Mul(lhs, &amp;rhsInv)
        return ok
}</span>

func (f *Fq) Sqrt(x *Fq) (ok ct.Bool) <span class="cov0" title="0">{
        return ct.Bool(sqrt(f, x, &amp;FqRootOfUnity, FqE, FqProgenitorExp[:]))
}</span>

func (f *Fq) IsNonZero() ct.Bool <span class="cov8" title="1">{
        // montgomery form might not be "fully reduced"
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)

        var nonZero uint64
        fiatFqNonzero(&amp;nonZero, (*[FqLimbs]uint64)(&amp;nonMonty))
        return ct.Bool((nonZero | -nonZero) &gt;&gt; 63)
}</span>

func (f *Fq) IsZero() ct.Bool <span class="cov8" title="1">{
        return f.IsNonZero() ^ 1
}</span>

func (f *Fq) IsOne() ct.Bool <span class="cov8" title="1">{
        var one Fq
        one.SetOne()
        return f.Equal(&amp;one)
}</span>

func (f *Fq) Equal(v *Fq) ct.Bool <span class="cov8" title="1">{
        var diff Fq
        diff.Sub(f, v)
        return diff.IsZero()
}</span>

func (f *Fq) ComponentsBytes() [][]byte <span class="cov0" title="0">{
        return [][]byte{f.Bytes()}
}</span>

func (f *Fq) Bytes() []byte <span class="cov8" title="1">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        var data [FqBytes]byte
        fiatFqToBytes(&amp;data, (*[FqLimbs]uint64)(&amp;nonMonty))
        return data[:]

}</span>

func (f *Fq) Limbs() []uint64 <span class="cov0" title="0">{
        var nonMonty fiatFqNonMontgomeryDomainFieldElement
        fiatFqFromMontgomery(&amp;nonMonty, &amp;f.fiatFqMontgomeryDomainFieldElement)
        return nonMonty[:]
}</span>

func (f *Fq) MustSetHex(v string) <span class="cov8" title="1">{
        data, err := hex.DecodeString(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">slices.Reverse(data)
        ok := f.SetBytes(data)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("invalid data")</span>
        }
}

func (f *Fq) Hex() string <span class="cov0" title="0">{
        data := f.Bytes()
        slices.Reverse(data)
        return hex.EncodeToString(data)
}</span>

func (f *Fq) Degree() uint64 <span class="cov8" title="1">{
        return 1
}</span>

func (f *Fq) String() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        fBi := new(big.Int).SetBytes(fBytes)
        return fBi.String()
}</span>

func (f *Fq) GoString() string <span class="cov0" title="0">{
        fBytes := f.Bytes()
        slices.Reverse(fBytes)
        return "0x" + hex.EncodeToString(f.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">package pasta

import (
        "crypto/elliptic"
        "encoding"
        "fmt"
        "hash/fnv"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        pastaImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

type (
        PallasBaseFieldElement = FpFieldElement
        PallasScalar           = FqFieldElement
)

const (
        // PallasName is the curve name.
        PallasName = "pallas"
        // PallasHash2CurveSuite is the hash-to-curve suite string.
        PallasHash2CurveSuite = "pallas_XMD:BLAKE2b_SSWU_RO_"
)

var (
        pallasInitOnce sync.Once
        pallasInstance *PallasCurve

        _ curves.Curve[*PallasPoint, *PallasBaseFieldElement, *PallasScalar] = (*PallasCurve)(nil)
        _ curves.Point[*PallasPoint, *PallasBaseFieldElement, *PallasScalar] = (*PallasPoint)(nil)
        _ encoding.BinaryMarshaler                                           = (*PallasPoint)(nil)
        _ encoding.BinaryUnmarshaler                                         = (*PallasPoint)(nil)
)

// PallasCurve represents the Pallas elliptic curve.
type PallasCurve struct {
        traits.PrimeCurveTrait[*pastaImpl.Fp, *pastaImpl.PallasPoint, *PallasPoint, PallasPoint]
}

// NewPallasCurve returns the Pallas curve instance.
func NewPallasCurve() *PallasCurve <span class="cov8" title="1">{
        pallasInitOnce.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for trait
                pallasInstance = &amp;PallasCurve{}
        }</span>)

        <span class="cov8" title="1">return pallasInstance</span>
}

// Name returns the name of the structure.
func (*PallasCurve) Name() string <span class="cov0" title="0">{
        return PallasName
}</span>

// Cofactor returns the curve cofactor.
func (*PallasCurve) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(1)
}</span>

// Order returns the group or field order.
func (*PallasCurve) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewPallasScalarField().Order()
}</span>

// FromBytes decodes an element from bytes.
func (c *PallasCurve) FromBytes(input []byte) (*PallasPoint, error) <span class="cov0" title="0">{
        return c.FromCompressed(input)
}</span>

// FromCompressed decodes a compressed point.
func (c *PallasCurve) FromCompressed(input []byte) (*PallasPoint, error) <span class="cov8" title="1">{
        if len(input) != pastaImpl.FpBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov8" title="1">sign := input[pastaImpl.FpBytes-1] &gt;&gt; 7
        var buffer [pastaImpl.FpBytes]byte
        copy(buffer[:], input)
        buffer[pastaImpl.FpBytes-1] &amp;= 0x7f

        var x, y pastaImpl.Fp
        ok := x.SetBytes(buffer[:])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>
        <span class="cov8" title="1">if x.IsZero() == 1 &amp;&amp; sign == 0 </span><span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov8" title="1">pp := new(PallasPoint)
        ok = pp.V.SetFromAffineX(&amp;x)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>
        <span class="cov8" title="1">ok = pp.V.ToAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov8" title="1">if (y.Bytes()[0] &amp; 0b1) != sign </span><span class="cov0" title="0">{
                pp.V.Neg(&amp;pp.V)
        }</span>
        <span class="cov8" title="1">return pp, nil</span>
}

// FromUncompressed decodes an uncompressed point.
func (c *PallasCurve) FromUncompressed(input []byte) (*PallasPoint, error) <span class="cov0" title="0">{
        if len(input) != 2*pastaImpl.FpBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov0" title="0">var x, y pastaImpl.Fp
        ok := x.SetBytes(input[:pastaImpl.FpBytes])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid input")
        }</span>
        <span class="cov0" title="0">ok = y.SetBytes(input[pastaImpl.FpBytes:])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid input")
        }</span>
        <span class="cov0" title="0">if x.IsZero() == 1 &amp;&amp; y.IsZero() == 1 </span><span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov0" title="0">pp := new(PallasPoint)
        ok = pp.V.SetAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid input")
        }</span>
        <span class="cov0" title="0">return pp, nil</span>
}

// FromAffine builds a point from affine coordinates.
func (*PallasCurve) FromAffine(x, y *PallasBaseFieldElement) (*PallasPoint, error) <span class="cov0" title="0">{
        var p PallasPoint
        ok := p.V.SetAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

// FromAffineX builds a point from an affine x-coordinate.
func (*PallasCurve) FromAffineX(x *PallasBaseFieldElement, b bool) (*PallasPoint, error) <span class="cov0" title="0">{
        var p PallasPoint
        ok := p.V.SetFromAffineX(&amp;x.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov0" title="0">y, err := p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // should never happen
        }
        <span class="cov0" title="0">if y.IsOdd() != b </span><span class="cov0" title="0">{
                return p.Neg(), nil
        }</span> else<span class="cov0" title="0"> {
                return &amp;p, nil
        }</span>
}

// Hash maps input bytes to an element or point.
func (c *PallasCurve) Hash(bytes []byte) (*PallasPoint, error) <span class="cov0" title="0">{
        return c.HashWithDst(base.Hash2CurveAppTag+PallasHash2CurveSuite, bytes)
}</span>

// HashWithDst maps input bytes to a point with a custom DST.
func (*PallasCurve) HashWithDst(dst string, bytes []byte) (*PallasPoint, error) <span class="cov0" title="0">{
        var p PallasPoint
        p.V.Hash(dst, bytes)
        return &amp;p, nil
}</span>

// ElementSize returns the element size in bytes.
func (*PallasCurve) ElementSize() int <span class="cov0" title="0">{
        return pastaImpl.FpBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*PallasCurve) WideElementSize() int <span class="cov0" title="0">{
        return int(^uint(0) &gt;&gt; 1)
}</span>

// ScalarStructure returns the scalar structure.
func (*PallasCurve) ScalarStructure() algebra.Structure[*PallasScalar] <span class="cov0" title="0">{
        return NewPallasScalarField()
}</span>

// BaseStructure returns the base field structure.
func (*PallasCurve) BaseStructure() algebra.Structure[*PallasBaseFieldElement] <span class="cov0" title="0">{
        return NewPallasBaseField()
}</span>

// ScalarRing returns the scalar ring.
func (*PallasCurve) ScalarRing() algebra.ZModLike[*PallasScalar] <span class="cov0" title="0">{
        return NewPallasScalarField()
}</span>

// ScalarField returns the scalar field.
func (*PallasCurve) ScalarField() algebra.PrimeField[*PallasScalar] <span class="cov0" title="0">{
        return NewPallasScalarField()
}</span>

// BaseField returns the base field.
func (*PallasCurve) BaseField() algebra.FiniteField[*PallasBaseFieldElement] <span class="cov0" title="0">{
        return NewPallasBaseField()
}</span>

// ScalarBaseOp adds a scalar multiple of the generator.
func (c *PallasCurve) ScalarBaseOp(sc *PallasScalar) *PallasPoint <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if sc == nil </span><span class="cov0" title="0">{
                panic("scalar is nil")</span>
        }
        <span class="cov0" title="0">if sc.IsZero() </span><span class="cov0" title="0">{
                return c.OpIdentity()
        }</span>
        <span class="cov0" title="0">return c.ScalarBaseMul(sc)</span>
}

// ScalarBaseMul multiplies the generator by a scalar.
func (c *PallasCurve) ScalarBaseMul(sc *PallasScalar) *PallasPoint <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if sc == nil </span><span class="cov0" title="0">{
                panic("scalar is nil")</span>
        }
        <span class="cov0" title="0">return c.Generator().ScalarMul(sc)</span>
}

// ToElliptic returns the standard library elliptic.Curve adapter.
func (*PallasCurve) ToElliptic() elliptic.Curve <span class="cov0" title="0">{
        return ellipticPallasInstance
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *PallasCurve) MultiScalarOp(scalars []*PallasScalar, points []*PallasPoint) (*PallasPoint, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*PallasCurve) MultiScalarMul(scalars []*PallasScalar, points []*PallasPoint) (*PallasPoint, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result PallasPoint
        scs := make([][]byte, len(scalars))
        pts := make([]*pastaImpl.PallasPoint, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// PallasPoint represents a Pallas curve point.
type PallasPoint struct {
        traits.PrimePointTrait[*pastaImpl.Fp, *pastaImpl.PallasPoint, pastaImpl.PallasPoint, *PallasPoint, PallasPoint]
}

// HashCode returns a hash code for the receiver.
func (p *PallasPoint) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(p.ToCompressed())
        return base.HashCode(h.Sum64())
}</span>

// Bytes returns the canonical byte encoding.
func (p *PallasPoint) Bytes() []byte <span class="cov0" title="0">{
        return p.ToCompressed()
}</span>

// Structure returns the algebraic structure for the receiver.
func (*PallasPoint) Structure() algebra.Structure[*PallasPoint] <span class="cov0" title="0">{
        return NewPallasCurve()
}</span>

// ToCompressed encodes the point in compressed form.
func (p *PallasPoint) ToCompressed() []byte <span class="cov8" title="1">{
        // Use ZCash encoding where infinity is all zeros and the top bit represents the sign of y
        // and the remainder represent the x-coordinate
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                var zeros [pastaImpl.FpBytes]byte
                return zeros[:]
        }</span>

        <span class="cov8" title="1">var x, y pastaImpl.Fp
        ok := p.V.ToAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }
        <span class="cov8" title="1">sign := (y.Bytes()[0] &amp; 0b1) &lt;&lt; 7
        result := x.Bytes()
        result[31] |= sign
        return result</span>
}

// ToUncompressed encodes the point in uncompressed form.
func (p *PallasPoint) ToUncompressed() []byte <span class="cov0" title="0">{
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                var zeros [pastaImpl.FpBytes * 2]byte
                return zeros[:]
        }</span>

        <span class="cov0" title="0">var x, y pastaImpl.Fp
        ok := p.V.ToAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov0" title="0">return slices.Concat(x.Bytes(), y.Bytes())</span>
}

// AffineX returns the affine x-coordinate.
func (p *PallasPoint) AffineX() (*PallasBaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y PallasBaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;x, nil</span>
}

// AffineY returns the affine y-coordinate.
func (p *PallasPoint) AffineY() (*PallasBaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y PallasBaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;y, nil</span>
}

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *PallasPoint) ScalarOp(sc *PallasScalar) *PallasPoint <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *PallasPoint) ScalarMul(actor *PallasScalar) *PallasPoint <span class="cov0" title="0">{
        var result PallasPoint
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (*PallasPoint) IsTorsionFree() bool <span class="cov0" title="0">{
        return true
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (p *PallasPoint) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        return p.ToCompressed(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (p *PallasPoint) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        pp, err := NewPallasCurve().FromCompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}

// String returns the string form of the receiver.
func (p *PallasPoint) String() string <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return "(0, 1, 0)"
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("(%s, %s, %s)", p.V.X.String(), p.V.Y.String(), p.V.Z.String())
        }</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package pasta

import (
        "crypto/elliptic"
        "encoding"
        "fmt"
        "hash/fnv"
        "slices"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        aimpl "github.com/bronlabs/bron-crypto/pkg/base/algebra/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/impl/traits"
        pastaImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

type (
        VestaBaseFieldElement = FqFieldElement
        VestaScalar           = FpFieldElement
)

const (
        // VestaName is the curve name.
        VestaName = "vesta"
        // VestaHash2CurveSuite is the hash-to-curve suite string.
        VestaHash2CurveSuite = "vesta_XMD:BLAKE2b_SSWU_RO_"
)

var (
        vestaInitOnce sync.Once
        vestaInstance *VestaCurve

        _ curves.Curve[*VestaPoint, *VestaBaseFieldElement, *VestaScalar] = (*VestaCurve)(nil)
        _ curves.Point[*VestaPoint, *VestaBaseFieldElement, *VestaScalar] = (*VestaPoint)(nil)
        _ encoding.BinaryMarshaler                                        = (*VestaPoint)(nil)
        _ encoding.BinaryUnmarshaler                                      = (*VestaPoint)(nil)
)

// VestaCurve represents the Vesta elliptic curve.
type VestaCurve struct {
        traits.PrimeCurveTrait[*pastaImpl.Fq, *pastaImpl.VestaPoint, *VestaPoint, VestaPoint]
}

// NewVestaCurve returns the Vesta curve instance.
func NewVestaCurve() *VestaCurve <span class="cov8" title="1">{
        vestaInitOnce.Do(func() </span><span class="cov8" title="1">{
                //nolint:exhaustruct // no need for trait
                vestaInstance = &amp;VestaCurve{}
        }</span>)

        <span class="cov8" title="1">return vestaInstance</span>
}

// Name returns the name of the structure.
func (*VestaCurve) Name() string <span class="cov0" title="0">{
        return VestaName
}</span>

// Order returns the group or field order.
func (*VestaCurve) Order() cardinal.Cardinal <span class="cov0" title="0">{
        return NewVestaScalarField().Order()
}</span>

// Cofactor returns the curve cofactor.
func (*VestaCurve) Cofactor() cardinal.Cardinal <span class="cov0" title="0">{
        return cardinal.New(1)
}</span>

// FromBytes decodes an element from bytes.
func (c *VestaCurve) FromBytes(input []byte) (*VestaPoint, error) <span class="cov0" title="0">{
        return c.FromCompressed(input)
}</span>

// FromCompressed decodes a compressed point.
func (c *VestaCurve) FromCompressed(input []byte) (*VestaPoint, error) <span class="cov8" title="1">{
        if len(input) != pastaImpl.FqBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov8" title="1">sign := input[31] &gt;&gt; 7
        var buffer [pastaImpl.FqBytes]byte
        copy(buffer[:], input)
        buffer[31] &amp;= 0x7f

        var x, y pastaImpl.Fq
        ok := x.SetBytes(buffer[:])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>
        <span class="cov8" title="1">if x.IsZero() == 1 &amp;&amp; sign == 0 </span><span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov8" title="1">pp := new(VestaPoint)
        ok = pp.V.SetFromAffineX(&amp;x)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>
        <span class="cov8" title="1">ok = pp.V.ToAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov8" title="1">if (y.Bytes()[0] &amp; 0b1) != sign </span><span class="cov8" title="1">{
                pp.V.Neg(&amp;pp.V)
        }</span>
        <span class="cov8" title="1">return pp, nil</span>
}

// FromUncompressed decodes an uncompressed point.
func (c *VestaCurve) FromUncompressed(input []byte) (*VestaPoint, error) <span class="cov0" title="0">{
        if len(input) != 2*pastaImpl.FqBytes </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("invalid input")
        }</span>

        <span class="cov0" title="0">var x, y pastaImpl.Fq
        ok := x.SetBytes(input[:pastaImpl.FqBytes])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid input")
        }</span>
        <span class="cov0" title="0">ok = y.SetBytes(input[pastaImpl.FqBytes:])
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid input")
        }</span>
        <span class="cov0" title="0">if x.IsZero() == 1 &amp;&amp; y.IsZero() == 1 </span><span class="cov0" title="0">{
                return c.OpIdentity(), nil
        }</span>

        <span class="cov0" title="0">pp := new(VestaPoint)
        ok = pp.V.SetAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("invalid input")
        }</span>
        <span class="cov0" title="0">return pp, nil</span>
}

// FromAffine builds a point from affine coordinates.
func (*VestaCurve) FromAffine(x, y *VestaBaseFieldElement) (*VestaPoint, error) <span class="cov0" title="0">{
        var p VestaPoint
        ok := p.V.SetAffine(&amp;x.V, &amp;y.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x/y")
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

// FromAffineX builds a point from an affine x-coordinate.
func (*VestaCurve) FromAffineX(x *VestaBaseFieldElement, b bool) (*VestaPoint, error) <span class="cov0" title="0">{
        var p VestaPoint
        ok := p.V.SetFromAffineX(&amp;x.V)
        if ok != 1 </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidCoordinates.WithMessage("x")
        }</span>
        <span class="cov0" title="0">y, err := p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span> // should never happen
        }
        <span class="cov0" title="0">if y.IsOdd() != b </span><span class="cov0" title="0">{
                return p.Neg(), nil
        }</span> else<span class="cov0" title="0"> {
                return &amp;p, nil
        }</span>
}

// Hash maps input bytes to an element or point.
func (c *VestaCurve) Hash(bytes []byte) (*VestaPoint, error) <span class="cov0" title="0">{
        return c.HashWithDst(base.Hash2CurveAppTag+VestaHash2CurveSuite, bytes)
}</span>

// HashWithDst maps input bytes to a point with a custom DST.
func (*VestaCurve) HashWithDst(dst string, bytes []byte) (*VestaPoint, error) <span class="cov0" title="0">{
        var p VestaPoint
        p.V.Hash(dst, bytes)
        return &amp;p, nil
}</span>

// ElementSize returns the element size in bytes.
func (*VestaCurve) ElementSize() int <span class="cov0" title="0">{
        return pastaImpl.FqBytes
}</span>

// WideElementSize returns the wide element size in bytes.
func (*VestaCurve) WideElementSize() int <span class="cov0" title="0">{
        return int(^uint(0) &gt;&gt; 1)
}</span>

// ScalarStructure returns the scalar structure.
func (*VestaCurve) ScalarStructure() algebra.Structure[*VestaScalar] <span class="cov0" title="0">{
        return NewVestaScalarField()
}</span>

// BaseStructure returns the base field structure.
func (*VestaCurve) BaseStructure() algebra.Structure[*VestaBaseFieldElement] <span class="cov0" title="0">{
        return NewVestaBaseField()
}</span>

// ScalarRing returns the scalar ring.
func (*VestaCurve) ScalarRing() algebra.ZModLike[*VestaScalar] <span class="cov0" title="0">{
        return NewVestaScalarField()
}</span>

// ScalarField returns the scalar field.
func (*VestaCurve) ScalarField() algebra.PrimeField[*VestaScalar] <span class="cov0" title="0">{
        return NewVestaScalarField()
}</span>

// BaseField returns the base field.
func (*VestaCurve) BaseField() algebra.FiniteField[*VestaBaseFieldElement] <span class="cov0" title="0">{
        return NewVestaBaseField()
}</span>

// ScalarBaseOp adds a scalar multiple of the generator.
func (c *VestaCurve) ScalarBaseOp(sc *VestaScalar) *VestaPoint <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if sc == nil </span><span class="cov0" title="0">{
                panic("scalar is nil")</span>
        }
        <span class="cov0" title="0">if sc.IsZero() </span><span class="cov0" title="0">{
                return c.OpIdentity()
        }</span>
        <span class="cov0" title="0">return c.ScalarBaseMul(sc)</span>
}

// ScalarBaseMul multiplies the generator by a scalar.
func (c *VestaCurve) ScalarBaseMul(sc *VestaScalar) *VestaPoint <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if sc == nil </span><span class="cov0" title="0">{
                panic("scalar is nil")</span>
        }
        <span class="cov0" title="0">return c.Generator().ScalarMul(sc)</span>
}

// ToElliptic returns the standard library elliptic.Curve adapter.
func (*VestaCurve) ToElliptic() elliptic.Curve <span class="cov0" title="0">{
        return ellipticVestaInstance
}</span>

// MultiScalarOp computes a multiscalar operation.
func (c *VestaCurve) MultiScalarOp(scalars []*VestaScalar, points []*VestaPoint) (*VestaPoint, error) <span class="cov0" title="0">{
        return c.MultiScalarMul(scalars, points)
}</span>

// MultiScalarMul computes a multiscalar multiplication.
func (*VestaCurve) MultiScalarMul(scalars []*VestaScalar, points []*VestaPoint) (*VestaPoint, error) <span class="cov0" title="0">{
        if len(scalars) != len(points) </span><span class="cov0" title="0">{
                return nil, curves.ErrInvalidLength.WithMessage("mismatched lengths of scalars and points")
        }</span>
        <span class="cov0" title="0">var result VestaPoint
        scs := make([][]byte, len(scalars))
        pts := make([]*pastaImpl.VestaPoint, len(points))
        for i := range points </span><span class="cov0" title="0">{
                pts[i] = &amp;points[i].V
                scs[i] = scalars[i].V.Bytes()
        }</span>
        <span class="cov0" title="0">aimpl.MultiScalarMulLowLevel(&amp;result.V, pts, scs)
        return &amp;result, nil</span>
}

// VestaPoint represents a Vesta curve point.
type VestaPoint struct {
        traits.PrimePointTrait[*pastaImpl.Fq, *pastaImpl.VestaPoint, pastaImpl.VestaPoint, *VestaPoint, VestaPoint]
}

// HashCode returns a hash code for the receiver.
func (p *VestaPoint) HashCode() base.HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write(p.ToCompressed())
        return base.HashCode(h.Sum64())
}</span>

// Structure returns the algebraic structure for the receiver.
func (*VestaPoint) Structure() algebra.Structure[*VestaPoint] <span class="cov0" title="0">{
        return NewVestaCurve()
}</span>

// ToCompressed encodes the point in compressed form.
func (p *VestaPoint) ToCompressed() []byte <span class="cov8" title="1">{
        // Use ZCash encoding where infinity is all zeros and the top bit represents the sign of y
        // and the remainder represent the x-coordinate
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                var zeros [pastaImpl.FqBytes]byte
                return zeros[:]
        }</span>

        <span class="cov8" title="1">var x, y pastaImpl.Fq
        ok := p.V.ToAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }
        <span class="cov8" title="1">sign := (y.Bytes()[0] &amp; 0b1) &lt;&lt; 7
        result := x.Bytes()
        result[31] |= sign
        return result</span>
}

// ToUncompressed encodes the point in uncompressed form.
func (p *VestaPoint) ToUncompressed() []byte <span class="cov0" title="0">{
        if p.IsOpIdentity() </span><span class="cov0" title="0">{
                var zeros [pastaImpl.FqBytes * 2]byte
                return zeros[:]
        }</span>

        <span class="cov0" title="0">var x, y pastaImpl.Fq
        ok := p.V.ToAffine(&amp;x, &amp;y)
        if ok != 1 </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }

        <span class="cov0" title="0">return slices.Concat(x.Bytes(), y.Bytes())</span>
}

// Bytes returns the canonical byte encoding.
func (p *VestaPoint) Bytes() []byte <span class="cov0" title="0">{
        return p.ToCompressed()
}</span>

// AffineX returns the affine x-coordinate.
func (p *VestaPoint) AffineX() (*VestaBaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y VestaBaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;x, nil</span>
}

// AffineY returns the affine y-coordinate.
func (p *VestaPoint) AffineY() (*VestaBaseFieldElement, error) <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return nil, curves.ErrFailed.WithMessage("point is identity")
        }</span>

        <span class="cov0" title="0">var x, y VestaBaseFieldElement
        if ok := p.V.ToAffine(&amp;x.V, &amp;y.V); ok == 0 </span><span class="cov0" title="0">{
                panic("this should never happen - failed to convert point to affine")</span>
        }

        <span class="cov0" title="0">return &amp;y, nil</span>
}

// ScalarOp adds a scalar multiple of q to the receiver.
func (p *VestaPoint) ScalarOp(sc *VestaScalar) *VestaPoint <span class="cov0" title="0">{
        return p.ScalarMul(sc)
}</span>

// ScalarMul multiplies the point by a scalar.
func (p *VestaPoint) ScalarMul(actor *VestaScalar) *VestaPoint <span class="cov0" title="0">{
        var result VestaPoint
        aimpl.ScalarMulLowLevel(&amp;result.V, &amp;p.V, actor.V.Bytes())
        return &amp;result
}</span>

// IsTorsionFree reports whether the point is torsion-free.
func (*VestaPoint) IsTorsionFree() bool <span class="cov0" title="0">{
        return true
}</span>

// MarshalBinary implements encoding.BinaryMarshaler.
func (p *VestaPoint) MarshalBinary() ([]byte, error) <span class="cov0" title="0">{
        return p.ToCompressed(), nil
}</span>

// UnmarshalBinary implements encoding.BinaryUnmarshaler.
func (p *VestaPoint) UnmarshalBinary(data []byte) error <span class="cov0" title="0">{
        pp, err := NewVestaCurve().FromCompressed(data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize point")
        }</span>
        <span class="cov0" title="0">p.V.Set(&amp;pp.V)
        return nil</span>
}

// String returns the string form of the receiver.
func (p *VestaPoint) String() string <span class="cov0" title="0">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return "(0, 1, 0)"
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("(%s, %s, %s)", p.V.X.String(), p.V.Y.String(), p.V.Z.String())
        }</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package bimap

import (
        "iter"
        "sync"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
)

// ConcurrentBiMap is a thread-safe wrapper around a MutableBiMap.
// All operations are protected by a read-write mutex.
type ConcurrentBiMap[K any, V any] struct {
        inner ds.MutableBiMap[K, V]
        mu    sync.RWMutex
}

// NewConcurrentBiMap creates a new thread-safe bimap wrapping the given mutable bimap.
func NewConcurrentBiMap[K any, V any](innerBiMap ds.MutableBiMap[K, V]) *ConcurrentBiMap[K, V] <span class="cov8" title="1">{
        return &amp;ConcurrentBiMap[K, V]{
                inner: innerBiMap,
                mu:    sync.RWMutex{},
        }
}</span>

// Reverse returns a thread-safe view of this bimap with keys and values swapped.
func (m *ConcurrentBiMap[K, V]) Reverse() ds.ConcurrentBiMap[V, K] <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        return NewConcurrentBiMap(m.inner.Reverse())
}</span>

// ContainsKey returns true if the key exists in the bimap.
func (m *ConcurrentBiMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.ContainsKey(key)
}</span>

// Get returns the value associated with the key and whether it exists.
func (m *ConcurrentBiMap[K, V]) Get(l K) (V, bool) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Get(l)
}</span>

// Retain returns a new concurrent bimap containing only entries with the specified keys.
func (m *ConcurrentBiMap[K, V]) Retain(keys ...K) ds.ConcurrentBiMap[K, V] <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return NewConcurrentBiMap(m.inner.Retain(keys...))
}</span>

// Filter returns a new concurrent bimap containing only entries where the predicate returns true.
func (m *ConcurrentBiMap[K, V]) Filter(predicate func(key K) bool) ds.ConcurrentBiMap[K, V] <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return NewConcurrentBiMap(m.inner.Filter(predicate))
}</span>

// Put adds or updates a key-value pair in the bimap.
func (m *ConcurrentBiMap[K, V]) Put(l K, r V) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        _, _ = m.inner.TryPut(l, r)
}</span>

// TryPut adds or updates a key-value pair, returning whether a value was replaced and the old value.
func (m *ConcurrentBiMap[K, V]) TryPut(l K, r V) (replaced bool, oldValue V) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.inner.TryPut(l, r)
}</span>

// Clear removes all entries from the bimap.
func (m *ConcurrentBiMap[_, _]) Clear() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.inner.Clear()
}</span>

// Size returns the number of entries in the bimap.
func (m *ConcurrentBiMap[_, _]) Size() int <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Size()
}</span>

// IsEmpty returns true if the bimap contains no entries.
func (m *ConcurrentBiMap[_, _]) IsEmpty() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.IsEmpty()
}</span>

// Remove deletes the entry with the given key from the bimap.
func (m *ConcurrentBiMap[K, V]) Remove(l K) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.inner.TryRemove(l)
}</span>

// TryRemove deletes the entry with the given key, returning whether it existed and its value.
func (m *ConcurrentBiMap[K, V]) TryRemove(l K) (removed bool, r V) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.inner.TryRemove(l)
}</span>

// Keys returns a slice of all keys in the bimap.
func (m *ConcurrentBiMap[K, _]) Keys() []K <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Keys()
}</span>

// Values returns a slice of all values in the bimap.
func (m *ConcurrentBiMap[_, V]) Values() []V <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Values()
}</span>

// Iter returns an iterator over all key-value pairs.
func (m *ConcurrentBiMap[K, V]) Iter() iter.Seq2[K, V] <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Iter()
}</span>

// Clone returns a new concurrent bimap with a copy of the data.
func (m *ConcurrentBiMap[K, V]) Clone() ds.ConcurrentBiMap[K, V] <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return NewConcurrentBiMap(m.inner.Clone())
}</span>

// Compute atomically computes a new value based on the key's current mapping.
// The remappingFunction receives the key, current value (if any), and existence flag,
// returning the new value and whether to store it (false removes the key).
func (m *ConcurrentBiMap[K, V]) Compute(key K, remappingFunction func(key K, oldVal V, exists bool) (V, bool)) V <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        oldValue, oldExist := m.inner.Get(key)

        newValue, shouldStore := remappingFunction(key, oldValue, oldExist)

        if shouldStore </span><span class="cov8" title="1">{
                m.inner.Put(key, newValue)
        }</span> else<span class="cov8" title="1"> {
                m.inner.Remove(key)
        }</span>
        <span class="cov8" title="1">return newValue</span>
}

// ComputeIfAbsent atomically computes a value only if the key is not present.
// The mappingFunction returns the value to store and whether to store it.
// If the key exists, returns the current value without calling mappingFunction.
func (m *ConcurrentBiMap[K, V]) ComputeIfAbsent(key K, mappingFunction func(key K) (V, bool)) V <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        oldValue, oldExist := m.inner.Get(key)

        if oldExist </span><span class="cov8" title="1">{
                return oldValue
        }</span>

        <span class="cov8" title="1">newValue, shouldStore := mappingFunction(key)

        if shouldStore </span><span class="cov8" title="1">{
                m.inner.Put(key, newValue)
        }</span>
        <span class="cov8" title="1">return newValue</span>
}

// ComputeIfPresent atomically computes a new value only if the key is present.
// The remappingFunction returns the new value and whether to keep it (false removes the key).
// If the key is absent, returns the zero value without calling remappingFunction.
func (m *ConcurrentBiMap[K, V]) ComputeIfPresent(key K, remappingFunction func(key K, oldVal V) (V, bool)) V <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        oldValue, oldExist := m.inner.Get(key)

        if !oldExist </span><span class="cov8" title="1">{
                return oldValue
        }</span>

        <span class="cov8" title="1">newValue, shouldStore := remappingFunction(key, oldValue)

        if shouldStore </span><span class="cov8" title="1">{
                m.inner.Put(key, newValue)
        }</span> else<span class="cov0" title="0"> {
                m.inner.Remove(key)
        }</span>
        <span class="cov8" title="1">return newValue</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package bimap

import (
        "iter"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
)

// ImmutableBiMap is an immutable bidirectional map where both keys and values are unique.
type ImmutableBiMap[K any, V any] struct {
        internalMap ds.Map[K, V]
        reverseMap  ds.Map[V, K]
}

// Reverse returns a view of this bimap with keys and values swapped.
func (m *ImmutableBiMap[K, V]) Reverse() ds.BiMap[V, K] <span class="cov8" title="1">{
        return &amp;ImmutableBiMap[V, K]{
                internalMap: m.reverseMap,
                reverseMap:  m.internalMap,
        }
}</span>

// Unfreeze returns a mutable copy of this bimap.
func (m *ImmutableBiMap[K, V]) Unfreeze() ds.MutableBiMap[K, V] <span class="cov8" title="1">{
        return &amp;MutableBiMap[K, V]{
                internalMap: m.internalMap.Unfreeze(),
                reverseMap:  m.reverseMap.Unfreeze(),
        }
}</span>

// ContainsKey returns true if the key exists in the bimap.
func (m *ImmutableBiMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        return m.internalMap.ContainsKey(key)
}</span>

// Get returns the value associated with the key and whether it exists.
func (m *ImmutableBiMap[K, V]) Get(l K) (V, bool) <span class="cov8" title="1">{
        return m.internalMap.Get(l)
}</span>

// Size returns the number of entries in the bimap.
func (m *ImmutableBiMap[_, _]) Size() int <span class="cov8" title="1">{
        return m.internalMap.Size()
}</span>

// IsEmpty returns true if the bimap contains no entries.
func (m *ImmutableBiMap[_, _]) IsEmpty() bool <span class="cov8" title="1">{
        return m.internalMap.IsEmpty()
}</span>

// Retain returns a new bimap containing only entries with the specified keys.
func (m *ImmutableBiMap[K, V]) Retain(keys ...K) ds.BiMap[K, V] <span class="cov8" title="1">{
        retained := m.internalMap.Retain(keys...).Unfreeze()
        reverseMap := m.reverseMap.Clone().Unfreeze()
        reverseMap.Clear()
        for key, value := range retained.Iter() </span><span class="cov8" title="1">{
                reverseMap.Put(value, key)
        }</span>
        <span class="cov8" title="1">return &amp;ImmutableBiMap[K, V]{
                internalMap: retained.Freeze(),
                reverseMap:  reverseMap.Freeze(),
        }</span>
}

// Filter returns a new bimap containing only entries where the predicate returns true.
func (m *ImmutableBiMap[K, V]) Filter(predicate func(key K) bool) ds.BiMap[K, V] <span class="cov8" title="1">{
        return &amp;ImmutableBiMap[K, V]{
                internalMap: m.internalMap.Filter(predicate),
                reverseMap: m.reverseMap.Filter(func(value V) bool </span><span class="cov8" title="1">{
                        for k := range m.internalMap.Iter() </span><span class="cov8" title="1">{
                                if predicate(k) </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                        <span class="cov8" title="1">return false</span>
                }),
        }
}

// Keys returns a slice of all keys in the bimap.
func (m *ImmutableBiMap[K, _]) Keys() []K <span class="cov8" title="1">{
        return m.internalMap.Keys()
}</span>

// Values returns a slice of all values in the bimap.
func (m *ImmutableBiMap[_, V]) Values() []V <span class="cov8" title="1">{
        return m.reverseMap.Keys()
}</span>

// Iter returns an iterator over all key-value pairs.
func (m *ImmutableBiMap[K, V]) Iter() iter.Seq2[K, V] <span class="cov8" title="1">{
        return m.internalMap.Iter()
}</span>

// Clone returns a copy of this bimap.
func (m *ImmutableBiMap[K, V]) Clone() ds.BiMap[K, V] <span class="cov8" title="1">{
        return &amp;ImmutableBiMap[K, V]{
                internalMap: m.internalMap.Clone(),
                reverseMap:  m.reverseMap.Clone(),
        }
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">// Package bimap provides bidirectional map implementations for the datastructures interfaces.
package bimap

import (
        "iter"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
)

// MutableBiMap is a mutable bidirectional map where both keys and values are unique.
// It maintains two internal maps for efficient lookup in both directions.
type MutableBiMap[K any, V any] struct {
        internalMap ds.MutableMap[K, V]
        reverseMap  ds.MutableMap[V, K]
}

// NewMutableBiMap creates a new mutable bidirectional map using the provided empty maps.
// Both emptyKey and emptyValue must be empty maps; returns an error if they are not.
func NewMutableBiMap[K any, V any](emptyKey ds.MutableMap[K, V], emptyValue ds.MutableMap[V, K]) (ds.MutableBiMap[K, V], error) <span class="cov8" title="1">{
        if !emptyKey.IsEmpty() </span><span class="cov8" title="1">{
                return nil, ds.ErrInvalidSize.WithMessage("key is not empty")
        }</span>
        <span class="cov8" title="1">if !emptyValue.IsEmpty() </span><span class="cov0" title="0">{
                return nil, ds.ErrInvalidSize.WithMessage("value is not empty")
        }</span>
        <span class="cov8" title="1">return &amp;MutableBiMap[K, V]{
                internalMap: emptyKey,
                reverseMap:  emptyValue,
        }, nil</span>
}

// Reverse returns a view of this bimap with keys and values swapped.
// The returned bimap shares storage with the original.
func (m *MutableBiMap[K, V]) Reverse() ds.MutableBiMap[V, K] <span class="cov8" title="1">{
        return &amp;MutableBiMap[V, K]{
                internalMap: m.reverseMap,
                reverseMap:  m.internalMap,
        }
}</span>

// Freeze returns an immutable snapshot of this bimap.
func (m *MutableBiMap[K, V]) Freeze() ds.BiMap[K, V] <span class="cov8" title="1">{
        return &amp;ImmutableBiMap[K, V]{
                internalMap: m.internalMap.Freeze(),
                reverseMap:  m.reverseMap.Freeze(),
        }
}</span>

// ContainsKey returns true if the key exists in the bimap.
func (m *MutableBiMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        return m.internalMap.ContainsKey(key)
}</span>

// Get returns the value associated with the key and whether it exists.
func (m *MutableBiMap[K, V]) Get(l K) (V, bool) <span class="cov8" title="1">{
        return m.internalMap.Get(l)
}</span>

// Retain returns a new bimap containing only entries with the specified keys.
func (m *MutableBiMap[K, V]) Retain(keys ...K) ds.MutableBiMap[K, V] <span class="cov8" title="1">{
        retained := m.internalMap.Retain(keys...)
        reverseMap := m.reverseMap.Clone()
        reverseMap.Clear()
        for key, value := range retained.Iter() </span><span class="cov8" title="1">{
                reverseMap.Put(value, key)
        }</span>
        <span class="cov8" title="1">return &amp;MutableBiMap[K, V]{
                internalMap: retained,
                reverseMap:  reverseMap,
        }</span>
}

// Filter returns a new bimap containing only entries where the predicate returns true.
func (m *MutableBiMap[K, V]) Filter(predicate func(key K) bool) ds.MutableBiMap[K, V] <span class="cov8" title="1">{
        return &amp;MutableBiMap[K, V]{
                internalMap: m.internalMap.Filter(predicate),
                reverseMap: m.reverseMap.Filter(func(value V) bool </span><span class="cov8" title="1">{
                        for k := range m.internalMap.Iter() </span><span class="cov8" title="1">{
                                if predicate(k) </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                        <span class="cov8" title="1">return false</span>
                }),
        }
}

// Put adds or updates a key-value pair in the bimap.
func (m *MutableBiMap[K, V]) Put(l K, r V) <span class="cov8" title="1">{
        _, _ = m.TryPut(l, r)
}</span>

// TryPut adds or updates a key-value pair, returning whether a value was replaced and the old value.
// If the key already existed, the old value is removed from the reverse map.
func (m *MutableBiMap[K, V]) TryPut(l K, r V) (replaced bool, oldValue V) <span class="cov8" title="1">{
        replaced, oldValue = m.internalMap.TryPut(l, r)
        if replaced </span><span class="cov8" title="1">{
                // Remove old value from reverse map since it's no longer mapped
                m.reverseMap.Remove(oldValue)
        }</span>
        <span class="cov8" title="1">_, _ = m.reverseMap.TryPut(r, l)
        return replaced, oldValue</span>
}

// Clear removes all entries from the bimap.
func (m *MutableBiMap[_, _]) Clear() <span class="cov8" title="1">{
        m.internalMap.Clear()
        m.reverseMap.Clear()
}</span>

// Size returns the number of entries in the bimap.
func (m *MutableBiMap[_, _]) Size() int <span class="cov8" title="1">{
        return m.internalMap.Size()
}</span>

// IsEmpty returns true if the bimap contains no entries.
func (m *MutableBiMap[_, _]) IsEmpty() bool <span class="cov8" title="1">{
        return m.internalMap.IsEmpty()
}</span>

// Remove deletes the entry with the given key from the bimap.
func (m *MutableBiMap[K, V]) Remove(l K) <span class="cov8" title="1">{
        m.TryRemove(l)
}</span>

// TryRemove deletes the entry with the given key, returning whether it existed and its value.
func (m *MutableBiMap[K, V]) TryRemove(l K) (removed bool, r V) <span class="cov8" title="1">{
        removed, r = m.internalMap.TryRemove(l)
        if removed </span><span class="cov8" title="1">{
                _, _ = m.reverseMap.TryRemove(r)
        }</span>
        <span class="cov8" title="1">return removed, r</span>
}

// Keys returns a slice of all keys in the bimap.
func (m *MutableBiMap[K, _]) Keys() []K <span class="cov8" title="1">{
        return m.internalMap.Keys()
}</span>

// Values returns a slice of all values in the bimap.
func (m *MutableBiMap[_, V]) Values() []V <span class="cov8" title="1">{
        return m.reverseMap.Keys()
}</span>

// Iter returns an iterator over all key-value pairs.
func (m *MutableBiMap[K, V]) Iter() iter.Seq2[K, V] <span class="cov8" title="1">{
        return m.internalMap.Iter()
}</span>

// Clone returns a mutable copy of this bimap.
func (m *MutableBiMap[K, V]) Clone() ds.MutableBiMap[K, V] <span class="cov8" title="1">{
        return &amp;MutableBiMap[K, V]{
                internalMap: m.internalMap.Clone(),
                reverseMap:  m.reverseMap.Clone(),
        }
}</span>
</pre>
		
		<pre class="file" id="file123" style="display: none">package datastructures

import (
        "encoding/binary"
        "hash/fnv"
)

// HashCode represents a 64-bit hash code.
type HashCode uint64

// Combine combines the current HashCode with additional HashCodes and returns a new HashCode.
func (hc HashCode) Combine(xs ...HashCode) HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        h.Write(hc.Bytes())
        for _, x := range xs </span><span class="cov0" title="0">{
                h.Write(x.Bytes())
        }</span>
        <span class="cov0" title="0">return HashCode(h.Sum64())</span>
}

// Bytes returns the byte representation of the HashCode in little-endian order.
func (hc HashCode) Bytes() []byte <span class="cov0" title="0">{
        return binary.LittleEndian.AppendUint64(nil, uint64(hc))
}</span>

// DeriveHashCode derives a HashCode from one or more byte slices.
func DeriveHashCode[T ~[]byte](xs ...T) HashCode <span class="cov0" title="0">{
        h := fnv.New64a()
        for _, x := range xs </span><span class="cov0" title="0">{
                h.Write(x)
        }</span>
        <span class="cov0" title="0">return HashCode(h.Sum64())</span>
}

// Equatable represents a type that can be compared for equality.
type Equatable[T any] interface {
        // Equal checks if the receiver is equal to rhs.
        Equal(rhs T) bool
}

// Clonable represents a type that can be cloned.
type Clonable[T any] interface {
        // Clone creates and returns a deep copy of the receiver.
        Clone() T
}

// Hashable represents a type that can be hashed and compared for equality.
type Hashable[T any] interface {
        Equatable[T]
        // HashCode returns the hash code of the receiver.
        HashCode() HashCode
}
</pre>
		
		<pre class="file" id="file124" style="display: none">// Package hashmap provides hash-based map implementations for the datastructures interfaces.
package hashmap

import (
        "iter"
        "maps"
        "slices"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
)

// NativeMap is a type alias for Go's built-in map with additional methods
// to satisfy common map interface requirements.
type NativeMap[K comparable, V any] map[K]V

// Get returns the value associated with the key and whether it exists.
func (m NativeMap[K, V]) Get(key K) (value V, exists bool) <span class="cov8" title="1">{
        v, exists := m[key]
        return v, exists
}</span>

// ContainsKey returns true if the key exists in the map.
func (m NativeMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        _, exists := m.Get(key)
        return exists
}</span>

// Put adds or updates a key-value pair in the map.
func (m NativeMap[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        _, _ = m.TryPut(key, value)
}</span>

// TryPut adds or updates a key-value pair, returning whether a value was replaced and the old value.
func (m NativeMap[K, V]) TryPut(key K, newValue V) (replaced bool, oldValue V) <span class="cov8" title="1">{
        oldV, oldExists := m[key]
        m[key] = newValue
        return oldExists, oldV
}</span>

// Clear removes all entries from the map.
func (m NativeMap[K, V]) Clear() <span class="cov8" title="1">{
        clear(m)
}</span>

// Size returns the number of entries in the map.
func (m NativeMap[K, V]) Size() int <span class="cov8" title="1">{
        return len(m)
}</span>

// IsEmpty returns true if the map contains no entries.
func (m NativeMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return len(m) == 0
}</span>

// Remove deletes the entry with the given key from the map.
func (m NativeMap[K, V]) Remove(key K) <span class="cov8" title="1">{
        _, _ = m.TryRemove(key)
}</span>

// TryRemove deletes the entry with the given key, returning whether it existed and its value.
func (m NativeMap[K, V]) TryRemove(key K) (removed bool, removedValue V) <span class="cov8" title="1">{
        oldValue, oldExists := m[key]
        delete(m, key)
        return oldExists, oldValue
}</span>

// Keys returns a slice of all keys in the map.
func (m NativeMap[K, V]) Keys() []K <span class="cov8" title="1">{
        return slices.AppendSeq(make([]K, 0, len(m)), maps.Keys(m))
}</span>

// Values returns a slice of all values in the map.
func (m NativeMap[K, V]) Values() []V <span class="cov8" title="1">{
        return slices.AppendSeq(make([]V, 0, len(m)), maps.Values(m))
}</span>

// Iter returns an iterator over all key-value pairs.
func (m NativeMap[K, V]) Iter() iter.Seq2[K, V] <span class="cov8" title="1">{
        return func(yield func(K, V) bool) </span><span class="cov8" title="1">{
                for k, v := range m </span><span class="cov8" title="1">{
                        if !yield(k, v) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Enumerate returns an iterator with index and MapEntry pairs.
func (m NativeMap[K, V]) Enumerate() iter.Seq2[int, ds.MapEntry[K, V]] <span class="cov8" title="1">{
        return func(yield func(int, ds.MapEntry[K, V]) bool) </span><span class="cov8" title="1">{
                i := 0
                for k, v := range m </span><span class="cov8" title="1">{
                        if !yield(i, ds.MapEntry[K, V]{Key: k, Value: v}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">i++</span>
                }
        }
}

// ImmutableComparableMap is an immutable hash map for comparable key types.
type ImmutableComparableMap[K comparable, V any] struct {
        inner NativeMap[K, V]
}

// NewImmutableComparable creates a new immutable map from the given entries.
func NewImmutableComparable[K comparable, V any](xs ...ds.MapEntry[K, V]) ds.Map[K, V] <span class="cov8" title="1">{
        out := make(NativeMap[K, V])
        for _, entry := range xs </span><span class="cov8" title="1">{
                out[entry.Key] = entry.Value
        }</span>
        <span class="cov8" title="1">return &amp;ImmutableComparableMap[K, V]{inner: out}</span>
}

// NewImmutableComparableFromNativeLike creates a new immutable map by copying from a native Go map.
func NewImmutableComparableFromNativeLike[K comparable, V any, T ~map[K]V](arg T) ds.Map[K, V] <span class="cov8" title="1">{
        out := make(NativeMap[K, V])
        if arg != nil </span><span class="cov8" title="1">{
                maps.Copy(out, arg)
        }</span>
        <span class="cov8" title="1">return &amp;ImmutableComparableMap[K, V]{inner: out}</span>
}

// CollectToImmutableComparable creates a new immutable map from parallel slices of keys and values.
// Returns an error if the slices have different lengths.
func CollectToImmutableComparable[K comparable, V any](xs []K, ys []V) (ds.Map[K, V], error) <span class="cov8" title="1">{
        if len(xs) == 0 &amp;&amp; len(ys) == 0 </span><span class="cov8" title="1">{
                return &amp;ImmutableComparableMap[K, V]{inner: make(NativeMap[K, V])}, nil
        }</span>
        <span class="cov8" title="1">if len(xs) != len(ys) </span><span class="cov0" title="0">{
                return nil, ds.ErrInvalidSize.WithMessage("xs and ys must have the same length")
        }</span>
        <span class="cov8" title="1">out := make(NativeMap[K, V])
        for i, x := range xs </span><span class="cov8" title="1">{
                out[x] = ys[i]
        }</span>
        <span class="cov8" title="1">return &amp;ImmutableComparableMap[K, V]{inner: out}, nil</span>
}

// IsImmutable returns true as this is an immutable map.
func (ImmutableComparableMap[K, V]) IsImmutable() bool <span class="cov8" title="1">{
        return true
}</span>

// Unfreeze returns a mutable copy of this map.
func (m ImmutableComparableMap[K, V]) Unfreeze() ds.MutableMap[K, V] <span class="cov8" title="1">{
        return NewComparableFromNativeLike(m.inner)
}</span>

// Get returns the value associated with the key and whether it exists.
func (m ImmutableComparableMap[K, V]) Get(key K) (value V, exists bool) <span class="cov8" title="1">{
        return m.inner.Get(key)
}</span>

// Filter returns a new map containing only entries where the predicate returns true.
func (m ImmutableComparableMap[K, V]) Filter(predicate func(key K) bool) ds.Map[K, V] <span class="cov8" title="1">{
        result := make(NativeMap[K, V])
        for k, v := range m.inner </span><span class="cov8" title="1">{
                if predicate(k) </span><span class="cov8" title="1">{
                        result[k] = v
                }</span>
        }
        <span class="cov8" title="1">return &amp;ImmutableComparableMap[K, V]{inner: result}</span>
}

// Retain returns a new map containing only entries with the specified keys.
func (m ImmutableComparableMap[K, V]) Retain(keys ...K) ds.Map[K, V] <span class="cov8" title="1">{
        return m.Filter(func(key K) bool </span><span class="cov8" title="1">{
                for _, k := range keys </span><span class="cov8" title="1">{
                        if k == key </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        })
}

// ContainsKey returns true if the key exists in the map.
func (m ImmutableComparableMap[K, V]) ContainsKey(key K) bool <span class="cov0" title="0">{
        return m.inner.ContainsKey(key)
}</span>

// IsEmpty returns true if the map contains no entries.
func (m ImmutableComparableMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return m.Size() == 0
}</span>

// Size returns the number of entries in the map.
func (m ImmutableComparableMap[K, V]) Size() int <span class="cov8" title="1">{
        return m.inner.Size()
}</span>

// Keys returns a slice of all keys in the map.
func (m ImmutableComparableMap[K, V]) Keys() []K <span class="cov8" title="1">{
        return m.inner.Keys()
}</span>

// Values returns a slice of all values in the map.
func (m ImmutableComparableMap[K, V]) Values() []V <span class="cov0" title="0">{
        return m.inner.Values()
}</span>

// Clone returns a copy of this map.
func (m ImmutableComparableMap[K, V]) Clone() ds.Map[K, V] <span class="cov8" title="1">{
        return NewImmutableComparableFromNativeLike(m.inner)
}</span>

// Iter returns an iterator over all key-value pairs.
func (m ImmutableComparableMap[K, V]) Iter() iter.Seq2[K, V] <span class="cov8" title="1">{
        return m.inner.Iter()
}</span>

// Enumerate returns an iterator with index and MapEntry pairs.
func (m ImmutableComparableMap[K, V]) Enumerate() iter.Seq2[int, ds.MapEntry[K, V]] <span class="cov0" title="0">{
        return m.inner.Enumerate()
}</span>

// NewComparable creates a new mutable map from the given entries.
func NewComparable[K comparable, V any](xs ...ds.MapEntry[K, V]) *MutableComparableMap[K, V] <span class="cov8" title="1">{
        out := make(NativeMap[K, V])
        for _, entry := range xs </span><span class="cov8" title="1">{
                out[entry.Key] = entry.Value
        }</span>
        <span class="cov8" title="1">return &amp;MutableComparableMap[K, V]{out}</span>
}

// CollectToComparable creates a new mutable map from parallel slices of keys and values.
// Returns an error if the slices have different lengths.
func CollectToComparable[K comparable, V any](xs []K, ys []V) (ds.MutableMap[K, V], error) <span class="cov8" title="1">{
        if len(xs) == 0 &amp;&amp; len(ys) == 0 </span><span class="cov8" title="1">{
                return &amp;MutableComparableMap[K, V]{make(NativeMap[K, V])}, nil
        }</span>
        <span class="cov8" title="1">if len(xs) != len(ys) </span><span class="cov8" title="1">{
                return nil, ds.ErrInvalidSize.WithMessage("xs and ys must have the same length")
        }</span>
        <span class="cov8" title="1">out := make(NativeMap[K, V])
        for i, x := range xs </span><span class="cov8" title="1">{
                out[x] = ys[i]
        }</span>
        <span class="cov8" title="1">return &amp;MutableComparableMap[K, V]{out}, nil</span>
}

// NewComparableFromNativeLike creates a new mutable map by copying from a native Go map.
func NewComparableFromNativeLike[K comparable, V any, T ~map[K]V](arg T) ds.MutableMap[K, V] <span class="cov8" title="1">{
        out := make(NativeMap[K, V])
        if arg == nil </span><span class="cov0" title="0">{
                return &amp;MutableComparableMap[K, V]{out}
        }</span>
        <span class="cov8" title="1">maps.Copy(out, arg)
        return &amp;MutableComparableMap[K, V]{out}</span>
}

// MutableComparableMap is a mutable hash map for comparable key types.
type MutableComparableMap[K comparable, V any] struct {
        NativeMap[K, V]
}

// IsImmutable returns false as this is a mutable map.
func (MutableComparableMap[K, V]) IsImmutable() bool <span class="cov8" title="1">{
        return false
}</span>

// Freeze returns an immutable snapshot of this map.
func (m MutableComparableMap[K, V]) Freeze() ds.Map[K, V] <span class="cov8" title="1">{
        return &amp;ImmutableComparableMap[K, V]{
                inner: maps.Clone(m.NativeMap),
        }
}</span>

// Clone returns a mutable copy of this map.
func (m MutableComparableMap[K, V]) Clone() ds.MutableMap[K, V] <span class="cov8" title="1">{
        return &amp;MutableComparableMap[K, V]{maps.Clone(m.NativeMap)}
}</span>

// Filter returns a new map containing only entries where the predicate returns true.
func (m MutableComparableMap[K, V]) Filter(predicate func(key K) bool) ds.MutableMap[K, V] <span class="cov8" title="1">{
        result := make(NativeMap[K, V])
        for k, v := range m.NativeMap </span><span class="cov8" title="1">{
                if predicate(k) </span><span class="cov8" title="1">{
                        result[k] = v
                }</span>
        }
        <span class="cov8" title="1">return &amp;MutableComparableMap[K, V]{result}</span>
}

// Retain returns a new map containing only entries with the specified keys.
func (m MutableComparableMap[K, V]) Retain(keys ...K) ds.MutableMap[K, V] <span class="cov8" title="1">{
        return m.Filter(func(key K) bool </span><span class="cov8" title="1">{
                for _, k := range keys </span><span class="cov8" title="1">{
                        if k == key </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        })
}

// ToNative returns a copy of the map data as a native Go map.
func (m *MutableComparableMap[K, V]) ToNative() map[K]V <span class="cov0" title="0">{
        out := make(map[K]V)
        for k, v := range m.NativeMap </span><span class="cov0" title="0">{
                out[k] = v
        }</span>
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package hashmap

import (
        "iter"
        "sync"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
)

// ConcurrentMap is a thread-safe wrapper around a MutableMap.
// All operations are protected by a read-write mutex.
type ConcurrentMap[K any, V any] struct {
        inner ds.MutableMap[K, V]
        mu    sync.RWMutex
}

// NewConcurrentMap creates a new thread-safe map wrapping the given mutable map.
func NewConcurrentMap[K any, V any](innerMap ds.MutableMap[K, V]) ds.ConcurrentMap[K, V] <span class="cov8" title="1">{
        return &amp;ConcurrentMap[K, V]{
                inner: innerMap,
                mu:    sync.RWMutex{},
        }
}</span>

// Get returns the value associated with the key and whether it exists.
func (m *ConcurrentMap[K, V]) Get(key K) (value V, exists bool) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Get(key)
}</span>

// Retain returns a new concurrent map containing only entries with the specified keys.
func (m *ConcurrentMap[K, V]) Retain(keys ...K) ds.ConcurrentMap[K, V] <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return &amp;ConcurrentMap[K, V]{
                inner: m.inner.Retain(keys...),
                mu:    sync.RWMutex{},
        }
}</span>

// Filter returns a new concurrent map containing only entries where the predicate returns true.
func (m *ConcurrentMap[K, V]) Filter(predicate func(key K) bool) ds.ConcurrentMap[K, V] <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        return &amp;ConcurrentMap[K, V]{
                inner: m.inner.Filter(predicate),
                mu:    sync.RWMutex{},
        }
}</span>

// ContainsKey returns true if the key exists in the map.
func (m *ConcurrentMap[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.ContainsKey(key)
}</span>

// Put adds or updates a key-value pair in the map.
func (m *ConcurrentMap[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        _, _ = m.inner.TryPut(key, value)
}</span>

// TryPut adds or updates a key-value pair, returning whether a value was replaced and the old value.
func (m *ConcurrentMap[K, V]) TryPut(key K, newValue V) (replaced bool, oldValue V) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.inner.TryPut(key, newValue)
}</span>

// Clear removes all entries from the map.
func (m *ConcurrentMap[K, V]) Clear() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.inner.Clear()
}</span>

// Clone returns a new concurrent map with a copy of the data.
func (m *ConcurrentMap[K, V]) Clone() ds.ConcurrentMap[K, V] <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return NewConcurrentMap(m.inner.Clone())
}</span>

// Size returns the number of entries in the map.
func (m *ConcurrentMap[K, V]) Size() int <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Size()
}</span>

// IsEmpty returns true if the map contains no entries.
func (m *ConcurrentMap[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.IsEmpty()
}</span>

// Remove deletes the entry with the given key from the map.
func (m *ConcurrentMap[K, V]) Remove(key K) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        _, _ = m.inner.TryRemove(key)
}</span>

// TryRemove deletes the entry with the given key, returning whether it existed and its value.
func (m *ConcurrentMap[K, V]) TryRemove(key K) (removed bool, removedValue V) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.inner.TryRemove(key)
}</span>

// Iter returns an iterator over all key-value pairs.
func (m *ConcurrentMap[K, V]) Iter() iter.Seq2[K, V] <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Iter()
}</span>

// Enumerate returns an iterator with index and MapEntry pairs.
func (m *ConcurrentMap[K, V]) Enumerate() iter.Seq2[int, ds.MapEntry[K, V]] <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Enumerate()
}</span>

// Keys returns a slice of all keys in the map.
func (m *ConcurrentMap[K, V]) Keys() []K <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Keys()
}</span>

// Values returns a slice of all values in the map.
func (m *ConcurrentMap[K, V]) Values() []V <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.inner.Values()
}</span>

// Compute atomically computes a new value based on the key's current mapping.
// The remappingFunction receives the key, current value (if any), and existence flag,
// returning the new value and whether to store it (false removes the key).
func (m *ConcurrentMap[K, V]) Compute(key K, remappingFunction func(key K, oldVal V, ifExist bool) (V, bool)) V <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        oldValue, oldExist := m.inner.Get(key)

        newValue, shouldStore := remappingFunction(key, oldValue, oldExist)

        if shouldStore </span><span class="cov8" title="1">{
                m.inner.Put(key, newValue)
        }</span> else<span class="cov8" title="1"> {
                m.inner.Remove(key)
        }</span>
        <span class="cov8" title="1">return newValue</span>
}

// ComputeIfAbsent atomically computes a value only if the key is not present.
// The mappingFunction returns the value to store and whether to store it.
// If the key exists, returns the current value without calling mappingFunction.
func (m *ConcurrentMap[K, V]) ComputeIfAbsent(key K, mappingFunction func(key K) (V, bool)) V <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        oldValue, oldExist := m.inner.Get(key)

        if oldExist </span><span class="cov8" title="1">{
                return oldValue
        }</span>

        <span class="cov8" title="1">newValue, shouldStore := mappingFunction(key)

        if shouldStore </span><span class="cov8" title="1">{
                m.inner.Put(key, newValue)
        }</span>

        <span class="cov8" title="1">return newValue</span>
}

// ComputeIfPresent atomically computes a new value only if the key is present.
// The remappingFunction returns the new value and whether to keep it (false removes the key).
// If the key is absent, returns the zero value without calling remappingFunction.
func (m *ConcurrentMap[K, V]) ComputeIfPresent(key K, remappingFunction func(key K, oldVal V) (V, bool)) V <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        oldValue, oldExist := m.inner.Get(key)

        if !oldExist </span><span class="cov8" title="1">{
                return oldValue
        }</span>

        <span class="cov8" title="1">newValue, shouldStore := remappingFunction(key, oldValue)

        if shouldStore </span><span class="cov8" title="1">{
                m.inner.Put(key, newValue)
        }</span> else<span class="cov0" title="0"> {
                m.inner.Remove(key)
        }</span>
        <span class="cov8" title="1">return newValue</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package hashmap

import (
        "iter"

        "github.com/bronlabs/bron-crypto/pkg/base"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
)

// HashableEntry represents a key-value pair where the key implements Hashable.
type HashableEntry[K ds.Hashable[K], V any] ds.MapEntry[K, V]

// HashableMapping is the internal storage for hashable maps, using hash codes as bucket keys.
type HashableMapping[K ds.Hashable[K], V any] map[base.HashCode][]*HashableEntry[K, V]

// TryPut adds or updates a key-value pair, returning whether a value was replaced and the old value.
func (m HashableMapping[K, V]) TryPut(key K, newValue V) (replaced bool, oldValue V) <span class="cov8" title="1">{
        hashCode := key.HashCode()
        entries, exists := m[hashCode]
        if !exists </span><span class="cov8" title="1">{
                m[hashCode] = []*HashableEntry[K, V]{
                        {
                                Key:   key,
                                Value: newValue,
                        },
                }
                return false, *new(V)
        }</span>

        <span class="cov8" title="1">for _, v := range entries </span><span class="cov8" title="1">{
                if v.Key.Equal(key) </span><span class="cov8" title="1">{
                        oldValue := v.Value
                        v.Value = newValue
                        return true, oldValue
                }</span>
        }

        <span class="cov8" title="1">m[hashCode] = append(m[hashCode], &amp;HashableEntry[K, V]{
                Key:   key,
                Value: newValue,
        })
        return false, *new(V)</span>
}

// TryRemove deletes the entry with the given key, returning whether it existed and its value.
func (m HashableMapping[K, V]) TryRemove(key K) (removed bool, removedValue V) <span class="cov8" title="1">{
        var nilValue V

        entries, ok := m[key.HashCode()]
        if !ok </span><span class="cov8" title="1">{
                return false, nilValue
        }</span>

        <span class="cov8" title="1">idx := -1
        for i, e := range entries </span><span class="cov8" title="1">{
                if e.Key.Equal(key) </span><span class="cov8" title="1">{
                        idx = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if idx == -1 </span><span class="cov8" title="1">{
                return false, nilValue
        }</span>

        <span class="cov8" title="1">removedValue = entries[idx].Value
        entries[idx] = entries[len(entries)-1]
        newEntries := entries[:len(entries)-1]
        if len(newEntries) == 0 </span><span class="cov8" title="1">{
                delete(m, key.HashCode())
        }</span> else<span class="cov8" title="1"> {
                m[key.HashCode()] = newEntries
        }</span>
        <span class="cov8" title="1">return true, removedValue</span>
}

// HashableTrait provides common functionality for hashable map implementations.
type HashableTrait[K ds.Hashable[K], V any] struct {
        inner HashableMapping[K, V]
}

// Get returns the value associated with the key and whether it exists.
func (m HashableTrait[K, V]) Get(key K) (value V, exists bool) <span class="cov8" title="1">{
        hashCode := key.HashCode()
        values, ok := m.inner[hashCode]
        if !ok </span><span class="cov8" title="1">{
                return *new(V), false
        }</span>
        <span class="cov8" title="1">for _, e := range values </span><span class="cov8" title="1">{
                if e.Key.Equal(key) </span><span class="cov8" title="1">{
                        return e.Value, true
                }</span>
        }

        <span class="cov8" title="1">return *new(V), false</span>
}

// ContainsKey returns true if the key exists in the map.
func (m HashableTrait[K, V]) ContainsKey(key K) bool <span class="cov8" title="1">{
        for _, e := range m.inner[key.HashCode()] </span><span class="cov8" title="1">{
                if key.Equal(e.Key) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsEmpty returns true if the map contains no entries.
func (m HashableTrait[K, V]) IsEmpty() bool <span class="cov8" title="1">{
        return len(m.inner) == 0
}</span>

// Size returns the number of entries in the map.
func (m HashableTrait[K, V]) Size() int <span class="cov8" title="1">{
        size := 0
        for _, v := range m.inner </span><span class="cov8" title="1">{
                size += len(v)
        }</span>
        <span class="cov8" title="1">return size</span>
}

// Keys returns a slice of all keys in the map.
func (m HashableTrait[K, V]) Keys() []K <span class="cov8" title="1">{
        var keys []K
        keys = make([]K, 0, m.Size())
        for _, entries := range m.inner </span><span class="cov8" title="1">{
                for _, entry := range entries </span><span class="cov8" title="1">{
                        keys = append(keys, entry.Key)
                }</span>
        }
        <span class="cov8" title="1">return keys</span>
}

// Values returns a slice of all values in the map.
func (m HashableTrait[K, V]) Values() []V <span class="cov8" title="1">{
        result := make([]V, 0, m.Size())
        for _, value := range m.Iter() </span><span class="cov8" title="1">{
                result = append(result, value)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Iter returns an iterator over all key-value pairs.
func (m HashableTrait[K, V]) Iter() iter.Seq2[K, V] <span class="cov8" title="1">{
        keys := m.Keys()
        return func(yield func(K, V) bool) </span><span class="cov8" title="1">{
                for _, key := range keys </span><span class="cov8" title="1">{
                        value, _ := m.Get(key)
                        if !yield(key, value) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Enumerate returns an iterator with index and MapEntry pairs.
func (m HashableTrait[K, V]) Enumerate() iter.Seq2[int, ds.MapEntry[K, V]] <span class="cov8" title="1">{
        return func(yield func(int, ds.MapEntry[K, V]) bool) </span><span class="cov8" title="1">{
                i := 0
                for key, value := range m.Iter() </span><span class="cov8" title="1">{
                        if !yield(i, ds.MapEntry[K, V]{Key: key, Value: value}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">i++</span>
                }
        }
}

// NewImmutableHashable creates a new empty immutable map for hashable key types.
func NewImmutableHashable[K ds.Hashable[K], V any]() ds.Map[K, V] <span class="cov8" title="1">{
        return &amp;ImmutableHashableMap[K, V]{
                HashableTrait[K, V]{
                        inner: make(HashableMapping[K, V]),
                },
        }
}</span>

// CollectToImmutableHashable creates a new immutable map from parallel slices of keys and values.
// Returns an error if the slices have different lengths.
func CollectToImmutableHashable[K ds.Hashable[K], V any](xs []K, ys []V) (ds.Map[K, V], error) <span class="cov8" title="1">{
        m, err := CollectToHashable(xs, ys)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return m.Freeze(), nil</span>
}

// ImmutableHashableMap is an immutable hash map for hashable key types.
type ImmutableHashableMap[K ds.Hashable[K], V any] struct {
        HashableTrait[K, V]
}

// IsImmutable returns true as this is an immutable map.
func (ImmutableHashableMap[K, V]) IsImmutable() bool <span class="cov8" title="1">{
        return true
}</span>

// Unfreeze returns a mutable copy of this map.
func (m ImmutableHashableMap[K, V]) Unfreeze() ds.MutableMap[K, V] <span class="cov8" title="1">{
        return &amp;MutableHashableMap[K, V]{
                HashableTrait[K, V]{
                        inner: m.inner,
                },
        }
}</span>

// Clone returns a copy of this map.
func (m ImmutableHashableMap[K, V]) Clone() ds.Map[K, V] <span class="cov8" title="1">{
        inner := make(HashableMapping[K, V])
        for code, entries := range m.inner </span><span class="cov8" title="1">{
                inner[code] = make([]*HashableEntry[K, V], len(entries))
                for i, e := range entries </span><span class="cov8" title="1">{
                        inner[code][i] = &amp;HashableEntry[K, V]{
                                Key:   e.Key,
                                Value: e.Value,
                        }
                }</span>
        }
        <span class="cov8" title="1">return &amp;ImmutableHashableMap[K, V]{
                HashableTrait[K, V]{
                        inner: inner,
                },
        }</span>
}

// Filter returns a new map containing only entries where the predicate returns true.
func (m ImmutableHashableMap[K, V]) Filter(predicate func(key K) bool) ds.Map[K, V] <span class="cov8" title="1">{
        inner := make(HashableMapping[K, V])
        for _, entries := range m.inner </span><span class="cov8" title="1">{
                for _, e := range entries </span><span class="cov8" title="1">{
                        if predicate(e.Key) </span><span class="cov8" title="1">{
                                inner.TryPut(e.Key, e.Value)
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;ImmutableHashableMap[K, V]{
                HashableTrait[K, V]{
                        inner: inner,
                },
        }</span>
}

// Retain returns a new map containing only entries with the specified keys.
func (m ImmutableHashableMap[K, V]) Retain(keys ...K) ds.Map[K, V] <span class="cov8" title="1">{
        return m.Filter(func(key K) bool </span><span class="cov8" title="1">{
                for _, k := range keys </span><span class="cov8" title="1">{
                        if k.Equal(key) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        })
}

// NewHashable creates a new empty mutable map for hashable key types.
func NewHashable[K ds.Hashable[K], V any]() ds.MutableMap[K, V] <span class="cov8" title="1">{
        return &amp;MutableHashableMap[K, V]{
                HashableTrait[K, V]{
                        inner: make(HashableMapping[K, V]),
                },
        }
}</span>

// CollectToHashable creates a new mutable map from parallel slices of keys and values.
// Returns an error if the slices have different lengths.
func CollectToHashable[K ds.Hashable[K], V any](xs []K, ys []V) (ds.MutableMap[K, V], error) <span class="cov8" title="1">{
        if len(xs) != len(ys) </span><span class="cov8" title="1">{
                return nil, ds.ErrInvalidSize.WithMessage("xs and ys must have the same length")
        }</span>
        <span class="cov8" title="1">m := NewHashable[K, V]()
        for i := range xs </span><span class="cov8" title="1">{
                m.Put(xs[i], ys[i])
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

// MutableHashableMap is a mutable hash map for hashable key types.
type MutableHashableMap[K ds.Hashable[K], V any] struct {
        HashableTrait[K, V]
}

// IsImmutable returns false as this is a mutable map.
func (MutableHashableMap[K, V]) IsImmutable() bool <span class="cov8" title="1">{
        return false
}</span>

// Freeze returns an immutable snapshot of this map.
func (m MutableHashableMap[K, V]) Freeze() ds.Map[K, V] <span class="cov8" title="1">{
        return &amp;ImmutableHashableMap[K, V]{
                HashableTrait[K, V]{
                        inner: m.inner,
                },
        }
}</span>

// Clone returns a mutable copy of this map.
func (m MutableHashableMap[K, V]) Clone() ds.MutableMap[K, V] <span class="cov8" title="1">{
        inner := make(HashableMapping[K, V])
        for code, entries := range m.inner </span><span class="cov8" title="1">{
                inner[code] = make([]*HashableEntry[K, V], len(entries))
                for i, e := range entries </span><span class="cov8" title="1">{
                        inner[code][i] = &amp;HashableEntry[K, V]{
                                Key:   e.Key,
                                Value: e.Value,
                        }
                }</span>
        }
        <span class="cov8" title="1">return &amp;MutableHashableMap[K, V]{
                HashableTrait[K, V]{
                        inner: inner,
                },
        }</span>
}

// Put adds or updates a key-value pair in the map.
func (m MutableHashableMap[K, V]) Put(key K, value V) <span class="cov8" title="1">{
        _, _ = m.TryPut(key, value)
}</span>

// TryPut adds or updates a key-value pair, returning whether a value was replaced and the old value.
func (m MutableHashableMap[K, V]) TryPut(key K, newValue V) (replaced bool, oldValue V) <span class="cov8" title="1">{
        return m.inner.TryPut(key, newValue)
}</span>

// Clear removes all entries from the map.
func (m MutableHashableMap[K, V]) Clear() <span class="cov8" title="1">{
        clear(m.inner)
}</span>

// Remove deletes the entry with the given key from the map.
func (m MutableHashableMap[K, V]) Remove(key K) <span class="cov8" title="1">{
        _, _ = m.TryRemove(key)
}</span>

// TryRemove deletes the entry with the given key, returning whether it existed and its value.
func (m MutableHashableMap[K, V]) TryRemove(key K) (removed bool, removedValue V) <span class="cov8" title="1">{
        return m.inner.TryRemove(key)
}</span>

// Filter returns a new map containing only entries where the predicate returns true.
func (m MutableHashableMap[K, V]) Filter(predicate func(key K) bool) ds.MutableMap[K, V] <span class="cov8" title="1">{
        inner := make(HashableMapping[K, V])
        for _, entries := range m.inner </span><span class="cov8" title="1">{
                for _, e := range entries </span><span class="cov8" title="1">{
                        if predicate(e.Key) </span><span class="cov8" title="1">{
                                inner.TryPut(e.Key, e.Value)
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;MutableHashableMap[K, V]{
                HashableTrait[K, V]{
                        inner: inner,
                },
        }</span>
}

// Retain returns a new map containing only entries with the specified keys.
func (m MutableHashableMap[K, V]) Retain(keys ...K) ds.MutableMap[K, V] <span class="cov8" title="1">{
        return m.Filter(func(key K) bool </span><span class="cov8" title="1">{
                for _, k := range keys </span><span class="cov8" title="1">{
                        if k.Equal(key) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        })
}
</pre>
		
		<pre class="file" id="file127" style="display: none">// Package hashset provides hash-based set implementations for the datastructures interfaces.
package hashset

import (
        "iter"
        "maps"
        "slices"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

type comparableMapping[K comparable] = map[K]struct{}

// NewComparable creates a new mutable set for comparable element types.
func NewComparable[E comparable](xs ...E) ds.MutableSet[E] <span class="cov8" title="1">{
        s := &amp;MutableComparableSet[E]{v: make(comparableMapping[E])}
        for _, x := range xs </span><span class="cov8" title="1">{
                s.v[x] = struct{}{}
        }</span>
        <span class="cov8" title="1">return s</span>
}

// MutableComparableSet is a mutable hash set for comparable element types.
type MutableComparableSet[E comparable] struct {
        v comparableMapping[E]
}

// Add adds an element to the set.
func (s *MutableComparableSet[E]) Add(e E) <span class="cov8" title="1">{
        s.v[e] = struct{}{}
}</span>

// AddAll adds multiple elements to the set.
func (s *MutableComparableSet[E]) AddAll(es ...E) <span class="cov8" title="1">{
        for _, e := range es </span><span class="cov8" title="1">{
                s.v[e] = struct{}{}
        }</span>
}

// Remove removes an element from the set.
func (s *MutableComparableSet[E]) Remove(e E) <span class="cov8" title="1">{
        delete(s.v, e)
}</span>

// RemoveAll removes multiple elements from the set.
func (s *MutableComparableSet[E]) RemoveAll(es ...E) <span class="cov8" title="1">{
        for _, e := range es </span><span class="cov8" title="1">{
                delete(s.v, e)
        }</span>
}

// Freeze returns an immutable snapshot of this set.
func (s *MutableComparableSet[E]) Freeze() ds.Set[E] <span class="cov8" title="1">{
        return &amp;ImmutableSet[E]{v: &amp;MutableComparableSet[E]{v: maps.Clone(s.v)}}
}</span>

// Clear removes all elements from the set.
func (s *MutableComparableSet[E]) Clear() <span class="cov8" title="1">{
        clear(s.v)
}</span>

// Contains returns true if the element is in the set.
func (s *MutableComparableSet[E]) Contains(e E) bool <span class="cov8" title="1">{
        _, exists := s.v[e]
        return exists
}</span>

// Clone returns a mutable copy of this set.
func (s *MutableComparableSet[E]) Clone() ds.MutableSet[E] <span class="cov8" title="1">{
        return &amp;MutableComparableSet[E]{v: maps.Clone(s.v)}
}</span>

// Equal returns true if both sets contain exactly the same elements.
func (s *MutableComparableSet[E]) Equal(other ds.MutableSet[E]) bool <span class="cov8" title="1">{
        return s.IsSubSet(other) &amp;&amp; other.IsSubSet(s)
}</span>

// Size returns the number of elements in the set.
func (s *MutableComparableSet[_]) Size() int <span class="cov8" title="1">{
        return len(s.v)
}</span>

// Cardinality returns the number of elements in the set.
func (s *MutableComparableSet[_]) Cardinality() int <span class="cov8" title="1">{
        return len(s.v)
}</span>

// IsEmpty returns true if the set contains no elements.
func (s *MutableComparableSet[_]) IsEmpty() bool <span class="cov8" title="1">{
        return len(s.v) == 0
}</span>

// Union returns a new set containing all elements from both sets.
func (s *MutableComparableSet[E]) Union(other ds.MutableSet[E]) ds.MutableSet[E] <span class="cov8" title="1">{
        out := s.Clone()
        out.AddAll(other.List()...)
        return out
}</span>

// Intersection returns a new set containing only elements present in both sets.
func (s *MutableComparableSet[E]) Intersection(other ds.MutableSet[E]) ds.MutableSet[E] <span class="cov8" title="1">{
        out := &amp;MutableComparableSet[E]{v: make(comparableMapping[E])}
        for k := range s.Iter() </span><span class="cov8" title="1">{
                if other.Contains(k) </span><span class="cov8" title="1">{
                        out.v[k] = struct{}{}
                }</span>
        }
        <span class="cov8" title="1">return out</span>
}

// Difference returns a new set containing elements in this set but not in the other.
func (s *MutableComparableSet[E]) Difference(other ds.MutableSet[E]) ds.MutableSet[E] <span class="cov8" title="1">{
        out := s.Clone()
        out.RemoveAll(other.List()...)
        return out
}</span>

// SymmetricDifference returns a new set containing elements in either set but not both.
func (s *MutableComparableSet[E]) SymmetricDifference(other ds.MutableSet[E]) ds.MutableSet[E] <span class="cov8" title="1">{
        return s.Union(other).Difference(s.Intersection(other))
}</span>

// SubSets returns all possible subsets of this set (power set).
func (s *MutableComparableSet[E]) SubSets() []ds.MutableSet[E] <span class="cov8" title="1">{
        result := make([]ds.MutableSet[E], 1&lt;&lt;s.Size())
        i := 0
        for subset := range s.IterSubSets() </span><span class="cov8" title="1">{
                result[i] = subset
                i++
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Iter returns an iterator over all elements in the set.
func (s *MutableComparableSet[E]) Iter() iter.Seq[E] <span class="cov8" title="1">{
        return func(yield func(E) bool) </span><span class="cov8" title="1">{
                for el := range s.v </span><span class="cov8" title="1">{
                        if !yield(el) </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
        }
}

// Iter2 returns an iterator with index and element pairs.
func (s *MutableComparableSet[E]) Iter2() iter.Seq2[int, E] <span class="cov8" title="1">{
        return func(yield func(int, E) bool) </span><span class="cov8" title="1">{
                i := 0
                for el := range s.v </span><span class="cov8" title="1">{
                        if !yield(i, el) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">i++</span>
                }
        }
}

// IsSubSet returns true if all elements of this set are in the other set.
func (s *MutableComparableSet[E]) IsSubSet(of ds.MutableSet[E]) bool <span class="cov8" title="1">{
        for k := range s.Iter() </span><span class="cov8" title="1">{
                if !of.Contains(k) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsProperSubSet returns true if this is a subset of other and they are not equal.
func (s *MutableComparableSet[E]) IsProperSubSet(of ds.MutableSet[E]) bool <span class="cov8" title="1">{
        return s.IsSubSet(of) &amp;&amp; !s.Equal(of)
}</span>

// IsSuperSet returns true if all elements of the other set are in this set.
func (s *MutableComparableSet[E]) IsSuperSet(of ds.MutableSet[E]) bool <span class="cov8" title="1">{
        for k := range of.Iter() </span><span class="cov8" title="1">{
                if _, exists := s.v[k]; !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsProperSuperSet returns true if this is a superset of other and they are not equal.
func (s *MutableComparableSet[E]) IsProperSuperSet(of ds.MutableSet[E]) bool <span class="cov8" title="1">{
        return s.IsSuperSet(of) &amp;&amp; !s.Equal(of)
}</span>

// IterSubSets returns an iterator over all possible subsets of this set.
func (s *MutableComparableSet[E]) IterSubSets() iter.Seq[ds.MutableSet[E]] <span class="cov8" title="1">{
        return func(yield func(ds.MutableSet[E]) bool) </span><span class="cov8" title="1">{
                list := s.List()
                for i := 0; i &lt;= s.Size(); i++ </span><span class="cov8" title="1">{
                        for comb := range sliceutils.Combinations(list, uint(i)) </span><span class="cov8" title="1">{
                                subset := NewComparable(comb...)
                                if !yield(subset) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

// List returns a slice of all elements in the set.
func (s *MutableComparableSet[E]) List() []E <span class="cov8" title="1">{
        return slices.AppendSeq(make([]E, 0, len(s.v)), maps.Keys(s.v))
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">package hashset

import (
        "iter"
        "sync"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

// ConcurrentSet is a thread-safe wrapper around a MutableSet.
// All operations are protected by a read-write mutex.
type ConcurrentSet[E any] struct {
        v  ds.MutableSet[E]
        mu sync.RWMutex
}

// NewConcurrentSet creates a new thread-safe set wrapping the given mutable set.
func NewConcurrentSet[E any](innerSet ds.MutableSet[E]) *ConcurrentSet[E] <span class="cov8" title="1">{
        return &amp;ConcurrentSet[E]{
                v:  innerSet,
                mu: sync.RWMutex{},
        }
}</span>

// Contains returns true if the element is in the set.
func (s *ConcurrentSet[E]) Contains(e E) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.Contains(e)
}</span>

// Add adds an element to the set.
func (s *ConcurrentSet[E]) Add(e E) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.v.Add(e)
}</span>

// AddAll adds multiple elements to the set.
func (s *ConcurrentSet[E]) AddAll(es ...E) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.v.AddAll(es...)
}</span>

// Remove removes an element from the set.
func (s *ConcurrentSet[E]) Remove(e E) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.v.Remove(e)
}</span>

// RemoveAll removes multiple elements from the set.
func (s *ConcurrentSet[E]) RemoveAll(es ...E) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.v.RemoveAll(es...)
}</span>

// Clear removes all elements from the set.
func (s *ConcurrentSet[E]) Clear() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.v.Clear()
}</span>

// Equal returns true if both sets contain exactly the same elements.
func (s *ConcurrentSet[E]) Equal(other ds.Set[E]) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.Equal(other.Unfreeze())
}</span>

// Size returns the number of elements in the set.
func (s *ConcurrentSet[_]) Size() int <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.Size()
}</span>

// Cardinality returns the number of elements in the set.
func (s *ConcurrentSet[_]) Cardinality() int <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.Cardinality()
}</span>

// IsEmpty returns true if the set contains no elements.
func (s *ConcurrentSet[_]) IsEmpty() bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.IsEmpty()
}</span>

// Union returns a new concurrent set containing all elements from both sets.
func (s *ConcurrentSet[E]) Union(other ds.Set[E]) ds.ConcurrentSet[E] <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return NewConcurrentSet(s.v.Union(other.Unfreeze()))
}</span>

// Intersection returns a new concurrent set containing only elements present in both sets.
func (s *ConcurrentSet[E]) Intersection(other ds.Set[E]) ds.ConcurrentSet[E] <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return NewConcurrentSet(s.v.Intersection(other.Unfreeze()))
}</span>

// Difference returns a new concurrent set containing elements in this set but not in the other.
func (s *ConcurrentSet[E]) Difference(other ds.Set[E]) ds.ConcurrentSet[E] <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return NewConcurrentSet(s.v.Difference(other.Unfreeze()))
}</span>

// SymmetricDifference returns a new concurrent set containing elements in either set but not both.
func (s *ConcurrentSet[E]) SymmetricDifference(other ds.Set[E]) ds.ConcurrentSet[E] <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return NewConcurrentSet(s.v.SymmetricDifference(other.Unfreeze()))
}</span>

// SubSets returns all possible subsets of this set (power set).
func (s *ConcurrentSet[E]) SubSets() []ds.Set[E] <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return sliceutils.Map(s.v.SubSets(), func(subset ds.MutableSet[E]) ds.Set[E] </span><span class="cov8" title="1">{
                return subset.Freeze()
        }</span>)
}

// IsSubSet returns true if all elements of this set are in the other set.
func (s *ConcurrentSet[E]) IsSubSet(other ds.Set[E]) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.IsSubSet(other.Unfreeze())
}</span>

// IsProperSubSet returns true if this is a subset of other and they are not equal.
func (s *ConcurrentSet[E]) IsProperSubSet(other ds.Set[E]) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.IsProperSubSet(other.Unfreeze())
}</span>

// IsSuperSet returns true if all elements of the other set are in this set.
func (s *ConcurrentSet[E]) IsSuperSet(other ds.Set[E]) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.IsSuperSet(other.Unfreeze())
}</span>

// IsProperSuperSet returns true if this is a superset of other and they are not equal.
func (s *ConcurrentSet[E]) IsProperSuperSet(other ds.Set[E]) bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.IsProperSuperSet(other.Unfreeze())
}</span>

// IterSubSets returns an iterator over all possible subsets of this set.
func (s *ConcurrentSet[E]) IterSubSets() iter.Seq[ds.Set[E]] <span class="cov8" title="1">{
        return func(yield func(ds.Set[E]) bool) </span><span class="cov8" title="1">{
                s.mu.RLock()
                defer s.mu.RUnlock()
                for subset := range s.v.IterSubSets() </span><span class="cov8" title="1">{
                        if !yield(subset.Freeze()) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// List returns a slice of all elements in the set.
func (s *ConcurrentSet[E]) List() []E <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.v.List()
}</span>

// Clone returns a new concurrent set with a copy of the data.
func (s *ConcurrentSet[E]) Clone() ds.ConcurrentSet[E] <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return NewConcurrentSet(s.v.Clone())
}</span>

// Iter returns an iterator over all elements in the set.
func (s *ConcurrentSet[E]) Iter() iter.Seq[E] <span class="cov8" title="1">{
        return func(yield func(E) bool) </span><span class="cov8" title="1">{
                s.mu.RLock()
                defer s.mu.RUnlock()
                for e := range s.v.Iter() </span><span class="cov8" title="1">{
                        if !yield(e) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Iter2 returns an iterator with index and element pairs.
func (s *ConcurrentSet[E]) Iter2() iter.Seq2[int, E] <span class="cov8" title="1">{
        return func(yield func(int, E) bool) </span><span class="cov8" title="1">{
                s.mu.RLock()
                defer s.mu.RUnlock()
                for i, e := range s.v.Iter2() </span><span class="cov8" title="1">{
                        if !yield(i, e) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Compute atomically computes a new value based on the element's presence.
// The remappingFunction receives the element and whether it exists, returning
// the new value and whether to store it.
func (s *ConcurrentSet[E]) Compute(e E, remappingFunction func(e E, exists bool) (E, bool)) E <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        oldExist := s.v.Contains(e)

        newValue, shouldStore := remappingFunction(e, oldExist)

        if shouldStore </span><span class="cov8" title="1">{
                s.v.Add(newValue)
        }</span> else<span class="cov8" title="1"> {
                s.v.Remove(e)
        }</span>
        <span class="cov8" title="1">return newValue</span>
}

// ComputeIfAbsent atomically computes a value only if the element is absent.
// The mappingFunction returns the value to store and whether to store it.
// If the element exists, returns the element without calling mappingFunction.
func (s *ConcurrentSet[E]) ComputeIfAbsent(e E, mappingFunction func(e E) (E, bool)) E <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        oldExist := s.v.Contains(e)

        if oldExist </span><span class="cov8" title="1">{
                return e
        }</span>

        <span class="cov8" title="1">newValue, shouldStore := mappingFunction(e)

        if shouldStore </span><span class="cov8" title="1">{
                s.v.Add(newValue)
        }</span>
        <span class="cov8" title="1">return newValue</span>
}

// ComputeIfPresent atomically computes a new value only if the element is present.
// The remappingFunction returns the new value and whether to keep it (false removes the element).
// If the element is absent, returns the element without calling remappingFunction.
func (s *ConcurrentSet[E]) ComputeIfPresent(e E, remappingFunction func(e E) (E, bool)) E <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        oldExist := s.v.Contains(e)

        if !oldExist </span><span class="cov8" title="1">{
                return e
        }</span>

        <span class="cov8" title="1">newValue, shouldStore := remappingFunction(e)

        if shouldStore </span><span class="cov8" title="1">{
                s.v.Add(newValue)
        }</span> else<span class="cov0" title="0"> if !shouldStore </span><span class="cov0" title="0">{
                s.v.Remove(e)
        }</span>
        <span class="cov8" title="1">return newValue</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package hashset

import (
        "iter"

        base "github.com/bronlabs/bron-crypto/pkg/base"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

// NewHashable creates a new mutable set for hashable element types.
func NewHashable[E ds.Hashable[E]](xs ...E) ds.MutableSet[E] <span class="cov8" title="1">{
        s := &amp;MutableHashableSet[E]{v: hashmap.NewHashable[E, struct{}]()}
        for _, x := range xs </span><span class="cov8" title="1">{
                s.v.Put(x, struct{}{})
        }</span>
        <span class="cov8" title="1">return s</span>
}

// MutableHashableSet is a mutable hash set for hashable element types.
type MutableHashableSet[E ds.Hashable[E]] struct {
        v ds.MutableMap[E, struct{}]
}

// Add adds an element to the set.
func (s *MutableHashableSet[E]) Add(e E) <span class="cov8" title="1">{
        s.v.Put(e, struct{}{})
}</span>

// AddAll adds multiple elements to the set.
func (s *MutableHashableSet[E]) AddAll(es ...E) <span class="cov8" title="1">{
        for _, e := range es </span><span class="cov8" title="1">{
                s.v.Put(e, struct{}{})
        }</span>
}

// Remove removes an element from the set.
func (s *MutableHashableSet[E]) Remove(e E) <span class="cov8" title="1">{
        s.v.Remove(e)
}</span>

// RemoveAll removes multiple elements from the set.
func (s *MutableHashableSet[E]) RemoveAll(es ...E) <span class="cov8" title="1">{
        for _, e := range es </span><span class="cov8" title="1">{
                s.v.Remove(e)
        }</span>
}

// Freeze returns an immutable snapshot of this set.
func (s *MutableHashableSet[E]) Freeze() ds.Set[E] <span class="cov8" title="1">{
        return &amp;ImmutableSet[E]{v: &amp;MutableHashableSet[E]{v: s.v.Clone()}}
}</span>

// Clone returns a mutable copy of this set.
func (s *MutableHashableSet[E]) Clone() ds.MutableSet[E] <span class="cov8" title="1">{
        return &amp;MutableHashableSet[E]{v: s.v.Clone()}
}</span>

// Clear removes all elements from the set.
func (s *MutableHashableSet[E]) Clear() <span class="cov8" title="1">{
        s.v.Clear()
}</span>

// Contains returns true if the element is in the set.
func (s *MutableHashableSet[E]) Contains(e E) bool <span class="cov8" title="1">{
        return s.v.ContainsKey(e)
}</span>

// Equal returns true if both sets contain exactly the same elements.
func (s *MutableHashableSet[E]) Equal(other ds.MutableSet[E]) bool <span class="cov8" title="1">{
        return s.IsSubSet(other) &amp;&amp; other.IsSubSet(s)
}</span>

// Size returns the number of elements in the set.
func (s *MutableHashableSet[_]) Size() int <span class="cov8" title="1">{
        return s.v.Size()
}</span>

// Cardinality returns the number of elements in the set.
func (s *MutableHashableSet[_]) Cardinality() int <span class="cov8" title="1">{
        return s.v.Size()
}</span>

// IsEmpty returns true if the set contains no elements.
func (s *MutableHashableSet[_]) IsEmpty() bool <span class="cov8" title="1">{
        return s.Size() == 0
}</span>

// Union returns a new set containing all elements from both sets.
func (s *MutableHashableSet[E]) Union(other ds.MutableSet[E]) ds.MutableSet[E] <span class="cov8" title="1">{
        out := s.Clone()
        out.AddAll(other.List()...)
        return out
}</span>

// Intersection returns a new set containing only elements present in both sets.
func (s *MutableHashableSet[E]) Intersection(other ds.MutableSet[E]) ds.MutableSet[E] <span class="cov8" title="1">{
        mapping := hashmap.NewHashable[E, struct{}]()
        for k := range s.v.Iter() </span><span class="cov8" title="1">{
                if other.Contains(k) </span><span class="cov8" title="1">{
                        mapping.Put(k, struct{}{})
                }</span>
        }
        <span class="cov8" title="1">return &amp;MutableHashableSet[E]{v: mapping}</span>
}

// Difference returns a new set containing elements in this set but not in the other.
func (s *MutableHashableSet[E]) Difference(other ds.MutableSet[E]) ds.MutableSet[E] <span class="cov8" title="1">{
        out := s.Clone()
        out.RemoveAll(other.List()...)
        return out
}</span>

// SymmetricDifference returns a new set containing elements in either set but not both.
func (s *MutableHashableSet[E]) SymmetricDifference(other ds.MutableSet[E]) ds.MutableSet[E] <span class="cov8" title="1">{
        return s.Union(other).Difference(s.Intersection(other))
}</span>

// SubSets returns all possible subsets of this set (power set).
func (s *MutableHashableSet[E]) SubSets() []ds.MutableSet[E] <span class="cov8" title="1">{
        result := make([]ds.MutableSet[E], 1&lt;&lt;s.Size())
        i := 0
        for subset := range s.IterSubSets() </span><span class="cov8" title="1">{
                result[i] = subset
                i++
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Iter returns an iterator over all elements in the set.
func (s *MutableHashableSet[E]) Iter() iter.Seq[E] <span class="cov8" title="1">{
        return func(yield func(E) bool) </span><span class="cov8" title="1">{
                for el := range s.v.Iter() </span><span class="cov8" title="1">{
                        if !yield(el) </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
        }
}

// Iter2 returns an iterator with index and element pairs.
func (s *MutableHashableSet[E]) Iter2() iter.Seq2[int, E] <span class="cov8" title="1">{
        return func(yield func(int, E) bool) </span><span class="cov8" title="1">{
                i := 0
                for el := range s.v.Iter() </span><span class="cov8" title="1">{
                        if !yield(i, el) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">i++</span>
                }
        }
}

// IsSubSet returns true if all elements of this set are in the other set.
func (s *MutableHashableSet[E]) IsSubSet(of ds.MutableSet[E]) bool <span class="cov8" title="1">{
        for k := range s.Iter() </span><span class="cov8" title="1">{
                if !of.Contains(k) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsProperSubSet returns true if this is a subset of other and they are not equal.
func (s *MutableHashableSet[E]) IsProperSubSet(of ds.MutableSet[E]) bool <span class="cov8" title="1">{
        return s.IsSubSet(of) &amp;&amp; !s.Equal(of)
}</span>

// IsSuperSet returns true if all elements of the other set are in this set.
func (s *MutableHashableSet[E]) IsSuperSet(of ds.MutableSet[E]) bool <span class="cov8" title="1">{
        for k := range of.Iter() </span><span class="cov8" title="1">{
                if _, exists := s.v.Get(k); !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsProperSuperSet returns true if this is a superset of other and they are not equal.
func (s *MutableHashableSet[E]) IsProperSuperSet(of ds.MutableSet[E]) bool <span class="cov8" title="1">{
        return s.IsSuperSet(of) &amp;&amp; !s.Equal(of)
}</span>

// IterSubSets returns an iterator over all possible subsets of this set.
func (s *MutableHashableSet[E]) IterSubSets() iter.Seq[ds.MutableSet[E]] <span class="cov8" title="1">{
        return func(yield func(ds.MutableSet[E]) bool) </span><span class="cov8" title="1">{
                list := s.List()
                for i := 0; i &lt;= s.Size(); i++ </span><span class="cov8" title="1">{
                        for comb := range sliceutils.Combinations(list, uint(i)) </span><span class="cov8" title="1">{
                                subset := NewHashable(comb...)
                                if !yield(subset) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

// List returns a slice of all elements in the set.
func (s *MutableHashableSet[E]) List() []E <span class="cov8" title="1">{
        return s.v.Keys()
}</span>

// HashCode computes and returns the hash code for this set.
// The hash code is computed by XORing the hash codes of all elements.
func (s *MutableHashableSet[E]) HashCode() base.HashCode <span class="cov8" title="1">{
        if s.IsEmpty() </span><span class="cov8" title="1">{
                return base.HashCode(0)
        }</span>
        <span class="cov8" title="1">l := s.List()
        if len(l) == 1 </span><span class="cov8" title="1">{
                return l[0].HashCode()
        }</span>
        <span class="cov8" title="1">return sliceutils.Reduce(
                sliceutils.Map(l[1:], func(e E) ds.HashCode </span><span class="cov8" title="1">{ return e.HashCode() }</span>),
                l[0].HashCode(),
                func(a, b ds.HashCode) ds.HashCode <span class="cov8" title="1">{ return a ^ b }</span>, // must be commutative
        )
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package hashset

import (
        "iter"
        "slices"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
)

// ImmutableSet is an immutable wrapper around a MutableSet.
type ImmutableSet[E any] struct {
        v ds.MutableSet[E]
}

// Unfreeze returns a mutable copy of this set.
func (s *ImmutableSet[E]) Unfreeze() ds.MutableSet[E] <span class="cov8" title="1">{
        return s.v.Clone()
}</span>

// Contains returns true if the element is in the set.
func (s *ImmutableSet[E]) Contains(e E) bool <span class="cov8" title="1">{
        return s.v.Contains(e)
}</span>

// Iter returns an iterator over all elements in the set.
func (s *ImmutableSet[E]) Iter() iter.Seq[E] <span class="cov8" title="1">{
        return s.v.Iter()
}</span>

// Iter2 returns an iterator with index and element pairs.
func (s *ImmutableSet[E]) Iter2() iter.Seq2[int, E] <span class="cov8" title="1">{
        return s.v.Iter2()
}</span>

// Size returns the number of elements in the set.
func (s *ImmutableSet[E]) Size() int <span class="cov8" title="1">{
        return s.v.Size()
}</span>

// IsEmpty returns true if the set contains no elements.
func (s *ImmutableSet[E]) IsEmpty() bool <span class="cov8" title="1">{
        return s.v.IsEmpty()
}</span>

// Union returns a new immutable set containing all elements from both sets.
func (s *ImmutableSet[E]) Union(other ds.Set[E]) ds.Set[E] <span class="cov8" title="1">{
        return s.v.Union(other.Unfreeze()).Freeze()
}</span>

// Intersection returns a new immutable set containing only elements present in both sets.
func (s *ImmutableSet[E]) Intersection(other ds.Set[E]) ds.Set[E] <span class="cov8" title="1">{
        return s.v.Intersection(other.Unfreeze()).Freeze()
}</span>

// Difference returns a new immutable set containing elements in this set but not in the other.
func (s *ImmutableSet[E]) Difference(other ds.Set[E]) ds.Set[E] <span class="cov8" title="1">{
        return s.v.Difference(other.Unfreeze()).Freeze()
}</span>

// SymmetricDifference returns a new immutable set containing elements in either set but not both.
func (s *ImmutableSet[E]) SymmetricDifference(other ds.Set[E]) ds.Set[E] <span class="cov8" title="1">{
        return s.v.SymmetricDifference(other.Unfreeze()).Freeze()
}</span>

// SubSets returns all possible subsets of this set (power set).
func (s *ImmutableSet[E]) SubSets() []ds.Set[E] <span class="cov8" title="1">{
        return slices.Collect(
                iterutils.Map(slices.Values(s.v.SubSets()), func(subset ds.MutableSet[E]) ds.Set[E] </span><span class="cov8" title="1">{
                        return subset.Freeze()
                }</span>),
        )
}

// IsSubSet returns true if all elements of this set are in the other set.
func (s *ImmutableSet[E]) IsSubSet(of ds.Set[E]) bool <span class="cov8" title="1">{
        for k := range s.Iter() </span><span class="cov8" title="1">{
                if !of.Contains(k) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsProperSubSet returns true if this is a subset of other and they are not equal.
func (s *ImmutableSet[E]) IsProperSubSet(of ds.Set[E]) bool <span class="cov8" title="1">{
        return s.IsSubSet(of) &amp;&amp; !s.Equal(of)
}</span>

// IsSuperSet returns true if all elements of the other set are in this set.
func (s *ImmutableSet[E]) IsSuperSet(of ds.Set[E]) bool <span class="cov8" title="1">{
        for k := range of.Iter() </span><span class="cov8" title="1">{
                if !s.Contains(k) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsProperSuperSet returns true if this is a superset of other and they are not equal.
func (s *ImmutableSet[E]) IsProperSuperSet(of ds.Set[E]) bool <span class="cov8" title="1">{
        return s.IsSuperSet(of) &amp;&amp; !s.Equal(of)
}</span>

// IterSubSets returns an iterator over all possible subsets of this set.
func (s *ImmutableSet[E]) IterSubSets() iter.Seq[ds.Set[E]] <span class="cov8" title="1">{
        return func(yield func(ds.Set[E]) bool) </span><span class="cov8" title="1">{
                for subset := range s.v.IterSubSets() </span><span class="cov8" title="1">{
                        if !yield(subset.Freeze()) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// List returns a slice of all elements in the set.
func (s *ImmutableSet[E]) List() []E <span class="cov8" title="1">{
        return s.v.List()
}</span>

// Equal returns true if both sets contain exactly the same elements.
func (s *ImmutableSet[E]) Equal(other ds.Set[E]) bool <span class="cov8" title="1">{
        return s.v.Equal(other.Unfreeze())
}</span>

// Clone returns a copy of this set.
func (s *ImmutableSet[E]) Clone() ds.Set[E] <span class="cov8" title="1">{
        return s.v.Freeze()
}</span>

// Cardinality returns the number of elements in the set.
func (s *ImmutableSet[E]) Cardinality() int <span class="cov8" title="1">{
        return s.v.Cardinality()
}</span>
</pre>
		
		<pre class="file" id="file131" style="display: none">package base

import (
        "golang.org/x/exp/constraints"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// IdentifiableAbortPartyIDTag is the tag used to identify parties responsible for an identifiable abort.
const IdentifiableAbortPartyIDTag = "identifiable_abort_party_id"

// ErrAbort indicates that an operation was aborted due to malicious behaviour.
var ErrAbort = errs2.New("ABORT")

// IdentifiableAbortID represents the type used for party identifiers in identifiable abort errors.
type IdentifiableAbortID interface {
        constraints.Unsigned
}

// ShouldAbort checks if the given error indicates that an operation should be aborted.
func ShouldAbort(err error) bool <span class="cov0" title="0">{
        return errs2.Is(err, ErrAbort) || IsIdentifiableAbortError(err)
}</span>

// IsIdentifiableAbortError checks if the given error is an identifiable abort error.
func IsIdentifiableAbortError(err error) bool <span class="cov0" title="0">{
        _, is := errs2.HasTag(err, IdentifiableAbortPartyIDTag)
        return is
}</span>

// GetMaliciousIdentities extracts the party IDs responsible for an identifiable abort from the given error.
func GetMaliciousIdentities[ID IdentifiableAbortID](err error) []ID <span class="cov0" title="0">{
        culprits := errs2.HasTagAll(err, IdentifiableAbortPartyIDTag)
        ids := make([]ID, len(culprits))
        for i, culprit := range culprits </span><span class="cov0" title="0">{
                id, ok := culprit.(ID)
                if ok </span><span class="cov0" title="0">{
                        ids[i] = id
                }</span>
        }
        <span class="cov0" title="0">return ids</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package main

import (
        "go/ast"
        "go/parser"
        "go/token"
        "os"
        "text/template"
)

const tmpl = `//nolint:depguard,wrapcheck // we want to use pkg/errors only here, but nowhere else
package errs

import (
        "fmt"
        "github.com/pkg/errors"
)

{{ range . }}
func New{{ . }}(format string, args ...any) error {
    return errors.Errorf("%s %s", {{ . }}, fmt.Sprintf(format, args...))
}

func Wrap{{ . }}(err error, format string, args ...any) error {
    return errors.Wrapf(err, "%s %s", {{ . }}, fmt.Sprintf(format, args...))
}

func Is{{ . }}(err error) bool {
    return Is(err, {{ . }})
}

func Has{{ . }}(err error) bool {
    return Has(err, {{ . }})
}
{{ end }}`

func main() <span class="cov0" title="0">{
        fset := token.NewFileSet()
        f, err := parser.ParseFile(fset, "errors.go", nil, parser.ParseComments)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var errorTypes []string
        ast.Inspect(f, func(n ast.Node) bool </span><span class="cov0" title="0">{
                v, ok := n.(*ast.ValueSpec)
                if !ok </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">for _, name := range v.Names </span><span class="cov0" title="0">{
                        if name.Name != "TotalAbort" &amp;&amp; name.Name != "IdentifiableAbort" </span><span class="cov0" title="0">{
                                errorTypes = append(errorTypes, name.Name)
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">file, err := os.Create("error_functions.gen.go")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer file.Close()

        t := template.Must(template.New("tmpl").Parse(tmpl))
        if err := t.Execute(file, errorTypes); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package main

import (
        "go/ast"
        "go/parser"
        "go/token"
        "os"
        "text/template"
)

const tmpl = `
package errs

var knownErrors = []ErrorType{
    {{- range . }}
    {{ . }},
    {{- end }}
}
`

func main() <span class="cov0" title="0">{
        fset := token.NewFileSet()
        f, err := parser.ParseFile(fset, "errors.go", nil, parser.ParseComments)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var errorTypes []string
        ast.Inspect(f, func(n ast.Node) bool </span><span class="cov0" title="0">{
                v, ok := n.(*ast.ValueSpec)
                if !ok </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">for _, name := range v.Names </span><span class="cov0" title="0">{
                        errorTypes = append(errorTypes, name.Name)
                }</span>
                <span class="cov0" title="0">return true</span>
        })

        <span class="cov0" title="0">file, err := os.Create("known_errors.gen.go")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer file.Close()

        t := template.Must(template.New("tmpl").Parse(tmpl))
        if err := t.Execute(file, errorTypes); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file134" style="display: none">//nolint:depguard,wrapcheck // we want to use pkg/errors only here, but nowhere else
package errs

import (
        "fmt"
        "github.com/pkg/errors"
)


func NewArgument(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Argument, fmt.Sprintf(format, args...))
}</span>

func WrapArgument(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Argument, fmt.Sprintf(format, args...))
}</span>

func IsArgument(err error) bool <span class="cov0" title="0">{
    return Is(err, Argument)
}</span>

func HasArgument(err error) bool <span class="cov0" title="0">{
    return Has(err, Argument)
}</span>

func NewCoordinates(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Coordinates, fmt.Sprintf(format, args...))
}</span>

func WrapCoordinates(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Coordinates, fmt.Sprintf(format, args...))
}</span>

func IsCoordinates(err error) bool <span class="cov0" title="0">{
    return Is(err, Coordinates)
}</span>

func HasCoordinates(err error) bool <span class="cov0" title="0">{
    return Has(err, Coordinates)
}</span>

func NewCurve(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Curve, fmt.Sprintf(format, args...))
}</span>

func WrapCurve(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Curve, fmt.Sprintf(format, args...))
}</span>

func IsCurve(err error) bool <span class="cov0" title="0">{
    return Is(err, Curve)
}</span>

func HasCurve(err error) bool <span class="cov0" title="0">{
    return Has(err, Curve)
}</span>

func NewHashing(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Hashing, fmt.Sprintf(format, args...))
}</span>

func WrapHashing(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Hashing, fmt.Sprintf(format, args...))
}</span>

func IsHashing(err error) bool <span class="cov0" title="0">{
    return Is(err, Hashing)
}</span>

func HasHashing(err error) bool <span class="cov0" title="0">{
    return Has(err, Hashing)
}</span>

func NewIsIdentity(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", IsIdentity, fmt.Sprintf(format, args...))
}</span>

func WrapIsIdentity(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", IsIdentity, fmt.Sprintf(format, args...))
}</span>

func IsIsIdentity(err error) bool <span class="cov0" title="0">{
    return Is(err, IsIdentity)
}</span>

func HasIsIdentity(err error) bool <span class="cov0" title="0">{
    return Has(err, IsIdentity)
}</span>

func NewIsNil(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", IsNil, fmt.Sprintf(format, args...))
}</span>

func WrapIsNil(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", IsNil, fmt.Sprintf(format, args...))
}</span>

func IsIsNil(err error) bool <span class="cov0" title="0">{
    return Is(err, IsNil)
}</span>

func HasIsNil(err error) bool <span class="cov0" title="0">{
    return Has(err, IsNil)
}</span>

func NewIsZero(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", IsZero, fmt.Sprintf(format, args...))
}</span>

func WrapIsZero(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", IsZero, fmt.Sprintf(format, args...))
}</span>

func IsIsZero(err error) bool <span class="cov0" title="0">{
    return Is(err, IsZero)
}</span>

func HasIsZero(err error) bool <span class="cov0" title="0">{
    return Has(err, IsZero)
}</span>

func NewLength(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Length, fmt.Sprintf(format, args...))
}</span>

func WrapLength(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Length, fmt.Sprintf(format, args...))
}</span>

func IsLength(err error) bool <span class="cov0" title="0">{
    return Is(err, Length)
}</span>

func HasLength(err error) bool <span class="cov0" title="0">{
    return Has(err, Length)
}</span>

func NewMembership(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Membership, fmt.Sprintf(format, args...))
}</span>

func WrapMembership(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Membership, fmt.Sprintf(format, args...))
}</span>

func IsMembership(err error) bool <span class="cov0" title="0">{
    return Is(err, Membership)
}</span>

func HasMembership(err error) bool <span class="cov0" title="0">{
    return Has(err, Membership)
}</span>

func NewMissing(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Missing, fmt.Sprintf(format, args...))
}</span>

func WrapMissing(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Missing, fmt.Sprintf(format, args...))
}</span>

func IsMissing(err error) bool <span class="cov0" title="0">{
    return Is(err, Missing)
}</span>

func HasMissing(err error) bool <span class="cov0" title="0">{
    return Has(err, Missing)
}</span>

func NewRandomSample(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", RandomSample, fmt.Sprintf(format, args...))
}</span>

func WrapRandomSample(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", RandomSample, fmt.Sprintf(format, args...))
}</span>

func IsRandomSample(err error) bool <span class="cov0" title="0">{
    return Is(err, RandomSample)
}</span>

func HasRandomSample(err error) bool <span class="cov0" title="0">{
    return Has(err, RandomSample)
}</span>

func NewRound(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Round, fmt.Sprintf(format, args...))
}</span>

func WrapRound(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Round, fmt.Sprintf(format, args...))
}</span>

func IsRound(err error) bool <span class="cov0" title="0">{
    return Is(err, Round)
}</span>

func HasRound(err error) bool <span class="cov0" title="0">{
    return Has(err, Round)
}</span>

func NewSerialisation(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Serialisation, fmt.Sprintf(format, args...))
}</span>

func WrapSerialisation(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Serialisation, fmt.Sprintf(format, args...))
}</span>

func IsSerialisation(err error) bool <span class="cov0" title="0">{
    return Is(err, Serialisation)
}</span>

func HasSerialisation(err error) bool <span class="cov0" title="0">{
    return Has(err, Serialisation)
}</span>

func NewSize(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Size, fmt.Sprintf(format, args...))
}</span>

func WrapSize(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Size, fmt.Sprintf(format, args...))
}</span>

func IsSize(err error) bool <span class="cov0" title="0">{
    return Is(err, Size)
}</span>

func HasSize(err error) bool <span class="cov0" title="0">{
    return Has(err, Size)
}</span>

func NewType(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Type, fmt.Sprintf(format, args...))
}</span>

func WrapType(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Type, fmt.Sprintf(format, args...))
}</span>

func IsType(err error) bool <span class="cov0" title="0">{
    return Is(err, Type)
}</span>

func HasType(err error) bool <span class="cov0" title="0">{
    return Has(err, Type)
}</span>

func NewValidation(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Validation, fmt.Sprintf(format, args...))
}</span>

func WrapValidation(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Validation, fmt.Sprintf(format, args...))
}</span>

func IsValidation(err error) bool <span class="cov0" title="0">{
    return Is(err, Validation)
}</span>

func HasValidation(err error) bool <span class="cov0" title="0">{
    return Has(err, Validation)
}</span>

func NewValue(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Value, fmt.Sprintf(format, args...))
}</span>

func WrapValue(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Value, fmt.Sprintf(format, args...))
}</span>

func IsValue(err error) bool <span class="cov0" title="0">{
    return Is(err, Value)
}</span>

func HasValue(err error) bool <span class="cov0" title="0">{
    return Has(err, Value)
}</span>

func NewVerification(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Verification, fmt.Sprintf(format, args...))
}</span>

func WrapVerification(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Verification, fmt.Sprintf(format, args...))
}</span>

func IsVerification(err error) bool <span class="cov0" title="0">{
    return Is(err, Verification)
}</span>

func HasVerification(err error) bool <span class="cov0" title="0">{
    return Has(err, Verification)
}</span>

func NewFailed(format string, args ...any) error <span class="cov0" title="0">{
    return errors.Errorf("%s %s", Failed, fmt.Sprintf(format, args...))
}</span>

func WrapFailed(err error, format string, args ...any) error <span class="cov0" title="0">{
    return errors.Wrapf(err, "%s %s", Failed, fmt.Sprintf(format, args...))
}</span>

func IsFailed(err error) bool <span class="cov0" title="0">{
    return Is(err, Failed)
}</span>

func HasFailed(err error) bool <span class="cov0" title="0">{
    return Has(err, Failed)
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">//go:generate go run codegen/error_functions/main.go
//go:generate go run codegen/known_errors/main.go
//nolint:depguard,wrapcheck // we want to use pkg/errors only here, but nowhere else
package errs

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/pkg/errors"
        "golang.org/x/exp/constraints"
)

type ErrorType string

type AbortIdentifier interface {
        constraints.Integer | ~string | ~[]byte | ~[32]byte
}

const (
        Argument          ErrorType = "[ARGUMENT_ERROR]"
        Coordinates       ErrorType = "[COORDINATES_ERROR]"
        Curve             ErrorType = "[CURVE_ERROR]"
        Hashing           ErrorType = "[HASHING_ERROR]"
        IdentifiableAbort ErrorType = "[ABORT]"
        IsIdentity        ErrorType = "[IS_IDENTITY_ERROR]"
        IsNil             ErrorType = "[IS_NIL_ERROR]"
        IsZero            ErrorType = "[IS_ZERO_ERROR]"
        Length            ErrorType = "[LENGTH_ERROR]"
        Membership        ErrorType = "[MEMBERSHIP_ERROR]"
        Missing           ErrorType = "[MISSING_ERROR]"
        RandomSample      ErrorType = "[RANDOM_SAMPLE_ERROR]"
        Round             ErrorType = "[ROUND_ERROR]"
        Serialisation     ErrorType = "[SERIALISATION_ERROR]"
        Size              ErrorType = "[SIZE_ERROR]"
        TotalAbort        ErrorType = "[TOTAL_ABORT]"
        Type              ErrorType = "[TYPE_ERROR]"
        Validation        ErrorType = "[VALIDATION_ERROR]"
        Value             ErrorType = "[VALUE_ERROR]"
        Verification      ErrorType = "[VERIFICATION_ERROR]"

        Failed ErrorType = "[FAILED]"
)

func Is(err error, errorType ErrorType) bool <span class="cov0" title="0">{
        return err != nil &amp;&amp; strings.Contains(err.Error(), string(errorType))
}</span>

func Has(err error, errorType ErrorType) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if Is(err, errorType) </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">cause := errors.Cause(err)
                if errors.Is(cause, err) || cause == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">err = cause</span>
        }

        <span class="cov0" title="0">return false</span>
}

func NewIdentifiableAbort[T AbortIdentifier](id T, format string, args ...any) error <span class="cov0" title="0">{
        return errors.Errorf(
                "%s(ID=%s) %s",
                IdentifiableAbort,
                fmt.Sprintf(abortFormatSpecifier(id), id),
                fmt.Sprintf(format, args...),
        )
}</span>

func WrapIdentifiableAbort[T AbortIdentifier](err error, id T, format string, args ...any) error <span class="cov0" title="0">{
        return errors.Wrapf(
                err,
                "%s(ID=%s) %s",
                IdentifiableAbort,
                fmt.Sprintf(abortFormatSpecifier(id), id),
                fmt.Sprintf(format, args...),
        )
}</span>

func IsIdentifiableAbort(err error, id any) bool <span class="cov0" title="0">{
        t := IdentifiableAbort
        if id != nil </span><span class="cov0" title="0">{
                t = ErrorType(
                        fmt.Sprintf(
                                "%s(ID=%s)", t, fmt.Sprintf(abortFormatSpecifier(id), id),
                        ),
                )
        }</span>
        <span class="cov0" title="0">return Is(err, t)</span>
}

func HasIdentifiableAbort(err error, id any) bool <span class="cov0" title="0">{
        t := IdentifiableAbort
        if id != nil </span><span class="cov0" title="0">{
                t = ErrorType(
                        fmt.Sprintf(
                                "%s(ID=%s)", t, fmt.Sprintf(abortFormatSpecifier(id), id),
                        ),
                )
        }</span>
        <span class="cov0" title="0">return Has(err, t)</span>
}

func NewTotalAbort(id any, format string, args ...any) error <span class="cov0" title="0">{
        if id != nil </span><span class="cov0" title="0">{
                return errors.Errorf(
                        "%s(ID=%s) %s",
                        TotalAbort,
                        fmt.Sprintf(abortFormatSpecifier(id), id),
                        fmt.Sprintf(format, args...),
                )
        }</span>
        <span class="cov0" title="0">return errors.Errorf("%s %s", IdentifiableAbort, fmt.Sprintf(format, args...))</span>
}

func WrapTotalAbort(err error, id any, format string, args ...any) error <span class="cov0" title="0">{
        if id != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(
                        err,
                        "%s(ID=%s) %s",
                        TotalAbort,
                        fmt.Sprintf(abortFormatSpecifier(id), id),
                        fmt.Sprintf(format, args...),
                )
        }</span>
        <span class="cov0" title="0">return errors.Wrapf(err, "%s %s", IdentifiableAbort, fmt.Sprintf(format, args...))</span>
}

func IsTotalAbort(err error, id any) bool <span class="cov0" title="0">{
        t := TotalAbort
        if id != nil </span><span class="cov0" title="0">{
                t = ErrorType(
                        fmt.Sprintf(
                                "%s(ID=%s)", t, fmt.Sprintf(abortFormatSpecifier(id), id),
                        ),
                )
        }</span>
        <span class="cov0" title="0">return Is(err, t)</span>
}

func HasTotalAbort(err error, id any) bool <span class="cov0" title="0">{
        t := IdentifiableAbort
        if id != nil </span><span class="cov0" title="0">{
                t = ErrorType(
                        fmt.Sprintf(
                                "%s(ID=%s)", t, fmt.Sprintf(abortFormatSpecifier(id), id),
                        ),
                )
        }</span>
        <span class="cov0" title="0">return Has(err, t)</span>
}

func isByteArrayOrSlice(x any) bool <span class="cov0" title="0">{
        if _, ok := x.([]byte); ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">v := reflect.ValueOf(x)
        return v.Kind() == reflect.Array &amp;&amp; v.Type().Elem().Kind() == reflect.Uint8</span>
}

func abortFormatSpecifier(id any) string <span class="cov0" title="0">{
        specifier := "%v"
        if isByteArrayOrSlice(id) </span><span class="cov0" title="0">{
                specifier = "%x"
        }</span>
        <span class="cov0" title="0">return specifier</span>
}

// IsKnownError returns true if the error is one of the known errors.
func IsKnownError(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, knownError := range knownErrors </span><span class="cov0" title="0">{
                if Is(err, knownError) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package errs2

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "runtime"
        "strconv"
)

const (
        errorHeader       = "ERROR: "
        defaultIndent     = "  "
        tagsPrefix        = "--- Tags: "
        stackFramePrefix  = "--- Frame: "
        sentinelSeparator = ": "
)

var (
        Is = errors.Is
        As = errors.As
)

func Unwrap(err error) []error <span class="cov8" title="1">{
        //nolint:errorlint // internal error handling
        switch x := err.(type) </span>{
        case interface{ Unwrap() error }:<span class="cov0" title="0">
                return []error{x.Unwrap()}</span>
        case interface{ Unwrap() []error }:<span class="cov8" title="1">
                return x.Unwrap()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type Error interface {
        error
        fmt.Formatter

        WithTag(string, any) Error
        WithMessage(format string, args ...any) Error
        WithStackFrame() Error
        Tags() map[string]any
        StackFrame() *StackFrame
}

func New(format string, args ...any) Error <span class="cov8" title="1">{
        return &amp;sentinelError{
                message: fmt.Sprintf(format, args...),
        }
}</span>

func Join(errs ...error) Error <span class="cov8" title="1">{
        if len(errs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">pc, _, _, _ := runtime.Caller(1)
        var children []error
        for _, e := range errs </span><span class="cov8" title="1">{
                //nolint:errorlint // internal error library
                if sentinelErr, ok := e.(*sentinelError); ok </span><span class="cov8" title="1">{
                        children = append(children, &amp;implError{
                                message:    sentinelErr.message,
                                wrapped:    []error{sentinelErr},
                                stackFrame: nil,
                                tags:       nil,
                        })
                }</span> else<span class="cov8" title="1"> {
                        children = append(children, e)
                }</span>
        }

        <span class="cov8" title="1">return &amp;implError{
                message:    "",
                wrapped:    children,
                stackFrame: NewStackFrame(pc),
                tags:       nil,
        }</span>
}

func wrap(err error, i int) Error <span class="cov8" title="1">{
        pc, _, _, _ := runtime.Caller(1 + i)

        //nolint:errorlint // internal error library
        if sentinelErr, ok := err.(*sentinelError); ok </span><span class="cov0" title="0">{
                return &amp;implError{
                        message:    sentinelErr.message,
                        wrapped:    []error{sentinelErr},
                        stackFrame: NewStackFrame(pc),
                        tags:       nil,
                }
        }</span> else<span class="cov8" title="1"> {
                return &amp;implError{
                        message:    "",
                        wrapped:    []error{err},
                        stackFrame: NewStackFrame(pc),
                        tags:       nil,
                }
        }</span>
}

func Wrap(err error) Error <span class="cov8" title="1">{
        return wrap(err, 0)
}</span>

func HasTag(err error, tag string) (any, bool) <span class="cov8" title="1">{
        //nolint:errorlint // internal error library
        if taggedErr, ok := err.(hasTags); ok </span><span class="cov8" title="1">{
                if v, ok := taggedErr.Tags()[tag]; ok </span><span class="cov8" title="1">{
                        return v, ok
                }</span>
        }

        // Recurse into wrapped errors (similar to errors.Is/errors.As behaviour)
        //nolint:errorlint // internal error library
        <span class="cov0" title="0">if wrapped, ok := err.(wrapsMultipleErrors); ok </span><span class="cov0" title="0">{
                for _, child := range wrapped.Unwrap() </span><span class="cov0" title="0">{
                        if v, ok := HasTag(child, tag); ok </span><span class="cov0" title="0">{
                                return v, ok
                        }</span>
                }
        }
        //nolint:errorlint // internal error library
        <span class="cov0" title="0">if wrapped, ok := err.(wrapsError); ok </span><span class="cov0" title="0">{
                if v, ok := HasTag(wrapped.Unwrap(), tag); ok </span><span class="cov0" title="0">{
                        return v, ok
                }</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}

// HasTagAll returns all values for a given tag across the entire error chain.
// This is useful when multiple wrapped errors may have the same tag with different values.
func HasTagAll(err error, tag string) []any <span class="cov0" title="0">{
        var results []any
        hasTagAllRecursive(err, tag, &amp;results)
        return results
}</span>

func hasTagAllRecursive(err error, tag string, results *[]any) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        //nolint:errorlint // internal error library
        <span class="cov0" title="0">if taggedErr, ok := err.(hasTags); ok </span><span class="cov0" title="0">{
                if v, ok := taggedErr.Tags()[tag]; ok </span><span class="cov0" title="0">{
                        *results = append(*results, v)
                }</span>
        }

        // Recurse into wrapped errors
        //nolint:errorlint // internal error library
        <span class="cov0" title="0">if wrapped, ok := err.(wrapsMultipleErrors); ok </span><span class="cov0" title="0">{
                for _, child := range wrapped.Unwrap() </span><span class="cov0" title="0">{
                        hasTagAllRecursive(child, tag, results)
                }</span>
        }
        //nolint:errorlint // internal error library
        <span class="cov0" title="0">if wrapped, ok := err.(wrapsError); ok </span><span class="cov0" title="0">{
                hasTagAllRecursive(wrapped.Unwrap(), tag, results)
        }</span>
}

type sentinelError struct {
        message string
}

func (e *sentinelError) WithTag(s string, a any) Error <span class="cov0" title="0">{
        pc, _, _, _ := runtime.Caller(1)
        return &amp;implError{
                message:    e.message,
                wrapped:    []error{e},
                stackFrame: NewStackFrame(pc),
                tags:       map[string]any{s: a},
        }
}</span>

func (e *sentinelError) WithMessage(format string, args ...any) Error <span class="cov8" title="1">{
        pc, _, _, _ := runtime.Caller(1)
        return &amp;implError{
                message:    e.message + sentinelSeparator + fmt.Sprintf(format, args...),
                wrapped:    []error{e},
                stackFrame: NewStackFrame(pc),
                tags:       nil,
        }
}</span>

func (e *sentinelError) WithStackFrame() Error <span class="cov0" title="0">{
        pc, _, _, _ := runtime.Caller(1)
        return &amp;implError{
                message:    e.message,
                wrapped:    []error{e},
                stackFrame: NewStackFrame(pc),
                tags:       nil,
        }
}</span>

func (e *sentinelError) Error() string <span class="cov8" title="1">{
        return e.message
}</span>

func (e *sentinelError) Format(s fmt.State, verb rune) <span class="cov0" title="0">{
        switch verb </span>{
        case 'v', 's', 'q':<span class="cov0" title="0">
                _, _ = fmt.Fprintf(s, "%s%s\n", errorHeader, e.Error())</span>
        }
}

func (*sentinelError) Tags() map[string]any <span class="cov0" title="0">{
        return nil
}</span>

func (*sentinelError) StackFrame() *StackFrame <span class="cov0" title="0">{
        return nil
}</span>

type implError struct {
        message    string
        wrapped    []error
        stackFrame *StackFrame
        tags       map[string]any
}

func (e *implError) WithTag(s string, a any) Error <span class="cov8" title="1">{
        if e.tags == nil </span><span class="cov8" title="1">{
                e.tags = map[string]any{s: a}
        }</span> else<span class="cov0" title="0"> {
                e.tags[s] = a
        }</span>
        <span class="cov8" title="1">return e</span>
}

func (e *implError) WithMessage(format string, args ...any) Error <span class="cov8" title="1">{
        if e.message == "" </span><span class="cov8" title="1">{
                e.message = fmt.Sprintf(format, args...)
        }</span> else<span class="cov0" title="0"> {
                e.message = e.message + sentinelSeparator + fmt.Sprintf(format, args...)
        }</span>
        <span class="cov8" title="1">return e</span>
}

func (e *implError) WithStackFrame() Error <span class="cov8" title="1">{
        pc, _, _, _ := runtime.Caller(1)
        e.stackFrame = NewStackFrame(pc)
        return e
}</span>

func (e *implError) Error() string <span class="cov8" title="1">{
        return e.message
}</span>

func (e *implError) Unwrap() []error <span class="cov8" title="1">{
        return e.wrapped
}</span>

func (e *implError) StackFrame() *StackFrame <span class="cov0" title="0">{
        return e.stackFrame
}</span>

func (e *implError) Tags() map[string]any <span class="cov8" title="1">{
        return e.tags
}</span>

func (e *implError) Format(s fmt.State, verb rune) <span class="cov8" title="1">{
        switch verb </span>{
        case 'v':<span class="cov0" title="0">
                if s.Flag('+') </span><span class="cov0" title="0">{
                        buf := new(bytes.Buffer)
                        formatErrorChainDetailed(buf, errorHeader, "", e)
                        _, _ = s.Write(buf.Bytes())
                        break</span>
                }
                <span class="cov0" title="0">fallthrough</span>
        case 's':<span class="cov8" title="1">
                _, _ = io.WriteString(s, errorHeader+e.Error()+"\n")
                if len(e.Tags()) &gt; 0 </span><span class="cov8" title="1">{
                        tags, err := json.Marshal(e.Tags())
                        if err == nil </span><span class="cov8" title="1">{
                                _, _ = io.WriteString(s, tagsPrefix)
                                _, _ = io.Writer.Write(s, tags) //nolint:gocritic // false positive
                                _, _ = io.WriteString(s, "\n")
                        }</span>
                }
        case 'q':<span class="cov0" title="0">
                _, _ = fmt.Fprintf(s, "%s%s\n", errorHeader, e.Error())</span>
        }
}

type hasTags interface {
        error
        Tags() map[string]any
}

type hasStackFrame interface {
        error
        StackFrame() *StackFrame
}

type wrapsError interface {
        error
        Unwrap() error
}

type wrapsMultipleErrors interface {
        error
        Unwrap() []error
}

func formatErrorChainDetailed(buffer *bytes.Buffer, header, indent string, err error) <span class="cov0" title="0">{
        buffer.WriteString(indent)
        buffer.WriteString(header)
        buffer.WriteString(err.Error())
        buffer.WriteString("\n")

        //nolint:errorlint // internal error library
        if stackFrameErr, ok := err.(hasStackFrame); ok &amp;&amp; stackFrameErr.StackFrame() != nil </span><span class="cov0" title="0">{
                stackFrame := stackFrameErr.StackFrame()
                buffer.WriteString(indent)
                buffer.WriteString(stackFramePrefix)
                buffer.WriteString(stackFrame.File + ":" + strconv.Itoa(stackFrame.LineNo))
                buffer.WriteString("\n")
        }</span>

        //nolint:errorlint // internal error library
        <span class="cov0" title="0">if tagsErr, ok := err.(hasTags); ok &amp;&amp; len(tagsErr.Tags()) &gt; 0 </span><span class="cov0" title="0">{
                tags := tagsErr.Tags()
                tagsStr, err := json.Marshal(tags)
                if err == nil </span><span class="cov0" title="0">{
                        buffer.WriteString(indent)
                        buffer.WriteString(tagsPrefix)
                        buffer.Write(tagsStr)
                        buffer.WriteString("\n")
                }</span>
        }

        <span class="cov0" title="0">var children []error
        //nolint:errorlint // internal error library
        if joined, ok := err.(wrapsMultipleErrors); ok </span><span class="cov0" title="0">{
                children = append(children, joined.Unwrap()...)
        }</span>
        //nolint:errorlint // internal error library
        <span class="cov0" title="0">if wrapped, ok := err.(wrapsError); ok </span><span class="cov0" title="0">{
                children = append(children, wrapped.Unwrap())
        }</span>
        <span class="cov0" title="0">filteredChildren := nonSentinelErrorsFilter(children)
        if len(filteredChildren) &gt; 0 </span><span class="cov0" title="0">{
                buffer.WriteString(indent)
                buffer.WriteString("Caused by:\n")
                for i, child := range filteredChildren </span><span class="cov0" title="0">{
                        formatErrorChainDetailed(buffer, "["+strconv.Itoa(i)+"] ", indent+defaultIndent, child)
                }</span>
        }
}

func nonSentinelErrorsFilter(errs []error) []error <span class="cov0" title="0">{
        var filtered []error
        for _, e := range errs </span><span class="cov0" title="0">{
                //nolint:errorlint // internal error library
                if _, ok := e.(*sentinelError); !ok </span><span class="cov0" title="0">{
                        filtered = append(filtered, e)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package errs2

import (
        "runtime"
        "strings"
)

type StackFrame struct {
        File           string
        LineNo         int
        Name           string
        Package        string
        ProgramCounter uintptr
}

func NewStackFrame(pc uintptr) *StackFrame <span class="cov8" title="1">{
        fn := runtime.FuncForPC(pc)
        fnFileName, fnLineNo := fn.FileLine(pc)
        fnName := fn.Name()
        fnPkgName := ""
        if lastSlash := strings.LastIndex(fnName, "/"); lastSlash &gt;= 0 </span><span class="cov8" title="1">{
                fnPkgName += fnName[:lastSlash] + "/"
                fnName = fnName[lastSlash+1:]
        }</span>
        <span class="cov8" title="1">if period := strings.Index(fnName, "."); period &gt;= 0 </span><span class="cov8" title="1">{
                fnPkgName += fnName[:period]
                fnName = fnName[period+1:]
        }</span>

        <span class="cov8" title="1">fnName = strings.ReplaceAll(fnName, "", ".")

        return &amp;StackFrame{File: fnFileName, LineNo: fnLineNo, Name: fnName, Package: fnPkgName, ProgramCounter: pc}</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package errs2

func Must(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func Must1[T any](v T, err error) T <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v</span>
}

func Must2[T1, T2 any](v1In T1, v2In T2, err error) (v1Out T1, v2Out T2) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return v1In, v2In</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package cardinal

import (
        "math/big"

        "github.com/bronlabs/bron-crypto/pkg/base"
)

var i Cardinal = infinite{}

func Infinite() Cardinal <span class="cov8" title="1">{
        return i
}</span>

// infinite represents an infinite cardinal number.
type infinite struct{}

// IsLessThanOrEqual checks if the infinite cardinal is less than or equal to another cardinal.
// It will be equal only to another Infinite cardinal.
func (infinite) IsLessThanOrEqual(other Cardinal) bool <span class="cov8" title="1">{
        _, otherIsInfinite := other.(infinite)
        return otherIsInfinite
}</span>

// Clone returns a copy of the infinite cardinal.
func (i infinite) Clone() Cardinal <span class="cov8" title="1">{
        return i
}</span>

// HashCode returns the hash code of the infinite cardinal.
func (infinite) HashCode() base.HashCode <span class="cov0" title="0">{
        return base.DeriveHashCode([]byte("InfiniteCardinal"))
}</span>

// Equal checks if the infinite cardinal is equal to another cardinal.
// It will be equal only to another Infinite cardinal.
func (infinite) Equal(other Cardinal) bool <span class="cov8" title="1">{
        _, otherIsInfinite := other.(infinite)
        return otherIsInfinite
}</span>

// Bytes panics as Bytes is not defined for Infinite cardinal.
func (infinite) Bytes() []byte <span class="cov8" title="1">{
        panic("Bytes() not supported for Infinite cardinal")</span>
}

// BytesBE panics as BytesBE is not defined for Infinite cardinal.
func (infinite) BytesBE() []byte <span class="cov8" title="1">{
        panic("BytesBE() not supported for Infinite cardinal")</span>
}

// String returns the string representation of the infinite cardinal.
func (infinite) String() string <span class="cov8" title="1">{
        return "InfiniteCardinal"
}</span>

// Add returns Infinite cardinal when adding with any other cardinal.
func (i infinite) Add(other Cardinal) Cardinal <span class="cov8" title="1">{
        return i
}</span>

// Mul returns Infinite cardinal when multiplying with any other cardinal.
func (i infinite) Mul(other Cardinal) Cardinal <span class="cov8" title="1">{
        return i
}</span>

// Big panics as Big is not defined for Infinite cardinal.
func (infinite) Big() *big.Int <span class="cov8" title="1">{
        panic("Big() not supported for Infinite cardinal")</span>
}

// Uint64 panics as Uint64 is not defined for Infinite cardinal.
func (infinite) Uint64() uint64 <span class="cov8" title="1">{
        panic("Uint64() not supported for Infinite cardinal")</span>
}

// IsZero always returns false for Infinite cardinal.
func (infinite) IsZero() bool <span class="cov8" title="1">{
        return false
}</span>

// IsFinite always returns false for Infinite cardinal.
func (infinite) IsFinite() bool <span class="cov8" title="1">{
        return false
}</span>

// IsUnknown always returns false for Infinite cardinal.
func (infinite) IsUnknown() bool <span class="cov8" title="1">{
        return false
}</span>

// IsProbablyPrime panics as IsProbablyPrime is not defined for Infinite cardinal.
func (infinite) IsProbablyPrime() bool <span class="cov8" title="1">{
        panic("IsProbablyPrime() not supported for Infinite cardinal")</span>
}

// BitLen panics as BitLen is not defined for Infinite cardinal.
func (infinite) BitLen() int <span class="cov8" title="1">{
        panic("BitLen() not supported for Infinite cardinal")</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package cardinal

import (
        "math/big"
        "math/bits"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        acrtp "github.com/bronlabs/bron-crypto/pkg/base/algebra/crtp"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

// New creates a new Known cardinal from a uint64 value.
func New(n uint64) Cardinal <span class="cov8" title="1">{
        var nat numct.Nat
        nat.SetUint64(n)
        nat.Resize(bits.Len64(n))
        return Known(nat.BytesBE())
}</span>

// NewFromBig creates a new Cardinal from a big.Int value.
func NewFromBig(n *big.Int) Cardinal <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return Unknown()
        }</span>
        <span class="cov8" title="1">if n.Sign() &lt; 0 </span><span class="cov8" title="1">{
                return Unknown()
        }</span>
        <span class="cov8" title="1">return Known(numct.NewNatFromBig(n, n.BitLen()).BytesBE())</span>
}

// NewFromNumeric creates a new Cardinal from a Numeric value.
func NewFromNumeric(num acrtp.Numeric) Cardinal <span class="cov0" title="0">{
        return Known(num.BytesBE())
}</span>

// Zero returns the zero cardinal.
func Zero() Cardinal <span class="cov0" title="0">{
        return Known([]byte{})
}</span>

// Known represents a cardinal number with a known value.
type Known []byte

// Nat returns the numeric representation of the known cardinal.
func (k Known) Nat() *numct.Nat <span class="cov8" title="1">{
        return numct.NewNatFromBytes(k)
}</span>

// IsLessThanOrEqual checks if the known cardinal is less than or equal to another cardinal.
func (k Known) IsLessThanOrEqual(other Cardinal) bool <span class="cov8" title="1">{
        otherKnown, ok := other.(Known)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">lt, eq, _ := k.Nat().Compare(otherKnown.Nat())
        return lt|eq == ct.True</span>
}

// Clone creates a copy of the known cardinal.
func (k Known) Clone() Cardinal <span class="cov8" title="1">{
        return slices.Clone(k)
}</span>

// HashCode computes the hash code of the known cardinal.
func (k Known) HashCode() base.HashCode <span class="cov0" title="0">{
        return base.DeriveHashCode(k)
}</span>

// Equal checks if the known cardinal is equal to another cardinal.
func (k Known) Equal(other Cardinal) bool <span class="cov8" title="1">{
        otherKnown, ok := other.(Known)
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return k.Nat().Equal(otherKnown.Nat()) == ct.True</span>
}

// Bytes returns the byte representation of the known cardinal.
func (k Known) Bytes() []byte <span class="cov0" title="0">{
        return slices.Clone(k)
}</span>

// BytesBE returns the big-endian byte representation of the known cardinal.
func (k Known) BytesBE() []byte <span class="cov0" title="0">{
        return slices.Clone(k)
}</span>

// String returns the string representation of the known cardinal.
func (k Known) String() string <span class="cov8" title="1">{
        return k.Nat().String()
}</span>

// Add adds two known cardinals.
func (k Known) Add(other Cardinal) Cardinal <span class="cov8" title="1">{
        otherKnown, _ := other.(Known)
        var sum numct.Nat
        sum.Add(k.Nat(), otherKnown.Nat())
        return Known(sum.BytesBE())
}</span>

// Mul multiplies two known cardinals.
func (k Known) Mul(other Cardinal) Cardinal <span class="cov8" title="1">{
        otherKnown, _ := other.(Known)
        var prod numct.Nat
        prod.Mul(k.Nat(), otherKnown.Nat())
        return Known(prod.BytesBE())
}</span>

// Sub subtracts another known cardinal from the known cardinal.
func (k Known) Sub(other Cardinal) Cardinal <span class="cov8" title="1">{
        otherKnown, _ := other.(Known)
        var diff numct.Nat
        diff.SubCap(k.Nat(), otherKnown.Nat(), -1)
        return Known(diff.BytesBE())
}</span>

// Big returns the big.Int representation of the known cardinal.
func (k Known) Big() *big.Int <span class="cov8" title="1">{
        return k.Nat().Big()
}</span>

// Uint64 returns the uint64 representation of the known cardinal.
func (k Known) Uint64() uint64 <span class="cov8" title="1">{
        return k.Nat().Uint64()
}</span>

// IsZero checks if the known cardinal is zero.
func (k Known) IsZero() bool <span class="cov8" title="1">{
        return k.Nat().IsZero() == ct.True
}</span>

// IsFinite checks if the known cardinal is finite, which is always true for Known.
func (Known) IsFinite() bool <span class="cov8" title="1">{
        return true
}</span>

// IsUnknown checks if the known cardinal is unknown, which is always false for Known.
func (Known) IsUnknown() bool <span class="cov8" title="1">{
        return false
}</span>

// IsProbablyPrime checks if the known cardinal is probably prime.
func (k Known) IsProbablyPrime() bool <span class="cov8" title="1">{
        return k.Nat().IsProbablyPrime() == ct.True
}</span>

// BitLen returns the bit length of the known cardinal.
func (k Known) BitLen() int <span class="cov0" title="0">{
        return k.Nat().AnnouncedLen()
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">package cardinal

import (
        "math/big"

        "github.com/bronlabs/bron-crypto/pkg/base"
)

var u Cardinal = unknown{}

func Unknown() Cardinal <span class="cov8" title="1">{
        return u
}</span>

// unknown represents a cardinal of unknown size.
type unknown struct{}

// IsLessThanOrEqual always returns false for Unknown cardinal.
func (unknown) IsLessThanOrEqual(other Cardinal) bool <span class="cov8" title="1">{
        return false
}</span>

// Clone returns a new instance of Unknown cardinal.
func (u unknown) Clone() Cardinal <span class="cov8" title="1">{
        return u
}</span>

// HashCode returns a hash code for Unknown cardinal.
func (unknown) HashCode() base.HashCode <span class="cov0" title="0">{
        return base.DeriveHashCode([]byte("UnknownCardinal"))
}</span>

// Equal always returns false when comparing Unknown cardinal with any other cardinal.
func (unknown) Equal(other Cardinal) bool <span class="cov8" title="1">{
        return false
}</span>

// Bytes panics as Bytes is not defined for Unknown cardinal.
func (unknown) Bytes() []byte <span class="cov8" title="1">{
        panic("Bytes() not supported for Unknown cardinal")</span>
}

// BytesBE panics as BytesBE is not defined for Unknown cardinal.
func (unknown) BytesBE() []byte <span class="cov8" title="1">{
        panic("BytesBE() not supported for Unknown cardinal")</span>
}

// String returns a string representation of Unknown cardinal.
func (unknown) String() string <span class="cov8" title="1">{
        return "UnknownCardinal"
}</span>

// Add returns Unknown cardinal when adding to any other cardinal.
func (u unknown) Add(other Cardinal) Cardinal <span class="cov8" title="1">{
        return u
}</span>

// Mul returns Unknown cardinal when multiplying with any other cardinal.
func (u unknown) Mul(other Cardinal) Cardinal <span class="cov8" title="1">{
        return u
}</span>

// Big panics as Big is not defined for Unknown cardinal.
func (unknown) Big() *big.Int <span class="cov8" title="1">{
        panic("Big() not supported for Unknown cardinal")</span>
}

// Uint64 panics as Uint64 is not defined for Unknown cardinal.
func (unknown) Uint64() uint64 <span class="cov8" title="1">{
        panic("Uint64() not supported for Unknown cardinal")</span>
}

// IsZero always returns false for Unknown cardinal.
func (unknown) IsZero() bool <span class="cov8" title="1">{
        return false
}</span>

// IsFinite always returns true for Unknown cardinal.
func (unknown) IsFinite() bool <span class="cov8" title="1">{
        return true
}</span>

// IsUnknown always returns true for Unknown cardinal.
func (unknown) IsUnknown() bool <span class="cov8" title="1">{
        return true
}</span>

// IsProbablyPrime panics as IsProbablyPrime is not defined for Unknown cardinal.
func (unknown) IsProbablyPrime() bool <span class="cov8" title="1">{
        panic("IsProbablyPrime() not supported for Unknown cardinal")</span>
}

// BitLen panics as BitLen is not defined for Unknown cardinal.
func (unknown) BitLen() int <span class="cov8" title="1">{
        panic("BitLen() not supported for Unknown cardinal")</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package crt

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

// Recombine is a one-shot variant that computes q^{-1} (mod p) on the fly.
func Recombine(mp, mq, p, q *numct.Nat) (result *numct.Nat, ok ct.Bool) <span class="cov8" title="1">{
        params, ok := Precompute(p, q)
        return params.Recombine(mp, mq), ok
}</span>

func Precompute(p, q *numct.Nat) (params *Params, ok ct.Bool) <span class="cov8" title="1">{
        allOk := p.Coprime(q)
        pModulus, ok := numct.NewModulus(p)
        allOk &amp;= ok

        // qModP := q mod p
        qModP := new(numct.Nat)
        pModulus.Mod(qModP, q)

        // qInv := (q mod p)^{-1} mod p
        qInv := new(numct.Nat)
        // q must be a unit modulo p (i.e., gcd(p,q)=1)
        allOk &amp;= pModulus.ModInv(qInv, qModP)

        return &amp;Params{
                P:    pModulus,
                QNat: q.Clone(),
                QInv: qInv,
                Cap:  pModulus.BitLen() + q.AnnouncedLen(),
        }, allOk
}</span>

// Params holds reusable data for CRT recombination mod N = p*q.
type Params struct {
        P    *numct.Modulus
        QNat *numct.Nat
        QInv *numct.Nat
        Cap  int
}

// Recombine reconstructs m (mod p*q) from residues (mp, mq),
// using precomputed q^{-1} (mod p).
//
// m = mq + q * ((mp - mq) * qInv mod p).
func (prm *Params) Recombine(mp, mq *numct.Nat) *numct.Nat <span class="cov8" title="1">{
        // h = (mp - mq) mod p
        h := new(numct.Nat)
        prm.P.ModSub(h, mp, mq)
        // h = h * qInv mod p
        prm.P.ModMul(h, h, prm.QInv)

        // m = mq + (h * q)
        m := new(numct.Nat)
        m.MulCap(h, prm.QNat, prm.Cap)
        m.AddCap(m, mq, prm.Cap)
        return m
}</span>

// Extended returns an extended ParamsExtended structure.
func (prm *Params) Extended() (ext *ParamsExtended, ok ct.Bool) <span class="cov8" title="1">{
        qModulus, ok := numct.NewModulus(prm.QNat)
        var mNat numct.Nat
        mNat.Mul(prm.P.Nat(), prm.QNat)
        mModulus, okT := numct.NewModulus(&amp;mNat)
        ok &amp;= okT
        return &amp;ParamsExtended{
                Params: *prm,
                PNat:   prm.P.Nat(),
                Q:      qModulus,
                M:      mModulus,
        }, ok
}</span>

// PrecomputePairExtended is a one-shot variant that precomputes extended CRT parameters.
func PrecomputePairExtended(p, q *numct.Nat) (params *ParamsExtended, ok ct.Bool) <span class="cov8" title="1">{
        prm, ok1 := Precompute(p, q)
        prmx, ok2 := prm.Extended()
        return prmx, ok1 &amp; ok2
}</span>

// NewParamsExtended constructs extended CRT parameters from given moduli p and q.
func NewParamsExtended(p, q *numct.Modulus) (params *ParamsExtended, ok ct.Bool) <span class="cov8" title="1">{
        qNat := q.Nat()
        pNat := p.Nat()

        ok = pNat.Coprime(qNat)

        // qModP := q mod p
        qModP := new(numct.Nat)
        p.Mod(qModP, qNat)

        // qInv := (q mod p)^{-1} mod p
        qInv := new(numct.Nat)
        // q must be a unit modulo p (i.e., gcd(p,q)=1)
        ok &amp;= p.ModInv(qInv, qModP)

        var mNat numct.Nat
        mNat.Mul(pNat, qNat)
        m, okT := numct.NewModulus(&amp;mNat)
        ok &amp;= okT

        return &amp;ParamsExtended{
                Params: Params{
                        P:    p,
                        QNat: qNat,
                        QInv: qInv,
                        Cap:  p.BitLen() + qNat.TrueLen(),
                },
                PNat: pNat,
                Q:    q,
                M:    m,
        }, ok
}</span>

// ParamsExtended holds reusable data for CRT recombination mod N = p*q,
// along with extended functionality such as modulus decomposition.
type ParamsExtended struct {
        Params

        PNat *numct.Nat
        Q    *numct.Modulus
        M    *numct.Modulus
}

// Modulus returns the modulus N = p * q.
func (prmx *ParamsExtended) Modulus() *numct.Modulus <span class="cov0" title="0">{
        return prmx.M
}</span>

// Decompose returns (m mod p, m mod q).
func (prmx *ParamsExtended) Decompose(m *numct.Modulus) (mp, mq *numct.Nat) <span class="cov8" title="1">{
        if m.BitLen() &lt;= 4096 </span><span class="cov8" title="1">{
                return prmx.DecomposeSerial(m)
        }</span>
        <span class="cov0" title="0">return prmx.DecomposeParallel(m)</span>
}

// DecomposeParallel returns (m mod p, m mod q), computed in parallel.
func (prmx *ParamsExtended) DecomposeParallel(m *numct.Modulus) (mp, mq *numct.Nat) <span class="cov8" title="1">{
        mpt := new(numct.Nat)
        mqt := new(numct.Nat)
        var wg sync.WaitGroup
        wg.Add(2)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                // Compute m.Nat() mod p
                prmx.P.Mod(mpt, m.Nat())
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                // Compute m.Nat() mod q
                prmx.Q.Mod(mqt, m.Nat())
        }</span>()
        <span class="cov8" title="1">wg.Wait()
        return mpt, mqt</span>
}

// DecomposeSerial returns (m mod p, m mod q), computed serially.
func (prmx *ParamsExtended) DecomposeSerial(m *numct.Modulus) (mp, mq *numct.Nat) <span class="cov8" title="1">{
        mpt := new(numct.Nat)
        mqt := new(numct.Nat)
        // Compute m.Nat() mod p
        prmx.P.Mod(mpt, m.Nat())
        // Compute m.Nat() mod q
        prmx.Q.Mod(mqt, m.Nat())
        return mpt, mqt
}</span>
</pre>
		
		<pre class="file" id="file143" style="display: none">package crt

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

// ParamsMulti holds precomputed values for multi-factor CRT with k pairwise coprime factors.
// For factors p_1, p_2, ..., p_k, we precompute:
// - M_i = N / p_i where N = p_1 * p_2 * ... * p_k
// - M_i^{-1} mod p_i for each i.
type ParamsMulti struct {
        Factors    []*numct.Modulus // p_i as moduli
        Products   []*numct.Nat     // M_i = N / p_i
        Inverses   []*numct.Nat     // inv_i = (M_i)^{-1} mod p_i
        Lifts      []*numct.Nat     // Lift_i = M_i * inv_i mod N
        Modulus    *numct.Modulus   // N as a modulus object (for Mod reductions)
        NumFactors int              // number of factors (pairwise coprime, not necessarily prime)
        // Garner's algorithm precomputed values:
        // GarnerCoeffs[i][j] = (p_1 * ... * p_j)^{-1} mod p_{i+1} for j &lt; i
        GarnerCoeffs [][]*numct.Nat
}

// NewParamsMulti constructs multi-factor CRT parameters from given moduli.
func NewParamsMulti(factors ...*numct.Modulus) (params *ParamsMulti, ok ct.Bool) <span class="cov8" title="1">{
        k := len(factors)
        allOk := ct.GreaterOrEqual(k, 2)

        params = &amp;ParamsMulti{
                Factors:      make([]*numct.Modulus, k),
                Products:     make([]*numct.Nat, k),
                Inverses:     make([]*numct.Nat, k),
                Lifts:        make([]*numct.Nat, k),
                NumFactors:   k,
                GarnerCoeffs: make([][]*numct.Nat, k),
                Modulus:      nil,
        }

        // Set p_i as moduli and compute N =  p_i
        prod := numct.NatOne()
        for i := range k </span><span class="cov8" title="1">{
                params.Factors[i] = factors[i]
                capMul := prod.AnnouncedLen() + factors[i].BitLen()
                prod.MulCap(prod, factors[i].Nat(), capMul)
        }</span>
        <span class="cov8" title="1">modulus, ok := numct.NewModulus(prod)
        allOk &amp;= ok
        params.Modulus = modulus

        // For each i: M_i = N / p_i; inv_i = (M_i)^{-1} mod p_i; Lift_i = M_i * inv_i mod N
        var Mi, MiModPi, inv, lift numct.Nat
        for i := range k </span><span class="cov8" title="1">{
                // M_i = N / p_i
                allOk &amp;= Mi.Div(nil, prod, factors[i].Nat())
                params.Products[i] = Mi.Clone()

                // inv_i = (M_i mod p_i)^{-1} mod p_i  (ok iff gcd(M_i, p_i)=1)
                params.Factors[i].Mod(&amp;MiModPi, &amp;Mi)

                allOk &amp;= params.Factors[i].ModInv(&amp;inv, &amp;MiModPi)
                params.Inverses[i] = inv.Clone()

                // Lift_i = (M_i * inv_i) mod N
                capMul := Mi.AnnouncedLen() + inv.AnnouncedLen()
                lift.MulCap(&amp;Mi, &amp;inv, capMul)
                params.Modulus.Mod(&amp;lift, &amp;lift)
                params.Lifts[i] = lift.Clone()
        }</span>

        // Precompute Garner coefficients
        // For each p_i (i &gt;= 1), we need inverses of P_j mod p_i for all j &lt; i
        // where P_j = p_0 * p_1 * ... * p_j
        <span class="cov8" title="1">for i := 1; i &lt; k; i++ </span><span class="cov8" title="1">{
                params.GarnerCoeffs[i] = make([]*numct.Nat, i)

                // Compute P_j for j = 0 to i-1
                pProd := numct.NatOne()
                for j := range i </span><span class="cov8" title="1">{
                        // pProd = p_0 * ... * p_j
                        capMul := pProd.AnnouncedLen() + factors[j].BitLen()
                        pProd.MulCap(pProd, factors[j].Nat(), capMul)

                        // Compute pProd^{-1} mod p_i
                        var pProdModPi, inv numct.Nat
                        params.Factors[i].Mod(&amp;pProdModPi, pProd)
                        allOk &amp;= params.Factors[i].ModInv(&amp;inv, &amp;pProdModPi)
                        params.GarnerCoeffs[i][j] = inv.Clone()
                }</span>
        }

        <span class="cov8" title="1">return params, allOk</span>
}

// PrecomputeMulti precomputes CRT parameters for k primes.
// All operations are constant-time with respect to the prime values.
// Returns nil if any prime is not coprime to the others.
func PrecomputeMulti(factors ...*numct.Nat) (params *ParamsMulti, ok ct.Bool) <span class="cov8" title="1">{
        allOk := ct.True
        fs := make([]*numct.Modulus, len(factors))
        for i, f := range factors </span><span class="cov8" title="1">{
                fi, ok := numct.NewModulus(f)
                allOk &amp;= ok
                fs[i] = fi
        }</span>
        <span class="cov8" title="1">out, ok := NewParamsMulti(fs...)
        allOk &amp;= ok
        return out, allOk</span>
}

// RecombineParallel reconstructs x (mod N) from residues[i] = x mod p_i using precomputed lifts.
// x   residues[i] * Lift_i (mod N).
func (prm *ParamsMulti) RecombineParallel(residues ...*numct.Nat) (result *numct.Nat, ok ct.Bool) <span class="cov8" title="1">{
        eqLen := ct.Equal(len(residues), prm.NumFactors)
        if eqLen == ct.False </span><span class="cov0" title="0">{
                return nil, eqLen
        }</span>
        <span class="cov8" title="1">var wg sync.WaitGroup
        wg.Add(prm.NumFactors)

        terms := make([]*numct.Nat, prm.NumFactors)
        for i := range prm.NumFactors </span><span class="cov8" title="1">{
                go func(idx int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        var term numct.Nat
                        prm.Modulus.ModMul(&amp;term, residues[idx], prm.Lifts[idx])
                        terms[idx] = &amp;term
                }</span>(i)
        }
        <span class="cov8" title="1">wg.Wait()
        result = numct.NatZero()
        for i := range terms </span><span class="cov8" title="1">{
                prm.Modulus.ModAdd(result, result, terms[i])
        }</span>
        <span class="cov8" title="1">return result, eqLen</span>
}

// RecombineSerial reconstructs x (mod N) from residues[i] = x mod p_i using Garner's algorithm.
func (prm *ParamsMulti) RecombineSerial(residues ...*numct.Nat) (result *numct.Nat, ok ct.Bool) <span class="cov8" title="1">{
        eqLen := ct.Equal(len(residues), prm.NumFactors)
        if eqLen == ct.False </span><span class="cov8" title="1">{
                return nil, eqLen
        }</span>
        // Garner's algorithm:
        // Start with x = a_0
        // For i = 1 to k-1:
        //   c_i = (a_i - x) * (p_0 * ... * p_{i-1})^{-1} mod p_i
        //   x = x + c_i * (p_0 * ... * p_{i-1})

        <span class="cov8" title="1">result = residues[0].Clone() // x = a_0
        pProd := numct.NatOne()
        for i := 1; i &lt; prm.NumFactors; i++ </span><span class="cov8" title="1">{
                // Update pProd = p_0 * ... * p_{i-1}
                capMul := pProd.AnnouncedLen() + prm.Factors[i-1].Nat().AnnouncedLen()
                (pProd).MulCap(pProd, prm.Factors[i-1].Nat(), capMul)

                // Compute c_i = (a_i - x) * (p_0 * ... * p_{i-1})^{-1} mod p_i
                var xModPi, diff, ci numct.Nat
                prm.Factors[i].Mod(&amp;xModPi, result)
                prm.Factors[i].ModSub(&amp;diff, residues[i], &amp;xModPi)
                prm.Factors[i].ModMul(&amp;ci, &amp;diff, prm.GarnerCoeffs[i][i-1])

                // x = x + c_i * pProd
                var term numct.Nat
                capMul = ci.AnnouncedLen() + pProd.AnnouncedLen()
                term.MulCap(&amp;ci, pProd, capMul)
                capAdd := result.AnnouncedLen() + term.AnnouncedLen()
                result.AddCap(result, &amp;term, capAdd)
        }</span>

        // Clone to return a properly typed value
        <span class="cov8" title="1">return result, eqLen</span>
}

// Recombine reconstructs x (mod N) from residues[i] = x mod p_i.
// Recombine chooses between serial and parallel based on size.
// The choice is deterministic based on modulus size and prime count.
func (prm *ParamsMulti) Recombine(residues ...*numct.Nat) (result *numct.Nat, ok ct.Bool) <span class="cov8" title="1">{
        if prm.NumFactors &lt;= 4 </span><span class="cov8" title="1">{
                return prm.RecombineSerial(residues...)
        }</span>
        <span class="cov0" title="0">return prm.RecombineParallel(residues...)</span>
}

// DecomposeSerial decomposes m into residues mod each prime.
// Constant-time with respect to values (not the number of primes).
func (prm *ParamsMulti) DecomposeSerial(m *numct.Modulus) []*numct.Nat <span class="cov8" title="1">{
        residues := make([]*numct.Nat, prm.NumFactors)

        // Process all primes to maintain constant time
        for i := range prm.NumFactors </span><span class="cov8" title="1">{
                var residueT numct.Nat
                prm.Factors[i].Mod(&amp;residueT, m.Nat())
                residues[i] = &amp;residueT
        }</span>

        <span class="cov8" title="1">return residues</span>
}

// DecomposeParallel decomposes m into residues mod each prime in parallel.
// Constant-time with respect to values (not the number of primes).
func (prm *ParamsMulti) DecomposeParallel(m *numct.Modulus) []*numct.Nat <span class="cov8" title="1">{
        residues := make([]*numct.Nat, prm.NumFactors)

        var wg sync.WaitGroup
        wg.Add(prm.NumFactors)

        // Launch all goroutines to maintain constant time
        for i := range prm.NumFactors </span><span class="cov8" title="1">{
                go func(idx int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        var residue numct.Nat
                        prm.Factors[idx].Mod(&amp;residue, m.Nat())
                        residues[idx] = &amp;residue
                }</span>(i)
        }

        <span class="cov8" title="1">wg.Wait()
        return residues</span>
}

// Decompose chooses between serial and parallel based on size.
// The choice is deterministic based on modulus size and prime count.
func (prm *ParamsMulti) Decompose(m *numct.Modulus) []*numct.Nat <span class="cov8" title="1">{
        // Use parallel for larger moduli or more primes
        // This is a deterministic choice, not data-dependent
        if m.BitLen() &gt; 4096 || prm.NumFactors &gt; 3 </span><span class="cov0" title="0">{
                return prm.DecomposeParallel(m)
        }</span>
        <span class="cov8" title="1">return prm.DecomposeSerial(m)</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package modular

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*SimpleModulus)(nil)
        _ cbor.Unmarshaler = (*SimpleModulus)(nil)
        _ cbor.Marshaler   = (*OddPrimeFactors)(nil)
        _ cbor.Unmarshaler = (*OddPrimeFactors)(nil)
        _ cbor.Marshaler   = (*OddPrimeSquareFactors)(nil)
        _ cbor.Unmarshaler = (*OddPrimeSquareFactors)(nil)
)

const (
        SimpleModulusTag         = 5006
        OddPrimeFactorsTag       = 5007
        OddPrimeSquareFactorsTag = 5008
)

func init() <span class="cov8" title="1">{
        serde.Register[*SimpleModulus](SimpleModulusTag)
        serde.Register[*OddPrimeFactors](OddPrimeFactorsTag)
        serde.Register[*OddPrimeSquareFactors](OddPrimeSquareFactorsTag)
}</span>

type simpleDTO struct {
        Modulus *numct.Modulus `cbor:"modulus"`
}

func (m *SimpleModulus) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;simpleDTO{Modulus: m.m}
        data, err := serde.MarshalCBORTagged(dto, SimpleModulusTag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal SimpleModulus")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (m *SimpleModulus) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[simpleDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">m.m = dto.Modulus
        return nil</span>
}

type pairDTO struct {
        P *numct.Nat `cbor:"p"`
        Q *numct.Nat `cbor:"q"`
}

func (m *OddPrimeFactors) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;pairDTO{
                P: m.Params.P.Nat(),
                Q: m.Params.Q.Nat(),
        }
        data, err := serde.MarshalCBORTagged(dto, OddPrimeFactorsTag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal OddPrimeFactors")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (m *OddPrimeFactors) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[pairDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">out, ok := NewOddPrimeFactors(dto.P, dto.Q)
        if ok == ct.False </span><span class="cov0" title="0">{
                return ErrFailed.WithMessage("failed to create OddPrimeFactors")
        }</span>
        <span class="cov8" title="1">*m = *out
        return nil</span>
}

func (m *OddPrimeSquareFactors) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;pairDTO{
                P: m.P.Factor.Nat(),
                Q: m.Q.Factor.Nat(),
        }
        data, err := serde.MarshalCBORTagged(dto, OddPrimeSquareFactorsTag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal OddPrimeSquareFactors")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (m *OddPrimeSquareFactors) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[pairDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">out, ok := NewOddPrimeSquareFactors(dto.P, dto.Q)
        if ok == ct.False </span><span class="cov0" title="0">{
                return ErrFailed.WithMessage("failed to create OddPrimeSquareFactors")
        }</span>
        <span class="cov8" title="1">*m = *out
        return nil</span>
}

var (
        ErrFailed = errs2.New("failed")
)
</pre>
		
		<pre class="file" id="file145" style="display: none">package modular

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/crt"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

// NewOddPrimeFactors constructs an OddPrimeFactors modular arithmetic
// instance from the given odd prime factors p and q.
// Returns ct.False if the inputs are invalid (not odd primes or equal).
func NewOddPrimeFactors(p, q *numct.Nat) (factors *OddPrimeFactors, ok ct.Bool) <span class="cov8" title="1">{
        allOk := p.Equal(q).Not() &amp; p.IsProbablyPrime() &amp; q.IsProbablyPrime() &amp; p.IsOdd() &amp; q.IsOdd()

        params, ok := crt.PrecomputePairExtended(p, q)
        allOk &amp;= ok

        // Compute m = p * q for the modulus
        var mNat numct.Nat
        mNat.Mul(p, q)
        m, ok := numct.NewModulus(&amp;mNat)
        allOk &amp;= ok

        // Compute phi(p) = p-1 and phi(q) = q-1
        var phiPnat, phiQnat numct.Nat
        phiPnat.Set(p.Clone())
        phiPnat.Decrement()
        phiQnat.Set(q.Clone())
        phiQnat.Decrement()

        phiP, ok := numct.NewModulus(&amp;phiPnat)
        allOk &amp;= ok
        phiQ, ok := numct.NewModulus(&amp;phiQnat)
        allOk &amp;= ok

        var phiNat numct.Nat
        phiNat.Mul(&amp;phiPnat, &amp;phiQnat)
        phi, ok := numct.NewModulus(&amp;phiNat)
        allOk &amp;= ok

        return &amp;OddPrimeFactors{
                Params: params,
                N:      m,
                PhiP:   phiP,
                PhiQ:   phiQ,
                Phi:    phi,
        }, allOk
}</span>

// OddPrimeFactors implements modular arithmetic modulo n = p * q,
// where p and q are distinct odd primes.
type OddPrimeFactors struct {
        Params *crt.ParamsExtended // CRT parameters for p and q
        N      *numct.Modulus      // n = p * q
        PhiP   *numct.Modulus      // (p) = p - 1
        PhiQ   *numct.Modulus      // (q) = q - 1
        Phi    *numct.Modulus      // (n) = (p - 1)*(q - 1)
}

// Modulus returns the modulus n = p * q.
func (m *OddPrimeFactors) Modulus() *numct.Modulus <span class="cov8" title="1">{
        return m.N
}</span>

// MultiplicativeOrder returns the multiplicative order (n) = (p-1)*(q-1).
func (m *OddPrimeFactors) MultiplicativeOrder() algebra.Cardinal <span class="cov8" title="1">{
        return cardinal.NewFromNumeric(m.Phi)
}</span>

// ModMul computes out = (a * b) mod n.
func (m *OddPrimeFactors) ModMul(out, a, b *numct.Nat) <span class="cov8" title="1">{
        var ap, aq, bp, bq numct.Nat
        var mp, mq numct.Nat

        var wg sync.WaitGroup
        wg.Add(2)

        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                m.Params.P.Mod(&amp;ap, a)
                m.Params.P.Mod(&amp;bp, b)
                m.Params.P.ModMul(&amp;mp, &amp;ap, &amp;bp)
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                m.Params.Q.Mod(&amp;aq, a)
                m.Params.Q.Mod(&amp;bq, b)
                m.Params.Q.ModMul(&amp;mq, &amp;aq, &amp;bq)
        }</span>()
        <span class="cov8" title="1">wg.Wait()

        out.Set(m.Params.Recombine(&amp;mp, &amp;mq))</span>
}

// ModExp computes out = (base ^ exp) mod n.
func (m *OddPrimeFactors) ModExp(out, base, exp *numct.Nat) <span class="cov8" title="1">{
        var ep, eq, mp, mq numct.Nat
        var wg sync.WaitGroup
        wg.Add(2)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                m.PhiP.Mod(&amp;ep, exp)
                // Use reduced exponent when base is coprime (Fermat applies),
                // full exponent otherwise.
                ep.Select(base.Coprime(m.Params.PNat), exp, &amp;ep)
                (m.Params.P).ModExp(&amp;mp, base, &amp;ep)
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                m.PhiQ.Mod(&amp;eq, exp)
                eq.Select(base.Coprime(m.Params.QNat), exp, &amp;eq)
                m.Params.Q.ModExp(&amp;mq, base, &amp;eq)
        }</span>()
        <span class="cov8" title="1">wg.Wait()

        out.Set(m.Params.Recombine(&amp;mp, &amp;mq))</span>
}

// ModExpI computes out = (base ^ exp) mod n, where exp is a signed integer.
func (m *OddPrimeFactors) ModExpI(out, base *numct.Nat, exp *numct.Int) <span class="cov8" title="1">{
        var expAbs, out2 numct.Nat
        expAbs.Abs(exp)
        m.ModExp(out, base, &amp;expAbs)
        m.ModInv(&amp;out2, out)
        out.CondAssign(exp.IsNegative(), &amp;out2)
}</span>

// ModDiv computes out = (a / b) mod n.
func (m *OddPrimeFactors) ModDiv(out, a, b *numct.Nat) ct.Bool <span class="cov8" title="1">{
        return m.N.ModDiv(out, a, b)
}</span>

// MultiBaseExp computes out[i] = (bases[i] ^ exp) mod n for all i.
func (m *OddPrimeFactors) MultiBaseExp(out, bases []*numct.Nat, exp *numct.Nat) <span class="cov8" title="1">{
        if len(out) != len(bases) </span><span class="cov0" title="0">{
                panic("out and bases must have the same length")</span>
        }
        <span class="cov8" title="1">k := len(bases)

        var ep, eq numct.Nat
        m.PhiP.Mod(&amp;ep, exp)
        m.PhiQ.Mod(&amp;eq, exp)

        var wg sync.WaitGroup
        wg.Add(k)
        for i := range k </span><span class="cov8" title="1">{
                go func(i int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        bi := bases[i]
                        var mp, mq numct.Nat
                        var wgInner sync.WaitGroup
                        wgInner.Add(2)
                        go func() </span><span class="cov8" title="1">{
                                defer wgInner.Done()
                                var epi numct.Nat
                                epi.Select(bi.Coprime(m.Params.PNat), exp, &amp;ep)
                                m.Params.P.ModExp(&amp;mp, bi, &amp;epi)
                        }</span>()
                        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                                defer wgInner.Done()
                                var eqi numct.Nat
                                eqi.Select(bi.Coprime(m.Params.QNat), exp, &amp;eq)
                                m.Params.Q.ModExp(&amp;mq, bi, &amp;eqi)
                        }</span>()
                        <span class="cov8" title="1">wgInner.Wait()
                        out[i].Set(m.Params.Recombine(&amp;mp, &amp;mq))</span>
                }(i)
        }
        <span class="cov8" title="1">wg.Wait()</span>
}

// ModInv computes out = (a^{-1}) mod n.
func (m *OddPrimeFactors) ModInv(out, a *numct.Nat) ct.Bool <span class="cov8" title="1">{
        var ap, aq numct.Nat
        var ip, iq numct.Nat
        var okP, okQ ct.Bool

        var wg sync.WaitGroup
        wg.Add(2)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                (m.Params.P).Mod(&amp;ap, a)
                okP = (m.Params.P).ModInv(&amp;ip, &amp;ap)
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                (m.Params.Q).Mod(&amp;aq, a)
                okQ = (m.Params.Q).ModInv(&amp;iq, &amp;aq)
        }</span>()
        <span class="cov8" title="1">wg.Wait()

        ok := okP &amp; okQ
        out.Set(m.Params.Recombine(&amp;ip, &amp;iq))
        return ok</span>
}

// Lift constructs an OddPrimeSquareFactors modular arithmetic instance
// by lifting the modulus n = p * q to n^2 = p^2 * q^2.
// Returns ct.False if the lift operation fails.
func (m *OddPrimeFactors) Lift() (lifted *OddPrimeSquareFactors, ok ct.Bool) <span class="cov8" title="1">{
        // TODO: optimise
        out, ok := NewOddPrimeSquareFactors(
                m.Params.PNat,
                m.Params.QNat,
        )
        return out, ok
}</span>
</pre>
		
		<pre class="file" id="file146" style="display: none">package modular

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/crt"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

// NewOddPrimeSquare constructs an OddPrimeSquare modular arithmetic
// instance from the given odd prime factor p.
// Returns ct.False if the input is invalid (not an odd prime).
func NewOddPrimeSquare(oddPrimeFactor *numct.Nat) (m *OddPrimeSquare, ok ct.Bool) <span class="cov8" title="1">{
        allOk := oddPrimeFactor.IsProbablyPrime() &amp; oddPrimeFactor.IsOdd()

        p, ok := numct.NewModulus(oddPrimeFactor)
        allOk &amp;= ok

        // Compute (p) = p - 1
        phiPNat := oddPrimeFactor.Clone()
        phiPNat.Decrement() // (p) = p - 1

        // Compute (p^2) = p * (p - 1)
        var phiP2Nat numct.Nat
        phiP2Nat.Mul(phiPNat, oddPrimeFactor) // (p^2) = p * (p - 1)

        phiP, ok := numct.NewModulus(phiPNat)
        allOk &amp;= ok
        phiP2, ok := numct.NewModulus(&amp;phiP2Nat)
        allOk &amp;= ok

        // Compute p^2
        var p2Nat numct.Nat
        p2Nat.Mul(oddPrimeFactor, oddPrimeFactor) // p^2

        p2, ok := numct.NewModulus(&amp;p2Nat)
        allOk &amp;= ok

        return &amp;OddPrimeSquare{
                Factor:     p,
                Squared:    p2,
                PhiFactor:  phiP,
                PhiSquared: phiP2,
        }, allOk
}</span>

// OddPrimeSquare implements modular arithmetic modulo p^2,
// where p is an odd prime.
type OddPrimeSquare struct {
        Factor     *numct.Modulus // p
        Squared    *numct.Modulus // p^2
        PhiFactor  *numct.Modulus // (p) = p - 1
        PhiSquared *numct.Modulus // (p^2) = p * (p - 1)
}

// ModExp computes out = (base ^ exp) mod p^2.
func (m *OddPrimeSquare) Modulus() *numct.Modulus <span class="cov8" title="1">{
        return m.Squared
}</span>

// ModExp computes out = (base ^ exp) mod p^2.
func (m *OddPrimeSquare) MultiplicativeOrder() algebra.Cardinal <span class="cov0" title="0">{
        return cardinal.NewFromNumeric(m.PhiSquared)
}</span>

// NewOddPrimeSquareFactors constructs an OddPrimeSquareFactors modular arithmetic
// instance from the given odd prime factors p and q.
// Returns ct.False if the inputs are invalid (not distinct).
func NewOddPrimeSquareFactors(firstPrime, secondPrime *numct.Nat) (m *OddPrimeSquareFactors, ok ct.Bool) <span class="cov8" title="1">{
        allOk := firstPrime.Equal(secondPrime).Not()

        // Clone the inputs to avoid any possibility of mutation
        firstPrimeClone := firstPrime.Clone()
        secondPrimeClone := secondPrime.Clone()

        p, ok := NewOddPrimeSquare(firstPrimeClone)
        allOk &amp;= ok
        q, ok := NewOddPrimeSquare(secondPrimeClone)
        allOk &amp;= ok

        crtModN, ok := crt.NewParamsExtended(p.Factor, q.Factor)
        allOk &amp;= ok

        crtModN2, ok := crt.NewParamsExtended(p.Squared, q.Squared)
        allOk &amp;= ok

        var nNat, nnNat numct.Nat
        nNat.Mul(p.Factor.Nat(), q.Factor.Nat())
        nnNat.Mul(&amp;nNat, &amp;nNat)

        n, ok := numct.NewModulus(&amp;nNat)
        allOk &amp;= ok
        nn, ok := numct.NewModulus(&amp;nnNat)
        allOk &amp;= ok

        var nModPhiP, nModPhiQ numct.Nat
        p.PhiFactor.Mod(&amp;nModPhiP, &amp;nNat) // n mod (p-1)
        q.PhiFactor.Mod(&amp;nModPhiQ, &amp;nNat) // n mod (q-1)

        // Precompute exponents for direct CRT mod-exp: Ep2 = p * (N mod (p-1)), Eq2 = q * (N mod (q-1))
        var Ep2, Eq2 numct.Nat
        Ep2.Mul(p.Factor.Nat(), &amp;nModPhiP) // p * (q mod (p-1))  since Nq (mod p-1)
        Eq2.Mul(q.Factor.Nat(), &amp;nModPhiQ) // q * (p mod (q-1))  since Np (mod q-1)

        var phiNNat, phiN2Nat numct.Nat
        phiNNat.Mul(p.PhiFactor.Nat(), q.PhiFactor.Nat())
        phiN2Nat.Mul(p.PhiSquared.Nat(), q.PhiSquared.Nat())

        phiN, ok := numct.NewModulus(&amp;phiNNat)
        allOk &amp;= ok
        phiN2, ok := numct.NewModulus(&amp;phiN2Nat)
        allOk &amp;= ok

        return &amp;OddPrimeSquareFactors{
                CrtModN: &amp;OddPrimeFactors{
                        Params: crtModN,
                        N:      n,
                        PhiP:   p.PhiFactor,
                        PhiQ:   q.PhiFactor,
                        Phi:    phiN,
                },
                CrtModN2: crtModN2,
                P:        p,
                Q:        q,
                N2:       nn,
                NExpP2:   &amp;Ep2,
                NExpQ2:   &amp;Eq2,
                PhiN2:    phiN2,
        }, allOk
}</span>

// OddPrimeSquareFactors implements modular arithmetic modulo n^2 = (p * q)^2,
// where p and q are distinct odd primes.
type OddPrimeSquareFactors struct {
        CrtModN  *OddPrimeFactors    // CRT parameters for p and q
        CrtModN2 *crt.ParamsExtended // CRT parameters for p^2 and q^2
        P        *OddPrimeSquare     // parameters for p
        Q        *OddPrimeSquare     // parameters for q
        N2       *numct.Modulus      // n^2 = (p * q)^2
        NExpP2   *numct.Nat          // Ep2 = p * (N mod (p-1))
        NExpQ2   *numct.Nat          // Eq2 = q * (N mod (q-1))
        PhiN2    *numct.Modulus      // (n^2) = (p^2)*(q^2)
}

// Modulus returns the modulus n^2 = (p * q)^2.
func (m *OddPrimeSquareFactors) Modulus() *numct.Modulus <span class="cov8" title="1">{
        return m.N2
}</span>

// MultiplicativeOrder returns the multiplicative order (n^2) = (p^2)*(q^2).
func (m *OddPrimeSquareFactors) MultiplicativeOrder() algebra.Cardinal <span class="cov8" title="1">{
        return cardinal.NewFromNumeric(m.PhiN2)
}</span>

// ModExp computes out = (base ^ exp) mod n^2.
func (m *OddPrimeSquareFactors) ModExp(out, base, exp *numct.Nat) <span class="cov8" title="1">{
        var mp, mq numct.Nat
        var wg sync.WaitGroup
        wg.Add(2)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                var ep numct.Nat
                m.P.PhiSquared.Mod(&amp;ep, exp)
                // Use reduced exponent when base is coprime (Euler applies),
                // full exponent otherwise.
                ep.Select(base.Coprime(m.P.Factor.Nat()), exp, &amp;ep)
                (m.CrtModN2.P).ModExp(&amp;mp, base, &amp;ep)
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                var eq numct.Nat
                m.Q.PhiSquared.Mod(&amp;eq, exp)
                eq.Select(base.Coprime(m.Q.Factor.Nat()), exp, &amp;eq)
                m.CrtModN2.Q.ModExp(&amp;mq, base, &amp;eq)
        }</span>()
        <span class="cov8" title="1">wg.Wait()

        out.Set(m.CrtModN2.Recombine(&amp;mp, &amp;mq))</span>
}

// ModExpI computes out = (base ^ exp) mod n^2, where exp is a signed integer.
func (m *OddPrimeSquareFactors) ModExpI(out, base *numct.Nat, exp *numct.Int) <span class="cov0" title="0">{
        var expAbs, out2 numct.Nat
        expAbs.Abs(exp)
        m.ModExp(out, base, &amp;expAbs)
        m.ModInv(&amp;out2, out)
        out.CondAssign(exp.IsNegative(), &amp;out2)
}</span>

// MultiBaseExp computes out[i] = (bases[i] ^ exp) mod n^2 for all i.
func (m *OddPrimeSquareFactors) MultiBaseExp(out, bases []*numct.Nat, exp *numct.Nat) <span class="cov8" title="1">{
        if len(out) != len(bases) </span><span class="cov0" title="0">{
                panic("out and bases must have the same length")</span>
        }
        <span class="cov8" title="1">k := len(bases)

        var ep, eq numct.Nat
        m.P.PhiSquared.Mod(&amp;ep, exp)
        m.Q.PhiSquared.Mod(&amp;eq, exp)

        var wg sync.WaitGroup
        wg.Add(k)
        for i := range k </span><span class="cov8" title="1">{
                go func(i int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        bi := bases[i]
                        var mp, mq numct.Nat
                        var wgInner sync.WaitGroup
                        wgInner.Add(2)
                        go func() </span><span class="cov8" title="1">{
                                defer wgInner.Done()
                                var epi numct.Nat
                                epi.Select(bi.Coprime(m.P.Factor.Nat()), exp, &amp;ep)
                                m.CrtModN2.P.ModExp(&amp;mp, bi, &amp;epi)
                        }</span>()
                        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                                defer wgInner.Done()
                                var eqi numct.Nat
                                eqi.Select(bi.Coprime(m.Q.Factor.Nat()), exp, &amp;eq)
                                m.CrtModN2.Q.ModExp(&amp;mq, bi, &amp;eqi)
                        }</span>()
                        <span class="cov8" title="1">wgInner.Wait()
                        out[i].Set(m.CrtModN2.Recombine(&amp;mp, &amp;mq))</span>
                }(i)
        }
        <span class="cov8" title="1">wg.Wait()</span>
}

// ModMul computes out = (a * b) mod n^2.
func (m *OddPrimeSquareFactors) ModMul(out, a, b *numct.Nat) <span class="cov8" title="1">{
        m.N2.ModMul(out, a, b)
}</span>

// ModDiv computes out = (a / b) mod n^2.
func (m *OddPrimeSquareFactors) ModDiv(out, a, b *numct.Nat) ct.Bool <span class="cov8" title="1">{
        return m.N2.ModDiv(out, a, b)
}</span>

// ModInv computes out = (a^{-1}) mod n^2.
func (m *OddPrimeSquareFactors) ModInv(out, a *numct.Nat) ct.Bool <span class="cov8" title="1">{
        return m.N2.ModInv(out, a)
}</span>

// ExpToN computes out = (a ^ N) mod n^2 using direct CRT mod-exp.
func (m *OddPrimeSquareFactors) ExpToN(out, a *numct.Nat) <span class="cov8" title="1">{
        // Direct CRT: y_p = a^{Ep2} mod p^2, y_q = a^{Eq2} mod q^2
        var yp, yq numct.Nat
        var wg sync.WaitGroup
        wg.Add(2)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                m.P.Squared.ModExp(&amp;yp, a, m.NExpP2) //  Ep2 = p * (N mod (p-1))
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                m.Q.Squared.ModExp(&amp;yq, a, m.NExpQ2) // Eq2 = q * (N mod (q-1))
        }</span>()
        <span class="cov8" title="1">wg.Wait()

        // One-multiply CRT using precomputed (q^2)^{-1} mod p^2 inside m.CrtModN2
        out.Set(m.CrtModN2.Recombine(&amp;yp, &amp;yq))</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">package modular

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
)

// NewSimple constructs a SimpleModulus modular arithmetic instance
// from the given modulus m.
// Returns ct.False if the input is invalid (nil).
func NewSimple(m *numct.Modulus) (simple *SimpleModulus, ok ct.Bool) <span class="cov8" title="1">{
        return &amp;SimpleModulus{m: m}, utils.BoolTo[ct.Bool](m != nil)
}</span>

// SimpleModulus implements modular arithmetic modulo a single modulus m.
type SimpleModulus struct {
        m *numct.Modulus // The modulus
}

// MultiplicativeOrder returns an unknown cardinal for SimpleModulus.
func (*SimpleModulus) MultiplicativeOrder() algebra.Cardinal <span class="cov8" title="1">{
        return cardinal.Unknown()
}</span>

// Modulus returns the modulus m.
func (m *SimpleModulus) Modulus() *numct.Modulus <span class="cov8" title="1">{
        return m.m
}</span>

// ModMul computes out = (a * b) mod m.
func (m *SimpleModulus) ModMul(out, a, b *numct.Nat) <span class="cov8" title="1">{
        m.m.ModMul(out, a, b)
}</span>

// ModExp computes out = (base ^ exp) mod m.
func (m *SimpleModulus) ModExp(out, base, exp *numct.Nat) <span class="cov8" title="1">{
        m.m.ModExp(out, base, exp)
}</span>

// ModExpI computes out = (base ^ exp) mod m, where exp is a signed integer.
func (m *SimpleModulus) ModExpI(out, base *numct.Nat, exp *numct.Int) <span class="cov0" title="0">{
        m.m.ModExpI(out, base, exp)
}</span>

// MultiBaseExp computes out[i] = (bases[i] ^ exp) mod m for all i.
func (m *SimpleModulus) MultiBaseExp(out, bases []*numct.Nat, exp *numct.Nat) <span class="cov0" title="0">{
        if len(out) != len(bases) </span><span class="cov0" title="0">{
                panic("out and bases must have the same length")</span>
        }
        <span class="cov0" title="0">k := len(bases)

        var wg sync.WaitGroup
        wg.Add(k)
        for i := range k </span><span class="cov0" title="0">{
                go func(i int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        bi := bases[i]
                        m.m.ModExp(out[i], bi, exp)
                }</span>(i)
        }
        <span class="cov0" title="0">wg.Wait()</span>
}

// ModInv computes out = (a^{-1}) mod m.
func (m *SimpleModulus) ModInv(out, a *numct.Nat) ct.Bool <span class="cov8" title="1">{
        return m.m.ModInv(out, a)
}</span>

// ModDiv computes out = (a / b) mod m.
func (m *SimpleModulus) ModDiv(out, a, b *numct.Nat) ct.Bool <span class="cov8" title="1">{
        return m.m.ModDiv(out, a, b)
}</span>

// Lift constructs a SimpleModulus modular arithmetic instance
// by lifting the modulus m to m^2.
// Returns ct.False if the lift operation fails.
func (m *SimpleModulus) Lift() (lifted *SimpleModulus, ok ct.Bool) <span class="cov8" title="1">{
        modulus := m.m.Nat()
        var m2 numct.Nat
        m2.Mul(modulus, modulus)
        m2Modulus, ok := numct.NewModulus(&amp;m2)
        return &amp;SimpleModulus{m: m2Modulus}, ok
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">package nt

import (
        crand "crypto/rand"
        "crypto/rsa"
        "io"
        "maps"
        "math/big"
        "slices"

        "golang.org/x/sync/errgroup"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

var (
        ErrInvalidSize = errs2.New("invalid size")
        ErrIsNil       = errs2.New("is nil")
)

// PrimeSamplable is an interface for types that can sample prime numbers.
type PrimeSamplable[E algebra.NatPlusLike[E]] interface {
        FromBig(*big.Int) (E, error)
}

// MillerRabinChecks returns the number of Miller-Rabin iterations required for a given bit length.
func MillerRabinChecks(bits uint) int <span class="cov8" title="1">{
        if len(millerRabinIterations) == 0 </span><span class="cov0" title="0">{
                panic("millerRabinIterations is not initialised")</span>
        }
        <span class="cov8" title="1">sortedKeys := slices.Sorted(maps.Keys(millerRabinIterations))

        // Case 1: bits smaller than the smallest table entry.
        if bits &lt; sortedKeys[0] </span><span class="cov8" title="1">{
                return max(
                        base.StatisticalSecurityBits/4,
                        millerRabinIterations[sortedKeys[0]],
                )
        }</span>

        // Case 2: find the largest key &lt;= bits and return its value.
        <span class="cov8" title="1">for i := len(sortedKeys) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if bits &gt;= sortedKeys[i] </span><span class="cov8" title="1">{
                        return millerRabinIterations[sortedKeys[i]]
                }</span>
        }
        <span class="cov0" title="0">panic("millerRabinIterations is not properly initialised")</span>
}

// GenerateSafePrime generates a safe prime of the specified bit length using the provided PrimeSamplable set.
func GenerateSafePrime[N algebra.NatPlusLike[N]](set PrimeSamplable[N], bits uint) (N, error) <span class="cov8" title="1">{
        if bits &lt; 3 </span><span class="cov0" title="0">{
                return *new(N), ErrInvalidSize.WithMessage("safe prime size must be at least 3-bits")
        }</span>
        <span class="cov8" title="1">if set == nil </span><span class="cov0" title="0">{
                return *new(N), ErrIsNil.WithMessage("nil structure")
        }</span>
        <span class="cov8" title="1">var p *big.Int
        var err error
        checks := MillerRabinChecks(bits)
        for </span><span class="cov8" title="1">{
                p, err = crand.Prime(crand.Reader, int(bits)-1)
                if err != nil </span><span class="cov0" title="0">{
                        return *new(N), errs2.Wrap(err).WithMessage("reading from crand")
                }</span>
                <span class="cov8" title="1">p.Add(p.Lsh(p, 1), big.NewInt(1))

                if p.ProbablyPrime(checks) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">n, err := set.FromBig(p)
        if err != nil </span><span class="cov0" title="0">{
                return *new(N), errs2.Wrap(err).WithMessage("cannot convert prime to structure")
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

// GenerateSafePrimePair generates two distinct safe primes of the specified bit length using the provided PrimeSamplable set.
func GenerateSafePrimePair[N algebra.NatPlusLike[N]](set PrimeSamplable[N], bits uint) (p, q N, err error) <span class="cov8" title="1">{
        g := errgroup.Group{}
        for </span><span class="cov8" title="1">{
                g.Go(func() error </span><span class="cov8" title="1">{
                        p, err = GenerateSafePrime(set, bits)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                        q, err = GenerateSafePrime(set, bits)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                        return *new(N), *new(N), errs2.Wrap(err).WithMessage("cannot generate same primes")
                }</span>
                <span class="cov8" title="1">if !p.Equal(q) </span><span class="cov8" title="1">{
                        return p, q, nil
                }</span>
        }
}

// GeneratePrimePair generates two distinct prime numbers of the specified bit length using the provided PrimeSamplable set.
func GeneratePrimePair[N algebra.NatPlusLike[N]](set PrimeSamplable[N], bits uint, prng io.Reader) (p, q N, err error) <span class="cov8" title="1">{
        if set == nil </span><span class="cov0" title="0">{
                return *new(N), *new(N), ErrIsNil.WithMessage("nil structure")
        }</span>
        <span class="cov8" title="1">rsaPrivateKey, err := rsa.GenerateKey(prng, int(2*bits))
        if err != nil </span><span class="cov0" title="0">{
                return *new(N), *new(N), errs2.Wrap(err).WithMessage("cannot generate keys pair")
        }</span>

        <span class="cov8" title="1">pBig := rsaPrivateKey.Primes[0]
        qBig := rsaPrivateKey.Primes[1]
        // double check
        if pBig.BitLen() != int(bits) || qBig.BitLen() != int(bits) </span><span class="cov0" title="0">{
                return *new(N), *new(N), errs2.Wrap(err).WithMessage("p,q have invalid length (%d, %d) - expected %d", pBig.BitLen(), qBig.BitLen(), bits)
        }</span>
        <span class="cov8" title="1">p, err = set.FromBig(pBig)
        if err != nil </span><span class="cov0" title="0">{
                return *new(N), *new(N), errs2.Wrap(err).WithMessage("cannot convert p to structure")
        }</span>
        <span class="cov8" title="1">q, err = set.FromBig(qBig)
        if err != nil </span><span class="cov0" title="0">{
                return *new(N), *new(N), errs2.Wrap(err).WithMessage("cannot convert q to structure")
        }</span>
        <span class="cov8" title="1">return p, q, nil</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">package num

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*NatPlus)(nil)
        _ cbor.Unmarshaler = (*NatPlus)(nil)
        _ cbor.Marshaler   = (*Nat)(nil)
        _ cbor.Unmarshaler = (*Nat)(nil)
        _ cbor.Marshaler   = (*Int)(nil)
        _ cbor.Unmarshaler = (*Int)(nil)
        _ cbor.Marshaler   = (*Uint)(nil)
        _ cbor.Unmarshaler = (*Uint)(nil)
        _ cbor.Marshaler   = (*Rat)(nil)
        _ cbor.Unmarshaler = (*Rat)(nil)

        _ cbor.Marshaler   = (*ZMod)(nil)
        _ cbor.Unmarshaler = (*ZMod)(nil)
)

type natPlusDTO struct {
        NatPlus *numct.Nat `cbor:"natPlus"`
}

func (np *NatPlus) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;natPlusDTO{NatPlus: np.v}
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (np *NatPlus) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*natPlusDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if dto.NatPlus.IsZero() == ct.True </span><span class="cov0" title="0">{
                return ErrOutOfRange.WithStackFrame().WithMessage("NatPlus must be greater than 0")
        }</span>
        <span class="cov8" title="1">np.v = dto.NatPlus
        return nil</span>
}

type natDTO struct {
        Nat *numct.Nat `cbor:"nat"`
}

func (n *Nat) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;natDTO{Nat: n.v}
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (n *Nat) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*natDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">n.v = dto.Nat
        return nil</span>
}

type intDTO struct {
        Int *numct.Int `cbor:"int"`
}

func (i *Int) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;intDTO{Int: i.v}
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (i *Int) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*intDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">i.v = dto.Int
        return nil</span>
}

type uintDTO struct {
        Value   *numct.Nat     `cbor:"value"`
        Modulus *numct.Modulus `cbor:"modulus"`
}

func (u *Uint) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;uintDTO{
                Value:   u.v,
                Modulus: u.m,
        }
        out, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (u *Uint) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*uintDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if dto.Modulus == nil </span><span class="cov0" title="0">{
                return ErrIsNil.WithStackFrame().WithMessage("modulus bytes")
        }</span>
        <span class="cov8" title="1">if dto.Value == nil </span><span class="cov0" title="0">{
                return ErrIsNil.WithStackFrame().WithMessage("value")
        }</span>

        // Deserialize the modulus interface directly - tags handle type preservation
        <span class="cov8" title="1">if lt, _, _ := dto.Value.Compare(dto.Modulus.Nat()); lt == ct.False </span><span class="cov0" title="0">{
                return ErrOutOfRange.WithStackFrame().WithMessage("value must be in [0, modulus)")
        }</span>
        <span class="cov8" title="1">u.v = dto.Value
        u.m = dto.Modulus
        return nil</span>
}

type ratDTO struct {
        A *Int     `cbor:"a"`
        B *NatPlus `cbor:"b"`
}

func (r *Rat) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;ratDTO{
                A: r.a,
                B: r.b,
        }
        out, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (r *Rat) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*ratDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if dto.A == nil </span><span class="cov0" title="0">{
                return ErrIsNil.WithStackFrame().WithMessage("numerator")
        }</span>
        <span class="cov8" title="1">if dto.B == nil </span><span class="cov0" title="0">{
                return ErrIsNil.WithStackFrame().WithMessage("denominator")
        }</span>
        <span class="cov8" title="1">r.a = dto.A
        r.b = dto.B
        return nil</span>
}

type zmodDTO struct {
        Modulus *NatPlus `cbor:"modulus"`
}

func (z *ZMod) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;zmodDTO{Modulus: z.n}
        out, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (z *ZMod) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*zmodDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if dto.Modulus == nil </span><span class="cov0" title="0">{
                return ErrIsNil.WithStackFrame().WithMessage("modulus")
        }</span>
        <span class="cov8" title="1">z.n = dto.Modulus
        return nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package num

import (
        "io"
        "math/big"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

var (
        nOnce     sync.Once
        nInstance *NaturalNumbers
)

// N returns the singleton instance of the NaturalNumbers structure.
func N() *NaturalNumbers <span class="cov8" title="1">{
        nOnce.Do(func() </span><span class="cov8" title="1">{
                nInstance = &amp;NaturalNumbers{}
        }</span>)
        <span class="cov8" title="1">return nInstance</span>
}

// NaturalNumbers represents the set of natural numbers (non-negative integers).
type NaturalNumbers struct{}

// Name returns the name of the structure: "N".
func (*NaturalNumbers) Name() string <span class="cov8" title="1">{
        return "N"
}</span>

// Characteristic returns the characteristic of the NaturalNumbers structure, which is 0.
func (*NaturalNumbers) Characteristic() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.Zero()
}</span>

// Order returns the order of the NaturalNumbers structure, which is infinite.
func (*NaturalNumbers) Order() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.Infinite()
}</span>

// Zero returns the additive identity element of the NaturalNumbers structure.
func (*NaturalNumbers) Zero() *Nat <span class="cov8" title="1">{
        return &amp;Nat{v: numct.NatZero()}
}</span>

// One returns the multiplicative identity element of the NaturalNumbers structure.
func (*NaturalNumbers) One() *Nat <span class="cov8" title="1">{
        return &amp;Nat{v: numct.NatOne()}
}</span>

// OpIdentity returns the identity element for the addition operation in the NaturalNumbers structure.
func (ns *NaturalNumbers) OpIdentity() *Nat <span class="cov8" title="1">{
        return ns.Zero()
}</span>

// FromUint64 creates a Nat from a uint64 value.
func (*NaturalNumbers) FromUint64(value uint64) *Nat <span class="cov8" title="1">{
        return &amp;Nat{v: numct.NewNat(value)}
}</span>

// FromNatPlus creates a Nat from a NatPlus value, returning an error if the input is nil.
func (*NaturalNumbers) FromNatPlus(value *NatPlus) (*Nat, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Nat{v: value.v.Clone()}, nil</span>
}

// FromBig creates a Nat from a big.Int value, returning an error if the input is nil or negative.
func (ns *NaturalNumbers) FromBig(value *big.Int) (*Nat, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.Sign() &lt; 0 </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.Sign() == 0 </span><span class="cov8" title="1">{
                return ns.Zero(), nil
        }</span>
        <span class="cov8" title="1">return ns.FromBytes(value.Bytes())</span>
}

// FromRat creates a Nat from a Rat value, returning an error if Rat is not a non-negative integer.
func (ns *NaturalNumbers) FromRat(value *Rat) (*Nat, error) <span class="cov8" title="1">{
        vInt, err := Z().FromRat(value)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return ns.FromInt(vInt)</span>
}

// FromNatCT creates a Nat from a numct.Nat value, returning an error if the input is nil.
func (*NaturalNumbers) FromNatCT(value *numct.Nat) (*Nat, error) <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return &amp;Nat{v: value.Clone()}, nil</span>
}

// FromInt creates a Nat from an Int value, returning an error if the input is nil or negative.
func (ns *NaturalNumbers) FromInt(value *Int) (*Nat, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.IsNegative() </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.IsZero() </span><span class="cov8" title="1">{
                return ns.Zero(), nil
        }</span>
        <span class="cov8" title="1">return value.Abs(), nil</span>
}

// FromBytes creates a Nat from a byte slice, returning an error if the input is nil.
func (*NaturalNumbers) FromBytes(input []byte) (*Nat, error) <span class="cov8" title="1">{
        if input == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Nat{v: numct.NewNatFromBytes(input)}, nil</span>
}

// FromBytesBE creates a Nat from a big-endian byte slice, returning an error if the input is nil.
func (ns *NaturalNumbers) FromBytesBE(input []byte) (*Nat, error) <span class="cov8" title="1">{
        return ns.FromBytes(input)
}</span>

// FromCardinal creates a Nat from a cardinal.Cardinal value, returning an error if the input is nil or infinite.
func (ns *NaturalNumbers) FromCardinal(value cardinal.Cardinal) (*Nat, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if !value.IsFinite() </span><span class="cov8" title="1">{
                return nil, ErrUndefined.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.IsZero() </span><span class="cov8" title="1">{
                return ns.Zero(), nil
        }</span>
        <span class="cov8" title="1">return &amp;Nat{v: numct.NewNatFromBytes(value.Bytes())}, nil</span>
}

// Random generates a random Nat in the range [lowInclusive, highExclusive), returning an error if highExclusive is nil.
func (ns *NaturalNumbers) Random(lowInclusive, highExclusive *Nat, prng io.Reader) (*Nat, error) <span class="cov8" title="1">{
        if lowInclusive == nil </span><span class="cov0" title="0">{
                lowInclusive = ns.Bottom()
        }</span>
        <span class="cov8" title="1">var v numct.Nat
        if err := v.SetRandomRangeLH(lowInclusive.Value(), highExclusive.Value(), prng); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Nat{v: &amp;v}, nil</span>
}

// Bottom returns the smallest element in the NaturalNumbers structure, which is 0.
func (ns *NaturalNumbers) Bottom() *Nat <span class="cov8" title="1">{
        return ns.Zero()
}</span>

// ElementSize returns -1 indicating that elements of NaturalNumbers do not have a fixed size.
func (*NaturalNumbers) ElementSize() int <span class="cov8" title="1">{
        return -1
}</span>

// ScalarStructure returns the regular semi-module structure of NaturalNumbers.
func (*NaturalNumbers) ScalarStructure() algebra.Structure[*Nat] <span class="cov0" title="0">{
        return N()
}</span>

// Nat represents a natural number (non-negative integer).
type Nat struct {
        v *numct.Nat
}

func (*Nat) isValid(x *Nat) (*Nat, error) <span class="cov8" title="1">{
        if x == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return x, nil</span>
}

// Structure returns the NaturalNumbers structure.
func (*Nat) Structure() algebra.Structure[*Nat] <span class="cov8" title="1">{
        return N()
}</span>

// Value returns the underlying numct.Nat value of the Nat.
func (n *Nat) Value() *numct.Nat <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return n.v</span>
}

// Op performs the addition operation on two Nat values.
func (n *Nat) Op(other *Nat) *Nat <span class="cov8" title="1">{
        return n.Add(other)
}</span>

// OtherOp performs the multiplication operation on two Nat values.
func (n *Nat) OtherOp(other *Nat) *Nat <span class="cov8" title="1">{
        return n.Mul(other)
}</span>

// Add performs the addition of two Nat values.
func (n *Nat) Add(other *Nat) *Nat <span class="cov8" title="1">{
        errs2.Must1(n.isValid(other))
        v := new(numct.Nat)
        v.Add(n.v, other.v)
        return &amp;Nat{v: v}
}</span>

// Mul performs the multiplication of two Nat values.
func (n *Nat) Mul(other *Nat) *Nat <span class="cov8" title="1">{
        errs2.Must1(n.isValid(other))
        v := new(numct.Nat)
        v.Mul(n.v, other.v)
        return &amp;Nat{v: v}
}</span>

// Lsh performs a left shift operation on the Nat by the specified number of bits.
func (n *Nat) Lsh(shift uint) *Nat <span class="cov8" title="1">{
        v := new(numct.Nat)
        v.Lsh(n.v, shift)
        return &amp;Nat{v: v}
}</span>

// Rsh performs a right shift operation on the Nat by the specified number of bits.
func (n *Nat) Rsh(shift uint) *Nat <span class="cov8" title="1">{
        v := new(numct.Nat)
        v.Rsh(n.v, shift)
        return &amp;Nat{v: v}
}</span>

// TryOpInv attempts to compute the additive inverse of the Nat. It will always return an error since natural numbers do not have additive inverses.
func (n *Nat) TryOpInv() (*Nat, error) <span class="cov8" title="1">{
        return n.TryNeg()
}</span>

// TryNeg attempts to compute the negation of the Nat. It will always return an error since natural numbers do not have negation.
func (*Nat) TryNeg() (*Nat, error) <span class="cov8" title="1">{
        return nil, ErrUndefined.WithStackFrame()
}</span>

// TrySub attempts to subtract another Nat from the current Nat. It returns an error if the result would not be a natural number.
func (n *Nat) TrySub(other *Nat) (*Nat, error) <span class="cov8" title="1">{
        if _, err := n.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if n.Compare(other).IsLessThan() </span><span class="cov8" title="1">{
                return nil, ErrUndefined.WithStackFrame()
        }</span>
        <span class="cov8" title="1">v := new(numct.Nat)
        v.SubCap(n.v, other.v, -1)
        return &amp;Nat{v: v}, nil</span>
}

// TryInv attempts to compute the multiplicative inverse of the Nat. It returns an error unless the Nat is 1.
func (n *Nat) TryInv() (*Nat, error) <span class="cov8" title="1">{
        if n.IsOne() </span><span class="cov8" title="1">{
                return n.Clone(), nil
        }</span>
        <span class="cov8" title="1">return nil, ErrUndefined.WithStackFrame()</span>
}

// IsUnit checks if the Nat is a unit modulo the given NatPlus modulus.
func (n *Nat) IsUnit(modulus *NatPlus) bool <span class="cov8" title="1">{
        if modulus == nil </span><span class="cov0" title="0">{
                panic("argument is nil")</span>
        }
        <span class="cov8" title="1">m, ok := numct.NewModulus(modulus.v)
        if ok == ct.False </span><span class="cov0" title="0">{
                panic(errs2.New("modulus is not valid"))</span>
        }
        <span class="cov8" title="1">return m.IsUnit(n.v) == ct.True</span>
}

// GCD computes the greatest common divisor (GCD) of the Nat and another Nat.
func (n *Nat) GCD(other *Nat) *Nat <span class="cov8" title="1">{
        var out numct.Nat
        out.GCD(n.v, other.v)
        return &amp;Nat{v: &amp;out}
}</span>

// Cardinal returns the cardinal representation of the Nat.
func (n *Nat) Cardinal() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.NewFromNumeric(n.v)
}</span>

// TryDiv attempts to divide the Nat by another Nat.
// It returns an error if the division is not exact.
func (n *Nat) TryDiv(other *Nat) (*Nat, error) <span class="cov8" title="1">{
        if _, err := n.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">var q, r numct.Nat
        if ok := q.Div(&amp;r, n.v, other.v); ok == ct.False </span><span class="cov8" title="1">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if z := r.IsZero(); z == ct.False </span><span class="cov8" title="1">{
                return nil, ErrInexactDivision.WithStackFrame()
        }</span>

        <span class="cov8" title="1">return &amp;Nat{v: &amp;q}, nil</span>
}

// TryDivVarTime attempts to divide the Nat by another Nat.
// It returns an error if the division is not exact.
// It is not constant-time due to having to generate montgomery parameters for the divisor (i.e., leaks divisor).
func (n *Nat) TryDivVarTime(other *Nat) (*Nat, error) <span class="cov0" title="0">{
        if _, err := n.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov0" title="0">var q, r numct.Nat
        if ok := q.Div(&amp;r, n.v, other.v); ok == ct.False </span><span class="cov0" title="0">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>
        <span class="cov0" title="0">if z := r.IsZero(); z == ct.False </span><span class="cov0" title="0">{
                return nil, ErrInexactDivision.WithStackFrame()
        }</span>

        <span class="cov0" title="0">return &amp;Nat{v: &amp;q}, nil</span>
}

// DivRound divides the Nat by another Nat returning quotient rounded towards zero.
// It returns an error if the division is not exact.
func (n *Nat) DivRound(other *Nat) (*Nat, error) <span class="cov0" title="0">{
        if _, err := n.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov0" title="0">var q numct.Nat
        if ok := q.Div(nil, n.v, other.v); ok == ct.False </span><span class="cov0" title="0">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>

        <span class="cov0" title="0">return &amp;Nat{v: &amp;q}, nil</span>
}

// DivRoundVarTime divides the Nat by another Nat returning quotient rounded towards zero.
// It returns an error if the division is not exact.
// It is not constant-time due to having to generate montgomery parameters for the divisor (i.e., leaks divisor).
func (n *Nat) DivRoundVarTime(other *Nat) (*Nat, error) <span class="cov0" title="0">{
        if _, err := n.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov0" title="0">var q numct.Nat
        if ok := q.Div(nil, n.v, other.v); ok == ct.False </span><span class="cov0" title="0">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>

        <span class="cov0" title="0">return &amp;Nat{v: &amp;q}, nil</span>
}

// Double returns the Nat doubled.
func (n *Nat) Double() *Nat <span class="cov8" title="1">{
        return n.Add(n)
}</span>

// IsPositive checks if the Nat is positive (greater than 0).
func (n *Nat) IsPositive() bool <span class="cov8" title="1">{
        return !n.IsZero()
}</span>

// Square returns the square of the Nat.
func (n *Nat) Square() *Nat <span class="cov8" title="1">{
        return n.Mul(n)
}</span>

// IsOpIdentity checks if the Nat is the additive identity (0).
func (n *Nat) IsOpIdentity() bool <span class="cov8" title="1">{
        return n.IsZero()
}</span>

// IsBottom checks if the Nat is the bottom element (0).
func (n *Nat) IsBottom() bool <span class="cov8" title="1">{
        return n.v.IsZero() == ct.True
}</span>

// IsZero checks if the Nat is zero.
func (n *Nat) IsZero() bool <span class="cov8" title="1">{
        return n.v.IsZero() == ct.True
}</span>

// IsOne checks if the Nat is one.
func (n *Nat) IsOne() bool <span class="cov8" title="1">{
        return n.v.IsOne() == ct.True
}</span>

// Coprime checks if the Nat is coprime with another Nat.
func (n *Nat) Coprime(other *Nat) bool <span class="cov8" title="1">{
        errs2.Must1(n.isValid(other))
        return n.v.Coprime(other.v) == ct.True
}</span>

// IsProbablyPrime checks if the Nat is probably prime.
func (n *Nat) IsProbablyPrime() bool <span class="cov8" title="1">{
        return n.v.IsProbablyPrime() == ct.True
}</span>

// EuclideanDiv performs Euclidean division of the Nat by another Nat, returning the quotient and remainder.
func (n *Nat) EuclideanDiv(other *Nat) (quot, rem *Nat, err error) <span class="cov8" title="1">{
        errs2.Must1(n.isValid(other))
        var vq, vr numct.Nat
        if ok := vq.EuclideanDiv(&amp;vr, n.v, other.v); ok == ct.False </span><span class="cov0" title="0">{
                return nil, nil, errs2.New("division failed")
        }</span>
        <span class="cov8" title="1">return &amp;Nat{v: &amp;vq}, &amp;Nat{v: &amp;vr}, nil</span>
}

// EuclideanDivVarTime performs Euclidean division of the Nat by another Nat, returning the quotient and remainder.
// It is not constant-time due to having to generate montgomery parameters for the divisor (i.e., leaks divisor).
func (n *Nat) EuclideanDivVarTime(other *Nat) (quot, rem *Nat, err error) <span class="cov0" title="0">{
        errs2.Must1(n.isValid(other))

        var vq, vr numct.Nat
        if ok := vq.EuclideanDivVarTime(&amp;vr, n.v, other.v); ok == ct.False </span><span class="cov0" title="0">{
                return nil, nil, errs2.New("division failed")
        }</span>
        <span class="cov0" title="0">return &amp;Nat{v: &amp;vq}, &amp;Nat{v: &amp;vr}, nil</span>
}

// EuclideanValuation computes the Euclidean valuation of the Nat.
func (n *Nat) EuclideanValuation() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.NewFromNumeric(n.v)
}</span>

// Mod computes the Nat modulo the given NatPlus modulus.
func (n *Nat) Mod(modulus *NatPlus) *Uint <span class="cov8" title="1">{
        return n.Lift().Mod(modulus)
}</span>

// Sqrt computes the square root of the Nat, returning an error if the square root is not defined.
func (n *Nat) Sqrt() (*Nat, error) <span class="cov8" title="1">{
        v := new(numct.Nat)
        ok := v.Sqrt(n.v)
        if ok == ct.False </span><span class="cov8" title="1">{
                return nil, ErrUndefined.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Nat{v: v}, nil</span>
}

// Compare compares the Nat with another Nat, returning an ordering result.
func (n *Nat) Compare(other *Nat) base.Ordering <span class="cov8" title="1">{
        errs2.Must1(n.isValid(other))
        lt, eq, gt := n.v.Compare(other.v)
        return base.Ordering(-1*int(lt) + 0*int(eq) + 1*int(gt))
}</span>

// IsLessThanOrEqual checks if the Nat is less than or equal to another Nat.
func (n *Nat) IsLessThanOrEqual(other *Nat) bool <span class="cov8" title="1">{
        errs2.Must1(n.isValid(other))
        lt, eq, _ := n.v.Compare(other.v)
        return lt|eq == ct.True
}</span>

// Lift converts the Nat to an Int.
func (n *Nat) Lift() *Int <span class="cov8" title="1">{
        return &amp;Int{v: n.v.Lift()}
}</span>

// Equal checks if the Nat is equal to another Nat.
func (n *Nat) Equal(other *Nat) bool <span class="cov8" title="1">{
        errs2.Must1(n.isValid(other))
        return n.v.Equal(other.v) == ct.True
}</span>

// Clone creates a copy of the Nat.
func (n *Nat) Clone() *Nat <span class="cov8" title="1">{
        return &amp;Nat{v: n.v.Clone()}
}</span>

// HashCode computes a hash code for the Nat.
func (n *Nat) HashCode() base.HashCode <span class="cov8" title="1">{
        return base.HashCode(n.v.Uint64())
}</span>

// String returns the string representation of the Nat.
func (n *Nat) String() string <span class="cov8" title="1">{
        return n.v.String()
}</span>

// Increment returns the Nat incremented by 1.
func (n *Nat) Increment() *Nat <span class="cov8" title="1">{
        return n.Add(N().One())
}</span>

// Decrement returns the Nat decremented by 1, returning an error if the result would be negative.
func (n *Nat) Decrement() (*Nat, error) <span class="cov8" title="1">{
        return n.TrySub(N().One())
}</span>

// Bytes returns the byte slice representation of the Nat.
func (n *Nat) Bytes() []byte <span class="cov8" title="1">{
        return n.v.Bytes()
}</span>

// BytesBE returns the big-endian byte slice representation of the Nat.
func (n *Nat) BytesBE() []byte <span class="cov8" title="1">{
        return n.Bytes()
}</span>

// Uint64 returns the uint64 representation of the Nat. It wraps around if the Nat is too large.
func (n *Nat) Uint64() uint64 <span class="cov8" title="1">{
        return n.v.Uint64()
}</span>

// Bit returns the value of the i-th bit of the Nat.
func (n *Nat) Bit(i uint) byte <span class="cov8" title="1">{
        return n.v.Bit(i)
}</span>

// Byte returns the value of the i-th byte of the Nat.
func (n *Nat) Byte(i uint) byte <span class="cov8" title="1">{
        return n.v.Byte(i)
}</span>

// IsEven checks if the Nat is even.
func (n *Nat) IsEven() bool <span class="cov8" title="1">{
        return n.v.IsEven() == ct.True
}</span>

// IsOdd checks if the Nat is odd.
func (n *Nat) IsOdd() bool <span class="cov8" title="1">{
        return n.v.IsOdd() == ct.True
}</span>

// Big returns the big.Int representation of the Nat.
func (n *Nat) Big() *big.Int <span class="cov8" title="1">{
        return n.v.Big()
}</span>

// IsTorsionFree checks if the Nat is torsion-free under addition, which is always true for natural numbers.
func (*Nat) IsTorsionFree() bool <span class="cov8" title="1">{
        return true
}</span>

// ScalarOp performs scalar multiplication of the Nat by another Nat.
func (n *Nat) ScalarOp(sc *Nat) *Nat <span class="cov8" title="1">{
        return n.ScalarMul(sc)
}</span>

// ScalarMul performs scalar multiplication of the Nat by another Nat.
func (n *Nat) ScalarMul(sc *Nat) *Nat <span class="cov8" title="1">{
        return n.Mul(sc)
}</span>

// TrueLen returns the true length of the Nat in bytes.
func (n *Nat) TrueLen() int <span class="cov8" title="1">{
        return n.v.TrueLen()
}</span>

// AnnouncedLen returns the announced length of the Nat in bytes.
func (n *Nat) AnnouncedLen() int <span class="cov8" title="1">{
        return n.v.AnnouncedLen()
}</span>
</pre>
		
		<pre class="file" id="file151" style="display: none">package num

import (
        "io"
        "math/big"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

var (
        nplusInstance *PositiveNaturalNumbers
        nplusOnce     sync.Once
)

// PositiveNaturalNumbers represents the set of positive natural numbers (N\{0}).
type PositiveNaturalNumbers struct{}

// NPlus returns the singleton instance of PositiveNaturalNumbers.
func NPlus() *PositiveNaturalNumbers <span class="cov8" title="1">{
        nplusOnce.Do(func() </span><span class="cov8" title="1">{
                nplusInstance = &amp;PositiveNaturalNumbers{}
        }</span>)
        <span class="cov8" title="1">return nplusInstance</span>
}

// Name returns the name of the structure: "N\{0}".
func (*PositiveNaturalNumbers) Name() string <span class="cov8" title="1">{
        return "N\\{0}"
}</span>

// Characteristic returns the characteristic of PositiveNaturalNumbers, which is 0.
func (*PositiveNaturalNumbers) Characteristic() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.Zero()
}</span>

// Order returns the order of PositiveNaturalNumbers, which is infinite.
func (*PositiveNaturalNumbers) Order() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.Infinite()
}</span>

// One returns the multiplicative identity element of PositiveNaturalNumbers, which is 1.
func (*PositiveNaturalNumbers) One() *NatPlus <span class="cov8" title="1">{
        return &amp;NatPlus{v: numct.NatOne(), m: nil}
}</span>

// FromCardinal creates a NatPlus from the given cardinal, returning an error if the cardinal is zero.
func (*PositiveNaturalNumbers) FromCardinal(c algebra.Cardinal) (*NatPlus, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if c.IsZero() </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;NatPlus{v: numct.NewNatFromBytes(c.Bytes()), m: nil}, nil</span>
}

// FromBig creates a NatPlus from the given big.Int, returning an error if the integer is nil or not positive.
func (nps *PositiveNaturalNumbers) FromBig(b *big.Int) (*NatPlus, error) <span class="cov8" title="1">{
        if b == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if b.Sign() &lt;= 0 </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return nps.FromBytes(b.Bytes())</span>
}

// FromModulusCT creates a NatPlus from the given numct.Modulus.
func (*PositiveNaturalNumbers) FromModulusCT(m *numct.Modulus) *NatPlus <span class="cov8" title="1">{
        return &amp;NatPlus{v: m.Nat(), m: m}
}</span>

// FromRat creates a NatPlus from the given Rat, returning an error if the Rat is not a positive integer.
func (nps *PositiveNaturalNumbers) FromRat(v *Rat) (*NatPlus, error) <span class="cov8" title="1">{
        vInt, err := Z().FromRat(v)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return nps.FromInt(vInt)</span>
}

// FromUint64 creates a NatPlus from the given uint64, returning an error if the value is zero.
func (*PositiveNaturalNumbers) FromUint64(value uint64) (*NatPlus, error) <span class="cov8" title="1">{
        if value == 0 </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;NatPlus{v: numct.NewNat(value), m: nil}, nil</span>
}

// FromNat creates a NatPlus from the given Nat, returning an error if the Nat is nil or zero.
func (*PositiveNaturalNumbers) FromNat(value *Nat) (*NatPlus, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.IsZero() </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;NatPlus{v: value.v.Clone(), m: nil}, nil</span>
}

// FromNatCT creates a NatPlus from the given numct.Nat, returning an error if the value is nil or zero.
func (*PositiveNaturalNumbers) FromNatCT(value *numct.Nat) (*NatPlus, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.IsZero() == ct.True </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;NatPlus{v: value.Clone(), m: nil}, nil</span>
}

// FromInt creates a NatPlus from the given Int, returning an error if the Int is nil, zero, or negative.
func (*PositiveNaturalNumbers) FromInt(value *Int) (*NatPlus, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.IsZero() </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.IsNegative() </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;NatPlus{v: value.Abs().v, m: nil}, nil</span>
}

// FromBytes creates a NatPlus from the given big-endian byte slice, returning an error if the input is empty or represents zero.
func (*PositiveNaturalNumbers) FromBytes(input []byte) (*NatPlus, error) <span class="cov8" title="1">{
        if len(input) == 0 || ct.SliceIsZero(input) == ct.True </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">out := &amp;NatPlus{v: numct.NewNatFromBytes(input), m: nil}
        if out.v.IsZero() == ct.True </span><span class="cov0" title="0">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// FromBytesBE creates a NatPlus from the given big-endian byte slice, returning an error if the input is empty or represents zero.
func (nps *PositiveNaturalNumbers) FromBytesBE(input []byte) (*NatPlus, error) <span class="cov8" title="1">{
        out, err := nps.FromBytes(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// Random generates a random NatPlus in the range [lowInclusive, highExclusive), returning an error if highExclusive is nil.
func (nps *PositiveNaturalNumbers) Random(lowInclusive, highExclusive *NatPlus, prng io.Reader) (*NatPlus, error) <span class="cov8" title="1">{
        if lowInclusive == nil </span><span class="cov0" title="0">{
                lowInclusive = nps.Bottom()
        }</span>
        <span class="cov8" title="1">var v numct.Nat
        if err := v.SetRandomRangeLH(lowInclusive.Value(), highExclusive.Value(), prng); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;NatPlus{v: &amp;v, m: nil}, nil</span>
}

// OpIdentity returns the multiplicative identity element of PositiveNaturalNumbers, which is 1.
// Note that this OpIdentity isn't standard, as it considers (N\{0}, *, +) to be a hemi ring, NOT the usual (N\{0}, +, *).
func (nps *PositiveNaturalNumbers) OpIdentity() *NatPlus <span class="cov8" title="1">{
        return nps.One()
}</span>

// ElementSize returns -1 indicating that NatPlus does not have a fixed element size.
func (*PositiveNaturalNumbers) ElementSize() int <span class="cov8" title="1">{
        return -1
}</span>

// Bottom returns the smallest element of PositiveNaturalNumbers, which is 1.
func (nps *PositiveNaturalNumbers) Bottom() *NatPlus <span class="cov8" title="1">{
        return nps.One()
}</span>

// NatPlus represents a positive natural number (N\{0}).
type NatPlus struct {
        v *numct.Nat
        m *numct.Modulus
}

func (*NatPlus) isValid(x *NatPlus) (*NatPlus, error) <span class="cov8" title="1">{
        if x == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if x.v.IsZero() == ct.True </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return x, nil</span>
}

func (np *NatPlus) cacheMont(m *numct.Modulus) *NatPlus <span class="cov8" title="1">{
        var ok ct.Bool
        if np.m == nil </span><span class="cov8" title="1">{
                if m == nil </span><span class="cov8" title="1">{
                        m, ok = numct.NewModulus(np.v)
                        if ok == ct.False </span><span class="cov0" title="0">{
                                panic(errs2.New("modulus is not valid"))</span>
                        }
                }
                <span class="cov8" title="1">np.m = m</span>
        }
        <span class="cov8" title="1">return np</span>
}

// Structure returns the algebraic structure of NatPlus, which is PositiveNaturalNumbers.
func (*NatPlus) Structure() algebra.Structure[*NatPlus] <span class="cov8" title="1">{
        return NPlus()
}</span>

// Value returns the underlying numct.Nat value of the NatPlus.
func (np *NatPlus) Value() *numct.Nat <span class="cov8" title="1">{
        if np == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return np.v</span>
}

// Op performs multiplication of two NatPlus elements.
func (np *NatPlus) Op(other *NatPlus) *NatPlus <span class="cov8" title="1">{
        return np.Add(other)
}</span>

// OtherOp performs addition of two NatPlus elements.
func (np *NatPlus) OtherOp(other *NatPlus) *NatPlus <span class="cov8" title="1">{
        return np.Mul(other)
}</span>

// Add performs addition of two NatPlus elements.
func (np *NatPlus) Add(other *NatPlus) *NatPlus <span class="cov8" title="1">{
        errs2.Must1(np.isValid(other))
        v := new(numct.Nat)
        v.Add(np.v, other.v)
        return errs2.Must1(np.isValid(&amp;NatPlus{v: v, m: nil}))
}</span>

// Mul performs multiplication of two NatPlus elements.
func (np *NatPlus) Mul(other *NatPlus) *NatPlus <span class="cov8" title="1">{
        errs2.Must1(np.isValid(other))
        v := new(numct.Nat)
        v.Mul(np.v, other.v)
        out := &amp;NatPlus{v: v, m: nil}
        return errs2.Must1(np.isValid(out))
}</span>

// Lsh performs a left shift operation on the NatPlus.
func (np *NatPlus) Lsh(shift uint) *NatPlus <span class="cov8" title="1">{
        v := new(numct.Nat)
        v.Lsh(np.v, shift)
        out := &amp;NatPlus{v: v, m: nil}
        return errs2.Must1(np.isValid(out))
}</span>

// TryRsh attempts to right shift the NatPlus, returning an error if the result would be zero.
func (np *NatPlus) TryRsh(shift uint) (*NatPlus, error) <span class="cov8" title="1">{
        v := new(numct.Nat)
        v.Rsh(np.v, shift)
        out := &amp;NatPlus{v: v, m: nil}
        return np.isValid(out)
}</span>

// Rsh performs a right shift operation on the NatPlus.
// Panics if the result would be zero.
func (np *NatPlus) Rsh(shift uint) *NatPlus <span class="cov8" title="1">{
        return errs2.Must1(np.TryRsh(shift))
}</span>

// Double returns the result of multiplying the NatPlus by 2.
func (np *NatPlus) Double() *NatPlus <span class="cov8" title="1">{
        return np.Add(np)
}</span>

// Square returns the result of squaring the NatPlus.
func (np *NatPlus) Square() *NatPlus <span class="cov8" title="1">{
        return np.Mul(np)
}</span>

// IsOne checks if the NatPlus is equal to 1.
func (np *NatPlus) IsOne() bool <span class="cov8" title="1">{
        return np.v.IsOne() == ct.True
}</span>

// IsOpIdentity checks if the NatPlus is the multiplicative identity (1).
func (np *NatPlus) IsOpIdentity() bool <span class="cov8" title="1">{
        return np.IsOne()
}</span>

// Compare compares the NatPlus with another NatPlus, returning the ordering result.
func (np *NatPlus) Compare(other *NatPlus) base.Ordering <span class="cov8" title="1">{
        errs2.Must1(np.isValid(other))
        lt, eq, gt := np.v.Compare(other.v)
        return base.Ordering(-1*int(lt) + 0*int(eq) + 1*int(gt))
}</span>

// TryInv attempts to compute the multiplicative inverse of the NatPlus, returning an error since it does not exist.
func (np *NatPlus) TryInv() (*NatPlus, error) <span class="cov8" title="1">{
        if np.IsOne() </span><span class="cov0" title="0">{
                return np.Clone(), nil
        }</span>
        <span class="cov8" title="1">return nil, ErrUndefined.WithStackFrame().WithMessage("multiplicative inverse only defined for 1")</span>
}

// TryOpInv attempts to compute the multiplicative inverse of the NatPlus, returning an error since it does not exist.
func (np *NatPlus) TryOpInv() (*NatPlus, error) <span class="cov8" title="1">{
        return np.TryInv()
}</span>

// TryDiv attempts to divide the NatPlus by another NatPlus, returning an error if the division is not exact.
func (np *NatPlus) TryDiv(other *NatPlus) (*NatPlus, error) <span class="cov8" title="1">{
        if _, err := np.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">var q, r numct.Nat
        if ok := q.Div(&amp;r, np.v, other.v); ok == ct.False </span><span class="cov0" title="0">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if r.IsNonZero() != ct.False </span><span class="cov8" title="1">{
                return nil, ErrInexactDivision.WithStackFrame()
        }</span>

        <span class="cov8" title="1">return &amp;NatPlus{v: &amp;q, m: nil}, nil</span>
}

// TrySub attempts to subtract another NatPlus from the NatPlus, returning an error if the result is not a positive natural number.
func (np *NatPlus) TrySub(other *NatPlus) (*NatPlus, error) <span class="cov8" title="1">{
        if _, err := np.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if np.IsLessThanOrEqual(other) </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame().WithMessage("result of subtraction is not a positive natural number")
        }</span>
        <span class="cov8" title="1">v := new(numct.Nat)
        v.SubCap(np.v, other.v, -1)
        out := &amp;NatPlus{v: v, m: nil}
        return np.isValid(out)</span>
}

// IsLessThanOrEqual checks if the NatPlus is less than or equal to another NatPlus.
func (np *NatPlus) IsLessThanOrEqual(other *NatPlus) bool <span class="cov8" title="1">{
        errs2.Must1(np.isValid(other))
        lt, eq, _ := np.v.Compare(other.v)
        return lt|eq == ct.True
}</span>

// IsUnit checks if the NatPlus is a unit with respect to the given modulus.
func (np *NatPlus) IsUnit(modulus *NatPlus) bool <span class="cov8" title="1">{
        errs2.Must1(np.isValid(modulus))
        return np.v.Coprime(modulus.v) == ct.True
}</span>

// Equal checks if the NatPlus is equal to another NatPlus.
func (np *NatPlus) Equal(other *NatPlus) bool <span class="cov8" title="1">{
        errs2.Must1(np.isValid(other))
        return np.v.Equal(other.v) == ct.True
}</span>

// Mod computes the modulus of the NatPlus with respect to another NatPlus.
func (np *NatPlus) Mod(modulus *NatPlus) *Uint <span class="cov8" title="1">{
        return np.Lift().Mod(modulus)
}</span>

// Lift converts the NatPlus to an Int.
func (np *NatPlus) Lift() *Int <span class="cov8" title="1">{
        return &amp;Int{v: np.v.Lift()}
}</span>

// Clone creates a copy of the NatPlus.
func (np *NatPlus) Clone() *NatPlus <span class="cov8" title="1">{
        return &amp;NatPlus{v: np.v.Clone(), m: np.m}
}</span>

// HashCode computes the hash code of the NatPlus.
func (np *NatPlus) HashCode() base.HashCode <span class="cov8" title="1">{
        return np.v.HashCode()
}</span>

// Abs returns the absolute value of the NatPlus, which is itself.
func (np *NatPlus) Abs() *NatPlus <span class="cov8" title="1">{
        return np.Clone()
}</span>

// String returns the string representation of the NatPlus.
func (np *NatPlus) String() string <span class="cov8" title="1">{
        return np.v.String()
}</span>

// Increment returns the NatPlus incremented by 1.
func (np *NatPlus) Increment() *NatPlus <span class="cov8" title="1">{
        return np.Add(NPlus().One())
}</span>

// Bytes returns the big-endian byte representation of the NatPlus.
func (np *NatPlus) Bytes() []byte <span class="cov8" title="1">{
        return np.v.Bytes()
}</span>

// BytesBE returns the big-endian byte representation of the NatPlus.
func (np *NatPlus) BytesBE() []byte <span class="cov8" title="1">{
        return np.Bytes()
}</span>

// IsBottom checks if the NatPlus is the smallest element (1).
func (np *NatPlus) IsBottom() bool <span class="cov8" title="1">{
        return np.IsOne()
}</span>

// Bit returns the value of the i-th bit of the NatPlus.
func (np *NatPlus) Bit(i uint) byte <span class="cov8" title="1">{
        return np.v.Bit(i)
}</span>

// Byte returns the value of the i-th byte of the NatPlus.
func (np *NatPlus) Byte(i uint) byte <span class="cov8" title="1">{
        return np.v.Byte(i)
}</span>

// IsEven checks if the NatPlus is even.
func (np *NatPlus) IsEven() bool <span class="cov8" title="1">{
        return np.v.IsEven() == ct.True
}</span>

// IsOdd checks if the NatPlus is odd.
func (np *NatPlus) IsOdd() bool <span class="cov8" title="1">{
        return np.v.IsOdd() == ct.True
}</span>

// Decrement returns the NatPlus decremented by 1, returning an error if the result would be less than 1.
func (np *NatPlus) Decrement() (*NatPlus, error) <span class="cov8" title="1">{
        if np.IsOne() </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame().WithMessage("cannot decrement NatPlus below 1")
        }</span>
        <span class="cov8" title="1">return np.TrySub(NPlus().One())</span>
}

// Big returns the big.Int representation of the NatPlus.
func (np *NatPlus) Big() *big.Int <span class="cov8" title="1">{
        return np.v.Big()
}</span>

func (np *NatPlus) Uint64() uint64 <span class="cov8" title="1">{
        return np.v.Uint64()
}</span>

// Cardinal returns the cardinal representation of the NatPlus.
func (np *NatPlus) Cardinal() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.NewFromNumeric(np.v)
}</span>

// Nat returns the Nat representation of the NatPlus.
func (np *NatPlus) Nat() *Nat <span class="cov8" title="1">{
        return &amp;Nat{v: np.v.Clone()}
}</span>

// IsProbablyPrime checks if the NatPlus is probably prime.
func (np *NatPlus) IsProbablyPrime() bool <span class="cov8" title="1">{
        return np.v.IsProbablyPrime() == ct.True
}</span>

// ModulusCT returns the cached modulus or computes it if not cached.
func (np *NatPlus) ModulusCT() *numct.Modulus <span class="cov8" title="1">{
        np.cacheMont(nil)
        return np.m
}</span>

// TrueLen returns the true length of the NatPlus in bytes.
func (np *NatPlus) TrueLen() int <span class="cov8" title="1">{
        return np.v.TrueLen()
}</span>

// AnnouncedLen returns the announced length of the NatPlus in bytes.
func (np *NatPlus) AnnouncedLen() int <span class="cov8" title="1">{
        return np.v.AnnouncedLen()
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">package num

import (
        "io"
        "math/big"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
)

var (
        qOnce     sync.Once
        qInstance *Rationals
)

// Q returns the singleton instance of the Rationals structure.
func Q() *Rationals <span class="cov8" title="1">{
        qOnce.Do(func() </span><span class="cov8" title="1">{
                qInstance = &amp;Rationals{}
        }</span>)
        <span class="cov8" title="1">return qInstance</span>
}

// Rationals represents the field of rational numbers Q.
type Rationals struct{}

// Name returns the name of the structure.
func (*Rationals) Name() string <span class="cov8" title="1">{
        return "Q"
}</span>

// Characteristic returns the characteristic of the field Q, which is 0.
func (*Rationals) Characteristic() algebra.Cardinal <span class="cov8" title="1">{
        return cardinal.New(0)
}</span>

// Order returns the order of the field Q, which is infinite.
func (*Rationals) Order() algebra.Cardinal <span class="cov8" title="1">{
        return cardinal.Infinite()
}</span>

// ElementSize returns -1 to indicate that elements of Q do not have a fixed size.
func (*Rationals) ElementSize() int <span class="cov8" title="1">{
        return -1
}</span>

// ExtensionDegree returns the extension degree of Q over itself, which is 1.
func (*Rationals) ExtensionDegree() uint <span class="cov8" title="1">{
        return 1
}</span>

// New creates a new Rat element with the given numerator and denominator.
func (*Rationals) New(a *Int, b *NatPlus) (*Rat, error) <span class="cov8" title="1">{
        if a == nil || b == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: a,
                b: b,
        }, nil</span>
}

// FromBytes deserializes a Rat element from the given byte slice.
func (*Rationals) FromBytes(data []byte) (*Rat, error) <span class="cov8" title="1">{
        var r Rat
        if err := r.UnmarshalCBOR(data); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;r, nil</span>
}

// FromUint64 creates a Rat element from a uint64 value.
func (*Rationals) FromUint64(n uint64) *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: Z().FromUint64(n),
                b: NPlus().One(),
        }
}</span>

// FromInt64 creates a Rat element from an int64 value.
func (*Rationals) FromInt64(n int64) *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: Z().FromInt64(n),
                b: NPlus().One(),
        }
}</span>

// FromNatPlus creates a Rat element from a NatPlus value.
func (*Rationals) FromNatPlus(n *NatPlus) (*Rat, error) <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: n.Lift(),
                b: NPlus().One(),
        }, nil</span>
}

// FromNat creates a Rat element from a Nat value.
func (*Rationals) FromNat(n *Nat) (*Rat, error) <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: n.Lift(),
                b: NPlus().One(),
        }, nil</span>
}

// FromInt creates a Rat element from an Int value.
func (*Rationals) FromInt(n *Int) (*Rat, error) <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: n.Clone(),
                b: NPlus().One(),
        }, nil</span>
}

// FromUint creates a Rat element from a Uint value.
func (*Rationals) FromUint(n *Uint) (*Rat, error) <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: n.Lift(),
                b: NPlus().One(),
        }, nil</span>
}

// FromBig creates a *Rat element from a *big.Int value.
func (*Rationals) FromBig(n *big.Int) (*Rat, error) <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">a, err := Z().FromBig(n)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: a,
                b: NPlus().One(),
        }, nil</span>
}

// FromBigRat creates a *Rat element from a *big.Rat value.
func (*Rationals) FromBigRat(n *big.Rat) (*Rat, error) <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">a, err := Z().FromBig(n.Num())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">b, err := NPlus().FromBig(n.Denom())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: a,
                b: b,
        }, nil</span>
}

// Random samples a random *Rat element in the interval [lowInclusive, highExclusive).
func (*Rationals) Random(lowInclusive, highExclusive *Rat, prng io.Reader) (*Rat, error) <span class="cov8" title="1">{
        if prng == nil || lowInclusive == nil || highExclusive == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        // Validate interval [lowInclusive, highExclusive)
        <span class="cov8" title="1">if !lowInclusive.IsLessThanOrEqual(highExclusive) </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame().WithMessage("lowInclusive is greater than highExclusive")
        }</span>
        <span class="cov8" title="1">if lowInclusive.Equal(highExclusive) </span><span class="cov8" title="1">{
                return nil, errs2.New("interval is empty")
        }</span>

        // Sample on the lattice with common denominator D = b1*b2.
        // Any rational n/D with n in [a1*b2, a2*b1) lies in [lowInclusive, highExclusive).
        <span class="cov8" title="1">D := lowInclusive.b.Mul(highExclusive.b)
        lowN := lowInclusive.a.Mul(highExclusive.b.Lift())  // a1*b2
        highN := highExclusive.a.Mul(lowInclusive.b.Lift()) // a2*b1

        n, err := Z().Random(lowN, highN, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return (&amp;Rat{a: n, b: D}).Canonical(), nil</span>
}

// RandomInt samples a random integer *Int element in the interval [lowInclusive, highExclusive).
//
// The valid integers are those n satisfying lowInclusive &lt;= n &lt; highExclusive, which is
// equivalent to the half-open integer interval [ceil(lowInclusive), ceil(highExclusive)).
//
// Returns ErrOutOfRange if the interval contains no integers.
func (*Rationals) RandomInt(lowInclusive, highExclusive *Rat, prng io.Reader) (*Int, error) <span class="cov8" title="1">{
        if prng == nil || lowInclusive == nil || highExclusive == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>

        // Validate [lowInclusive, highExclusive)
        <span class="cov8" title="1">if !lowInclusive.IsLessThanOrEqual(highExclusive) </span><span class="cov0" title="0">{
                return nil, ErrOutOfRange.WithStackFrame().WithMessage("lowInclusive is greater than highExclusive")
        }</span>

        // Integers n with lowInclusive &lt;= n &lt; highExclusive are exactly those in
        // the half-open interval [ceil(lowInclusive), ceil(highExclusive)).
        <span class="cov8" title="1">lowInt, err := lowInclusive.Ceil()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">highIntExclusive, err := highExclusive.Ceil()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        // If ceil(low) &gt;= ceil(high), there is no integer n with low &lt;= n &lt; high.
        <span class="cov8" title="1">if !lowInt.Compare(highIntExclusive).IsLessThan() </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame().WithMessage("no integers in the specified interval")
        }</span>

        // Z().Random samples from [lowInt, highIntExclusive), matching the integer
        // points in [lowInclusive, highExclusive).
        <span class="cov8" title="1">result, err := Z().Random(lowInt, highIntExclusive, prng)
        if err != nil </span><span class="cov0" title="0">{
                // Wrap any error from Z().Random as ErrOutOfRange for consistent error handling.
                // This can happen if highIntExclusive is zero (Z().Random requires non-zero high bound).
                return nil, ErrOutOfRange.WithStackFrame().WithMessage("failed to sample integer in interval: %v", err)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// IsDomain indicates that Q is a domain.
func (*Rationals) IsDomain() bool <span class="cov8" title="1">{
        return true
}</span>

// OpIdentity returns the additive identity element of Q.
func (q *Rationals) OpIdentity() *Rat <span class="cov8" title="1">{
        return q.One()
}</span>

// Zero returns the zero element of Q.
func (*Rationals) Zero() *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: Z().Zero(),
                b: NPlus().One(),
        }
}</span>

// One returns the multiplicative identity element of Q.
func (*Rationals) One() *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: Z().One(),
                b: NPlus().One(),
        }
}</span>

// Rat represents an element of the field of rational numbers Q.
type Rat struct {
        a *Int
        b *NatPlus
}

// Numerator returns the numerator of the Rat element.
func (r *Rat) Numerator() *Int <span class="cov8" title="1">{
        return r.a
}</span>

// Denominator returns the denominator of the Rat element.
func (r *Rat) Denominator() *NatPlus <span class="cov8" title="1">{
        return r.b
}</span>

// Ceil returns the smallest integer greater than or equal to the Rat element.
func (r *Rat) Ceil() (*Int, error) <span class="cov8" title="1">{
        quot, rem, err := r.a.EuclideanDiv(r.b.Lift())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if rem.IsZero() </span><span class="cov8" title="1">{
                return quot, nil
        }</span>
        <span class="cov8" title="1">return quot.Increment(), nil</span>
}

// Floor returns the largest integer less than or equal to the Rat element.
func (r *Rat) Floor() (*Int, error) <span class="cov8" title="1">{
        quot, _, err := r.a.EuclideanDiv(r.b.Lift())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return quot, nil</span>
}

// Structure returns the algebraic structure to which the Rat element belongs.
func (*Rat) Structure() algebra.Structure[*Rat] <span class="cov8" title="1">{
        return Q()
}</span>

// Op performs addition of two Rat elements.
func (r *Rat) Op(rhs *Rat) *Rat <span class="cov8" title="1">{
        return r.Add(rhs)
}</span>

// Add performs addition of two Rat elements.
func (r *Rat) Add(rhs *Rat) *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: r.a.Mul(rhs.b.Lift()).Add(rhs.a.Mul(r.b.Lift())),
                b: r.b.Mul(rhs.b),
        }
}</span>

// Double returns the result of adding the Rat element to itself.
func (r *Rat) Double() *Rat <span class="cov8" title="1">{
        return r.Add(r)
}</span>

// TrySub performs subtraction of two Rat elements.
func (r *Rat) TrySub(rhs *Rat) (*Rat, error) <span class="cov8" title="1">{
        return r.Sub(rhs), nil
}</span>

// Sub performs subtraction of two Rat elements.
func (r *Rat) Sub(rhs *Rat) *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: r.a.Mul(rhs.b.Lift()).Sub(rhs.a.Mul(r.b.Lift())),
                b: r.b.Mul(rhs.b),
        }
}</span>

// OtherOp performs multiplication of two Rat elements.
func (r *Rat) OtherOp(rhs *Rat) *Rat <span class="cov8" title="1">{
        return r.Mul(rhs)
}</span>

// Mul performs multiplication of two Rat elements.
func (r *Rat) Mul(rhs *Rat) *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: r.a.Mul(rhs.a),
                b: r.b.Mul(rhs.b),
        }
}</span>

// Square returns the square of the Rat element.
func (r *Rat) Square() *Rat <span class="cov8" title="1">{
        return r.Mul(r)
}</span>

// EuclideanDiv performs Euclidean division of two Rat elements.
func (r *Rat) EuclideanDiv(rhs *Rat) (quo, rem *Rat, err error) <span class="cov8" title="1">{
        quo, err = r.TryDiv(rhs)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return quo, Q().Zero(), nil</span>
}

// EuclideanValuation returns the Euclidean valuation of the Rat element.
func (r *Rat) EuclideanValuation() cardinal.Cardinal <span class="cov8" title="1">{
        if r.IsZero() </span><span class="cov8" title="1">{
                return cardinal.Zero()
        }</span>
        <span class="cov8" title="1">return cardinal.New(1)</span>
}

// TryDiv performs division of two Rat elements.
func (r *Rat) TryDiv(rhs *Rat) (*Rat, error) <span class="cov8" title="1">{
        if rhs.IsZero() </span><span class="cov8" title="1">{
                return nil, errs2.New("division by zero")
        }</span>
        <span class="cov8" title="1">numerator := r.a.Mul(rhs.b.Lift())
        // Handle sign: if rhs.a is negative, negate the numerator
        absRhsA := rhs.a
        if rhs.a.IsNegative() </span><span class="cov8" title="1">{
                numerator = numerator.Neg()
                absRhsA = rhs.a.Neg()
        }</span>
        <span class="cov8" title="1">rhsANP, err := NPlus().FromInt(absRhsA)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: numerator,
                b: r.b.Mul(rhsANP),
        }, nil</span>
}

// TryOpInv returns the additive inverse of the Rat element.
func (r *Rat) TryOpInv() (*Rat, error) <span class="cov8" title="1">{
        return r.TryNeg()
}</span>

// OpInv returns the additive inverse of the Rat element.
func (r *Rat) OpInv() *Rat <span class="cov8" title="1">{
        return r.Neg()
}</span>

// TryNeg returns the additive inverse of the Rat element.
func (r *Rat) TryNeg() (*Rat, error) <span class="cov8" title="1">{
        return r.Neg(), nil
}</span>

// Neg returns the additive inverse of the Rat element.
func (r *Rat) Neg() *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: r.a.Neg(),
                b: r.b,
        }
}</span>

// TryInv returns the multiplicative inverse of the Rat element.
func (r *Rat) TryInv() (*Rat, error) <span class="cov8" title="1">{
        if r.IsZero() </span><span class="cov8" title="1">{
                return nil, errs2.New("inversion of zero")
        }</span>
        // Swap numerator and denominator: a/b becomes b/a
        // Handle sign: if a is negative, result should have negative numerator
        <span class="cov8" title="1">absA := r.a
        sign := false
        if r.a.IsNegative() </span><span class="cov8" title="1">{
                absA = r.a.Neg()
                sign = true
        }</span>
        <span class="cov8" title="1">bAsNP, err := NPlus().FromInt(absA)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">numerator := r.b.Lift()
        if sign </span><span class="cov8" title="1">{
                numerator = numerator.Neg()
        }</span>
        <span class="cov8" title="1">return &amp;Rat{
                a: numerator,
                b: bAsNP,
        }, nil</span>
}

// IsOpIdentity checks if the Rat element is the additive identity (zero).
func (r *Rat) IsOpIdentity() bool <span class="cov8" title="1">{
        return r.a.IsZero()
}</span>

// IsZero checks if the Rat element is zero.
func (r *Rat) IsZero() bool <span class="cov8" title="1">{
        return r.a.IsZero()
}</span>

// IsOne checks if the Rat element is one.
func (r *Rat) IsOne() bool <span class="cov8" title="1">{
        return r.a.Equal(r.b.Lift())
}</span>

// Canonical returns the canonical form of the Rat element.
func (r *Rat) Canonical() *Rat <span class="cov8" title="1">{
        if r.IsZero() </span><span class="cov8" title="1">{
                return &amp;Rat{a: Z().Zero(), b: NPlus().One()}
        }</span>
        <span class="cov8" title="1">if r.Denominator().IsOne() </span><span class="cov8" title="1">{
                return &amp;Rat{a: r.a.Clone(), b: NPlus().One()}
        }</span>
        <span class="cov8" title="1">gcd := r.a.Abs().GCD(r.b.Nat())
        if gcd.IsOne() </span><span class="cov8" title="1">{ // Already canonical
                return &amp;Rat{a: r.a.Clone(), b: r.b.Clone()}
        }</span>
        // Divide numerator and denominator by gcd
        <span class="cov8" title="1">num, r1, err := r.a.EuclideanDiv(gcd.Lift())
        if err != nil || !r1.IsZero() </span><span class="cov0" title="0">{
                return &amp;Rat{a: r.a.Clone(), b: r.b.Clone()}
        }</span>
        <span class="cov8" title="1">den, r2, err := r.b.Lift().EuclideanDiv(gcd.Lift())
        if err != nil || !r2.IsZero() </span><span class="cov0" title="0">{
                return &amp;Rat{a: r.a.Clone(), b: r.b.Clone()}
        }</span>
        <span class="cov8" title="1">den2, err := NPlus().FromInt(den)
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err))</span>
        }
        <span class="cov8" title="1">return &amp;Rat{a: num, b: den2}</span>
}

// IsInt checks if the Rat element is an integer.
func (r *Rat) IsInt() bool <span class="cov8" title="1">{
        return r.Canonical().Denominator().IsOne()
}</span>

// IsProbablyPrime checks if the Rat element is probably prime.
func (r *Rat) IsProbablyPrime() bool <span class="cov8" title="1">{
        canonical := r.Canonical()
        return canonical.Denominator().IsOne() &amp;&amp; canonical.Numerator().IsProbablyPrime()
}</span>

// Clone creates a deep copy of the Rat element.
func (r *Rat) Clone() *Rat <span class="cov8" title="1">{
        return &amp;Rat{
                a: r.a.Clone(),
                b: r.b.Clone(),
        }
}</span>

// IsLessThanOrEqual checks if the Rat element is less than another Rat element.
func (r *Rat) IsLessThanOrEqual(rhs *Rat) bool <span class="cov8" title="1">{
        left := r.a.Mul(rhs.b.Lift())
        right := rhs.a.Mul(r.b.Lift())
        return left.IsLessThanOrEqual(right)
}</span>

// IsNegative checks if the Rat element is negative.
func (r *Rat) IsNegative() bool <span class="cov8" title="1">{
        return r.a.IsNegative()
}</span>

// IsPositive checks if the Rat element is positive.
func (r *Rat) IsPositive() bool <span class="cov8" title="1">{
        return !r.IsNegative() &amp;&amp; !r.IsZero()
}</span>

// Equal checks if the Rat element is equal to another Rat element.
func (r *Rat) Equal(rhs *Rat) bool <span class="cov8" title="1">{
        return r.a.Mul(rhs.b.Lift()).Equal(r.b.Lift().Mul(rhs.a))
}</span>

// Bytes serialises the Rat element to a byte slice.
func (r *Rat) Bytes() []byte <span class="cov8" title="1">{
        out, err := r.MarshalCBOR()
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err))</span>
        }
        <span class="cov8" title="1">return out</span>
}

func (r *Rat) Big() *big.Rat <span class="cov0" title="0">{
        num := r.a.Big()
        den := r.b.Big()
        return big.NewRat(0, 1).SetFrac(num, den)
}</span>

// HashCode computes the hash code of the Rat element.
func (r *Rat) HashCode() base.HashCode <span class="cov8" title="1">{
        return r.a.HashCode().Combine(r.b.HashCode())
}</span>

// String returns the string representation of the Rat element.
func (r *Rat) String() string <span class="cov8" title="1">{
        return r.a.String() + "/" + r.b.String()
}</span>
</pre>
		
		<pre class="file" id="file153" style="display: none">package num

import (
        "io"
        "math/big"
        "sync"

        "github.com/cronokirby/saferith"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

var (
        zOnce     sync.Once
        zInstance *Integers
)

// Z returns the singleton instance of the Integers structure.
func Z() *Integers <span class="cov8" title="1">{
        zOnce.Do(func() </span><span class="cov8" title="1">{
                zInstance = &amp;Integers{}
        }</span>)
        <span class="cov8" title="1">return zInstance</span>
}

// Integers implements the algebra.Structure interface for the ring of integers Z.
type Integers struct{}

func (*Integers) Name() string <span class="cov8" title="1">{
        return "Z"
}</span>

// Order returns the (infinite) order of the integers.
func (*Integers) Order() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.Infinite()
}</span>

// Characteristic returns the characteristic of the integers, which is 0.
func (*Integers) Characteristic() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.Zero()
}</span>

// OpIdentity returns the additive identity element (zero) of the integers.
func (zs *Integers) OpIdentity() *Int <span class="cov8" title="1">{
        return zs.Zero()
}</span>

// Zero returns the zero element of the integers.
func (*Integers) Zero() *Int <span class="cov8" title="1">{
        return &amp;Int{v: numct.IntZero()}
}</span>

// One returns the multiplicative identity element (one) of the integers.
func (*Integers) One() *Int <span class="cov8" title="1">{
        return &amp;Int{v: numct.IntOne()}
}</span>

// IsDomain returns true, indicating that the integers form a domain (no zero divisors).
func (*Integers) IsDomain() bool <span class="cov8" title="1">{
        return true
}</span>

// FromUint64 creates an integer from a uint64 value.
func (*Integers) FromUint64(value uint64) *Int <span class="cov8" title="1">{
        return &amp;Int{v: numct.NewIntFromUint64(value)}
}</span>

// FromBig creates an integer from a big.Int value.
func (zs *Integers) FromBig(value *big.Int) (*Int, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if value.Sign() == 0 </span><span class="cov8" title="1">{
                return zs.Zero(), nil
        }</span>
        // Use numct.NewIntFromBig which correctly handles sign
        <span class="cov8" title="1">return &amp;Int{v: numct.NewIntFromBig(value, value.BitLen())}, nil</span>
}

// FromNatPlus creates an integer from a NatPlus value.
func (zs *Integers) FromNatPlus(value *NatPlus) (*Int, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return zs.FromNatCT(value.Value())</span>
}

// FromNat creates an integer from a Nat value.
func (zs *Integers) FromNat(value *Nat) (*Int, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return zs.FromNatCT(value.Value())</span>
}

// FromNatCT creates an integer from a numct.Nat value.
func (*Integers) FromNatCT(value *numct.Nat) (*Int, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">result := new(numct.Int)
        result.SetNat(value)
        return &amp;Int{v: result}, nil</span>
}

// FromIntCT creates an integer from a numct.Int value.
func (*Integers) FromIntCT(value *numct.Int) (*Int, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Int{v: value.Clone()}, nil</span>
}

// FromInt64 creates an integer from an int64 value.
func (*Integers) FromInt64(value int64) *Int <span class="cov8" title="1">{
        return &amp;Int{v: numct.NewInt(value)}
}</span>

// FromCardinal creates an integer from a cardinal.Cardinal value.
func (zs *Integers) FromCardinal(value cardinal.Cardinal) (*Int, error) <span class="cov8" title="1">{
        n, err := N().FromCardinal(value)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return zs.FromNat(n)</span>
}

// FromBytes creates an integer from its byte representation.
func (*Integers) FromBytes(input []byte) (*Int, error) <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Int{v: numct.NewIntFromBytes(input)}, nil</span>
}

// FromUint creates an integer from a Uint value.
func (zs *Integers) FromUint(input *Uint) (*Int, error) <span class="cov8" title="1">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return zs.FromNatCT(input.v)</span>
}

// FromRat creates an integer from a Rat value, if the Rat is an integer.
func (*Integers) FromRat(input *Rat) (*Int, error) <span class="cov8" title="1">{
        if input == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">canonical := input.Canonical()
        if !canonical.IsInt() </span><span class="cov8" title="1">{
                return nil, ErrUndefined.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return canonical.a.Clone(), nil</span>
}

// FromUintSymmetric creates an integer from a Uint value using symmetric representation.
func (*Integers) FromUintSymmetric(input *Uint) (*Int, error) <span class="cov8" title="1">{
        if input == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">var v numct.Int
        input.m.ModSymmetric(&amp;v, input.v)
        return &amp;Int{v: &amp;v}, nil</span>
}

// Random generates a random integer in the range [lowInclusive, highExclusive).
func (*Integers) Random(lowInclusive, highExclusive *Int, prng io.Reader) (*Int, error) <span class="cov8" title="1">{
        var v numct.Int
        if err := v.SetRandomRangeLH(lowInclusive.Value(), highExclusive.Value(), prng); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Int{v: &amp;v}, nil</span>
}

// ElementSize returns -1 indicating that the size of integer elements is unbounded.
func (*Integers) ElementSize() int <span class="cov8" title="1">{
        return -1
}</span>

// ScalarStructure returns the structure of the scalars, which is also the integers.
func (*Integers) ScalarStructure() algebra.Structure[*Int] <span class="cov8" title="1">{
        return Z()
}</span>

// Int represents an integer in the ring of integers Z.
type Int struct {
        v *numct.Int
}

// Value returns the underlying numct.Int value of the integer.
func (i *Int) Value() *numct.Int <span class="cov8" title="1">{
        return i.v
}</span>

func (*Int) isValid(x *Int) (*Int, error) <span class="cov8" title="1">{
        if x == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return x, nil</span>
}

// Structure returns the algebraic structure of the integers.
func (*Int) Structure() algebra.Structure[*Int] <span class="cov8" title="1">{
        return Z()
}</span>

// Op performs addition of two integers.
func (i *Int) Op(other *Int) *Int <span class="cov8" title="1">{
        return i.Add(other)
}</span>

// TryOpInv returns the additive inverse of the integer.
func (i *Int) TryOpInv() (*Int, error) <span class="cov8" title="1">{
        return i.OpInv(), nil
}</span>

// OpInv returns the additive inverse of the integer.
func (i *Int) OpInv() *Int <span class="cov8" title="1">{
        return i.Neg()
}</span>

// OtherOp performs multiplication of two integers.
func (i *Int) OtherOp(other *Int) *Int <span class="cov8" title="1">{
        return i.Mul(other)
}</span>

// Add performs addition of two integers.
func (i *Int) Add(other *Int) *Int <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))
        v := new(numct.Int)
        v.Add(i.v, other.v)
        return &amp;Int{v: v}
}</span>

// TrySub performs subtraction of two integers.
func (i *Int) TrySub(other *Int) (*Int, error) <span class="cov8" title="1">{
        return i.Sub(other), nil
}</span>

// Sub performs subtraction of two integers.
func (i *Int) Sub(other *Int) *Int <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))
        v := new(numct.Int)
        v.Sub(i.v, other.v)
        return &amp;Int{v: v}
}</span>

// Mul performs multiplication of two integers.
func (i *Int) Mul(other *Int) *Int <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))
        v := new(numct.Int)
        v.Mul(i.v, other.v)
        return &amp;Int{v: v}
}</span>

// Lsh performs a left shift operation on the integer.
func (i *Int) Lsh(shift uint) *Int <span class="cov8" title="1">{
        v := new(numct.Int)
        v.Lsh(i.v, shift)
        return &amp;Int{v: v}
}</span>

// Rsh performs a right shift operation on the integer.
func (i *Int) Rsh(shift uint) *Int <span class="cov8" title="1">{
        v := new(numct.Int)
        v.Rsh(i.v, shift)
        return &amp;Int{v: v}
}</span>

// IsInRange checks if the integer is within the range defined by the modulus i.e., 0 &lt;= x &lt; m.
func (i *Int) IsInRange(modulus *NatPlus) bool <span class="cov8" title="1">{
        if modulus == nil </span><span class="cov0" title="0">{
                panic("argument is nil")</span>
        }
        <span class="cov8" title="1">if i.IsNegative() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return modulus.ModulusCT().IsInRange(i.Abs().v) == ct.True</span>
}

// IsInRangeSymmetric checks if the integer is within the symmetric range defined by the modulus i.e., -m/2 &lt;= x &lt; m/2.
func (i *Int) IsInRangeSymmetric(modulus *NatPlus) bool <span class="cov8" title="1">{
        if modulus == nil </span><span class="cov0" title="0">{
                panic("argument is nil")</span>
        }
        <span class="cov8" title="1">return modulus.ModulusCT().IsInRangeSymmetric(i.v) == ct.True</span>
}

// Mod returns the integer modulo the given NatPlus modulus.
func (i *Int) Mod(modulus *NatPlus) *Uint <span class="cov8" title="1">{
        out := new(numct.Nat)
        modulus.ModulusCT().ModI(out, i.v)
        return &amp;Uint{v: out, m: modulus.ModulusCT()}
}</span>

// IsPositive checks if the integer is positive.
func (i *Int) IsPositive() bool <span class="cov8" title="1">{
        return i.v.IsNegative()|i.v.IsZero() == ct.False
}</span>

// Coprime checks if two integers are coprime.
func (i *Int) Coprime(other *Int) bool <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))
        return i.v.Coprime(other.v) == ct.True
}</span>

// IsProbablyPrime checks if the integer is probably prime.
func (i *Int) IsProbablyPrime() bool <span class="cov8" title="1">{
        return i.v.IsProbablyPrime() == ct.True
}</span>

// EuclideanDiv performs Euclidean division of the integer by another integer.
func (i *Int) EuclideanDiv(other *Int) (quot, rem *Int, err error) <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))

        var q numct.Int
        var r numct.Nat
        if ok := q.EuclideanDiv(&amp;r, i.v, other.v); ok == ct.False </span><span class="cov8" title="1">{
                return nil, nil, ErrDivisionByZero.WithStackFrame()
        }</span>

        <span class="cov8" title="1">quot = &amp;Int{v: &amp;q}
        rem = &amp;Int{v: new(numct.Int)}
        rem.v.SetNat(&amp;r)
        return quot, rem, nil</span>
}

// EuclideanDivVarTime performs Euclidean division of the integer by another integer.
// It is not constant-time due to having to generate montgomery parameters for the divisor (i.e., leaks divisor).
func (i *Int) EuclideanDivVarTime(other *Int) (quot, rem *Int, err error) <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))

        var q numct.Int
        var r numct.Nat
        if ok := q.EuclideanDivVarTime(&amp;r, i.v, other.v); ok == ct.False </span><span class="cov8" title="1">{
                return nil, nil, ErrDivisionByZero.WithStackFrame()
        }</span>

        <span class="cov8" title="1">quot = &amp;Int{v: &amp;q}
        rem = &amp;Int{v: new(numct.Int)}
        rem.v.SetNat(&amp;r)
        return quot, rem, nil</span>
}

// EuclideanValuation returns the Euclidean valuation of the integer.
func (i *Int) EuclideanValuation() algebra.Cardinal <span class="cov8" title="1">{
        return cardinal.NewFromNumeric(i.Abs())
}</span>

// Abs returns the absolute value of the integer.
func (i *Int) Abs() *Nat <span class="cov8" title="1">{
        return &amp;Nat{v: (*numct.Nat)((*saferith.Int)(i.v.Clone()).Abs())}
}</span>

// IsNegative checks if the integer is negative.
func (i *Int) IsNegative() bool <span class="cov8" title="1">{
        return i.v.IsNegative() == ct.True
}</span>

// IsUnit checks if the integer is a unit modulo the given NatPlus modulus.
func (i *Int) IsUnit(modulus *NatPlus) bool <span class="cov8" title="1">{
        if modulus == nil </span><span class="cov0" title="0">{
                panic("argument is nil")</span>
        }
        <span class="cov8" title="1">m, ok := numct.NewModulus(modulus.v)
        if ok == ct.False </span><span class="cov0" title="0">{
                panic(errs2.New("modulus is not valid"))</span>
        }
        <span class="cov8" title="1">return m.IsUnit(i.Mod(modulus).v) == ct.True</span>
}

// TryDiv performs the exact division of the integer by another integer.
func (i *Int) TryDiv(other *Int) (*Int, error) <span class="cov8" title="1">{
        if _, err := i.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">var q, r numct.Int
        if ok := q.Div(&amp;r, i.v, other.v); ok == ct.False </span><span class="cov8" title="1">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if r.IsNonZero() != ct.False </span><span class="cov8" title="1">{
                return nil, ErrInexactDivision.WithStackFrame()
        }</span>

        <span class="cov8" title="1">return &amp;Int{v: &amp;q}, nil</span>
}

// TryDivVarTime performs the exact division of the integer by another integer.
// It is not constant-time due to having to generate montgomery parameters for the divisor (i.e., leaks divisor).
func (i *Int) TryDivVarTime(other *Int) (*Int, error) <span class="cov8" title="1">{
        if _, err := i.isValid(other); err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">var q, r numct.Int
        if ok := q.DivVarTime(&amp;r, i.v, other.v); ok != ct.True </span><span class="cov8" title="1">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if r.IsNonZero() != ct.False </span><span class="cov8" title="1">{
                return nil, ErrInexactDivision.WithStackFrame()
        }</span>

        <span class="cov8" title="1">return &amp;Int{v: &amp;q}, nil</span>
}

// DivRound performs the division of the integer by another integer returning the quotient rounded towards zero.
func (i *Int) DivRound(other *Int) (*Int, error) <span class="cov8" title="1">{
        if _, err := i.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">var q numct.Int
        if ok := q.Div(nil, i.v, other.v); ok == ct.False </span><span class="cov8" title="1">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>

        <span class="cov8" title="1">return &amp;Int{v: &amp;q}, nil</span>
}

// DivRoundVarTime performs the division of the integer by another integer returning the quotient rounded towards zero.
// It is not constant-time due to having to generate montgomery parameters for the divisor (i.e., leaks divisor).
func (i *Int) DivRoundVarTime(other *Int) (*Int, error) <span class="cov0" title="0">{
        if _, err := i.isValid(other); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov0" title="0">var q numct.Int
        if ok := q.DivVarTime(nil, i.v, other.v); ok != ct.True </span><span class="cov0" title="0">{
                return nil, ErrDivisionByZero.WithStackFrame()
        }</span>

        <span class="cov0" title="0">return &amp;Int{v: &amp;q}, nil</span>
}

// TryInv attempts to compute the multiplicative inverse of the integer.
func (i *Int) TryInv() (*Int, error) <span class="cov8" title="1">{
        if i.Abs().IsOne() </span><span class="cov8" title="1">{
                return i.Clone(), nil
        }</span>
        <span class="cov8" title="1">return nil, ErrUndefined.WithStackFrame()</span>
}

// TryNeg attempts to compute the negation of the integer. It never fails.
func (i *Int) TryNeg() (*Int, error) <span class="cov8" title="1">{
        return i.Neg(), nil
}</span>

// Neg computes the negation of the integer.
func (i *Int) Neg() *Int <span class="cov8" title="1">{
        v := new(numct.Int)
        v.Neg(i.v.Clone())
        return &amp;Int{v: v}
}</span>

// Double returns the integer multiplied by 2.
func (i *Int) Double() *Int <span class="cov8" title="1">{
        return i.Add(i)
}</span>

// Square returns the square of the integer.
func (i *Int) Square() *Int <span class="cov8" title="1">{
        return i.Mul(i)
}</span>

// Compare compares the integer with another integer.
func (i *Int) Compare(other *Int) base.Ordering <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))
        lt, eq, gt := i.v.Compare(other.v)
        return base.Ordering(-1*int(lt) + 0*int(eq) + 1*int(gt))
}</span>

// IsLessThanOrEqual checks if the integer is less than or equal to another integer.
func (i *Int) IsLessThanOrEqual(other *Int) bool <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))
        lt, eq, _ := i.v.Compare(other.v)
        return lt|eq == ct.True
}</span>

// Equal checks if the integer is equal to another integer.
func (i *Int) Equal(other *Int) bool <span class="cov8" title="1">{
        errs2.Must1(i.isValid(other))
        return i.v.Equal(other.v) == ct.True
}</span>

// IsOpIdentity checks if the integer is the additive identity (zero).
func (i *Int) IsOpIdentity() bool <span class="cov8" title="1">{
        return i.IsZero()
}</span>

// ScalarOp performs scalar multiplication of the integer by another integer.
func (i *Int) ScalarOp(other *Int) *Int <span class="cov8" title="1">{
        return i.Mul(other)
}</span>

// IsTorsionFree returns true, indicating that the integers are torsion-free.
func (*Int) IsTorsionFree() bool <span class="cov8" title="1">{
        return true
}</span>

// ScalarMul performs scalar multiplication of the integer by another integer.
func (i *Int) ScalarMul(other *Int) *Int <span class="cov8" title="1">{
        return i.Mul(other)
}</span>

// IsZero checks if the integer is zero.
func (i *Int) IsZero() bool <span class="cov8" title="1">{
        return i.v.IsZero() == ct.True
}</span>

// IsOne checks if the integer is one.
func (i *Int) IsOne() bool <span class="cov8" title="1">{
        return i.v.IsOne() == ct.True
}</span>

// HashCode returns the hash code of the integer.
func (i *Int) HashCode() base.HashCode <span class="cov8" title="1">{
        return i.v.HashCode()
}</span>

// Clone creates a copy of the integer.
func (i *Int) Clone() *Int <span class="cov8" title="1">{
        return &amp;Int{v: i.v.Clone()}
}</span>

// String returns the string representation of the integer.
func (i *Int) String() string <span class="cov8" title="1">{
        return i.v.String()
}</span>

// Increment returns the integer incremented by one.
func (i *Int) Increment() *Int <span class="cov8" title="1">{
        return i.Add(Z().One())
}</span>

// Decrement returns the integer decremented by one.
func (i *Int) Decrement() *Int <span class="cov8" title="1">{
        return i.Sub(Z().One())
}</span>

// Rat converts the integer to a rational number.
func (i *Int) Rat() *Rat <span class="cov8" title="1">{
        return &amp;Rat{a: i.Clone(), b: NPlus().One()}
}</span>

// Bytes returns the byte representation of the integer.
func (i *Int) Bytes() []byte <span class="cov8" title="1">{
        return i.v.Bytes()
}</span>

// IsEven checks if the integer is even.
func (i *Int) IsEven() bool <span class="cov8" title="1">{
        return i.v.IsEven() == ct.True
}</span>

// IsOdd checks if the integer is odd.
func (i *Int) IsOdd() bool <span class="cov8" title="1">{
        return i.v.IsOdd() == ct.True
}</span>

// Big converts the integer to a big.Int.
func (i *Int) Big() *big.Int <span class="cov8" title="1">{
        return i.v.Big()
}</span>

// Lift returns a copy of the integer (identity function for integers).
func (i *Int) Lift() *Int <span class="cov8" title="1">{
        return i.Clone()
}</span>

// Cardinal returns the cardinality of the absolute value of the integer.
func (i *Int) Cardinal() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.NewFromNumeric(i.Abs())
}</span>

// TrueLen returns the true length of the integer in bytes.
func (i *Int) TrueLen() int <span class="cov8" title="1">{
        return i.v.TrueLen()
}</span>

// AnnouncedLen returns the announced length of the integer in bytes.
func (i *Int) AnnouncedLen() int <span class="cov8" title="1">{
        return i.v.AnnouncedLen()
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">package num

import (
        "fmt"
        "io"
        "math/big"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

// NewZMod creates a new ZMod structure given a modulus NatPlus.
func NewZMod(modulus *NatPlus) (*ZMod, error) <span class="cov8" title="1">{
        if modulus == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;ZMod{n: modulus.cacheMont(nil)}, nil</span>
}

// NewZModFromCardinal creates a new ZMod structure given a cardinal.
func NewZModFromCardinal(n cardinal.Cardinal) (*ZMod, error) <span class="cov8" title="1">{
        nn, err := NPlus().FromCardinal(n)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">nn.cacheMont(nil)
        return &amp;ZMod{n: nn}, nil</span>
}

// NewZModFromModulus creates a new ZMod structure given a modulus Modulus.
func NewZModFromModulus(m *numct.Modulus) (*ZMod, error) <span class="cov0" title="0">{
        if m.Nat() == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return &amp;ZMod{n: NPlus().FromModulusCT(m)}, nil</span>
}

// NewUintGivenModulus creates a new Uint element given a value Nat and a modulus Modulus.
func NewUintGivenModulus(value *numct.Nat, m *numct.Modulus) (*Uint, error) <span class="cov0" title="0">{
        if m.Nat() == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov0" title="0">if value == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov0" title="0">if m.IsInRange(value) == ct.False </span><span class="cov0" title="0">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return &amp;Uint{v: value.Clone(), m: m}, nil</span>
}

// ZMod represents the integers modulo n.
type ZMod struct {
        n *NatPlus
}

// Name returns the name of the structure.
func (zn *ZMod) Name() string <span class="cov8" title="1">{
        return fmt.Sprintf("Z\\%sZ", zn.n.String())
}</span>

// Order returns the order of the group.
func (zn *ZMod) Order() cardinal.Cardinal <span class="cov8" title="1">{
        return zn.n.Cardinal()
}</span>

// Characteristic returns the characteristic of the group.
func (zn *ZMod) Characteristic() cardinal.Cardinal <span class="cov8" title="1">{
        return zn.n.Cardinal()
}</span>

// Modulus returns the modulus NatPlus of the group.
func (zn *ZMod) Modulus() *NatPlus <span class="cov8" title="1">{
        return zn.n
}</span>

func (zn *ZMod) ModulusCT() *numct.Modulus <span class="cov0" title="0">{
        return zn.n.ModulusCT()
}</span>

// ElementSize returns the size in bytes of an element.
func (zn *ZMod) ElementSize() int <span class="cov8" title="1">{
        return zn.n.AnnouncedLen()
}</span>

// WideElementSize returns the size in bytes of a wide element.
func (zn *ZMod) WideElementSize() int <span class="cov8" title="1">{
        return 2 * zn.ElementSize()
}</span>

// Bottom returns the bottom element of the group.
func (zn *ZMod) Bottom() *Uint <span class="cov8" title="1">{
        return zn.Zero()
}</span>

// FromUint64 creates a Uint element from a uint64 value.
func (zn *ZMod) FromUint64(value uint64) *Uint <span class="cov8" title="1">{
        return errs2.Must1(zn.FromNat(N().FromUint64(value)))
}</span>

// FromInt64 creates a Uint element from an int64 value.
func (zn *ZMod) FromInt64(value int64) (*Uint, error) <span class="cov8" title="1">{
        return zn.FromInt(Z().FromInt64(value))
}</span>

// FromInt creates a Uint element from an Int value.
// It will reduce the Int modulo the modulus of the ZMod.
func (zn *ZMod) FromInt(v *Int) (*Uint, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return v.Mod(zn.n), nil</span>
}

// FromRat creates a Uint element from a Rat value.
// It will reduce the Rat modulo the modulus of the ZMod.
func (zn *ZMod) FromRat(v *Rat) (*Uint, error) <span class="cov8" title="1">{
        vInt, err := Z().FromRat(v)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return zn.FromInt(vInt)</span>
}

// FromBytes creates a Uint element from a byte slice.
// It will NOT reduce the value modulo the modulus, and will return an error if the value is out of range.
func (zn *ZMod) FromBytes(input []byte) (*Uint, error) <span class="cov8" title="1">{
        v, err := N().FromBytes(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return zn.FromNatCTReduced(v.Value())</span>
}

// FromBytesBE creates a Uint element from a big-endian byte slice.
// It will NOT reduce the value modulo the modulus, and will return an error if the value is out of range.
func (zn *ZMod) FromBytesBE(input []byte) (*Uint, error) <span class="cov8" title="1">{
        return zn.FromBytes(input)
}</span>

// FromBytesBEReduce creates a Uint element from a big-endian byte slice, reducing it modulo the modulus.
// It will reduce the value modulo the modulus of the ZMod.
func (zn *ZMod) FromBytesBEReduce(input []byte) (*Uint, error) <span class="cov8" title="1">{
        v, err := N().FromBytes(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return zn.FromNatCT(v.Value())</span>
}

// FromNat creates a Uint element from a Nat value.
// It will reduce the value modulo the modulus of the ZMod.
func (zn *ZMod) FromNat(v *Nat) (*Uint, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return v.Mod(zn.n), nil</span>
}

// FromNatCT creates a Uint element from a numct.Nat value.
// It will reduce the value modulo the modulus.
func (zn *ZMod) FromNatCT(v *numct.Nat) (*Uint, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return (&amp;Nat{v: v}).Mod(zn.n), nil</span>
}

// FromNatCTReduced creates a Uint element from a reduced numct.Nat value.
// It will NOT reduce the value modulo the modulus, and will return an error if the value is out of range.
func (zn *ZMod) FromNatCTReduced(reducedV *numct.Nat) (*Uint, error) <span class="cov8" title="1">{
        if reducedV == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if zn.n.m.IsInRange(reducedV) == ct.False </span><span class="cov8" title="1">{
                return nil, ErrOutOfRange.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;Uint{v: reducedV.Clone(), m: zn.n.m}, nil</span>
}

// FromNatPlus creates a Uint element from a NatPlus value.
// It will reduce the value modulo the modulus of the ZMod.
func (zn *ZMod) FromNatPlus(v *NatPlus) (*Uint, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return v.Mod(zn.n), nil</span>
}

// FromCardinal creates a Uint element from a cardinal.
// It will NOT reduce the value modulo the modulus, and will return an error if the value is out of range.
func (zn *ZMod) FromCardinal(v cardinal.Cardinal) (*Uint, error) <span class="cov8" title="1">{
        return zn.FromBytes(v.Bytes())
}</span>

// FromBig creates a Uint element from a big.Int value.
// It will reduce the value modulo the modulus of the ZMod.
func (zn *ZMod) FromBig(v *big.Int) (*Uint, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">z, err := Z().FromBig(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return zn.FromInt(z)</span>
}

// OpIdentity returns the additive identity element of the group.
func (zn *ZMod) OpIdentity() *Uint <span class="cov8" title="1">{
        return zn.Zero()
}</span>

// Zero returns the zero element of the group.
func (zn *ZMod) Zero() *Uint <span class="cov8" title="1">{
        return &amp;Uint{v: numct.NatZero(), m: zn.n.m}
}</span>

// One returns the one element of the group.
func (zn *ZMod) One() *Uint <span class="cov8" title="1">{
        return &amp;Uint{v: numct.NatOne(), m: zn.n.m}
}</span>

// Top returns the top element of the group.
func (zn *ZMod) Top() *Uint <span class="cov8" title="1">{
        out, err := zn.n.Decrement()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;Uint{v: out.v, m: zn.n.m}</span>
}

// Random samples a random element from the group using the provided PRNG.
func (zn *ZMod) Random(prng io.Reader) (*Uint, error) <span class="cov8" title="1">{
        out, err := zn.n.m.Random(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Uint{v: out, m: zn.n.m}, nil</span>
}

// Hash hashes the input byte slice to an element of the group.
func (zn *ZMod) Hash(input []byte) (*Uint, error) <span class="cov8" title="1">{
        xof, err := blake2b.NewXOF(uint32(zn.WideElementSize()), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if _, err := xof.Write(input); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">digest := make([]byte, zn.WideElementSize())
        if _, err = io.ReadFull(xof, digest); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">x := new(numct.Nat)
        if ok := x.SetBytes(digest); ok == ct.False </span><span class="cov0" title="0">{
                return nil, errs2.New("failed to interpret hash digest as Nat")
        }</span>
        <span class="cov8" title="1">v := new(numct.Nat)
        // Perform modular reduction using the modulus from n
        zn.n.m.Mod(v, x)
        return &amp;Uint{v: v, m: zn.n.m}, nil</span>
}

// IsInRange checks if a Nat value is in the range of the group.
func (zn *ZMod) IsInRange(v *Nat) bool <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                panic(ErrIsNil.WithStackFrame())</span>
        }
        <span class="cov8" title="1">return zn.n.m.IsInRange(v.v) == ct.True</span>
}

// IsDomain checks if the group is a domain (i.e., if the modulus is probably prime).
func (zn *ZMod) IsDomain() bool <span class="cov8" title="1">{
        return zn.Modulus().Lift().IsProbablyPrime()
}</span>

// ScalarStructure returns the scalar structure of the group.
func (*ZMod) ScalarStructure() algebra.Structure[*Nat] <span class="cov8" title="1">{
        return N()
}</span>

// AmbientStructure returns the ambient structure of quotient group ie. Z.
func (*ZMod) AmbientStructure() algebra.Structure[*Int] <span class="cov8" title="1">{ //nolint:staticcheck // false positive.
        return Z()
}</span>

// Uint represents an integer modulo n.
type Uint struct {
        v *numct.Nat
        m *numct.Modulus
}

func (u *Uint) isValid(x *Uint) (*Uint, error) <span class="cov8" title="1">{
        if x == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if x.m.Nat().Equal(u.m.Nat()) == ct.False </span><span class="cov8" title="1">{
                return nil, ErrUnequalModuli.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return x, nil</span>
}

// Group returns the ZMod structure that this Uint belongs to.
func (u *Uint) Group() *ZMod <span class="cov8" title="1">{
        return &amp;ZMod{
                n: NPlus().FromModulusCT(u.m),
        }
}</span>

// Value returns the underlying numct.Nat value of the Uint.
func (u *Uint) Value() *numct.Nat <span class="cov8" title="1">{
        return u.v
}</span>

// Structure returns the algebraic structure of the Uint.
func (u *Uint) Structure() algebra.Structure[*Uint] <span class="cov8" title="1">{
        return u.Group()
}</span>

// Op performs the group operation (addition) on two Uint elements.
func (u *Uint) Op(other *Uint) *Uint <span class="cov8" title="1">{
        return u.Add(other)
}</span>

// OtherOp performs the other group operation (multiplication) on two Uint elements.
func (u *Uint) OtherOp(other *Uint) *Uint <span class="cov8" title="1">{
        return u.Mul(other)
}</span>

// IsNegative checks the Uint would have been wrapped around if interpreted as an element of in [-n/2, n/2).
func (u *Uint) IsNegative() bool <span class="cov8" title="1">{
        return !u.Lift().IsLessThanOrEqual(u.Modulus().Increment().Rsh(1).Lift())
}</span>

// TryOpInv returns the additive inverse of the Uint element.
func (u *Uint) TryOpInv() (*Uint, error) <span class="cov8" title="1">{
        return u.OpInv(), nil
}</span>

// OpInv returns the additive inverse of the Uint element.
func (u *Uint) OpInv() *Uint <span class="cov8" title="1">{
        return u.Neg()
}</span>

// IsPositive checks if the Uint is non-zero.
func (u *Uint) IsPositive() bool <span class="cov8" title="1">{
        return u.v.IsNonZero() == ct.True
}</span>

// Add performs addition of two Uint elements.
func (u *Uint) Add(other *Uint) *Uint <span class="cov8" title="1">{
        errs2.Must1(u.isValid(other))
        v := new(numct.Nat)
        u.m.ModAdd(v, u.v, other.v)
        return &amp;Uint{v: v, m: u.m}
}</span>

// TrySub performs subtraction of two Uint elements.
func (u *Uint) TrySub(other *Uint) (*Uint, error) <span class="cov8" title="1">{
        return u.Sub(other), nil
}</span>

// Sub performs subtraction of two Uint elements.
func (u *Uint) Sub(other *Uint) *Uint <span class="cov8" title="1">{
        errs2.Must1(u.isValid(other))
        v := new(numct.Nat)
        u.m.ModSub(v, u.v, other.v)
        return &amp;Uint{v: v, m: u.m}
}</span>

// Mul performs multiplication of two Uint elements.
func (u *Uint) Mul(other *Uint) *Uint <span class="cov8" title="1">{
        errs2.Must1(u.isValid(other))
        v := new(numct.Nat)
        u.m.ModMul(v, u.v, other.v)
        return &amp;Uint{v: v, m: u.m}
}</span>

// Lsh performs left shift on the Uint element.
// Lsh is equivalent to multiplying by 2^shift mod modulus.
func (u *Uint) Lsh(shift uint) *Uint <span class="cov8" title="1">{
        return u.Lift().Lsh(shift).Mod(NPlus().FromModulusCT(u.m))
}</span>

// Rsh performs right shift on the Uint element.
// Rsh is equivalent to floor division by 2^shift, then mod modulus.
func (u *Uint) Rsh(shift uint) *Uint <span class="cov8" title="1">{
        return u.Lift().Rsh(shift).Mod(NPlus().FromModulusCT(u.m))
}</span>

// Exp performs exponentiation of the Uint element by a Nat exponent.
func (u *Uint) Exp(exponent *Nat) *Uint <span class="cov8" title="1">{
        if exponent == nil </span><span class="cov0" title="0">{
                panic(ErrIsNil.WithStackFrame())</span>
        }
        <span class="cov8" title="1">v := new(numct.Nat)
        u.m.ModExp(v, u.v, exponent.v)
        return &amp;Uint{v: v, m: u.m}</span>
}

// ExpBounded performs exponentiation of the Uint element by a Nat exponent, using only the lower 'bits' bits of the exponent.
func (u *Uint) ExpBounded(exponent *Nat, bits uint) *Uint <span class="cov8" title="1">{
        if exponent == nil </span><span class="cov0" title="0">{
                panic(ErrIsNil.WithStackFrame())</span>
        }
        <span class="cov8" title="1">boundedExp := exponent.v.Clone()
        boundedExp.Resize(int(bits))
        result := new(numct.Nat)
        u.m.ModExp(result, u.v, boundedExp)
        return &amp;Uint{v: result, m: u.m}</span>
}

// ExpI performs exponentiation of the Uint element by an Int exponent.
func (u *Uint) ExpI(exponent *Int) *Uint <span class="cov8" title="1">{
        if exponent == nil </span><span class="cov0" title="0">{
                panic(ErrIsNil.WithStackFrame())</span>
        }
        <span class="cov8" title="1">v := new(numct.Nat)
        u.m.ModExpI(v, u.v, exponent.v)
        return &amp;Uint{v: v, m: u.m}</span>
}

// ExpIBounded performs exponentiation of the Uint element by an Int exponent, using only the lower 'bits' bits of the exponent.
func (u *Uint) ExpIBounded(exponent *Int, bits uint) *Uint <span class="cov8" title="1">{
        if exponent == nil </span><span class="cov0" title="0">{
                panic(ErrIsNil.WithStackFrame())</span>
        }
        <span class="cov8" title="1">boundedExp := exponent.v.Clone()
        boundedExp.Resize(int(bits))
        result := new(numct.Nat)
        u.m.ModExpI(result, u.v, boundedExp)
        return &amp;Uint{v: result, m: u.m}</span>
}

// IsUnit checks if the Uint element is a unit (i.e., has a multiplicative inverse).
func (u *Uint) IsUnit() bool <span class="cov8" title="1">{
        return u.m.IsUnit(u.v) == ct.True
}</span>

// Coprime checks if the Uint element is coprime to another Uint element.
func (u *Uint) Coprime(other *Uint) bool <span class="cov8" title="1">{
        errs2.Must1(u.isValid(other))
        return u.v.Coprime(other.v) == ct.True
}</span>

// IsProbablyPrime checks if the Uint element is probably prime.
func (u *Uint) IsProbablyPrime() bool <span class="cov8" title="1">{
        return u.v.IsProbablyPrime() == ct.True
}</span>

// EuclideanDiv performs Euclidean division of the Uint element by another Uint element.
func (u *Uint) EuclideanDiv(other *Uint) (quot, rem *Uint, err error) <span class="cov8" title="1">{
        errs2.Must1(u.isValid(other))
        if !u.Group().IsDomain() </span><span class="cov8" title="1">{
                return nil, nil, errs2.New("not a euclidean domain")
        }</span>

        <span class="cov8" title="1">var q, r numct.Nat
        if ok := q.EuclideanDiv(&amp;r, u.v, other.v); ok == ct.False </span><span class="cov8" title="1">{
                return nil, nil, errs2.New("division failed")
        }</span>
        <span class="cov8" title="1">u.m.Mod(&amp;q, &amp;q)
        u.m.Mod(&amp;r, &amp;r)
        return &amp;Uint{v: &amp;q, m: u.m}, &amp;Uint{v: &amp;r, m: u.m}, nil</span>
}

// EuclideanValuation returns the Euclidean valuation of the Uint element.
func (u *Uint) EuclideanValuation() algebra.Cardinal <span class="cov8" title="1">{
        if !u.Group().IsDomain() </span><span class="cov0" title="0">{
                panic(errs2.New("not a euclidean domain"))</span>
        }
        <span class="cov8" title="1">return cardinal.NewFromNumeric(u.v)</span>
}

// TryNeg returns the additive inverse of the Uint element.
func (u *Uint) TryNeg() (*Uint, error) <span class="cov8" title="1">{
        return u.Neg(), nil
}</span>

// TryInv returns the multiplicative inverse of the Uint element.
func (u *Uint) TryInv() (*Uint, error) <span class="cov8" title="1">{
        if !u.IsUnit() </span><span class="cov8" title="1">{
                return nil, errs2.New("not a unit")
        }</span>
        <span class="cov8" title="1">v := new(numct.Nat)
        u.m.ModInv(v, u.v)
        return &amp;Uint{v: v, m: u.m}, nil</span>
}

// TryDiv performs division of the Uint element by another Uint element.
func (u *Uint) TryDiv(other *Uint) (*Uint, error) <span class="cov8" title="1">{
        errs2.Must1(u.isValid(other))
        v := new(numct.Nat)
        if ok := u.m.ModDiv(v, u.v, other.v); ok == ct.False </span><span class="cov8" title="1">{
                return nil, errs2.New("division failed")
        }</span>
        <span class="cov8" title="1">return &amp;Uint{v: v, m: u.m}, nil</span>
}

// Double returns the result of adding the Uint element to itself.
func (u *Uint) Double() *Uint <span class="cov8" title="1">{
        return u.Add(u)
}</span>

// Square returns the result of multiplying the Uint element by itself.
func (u *Uint) Square() *Uint <span class="cov8" title="1">{
        return u.Mul(u)
}</span>

// IsOpIdentity checks if the Uint element is the additive identity.
func (u *Uint) IsOpIdentity() bool <span class="cov8" title="1">{
        return u.IsZero()
}</span>

// IsZero checks if the Uint element is zero.
func (u *Uint) IsZero() bool <span class="cov8" title="1">{
        return u.v.IsZero() == ct.True
}</span>

// IsOne checks if the Uint element is one.
func (u *Uint) IsOne() bool <span class="cov8" title="1">{
        return u.v.IsOne() == ct.True
}</span>

// IsBottom checks if the Uint element is the bottom element.
func (u *Uint) IsBottom() bool <span class="cov8" title="1">{
        return u.IsOne()
}</span>

// IsTop checks if the Uint element is the top element.
func (u *Uint) IsTop() bool <span class="cov8" title="1">{
        v := u.m.Nat()
        v.Decrement()
        return u.v.Equal(v) == ct.True
}</span>

// PartialCompare performs a partial comparison between two Uint elements.
func (u *Uint) PartialCompare(other *Uint) base.PartialOrdering <span class="cov8" title="1">{
        // Check if other is nil first
        if other == nil </span><span class="cov8" title="1">{
                return base.Incomparable
        }</span>
        // Check if they have the same modulus
        <span class="cov8" title="1">comparability := u.m.Nat().Equal(other.m.Nat())
        if comparability == ct.False </span><span class="cov8" title="1">{
                return base.Incomparable
        }</span>
        // If they have the same modulus, compare values
        <span class="cov8" title="1">lt, eq, gt := u.v.Compare(other.v)
        return base.PartialOrdering(-1*int(lt) + 0*int(eq) + 1*int(gt))</span>
}

// Compare performs a total comparison between two Uint elements.
func (u *Uint) Compare(other *Uint) base.Ordering <span class="cov8" title="1">{
        errs2.Must1(u.isValid(other))
        lt, eq, gt := u.v.Compare(other.v)
        return base.Ordering(-1*int(lt) + 0*int(eq) + 1*int(gt))
}</span>

// IsLessThanOrEqual checks if the Uint element is less than or equal to another Uint element.
func (u *Uint) IsLessThanOrEqual(other *Uint) bool <span class="cov8" title="1">{
        errs2.Must1(u.isValid(other))
        lt, eq, _ := u.v.Compare(other.v)
        return lt|eq == ct.True
}</span>

// EqualModulus checks if two Uint elements have the same modulus.
func (u *Uint) EqualModulus(other *Uint) bool <span class="cov8" title="1">{
        _, err := u.isValid(other)
        return err == nil
}</span>

// Equal checks if two Uint elements are equal.
func (u *Uint) Equal(other *Uint) bool <span class="cov8" title="1">{
        _, err := u.isValid(other)
        return err == nil &amp;&amp; u.v.Equal(other.v) == ct.True
}</span>

// IsQuadraticResidue checks if the Uint element is a quadratic residue modulo the modulus.
func (u *Uint) IsQuadraticResidue() bool <span class="cov8" title="1">{
        _, err := u.Sqrt()
        return err == nil
}</span>

// Sqrt computes the square root of the Uint element if it exists.
func (u *Uint) Sqrt() (*Uint, error) <span class="cov8" title="1">{
        v := new(numct.Nat)
        if ok := u.m.ModSqrt(v, u.v); ok == ct.False </span><span class="cov8" title="1">{
                return nil, errs2.New("square root failed")
        }</span>
        <span class="cov8" title="1">return &amp;Uint{v: v, m: u.m}, nil</span>
}

// Neg returns the additive inverse of the Uint element.
func (u *Uint) Neg() *Uint <span class="cov8" title="1">{
        v := new(numct.Nat)
        u.m.ModNeg(v, u.v)
        return &amp;Uint{v: v, m: u.m}
}</span>

// ScalarOp performs scalar multiplication of the Uint element by a Nat scalar.
func (u *Uint) ScalarOp(other *Nat) *Uint <span class="cov8" title="1">{
        return u.ScalarExp(other)
}</span>

// IsTorsionFree checks if the Uint element is torsion-free.
func (*Uint) IsTorsionFree() bool <span class="cov8" title="1">{
        return true
}</span>

// ScalarMul performs scalar multiplication of the Uint element by a Nat scalar.
func (u *Uint) ScalarMul(other *Nat) *Uint <span class="cov8" title="1">{
        out, err := u.Group().FromNat(u.Nat().Mul(other))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return out</span>
}

// ScalarExp performs exponentiation of the Uint element by a Nat scalar.
func (u *Uint) ScalarExp(other *Nat) *Uint <span class="cov8" title="1">{
        return u.Exp(other)
}</span>

// Cardinal returns the cardinality of the Uint element.
func (u *Uint) Cardinal() cardinal.Cardinal <span class="cov8" title="1">{
        return cardinal.NewFromNumeric(u.v)
}</span>

// Clone creates a copy of the Uint element.
func (u *Uint) Clone() *Uint <span class="cov8" title="1">{
        return &amp;Uint{u.v.Clone(), u.m}
}</span>

// Lift lifts the Uint element to an Int element.
func (u *Uint) Lift() *Int <span class="cov8" title="1">{
        out, err := Z().FromUint(u)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return out</span>
}

// HashCode returns a hash code for the Uint element.
func (u *Uint) HashCode() base.HashCode <span class="cov8" title="1">{
        return base.HashCode(u.v.Uint64() % u.m.Nat().Uint64())
}</span>

// Modulus returns the modulus NatPlus of the Uint element.
func (u *Uint) Modulus() *NatPlus <span class="cov8" title="1">{
        out := &amp;NatPlus{v: u.m.Nat(), m: u.m}
        return out
}</span>

// ModulusCT returns the modulus Modulus of the Uint element.
func (u *Uint) ModulusCT() *numct.Modulus <span class="cov8" title="1">{
        return u.m
}</span>

// String returns the string representation of the Uint element.
func (u *Uint) String() string <span class="cov8" title="1">{
        return u.v.String()
}</span>

// Increment increments the Uint element by one.
func (u *Uint) Increment() *Uint <span class="cov8" title="1">{
        return u.Add(u.Group().One())
}</span>

// Decrement decrements the Uint element by one.
func (u *Uint) Decrement() *Uint <span class="cov8" title="1">{
        return u.Sub(u.Group().One())
}</span>

// Bytes returns the byte slice representation of the Uint element.
func (u *Uint) Bytes() []byte <span class="cov8" title="1">{
        return u.v.Bytes()
}</span>

// BytesBE returns the big-endian byte slice representation of the Uint element.
func (u *Uint) BytesBE() []byte <span class="cov8" title="1">{
        return u.Bytes()
}</span>

// Bit returns the i-th bit of the Uint element.
func (u *Uint) Bit(i uint) byte <span class="cov8" title="1">{
        return u.v.Bit(i)
}</span>

// IsEven checks if the Uint element is even.
func (u *Uint) IsEven() bool <span class="cov8" title="1">{
        return u.v.IsEven() == ct.True
}</span>

// IsOdd checks if the Uint element is odd.
func (u *Uint) IsOdd() bool <span class="cov8" title="1">{
        return u.v.IsOdd() == ct.True
}</span>

// Abs returns the absolute value of the Uint element as a Nat.
func (u *Uint) Abs() *Nat <span class="cov8" title="1">{
        return &amp;Nat{v: u.v.Clone()}
}</span>

// Nat returns the Nat representation of the Uint element.
func (u *Uint) Nat() *Nat <span class="cov8" title="1">{
        return &amp;Nat{v: u.v.Clone()}
}</span>

// Big returns the big.Int representation of the Uint element.
func (u *Uint) Big() *big.Int <span class="cov8" title="1">{
        return u.v.Big()
}</span>

// TrueLen returns the true length in bytes of the Uint element.
func (u *Uint) TrueLen() int <span class="cov8" title="1">{
        return u.v.TrueLen()
}</span>

// AnnouncedLen returns the announced length in bytes of the Uint element.
func (u *Uint) AnnouncedLen() int <span class="cov8" title="1">{
        return u.v.AnnouncedLen()
}</span>

// Select sets the Uint element to x0 if choice is true, and to x1 if choice is false.
func (u *Uint) Select(choice ct.Choice, x0, x1 *Uint) <span class="cov8" title="1">{
        u.v.Select(choice&amp;x0.m.Nat().Equal(x1.m.Nat()), x0.v, x1.v)
        u.m = x0.m
}</span>

// CondAssign conditionally assigns the value of x to the Uint element if choice is true.
func (u *Uint) CondAssign(choice ct.Choice, x *Uint) <span class="cov8" title="1">{
        u.v.CondAssign(choice, x.v)
        u.m = x.m
}</span>
</pre>
		
		<pre class="file" id="file155" style="display: none">package numct

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*Nat)(nil)
        _ cbor.Unmarshaler = (*Nat)(nil)
        _ cbor.Marshaler   = (*Int)(nil)
        _ cbor.Unmarshaler = (*Int)(nil)
        _ cbor.Marshaler   = (*Modulus)(nil)
        _ cbor.Unmarshaler = (*Modulus)(nil)
)

type natDTO struct {
        NatBytes []byte `cbor:"natBytes"`
}

func (n *Nat) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;natDTO{NatBytes: n.Bytes()}
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Nat")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (n *Nat) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*natDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">n.SetBytes(dto.NatBytes)
        return nil</span>
}

type intDTO struct {
        IntBytes []byte `cbor:"intBytes"`
}

func (i *Int) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;intDTO{
                IntBytes: i.Bytes(),
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Int")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (i *Int) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*intDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">i.SetBytes(dto.IntBytes)
        return nil</span>
}

type modulusDTO struct {
        N *Nat `cbor:"modulus"`
}

func (m *Modulus) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        serial := &amp;modulusDTO{N: m.Nat()}
        data, err := serde.MarshalCBOR(serial)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal ModulusBasic")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

func (m *Modulus) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        serial, err := serde.UnmarshalCBOR[*modulusDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if serial.N == nil </span><span class="cov0" title="0">{
                return ErrFailed.WithMessage("modulus data is nil")
        }</span>
        <span class="cov8" title="1">if serial.N.IsZero() == ct.True </span><span class="cov0" title="0">{
                return ErrFailed.WithMessage("modulus cannot be zero")
        }</span>
        <span class="cov8" title="1">ok := m.SetNat(serial.N)
        if ok == ct.False </span><span class="cov0" title="0">{
                return ErrFailed.WithMessage("invalid modulus")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

var (
        ErrFailed = errs2.New("failed")
)
</pre>
		
		<pre class="file" id="file156" style="display: none">package numct

import (
        "crypto/subtle"
        "io"
        "math/big"

        "github.com/cronokirby/saferith"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct/internal"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
)

// IntOne returns a new Int set to 1.
func IntOne() *Int <span class="cov8" title="1">{
        return (*Int)(new(saferith.Int).SetUint64(1).Resize(1))
}</span>

// IntZero returns a new Int set to 0.
func IntZero() *Int <span class="cov8" title="1">{
        return (*Int)(new(saferith.Int).SetUint64(0).Resize(1))
}</span>

// NewInt creates a new Int set to the given int64 value.
func NewInt(value int64) *Int <span class="cov8" title="1">{
        n := new(Int)
        n.SetInt64(value)
        return n
}</span>

// NewIntFromUint64 creates a new Int set to the given uint64 value.
func NewIntFromUint64(value uint64) *Int <span class="cov8" title="1">{
        n := new(Int)
        n.SetUint64(value)
        return n
}</span>

// NewIntFromSaferith creates a new Int from a saferith.Int.
func NewIntFromSaferith(n *saferith.Int) *Int <span class="cov0" title="0">{
        return (*Int)(n)
}</span>

// NewIntFromBytes creates a new Int from a big-endian byte slice.
func NewIntFromBytes(b []byte) *Int <span class="cov8" title="1">{
        n := new(Int)
        n.SetBytes(b)
        return n
}</span>

// NewIntFromBig creates a new Int from a big.Int with the given capacity.
func NewIntFromBig(n *big.Int, capacity int) *Int <span class="cov8" title="1">{
        return (*Int)(new(saferith.Int).SetBig(n, capacity))
}</span>

type Int saferith.Int

// Abs sets i = |i|.
func (i *Int) Abs(x *Int) <span class="cov8" title="1">{
        i.Set(x)
        (*saferith.Int)(i).Neg(saferith.Choice(i.IsNegative()))
}</span>

// Set sets i = v.
func (i *Int) Set(v *Int) <span class="cov8" title="1">{
        (*saferith.Int)(i).SetInt((*saferith.Int)(v))
}</span>

// SetNat sets i = v where v is a Nat.
func (i *Int) SetNat(v *Nat) <span class="cov8" title="1">{
        i.Set((*Int)(new(saferith.Int).SetNat((*saferith.Nat)(v))))
}</span>

// Clone returns a copy of i.
func (i *Int) Clone() *Int <span class="cov8" title="1">{
        return (*Int)((*saferith.Int)(i).Clone())
}</span>

// SetZero sets i = 0.
func (i *Int) SetZero() <span class="cov8" title="1">{
        i.Set(IntZero())
}</span>

// SetOne sets i = 1.
func (i *Int) SetOne() <span class="cov8" title="1">{
        i.Set(IntOne())
}</span>

// Add sets i = lhs + rhs.
func (i *Int) Add(lhs, rhs *Int) <span class="cov8" title="1">{
        i.AddCap(lhs, rhs, -1)
}</span>

// AddCap sets i = lhs + rhs with capacity capacity.
// When capacity &lt; 0, it is set to max(lhs.AnnouncedLen(), rhs.AnnouncedLen()) + 1.
func (i *Int) AddCap(lhs, rhs *Int, capacity int) <span class="cov8" title="1">{
        (*saferith.Int)(i).Add((*saferith.Int)(lhs), (*saferith.Int)(rhs), capacity)
}</span>

// Neg sets i = -x.
func (i *Int) Neg(x *Int) <span class="cov8" title="1">{
        i.Set((*Int)((*saferith.Int)(x.Clone()).Neg(saferith.Choice(1))))
}</span>

// Sub sets i = lhs - rhs.
func (i *Int) Sub(lhs, rhs *Int) <span class="cov8" title="1">{
        i.SubCap(lhs, rhs, -1)
}</span>

// SubCap sets i = lhs - rhs with capacity capacity.
// When capacity &lt; 0, it is set to max(lhs.AnnouncedLen(), rhs.AnnouncedLen()) + 1.
func (i *Int) SubCap(lhs, rhs *Int, capacity int) <span class="cov8" title="1">{
        rhsNeg := rhs.Clone()
        rhsNeg.Neg(rhs)
        i.AddCap(lhs, rhsNeg, capacity)
}</span>

// Mul sets i = lhs * rhs.
func (i *Int) Mul(lhs, rhs *Int) <span class="cov8" title="1">{
        i.MulCap(lhs, rhs, -1)
}</span>

// MulCap sets i = lhs * rhs with capacity capacity.
// When capacity &lt; 0, it is set to lhs.AnnouncedLen() + rhs.AnnouncedLen().
func (i *Int) MulCap(lhs, rhs *Int, capacity int) <span class="cov8" title="1">{
        (*saferith.Int)(i).Mul((*saferith.Int)(lhs), (*saferith.Int)(rhs), capacity)
}</span>

// EuclideanDiv sets n to quotient of numerator / denominator.
// If r is not nil, it will be set it to the remainder.
// It returns ok=1 if the division was successful, ok=0 otherwise (i.e., division by zero).
// The number of bits of the quotient will be numerator.AnnouncedLen() and
// the number of bits of the remainder will be denominator.AnnouncedLen().
func (i *Int) EuclideanDiv(remainder *Nat, numerator, denominator *Int) (ok ct.Bool) <span class="cov8" title="1">{
        var qq, rr, n, d Nat
        n.Abs(numerator)
        d.Abs(denominator)
        ok = qq.EuclideanDiv(&amp;rr, &amp;n, &amp;d)
        sa := numerator.IsNegative()
        sb := denominator.IsNegative()
        z := rr.IsZero()

        var rOut, notR Int
        notR.Set(denominator)
        notR.CondNeg(notR.IsNegative())
        notR.Sub(&amp;notR, rr.Lift())
        rOut.CondAssign(sa.Not(), rr.Lift())
        rOut.CondAssign(sa&amp;z, IntZero())
        rOut.CondAssign(sa&amp;(z^1), &amp;notR)

        var qn, qn1, qa, qan, qOut Int
        qn.Neg(qq.Lift())
        qn1.Sub(&amp;qn, IntOne())
        qa.CondAssign(sa.Not(), qq.Lift())
        qa.CondAssign(sa&amp;z, &amp;qn)
        qa.CondAssign(sa&amp;z.Not(), &amp;qn1)
        qan.Neg(&amp;qa)
        qOut.CondAssign(sb, &amp;qan)
        qOut.CondAssign(sb.Not(), &amp;qa)
        qOut.Resize(numerator.AnnouncedLen())
        i.CondAssign(ok, &amp;qOut)

        if remainder != nil </span><span class="cov8" title="1">{
                var rOutAbs Nat
                rOutAbs.Abs(&amp;rOut)
                rOutAbs.Resize(denominator.AnnouncedLen())
                remainder.CondAssign(ok, &amp;rOutAbs)
        }</span>

        <span class="cov8" title="1">return ok</span>
}

// EuclideanDivVarTime sets n to quotient of numerator / denominator.
// If r is not nil, it will be set it to the remainder.
// It returns ok=1 if the division was successful, ok=0 otherwise (i.e., division by zero).
// The number of bits of the quotient will be
// min(numerator.AnnouncedLen(), numerator.AnnouncedLen() - denominator.TrueLen() + 2) and
// the number of bits of the remainder will be denominator.AnnouncedLen().
func (i *Int) EuclideanDivVarTime(remainder *Nat, numerator, denominator *Int) (ok ct.Bool) <span class="cov0" title="0">{
        var qq, rr, n, d Nat
        n.Abs(numerator)
        d.Abs(denominator)
        ok = qq.EuclideanDivVarTime(&amp;rr, &amp;n, &amp;d)
        if ok == ct.False </span><span class="cov0" title="0">{
                return ct.False
        }</span>

        <span class="cov0" title="0">sa := numerator.IsNegative()
        sb := denominator.IsNegative()
        z := rr.IsZero()

        var qa Int
        switch </span>{
        case sa == ct.False:<span class="cov0" title="0">
                qa.Set(qq.Lift())</span>
        case (sa &amp; z) != ct.False:<span class="cov0" title="0">
                var qn Int
                qn.Neg(qq.Lift())
                qa.Set(&amp;qn)</span>
        default:<span class="cov0" title="0">
                var qn, qn1 Int
                qn.Neg(qq.Lift())
                qn1.Sub(&amp;qn, IntOne())
                qa.Set(&amp;qn1)</span>
        }

        <span class="cov0" title="0">var qOut Int
        if sb == ct.False </span><span class="cov0" title="0">{
                qOut.Set(&amp;qa)
        }</span> else<span class="cov0" title="0"> {
                var qan Int
                qan.Neg(&amp;qa)
                qOut.Set(&amp;qan)
        }</span>
        <span class="cov0" title="0">i.Set(&amp;qOut)
        i.Resize(min(numerator.AnnouncedLen(), numerator.AnnouncedLen()-denominator.TrueLen()+2))

        if remainder != nil </span><span class="cov0" title="0">{
                var rOut Int
                switch </span>{
                case sa == ct.False:<span class="cov0" title="0">
                        rOut.Set(rr.Lift())</span>
                case (sa &amp; z) != ct.False:<span class="cov0" title="0">
                        rOut.Set(IntZero())</span>
                default:<span class="cov0" title="0">
                        var notR Int
                        notR.SetNat(&amp;d)
                        notR.Sub(&amp;notR, rr.Lift())
                        rOut.Set(&amp;notR)</span>
                }
                <span class="cov0" title="0">remainder.Abs(&amp;rOut)
                remainder.Resize(denominator.TrueLen())</span>
        }

        <span class="cov0" title="0">return ct.True</span>
}

// Div sets n = numerator / denominator.
// If r is not nil, it will be set it to the remainder.
// It returns ok=1 if the division was successful, ok=0 otherwise (i.e., division by zero).
// The number of bits of the quotient will be numerator.AnnouncedLen() and
// the number of bits of the remainder will be denominator.AnnouncedLen().
func (i *Int) Div(remainder, numerator, denominator *Int) ct.Bool <span class="cov8" title="1">{
        ok := denominator.IsNonZero()
        ns := ((*saferith.Int)(numerator)).IsNegative()
        ds := ((*saferith.Int)(denominator)).IsNegative()
        qs := ns ^ ds
        rs := ns

        var q, r saferith.Nat
        nAbs := ((*saferith.Int)(numerator)).Abs()
        dAbs := ((*saferith.Int)(denominator)).Abs()
        _, _ = internal.EuclideanDiv(&amp;q, &amp;r, nAbs, dAbs)
        var qInt saferith.Int
        qInt.SetNat(&amp;q)
        qInt.Neg(qs)
        qInt.Resize(numerator.AnnouncedLen())
        i.CondAssign(ok, (*Int)(&amp;qInt))

        if remainder != nil </span><span class="cov8" title="1">{
                var rInt saferith.Int
                rInt.SetNat(&amp;r)
                rInt.Neg(rs)
                rInt.Resize(denominator.AnnouncedLen())
                remainder.CondAssign(ok, (*Int)(&amp;rInt))
        }</span>

        <span class="cov8" title="1">return ok</span>
}

// DivVarTime sets n to quotient of numerator / denominator.
// If r is not nil, it will be set it to the remainder.
// It returns ok=1 if the division was successful, ok=0 otherwise (i.e., division by zero).
// The number of bits of the quotient will be
// min(numerator.AnnouncedLen(), numerator.AnnouncedLen() - denominator.TrueLen() + 2) and
// the number of bits of the remainder will be denominator.AnnouncedLen().
func (i *Int) DivVarTime(remainder, numerator, denominator *Int) (ok ct.Bool) <span class="cov8" title="1">{
        if denominator.IsNonZero() == ct.False </span><span class="cov8" title="1">{
                return ct.False
        }</span>

        <span class="cov8" title="1">ns := ((*saferith.Int)(numerator)).IsNegative()
        ds := ((*saferith.Int)(denominator)).IsNegative()
        qs := ns ^ ds
        rs := ns

        var q, r saferith.Nat
        nAbs := ((*saferith.Int)(numerator)).Abs()
        dAbs := ((*saferith.Int)(denominator)).Abs()
        _ = ((*Nat)(&amp;q)).EuclideanDivVarTime((*Nat)(&amp;r), (*Nat)(nAbs), (*Nat)(dAbs))
        var qInt saferith.Int
        qInt.SetNat(&amp;q)
        qInt.Neg(qs)
        qInt.Resize(min(numerator.AnnouncedLen(), numerator.AnnouncedLen()-denominator.TrueLen()+2))
        i.Set((*Int)(&amp;qInt))

        if remainder != nil </span><span class="cov8" title="1">{
                var rInt saferith.Int
                rInt.SetNat(&amp;r)
                rInt.Neg(rs)
                rInt.Resize(denominator.TrueLen())
                remainder.Set((*Int)(&amp;rInt))
        }</span>

        <span class="cov8" title="1">return ct.True</span>
}

// IsUnit returns true if i is a unit (i.e., 1).
func (i *Int) IsUnit() ct.Bool <span class="cov8" title="1">{
        var n Nat
        n.Abs(i)
        return n.IsOne()
}</span>

// Inv sets i = x^{-1}. It returns ok = false if x is not a unit.
func (i *Int) Inv(x *Int) (ok ct.Bool) <span class="cov8" title="1">{
        ok = x.IsUnit()
        i.CondAssign(ok, x)
        return ok
}</span>

// GCD sets i = gcd(a, b) in Z, always non-negative.
// It is implemented via the constant-time Nat.GCD on |a| and |b|.
func (i *Int) GCD(a, b *Int) <span class="cov8" title="1">{
        if a == nil || b == nil </span><span class="cov8" title="1">{
                panic("numct.Int.GCD: nil input")</span>
        }

        // Work with absolute values; gcd in Z is always taken as non-negative.
        <span class="cov8" title="1">var an, bn Nat
        an.Abs(a)
        bn.Abs(b)

        var g Nat
        g.GCD(&amp;an, &amp;bn)
        i.SetNat(&amp;g)</span>
}

// Double sets i = 2 * x.
func (i *Int) Double(x *Int) <span class="cov8" title="1">{
        i.Add(x, x)
}</span>

// IsNegative returns 1 if i is negative.
func (i *Int) IsNegative() ct.Bool <span class="cov8" title="1">{
        return ct.Bool((*saferith.Int)(i).IsNegative())
}</span>

// IsZero returns 1 if i == 0.
func (i *Int) IsZero() ct.Bool <span class="cov8" title="1">{
        var n Nat
        n.Abs(i)
        return n.IsZero()
}</span>

// IsNonZero returns 1 if i != 0.
func (i *Int) IsNonZero() ct.Bool <span class="cov8" title="1">{
        return i.IsZero().Not()
}</span>

// IsOne returns 1 if i == 1.
func (i *Int) IsOne() ct.Bool <span class="cov8" title="1">{
        return i.Equal(IntOne())
}</span>

// Sqrt sets i = sqrt(x) if x is a perfect square, else leaves i unchanged.
// Returns ok = 1 if x is a perfect square.
func (i *Int) Sqrt(x *Int) (ok ct.Bool) <span class="cov8" title="1">{
        // Constant-time (w.r.t. announced capacity) integer square root.
        // Work on |x| and assign only if |x| is a perfect square.

        var inNat, outNat Nat
        inNat.Abs(x)
        ok = outNat.Sqrt(&amp;inNat)

        // Negative numbers are never perfect squares in Z.
        ok &amp;= x.IsNegative().Not()

        var out Int
        out.SetNat(&amp;outNat)

        i.CondAssign(ok, &amp;out)

        return ok
}</span>

// Square sets i = x^2.
func (i *Int) Square(x *Int) <span class="cov8" title="1">{
        i.Mul(x, x)
}</span>

//// Bit returns the value of the bit at the given index.
// func (i *Int) Bit(index uint) byte {
//        return i.Absed().Bit(index)
// }.

// Bytes returns a sign-magnitude encoding:
//
//        b[0] = 0 if i &gt;= 0, 1 if i &lt; 0
//        b[1:] = big-endian |i|
func (i *Int) Bytes() []byte <span class="cov8" title="1">{
        return errs2.Must1((*saferith.Int)(i).MarshalBinary())
}</span>

// SetBytes expects the sign-magnitude encoding produced by Bytes/BytesBE:
//
//        b[0] = 0 for &gt;=0, 1 for &lt;0
//        b[1:] = big-endian |i|
//
// Returns ok = 0 only for obviously malformed input (empty slice).
func (i *Int) SetBytes(b []byte) (ok ct.Bool) <span class="cov8" title="1">{
        err := (*saferith.Int)(i).UnmarshalBinary(b)
        return utils.BoolTo[ct.Bool](err == nil)
}</span>

// SetTwosComplementBEBytes sets i from the two's-complement big-endian byte representation.
func (i *Int) SetTwosComplementBEBytes(b []byte) <span class="cov8" title="1">{
        sign := b[0] &gt;&gt; 7
        notBytes := make([]byte, len(b))
        ct.NotBytes(notBytes, b)
        natBytes := make([]byte, len(b))
        subtle.ConstantTimeCopy(int(sign), natBytes, notBytes)
        subtle.ConstantTimeCopy(int(sign^0b1), natBytes, b)
        var nat saferith.Nat
        // Use len(b)*8 capacity to handle edge case where magnitude needs full width
        // (e.g., min int64 = -2^63 has magnitude 2^63 which needs 64 bits)
        nat.SetBytes(natBytes).Resize(len(b) * 8)
        nat.Add(&amp;nat, new(saferith.Nat).SetUint64(uint64(sign)), len(b)*8)
        (*saferith.Int)(i).SetNat(&amp;nat)
        (*saferith.Int)(i).Neg(saferith.Choice(sign))
}</span>

// Increment sets i = i + 1.
func (i *Int) Increment() <span class="cov8" title="1">{
        i.Add(i, IntOne())
}</span>

// Decrement sets i = i - 1.
func (i *Int) Decrement() <span class="cov8" title="1">{
        i.Sub(i, IntOne())
}</span>

// Lsh sets i = x &lt;&lt; shift.
func (i *Int) Lsh(x *Int, shift uint) <span class="cov8" title="1">{
        i.LshCap(x, shift, -1)
}</span>

// LshCap sets i = x &lt;&lt; shift with given capacity.
func (i *Int) LshCap(x *Int, shift uint, capacity int) <span class="cov8" title="1">{
        xAbs := (*saferith.Int)(x).Abs()
        xSign := (*saferith.Int)(x).IsNegative()
        xAbs.Lsh(xAbs, shift, capacity)
        (*saferith.Int)(i).SetNat(xAbs)
        // Preserve sign
        (*saferith.Int)(i).Neg(xSign)
}</span>

// Rsh sets i = x &gt;&gt; shift.
func (i *Int) Rsh(x *Int, shift uint) <span class="cov8" title="1">{
        i.RshCap(x, shift, -1)
}</span>

// RshCap sets i = x &gt;&gt; shift with given capacity.
// if capacity &lt; 0, capacity will be x.AnnouncedLen() - shift.
func (i *Int) RshCap(x *Int, shift uint, capacity int) <span class="cov8" title="1">{
        xAbs := (*saferith.Int)(x).Abs()
        xSign := (*saferith.Int)(x).IsNegative()
        xAbs.Rsh(xAbs, shift, capacity)
        (*saferith.Int)(i).SetNat(xAbs)
        // Preserve sign
        (*saferith.Int)(i).Neg(xSign)
}</span>

// Resize resizes i to have the given capacity.
// When capacity &lt; 0, use the current announced length
// When capacity &gt;= 0, use the provided capacity.
func (i *Int) Resize(capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov0" title="0">{
                capacity = i.AnnouncedLen()
        }</span>

        <span class="cov8" title="1">(*saferith.Int)(i).Resize(capacity)</span>
}

// Coprime returns 1 if gcd(|i|, |rhs|) == 1.
func (i *Int) Coprime(rhs *Int) ct.Bool <span class="cov8" title="1">{
        var iNat, rhsNat Nat
        iNat.Abs(i)
        rhsNat.Abs(rhs)
        return iNat.Coprime(&amp;rhsNat)
}</span>

// IsProbablyPrime returns 1 if i is probably prime and non-negative.
func (i *Int) IsProbablyPrime() ct.Bool <span class="cov8" title="1">{
        var iNat Nat
        iNat.Abs(i)
        return iNat.IsProbablyPrime() &amp; i.IsNegative().Not()
}</span>

// Select sets i = x0 if choice == 0, or i = x1 if choice == 1,
// using only arithmetic on Int (no ct slice helpers).
func (i *Int) Select(choice ct.Choice, x0, x1 *Int) <span class="cov8" title="1">{
        var abs saferith.Nat
        abs.CondAssign(saferith.Choice(choice.Not()), (*saferith.Int)(x0).Abs())
        abs.CondAssign(saferith.Choice(choice), (*saferith.Int)(x1).Abs())
        sign := ct.CSelectInt(choice, (*saferith.Int)(x0).IsNegative(), (*saferith.Int)(x1).IsNegative())

        (*saferith.Int)(i).SetNat(&amp;abs)
        (*saferith.Int)(i).Neg(sign)
}</span>

// CondAssign sets i = x iff choice == 1, otherwise leaves i unchanged.
func (i *Int) CondAssign(choice ct.Choice, x *Int) <span class="cov8" title="1">{
        i.Select(choice, i, x)
}</span>

// CondNeg negates i iff choice == 1.
func (i *Int) CondNeg(choice ct.Choice) <span class="cov8" title="1">{
        (*saferith.Int)(i).Neg(saferith.Choice(choice))
}</span>

// Equal returns 1 if i == rhs.
func (i *Int) Equal(rhs *Int) ct.Bool <span class="cov8" title="1">{
        return ct.Bool((*saferith.Int)(i).Eq((*saferith.Int)(rhs)))
}</span>

// Compare compares i and rhs and returns (lt, eq, gt) where each is 1 or 0.
func (i *Int) Compare(rhs *Int) (lt, eq, gt ct.Bool) <span class="cov8" title="1">{
        // Sign bits (0/1).
        aNeg := i.IsNegative()
        bNeg := rhs.IsNegative()

        // Magnitude comparison on |i|, |rhs|.
        var iAbs, rhsAbs Nat
        iAbs.Abs(i)
        rhsAbs.Abs(rhs)
        ltM, eqM, gtM := iAbs.Compare(&amp;rhsAbs)

        // sameSign = 1 iff signs are equal, diffSign = 1 iff they differ.
        sameSign := (aNeg ^ bNeg).Not()
        diffSign := sameSign.Not()

        // bothNeg = 1 iff both are negative.
        bothNeg := sameSign &amp; aNeg

        // If same sign:
        //   - both non-negative: ordering = magnitude ordering
        //   - both negative:     ordering = reversed magnitude ordering
        //
        // ltSame = (bothNeg ? gtM : ltM)
        // gtSame = (bothNeg ? ltM : gtM)
        ltSame := ct.CSelectInt(bothNeg, ltM, gtM)
        gtSame := ct.CSelectInt(bothNeg, gtM, ltM)

        // Only use these when signs match.
        ltSame &amp;= sameSign
        gtSame &amp;= sameSign
        eqSame := sameSign &amp; eqM

        // If different signs, negative &lt; non-negative.
        ltDiff := diffSign &amp; aNeg
        gtDiff := diffSign &amp; bNeg

        lt = ltSame | ltDiff
        gt = gtSame | gtDiff
        eq = eqSame
        return lt, eq, gt
}</span>

// Uint64 returns the absolute value of i as a uint64.
func (i *Int) Uint64() uint64 <span class="cov8" title="1">{
        var iAbs Nat
        iAbs.Abs(i)
        return iAbs.Uint64()
}</span>

// SetUint64 sets i = x.
func (i *Int) SetUint64(x uint64) <span class="cov8" title="1">{
        (*saferith.Int)(i).SetUint64(x)
}</span>

// Int64 returns the int64 value of i.
func (i *Int) Int64() int64 <span class="cov8" title="1">{
        var iAbs Nat
        iAbs.Abs(i)
        abs := int64(iAbs.Uint64())
        return ct.CSelectInt(i.IsNegative(), abs, -abs)
}</span>

// SetInt64 sets i = x.
func (i *Int) SetInt64(x int64) <span class="cov8" title="1">{
        ux := uint64(x)

        // mask = 0x000...0 if x &gt;= 0, 0xFFF...F if x &lt; 0
        mask := uint64(x &gt;&gt; 63)

        // mag = |x| as uint64, safe for MinInt64:
        //   x &gt;= 0: mask = 0          =&gt; (ux ^ 0)      - 0      = ux
        //   x &lt; 0 : mask = 0xFFFF..FF =&gt; (ux ^ mask)   - mask   = (~ux) + 1
        mag := (ux ^ mask) - mask

        (*saferith.Int)(i).SetUint64(mag)

        // sign bit = 1 iff x &lt; 0, else 0
        signBit := mask &amp; 1
        // Use 64 bits to accommodate MinInt64 which has magnitude 2^63
        (*saferith.Int)(i).Neg(saferith.Choice(signBit)).Resize(64)
}</span>

// TrueLen returns the exact number of bits required to represent i.
func (i *Int) TrueLen() int <span class="cov8" title="1">{
        return (*saferith.Int)(i).TrueLen()
}</span>

// AnnouncedLen returns the announced length in bits of i. Safe to be used publicly.
func (i *Int) AnnouncedLen() int <span class="cov8" title="1">{
        return (*saferith.Int)(i).AnnouncedLen()
}</span>

// IsOdd returns 1 if i is odd.
func (i *Int) IsOdd() ct.Bool <span class="cov8" title="1">{
        var iAbs Nat
        iAbs.Abs(i)
        return iAbs.IsOdd()
}</span>

// IsEven returns 1 if i is even.
func (i *Int) IsEven() ct.Bool <span class="cov8" title="1">{
        return i.IsOdd().Not()
}</span>

// String returns the hex string representation of i.
func (i *Int) String() string <span class="cov8" title="1">{
        return (*saferith.Int)(i).String()
}</span>

// HashCode returns a hash code for i.
func (i *Int) HashCode() base.HashCode <span class="cov8" title="1">{
        return base.DeriveHashCode(i.Bytes())
}</span>

// Big returns a big.Int representation of i.
func (i *Int) Big() *big.Int <span class="cov8" title="1">{
        return (*saferith.Int)(i).Big()
}</span>

// And sets i = x &amp; y.
// For signed integers, this operates on the two's complement representation.
func (i *Int) And(x, y *Int) <span class="cov8" title="1">{
        i.AndCap(x, y, -1)
}</span>

// AndCap sets i = x &amp; y with capacity capacity.
// For signed integers, this operates on the two's-complement representation.
func (i *Int) AndCap(x, y *Int, capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov8" title="1">{
                capacity = max(x.AnnouncedLen(), y.AnnouncedLen())
        }</span>

        <span class="cov8" title="1">var xClone, yClone Int
        xClone.Set(x)
        xClone.Resize(capacity)
        yClone.Set(y)
        yClone.Resize(capacity)

        xBytes := xClone.TwosComplementBEBytes()
        yBytes := yClone.TwosComplementBEBytes()
        zBytes := make([]byte, len(xBytes))
        ct.AndBytes(zBytes, xBytes, yBytes)
        i.SetTwosComplementBEBytes(zBytes)</span>
}

// Or sets i = x | y.
// For signed integers, this operates on the two's complement representation.
func (i *Int) Or(x, y *Int) <span class="cov8" title="1">{
        i.OrCap(x, y, -1)
}</span>

// OrCap sets i = x | y with a given capacity.
func (i *Int) OrCap(x, y *Int, capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov8" title="1">{
                capacity = max(x.AnnouncedLen(), y.AnnouncedLen())
        }</span>

        <span class="cov8" title="1">var xClone, yClone Int
        xClone.Set(x)
        xClone.Resize(capacity)
        yClone.Set(y)
        yClone.Resize(capacity)

        xBytes := xClone.TwosComplementBEBytes()
        yBytes := yClone.TwosComplementBEBytes()
        zBytes := make([]byte, len(xBytes))
        ct.OrBytes(zBytes, xBytes, yBytes)
        i.SetTwosComplementBEBytes(zBytes)</span>
}

// Xor sets i = x ^ y.
// For signed integers, this operates on the two's complement representation.
func (i *Int) Xor(x, y *Int) <span class="cov8" title="1">{
        i.XorCap(x, y, -1)
}</span>

// XorCap sets i = x ^ y with the given capacity.
func (i *Int) XorCap(x, y *Int, capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov8" title="1">{
                capacity = max(x.AnnouncedLen(), y.AnnouncedLen())
        }</span>

        <span class="cov8" title="1">var xClone, yClone Int
        xClone.Set(x)
        xClone.Resize(capacity)
        yClone.Set(y)
        yClone.Resize(capacity)

        xBytes := xClone.TwosComplementBEBytes()
        yBytes := yClone.TwosComplementBEBytes()
        zBytes := make([]byte, len(xBytes))
        ct.XorBytes(zBytes, xBytes, yBytes)
        i.SetTwosComplementBEBytes(zBytes)</span>
        // Don't resize - result may need more bits than inputs
}

// Not sets i = ^x.
// For signed integers, this is equivalent to -(x+1) due to two's complement.
func (i *Int) Not(x *Int) <span class="cov8" title="1">{
        i.NotCap(x, -1)
}</span>

// NotCap sets i = ^x with a given capacity.
// For signed integers, this is equivalent to -(x+1) due to two's complement.
func (i *Int) NotCap(x *Int, capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov8" title="1">{
                capacity = x.AnnouncedLen()
        }</span>

        <span class="cov8" title="1">var xClone Int
        xClone.Set(x)
        xClone.Resize(capacity)

        xBytes := xClone.TwosComplementBEBytes()
        zBytes := make([]byte, len(xBytes))
        ct.NotBytes(zBytes, xBytes)
        i.SetTwosComplementBEBytes(zBytes)</span>
        // Don't resize down - NOT may produce a value that needs more bits
        // (e.g., NOT(2^63-1) = -2^63 needs 64 bits for magnitude)
}

// SetRandomRangeLH sets i to a random integer in [lowInclusive, highExclusive).
func (i *Int) SetRandomRangeLH(lowInclusive, highExclusive *Int, prng io.Reader) error <span class="cov8" title="1">{
        var errs []error
        if lowInclusive == nil </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("lowInclusive must not be nil"))
        }</span>
        <span class="cov8" title="1">if highExclusive == nil </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("highExclusive must not be nil"))
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("prng must not be nil"))
        }</span>
        <span class="cov8" title="1">if lt, _, _ := lowInclusive.Compare(highExclusive); lt == ct.False </span><span class="cov8" title="1">{
                errs = append(errs, ErrInvalidArgument.WithMessage("highExclusive must be greater than lowInclusive"))
        }</span>
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return errs2.Join(errs...)
        }</span>

        // Compute interval = highExclusive - lowInclusive (always positive since low &lt; high)
        <span class="cov8" title="1">var interval Int
        interval.Sub(highExclusive, lowInclusive)

        // Generate random value in [0, interval) using Nat's method
        var intervalAbs, r Nat
        intervalAbs.Abs(&amp;interval)
        err := r.SetRandomRangeH(&amp;intervalAbs, prng)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>

        // Result = lowInclusive + r
        <span class="cov8" title="1">var rInt Int
        rInt.SetNat(&amp;r)
        i.Add(lowInclusive, &amp;rInt)
        return nil</span>
}

// TwosComplementBEBytes returns the two's-complement big-endian byte representation of i.
func (i *Int) TwosComplementBEBytes() []byte <span class="cov8" title="1">{
        // keep extra bit for sign
        capacityBits := i.AnnouncedLen() + 1
        capacityBytes := (capacityBits + 7) / 8

        iSign := (*saferith.Int)(i).IsNegative()
        iAbsBytes := make([]byte, capacityBytes)
        iAbsNotBytes := make([]byte, capacityBytes)
        (*saferith.Int)(i).Abs().FillBytes(iAbsBytes)
        ct.NotBytes(iAbsNotBytes, iAbsBytes)

        natBytes := make([]byte, capacityBytes)
        subtle.ConstantTimeCopy(int(iSign^0b1), natBytes, iAbsBytes)
        subtle.ConstantTimeCopy(int(iSign), natBytes, iAbsNotBytes)
        var nat saferith.Nat
        nat.SetBytes(natBytes)
        nat.Add(&amp;nat, new(saferith.Nat).SetUint64(uint64(iSign)).Resize(1), capacityBytes*8)
        nat.FillBytes(natBytes)
        return natBytes
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">package internal

import (
        "github.com/cronokirby/saferith"
)

func EuclideanDiv(q, r, a, d *saferith.Nat) (quotient, remainder *saferith.Nat) <span class="cov8" title="1">{
        var qq, rr, rt, t saferith.Nat

        for i := a.AnnouncedLen() - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                b := (a.Byte(i/8) &gt;&gt; (i % 8)) &amp; 0b1
                rt.Lsh(&amp;rr, 1, d.AnnouncedLen()+1)
                t.SetUint64(uint64(b)).Resize(1)
                rt.Add(&amp;rt, &amp;t, d.AnnouncedLen()+1)
                t.Sub(&amp;rt, d, d.AnnouncedLen()+1)
                _, _, rtLessThanD := rt.Cmp(d)
                rr.CondAssign(rtLessThanD^0b1, &amp;t)
                rr.CondAssign(rtLessThanD, &amp;rt)
                rr.Resize(d.AnnouncedLen())
                t.SetUint64(uint64(rtLessThanD ^ 0b1)).Resize(1)
                t.Lsh(&amp;t, uint(i), a.AnnouncedLen())
                qq.Add(&amp;qq, &amp;t, a.AnnouncedLen())
        }</span>

        <span class="cov8" title="1">q.SetNat(&amp;qq)
        r.SetNat(&amp;rr)
        return q, r</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">package internal

import "github.com/cronokirby/saferith"

// GCD sets n = gcd(x, y) using a constant-time (w.r.t. announced capacity) binary GCD (Stein) algorithm.
// The result is always non-negative and gcd(0, 0) = 0.
func GCD(g, x, y *saferith.Nat) *saferith.Nat <span class="cov8" title="1">{
        capacity := max(x.AnnouncedLen(), y.AnnouncedLen())

        var u, v, shift saferith.Nat
        u.SetNat(x).Resize(capacity)
        v.SetNat(y).Resize(capacity)
        shift.SetUint64(1).Resize(capacity)

        var t, tu, tv saferith.Nat
        for range 2 * capacity </span><span class="cov8" title="1">{
                uEven := saferith.Choice(u.Byte(0)&amp;0b1) ^ 0b1
                vEven := saferith.Choice(v.Byte(0)&amp;0b1) ^ 0b1
                tu.SetNat(&amp;u)
                tu.Rsh(&amp;tu, 1, capacity)
                u.CondAssign(uEven, &amp;tu)
                tv.SetNat(&amp;v)
                tv.Rsh(&amp;tv, 1, capacity)
                v.CondAssign(vEven, &amp;tv)
                t.SetNat(&amp;shift)
                t.Lsh(&amp;t, 1, capacity)
                shift.CondAssign(uEven&amp;vEven, &amp;t)

                // make v &gt;= u
                t.SetNat(&amp;u)
                uGreaterThanV, _, _ := u.Cmp(&amp;v)
                u.CondAssign(uGreaterThanV, &amp;v)
                v.CondAssign(uGreaterThanV, &amp;t)

                uOdd := saferith.Choice(u.Byte(0) &amp; 0b1)
                vOdd := saferith.Choice(v.Byte(0) &amp; 0b1)
                t.Sub(&amp;v, &amp;u, capacity)
                v.CondAssign(uOdd&amp;vOdd, &amp;t)
        }</span>

        <span class="cov8" title="1">return g.Mul(&amp;v, &amp;shift, capacity)</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">package numct

import (
        crand "crypto/rand"
        "io"
        "math/big"
        "sync"

        "github.com/cronokirby/saferith"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// ModulusBasic is a modulus implementation based on saferith.Modulus.
type ModulusBasic saferith.Modulus

// NewModulus creates a new Modulus from a Nat.
func NewModulusFromBytesBE(input []byte) (modulus *Modulus, ok ct.Bool) <span class="cov8" title="1">{
        n := NewNatFromBytes(input)
        return NewModulus(n)
}</span>

// HashCode returns a hash code for the modulus.
func (m *ModulusBasic) HashCode() base.HashCode <span class="cov8" title="1">{
        return base.DeriveHashCode(m.Bytes())
}</span>

// Random returns a random Nat in [0, m).
func (m *ModulusBasic) Random(prng io.Reader) (*Nat, error) <span class="cov8" title="1">{
        randBig, err := crand.Int(prng, m.Big())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return NewNatFromBig(randBig, m.BitLen()), nil</span>
}

// Big returns the big.Int representation of the modulus.
func (m *ModulusBasic) Big() *big.Int <span class="cov8" title="1">{
        return (*saferith.Modulus)(m).Big()
}</span>

// Saferith returns the underlying saferith.Modulus.
func (m *ModulusBasic) Saferith() *saferith.Modulus <span class="cov8" title="1">{
        return (*saferith.Modulus)(m)
}</span>

// Set sets m = v.
func (m *ModulusBasic) Set(v *ModulusBasic) <span class="cov0" title="0">{
        *m = *v
}</span>

// Mod sets out = x (mod m).
func (m *ModulusBasic) Mod(out, x *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(out).Mod((*saferith.Nat)(x), (*saferith.Modulus)(m))
}</span>

// ModI sets out = x (mod m) where x is an Int.
func (m *ModulusBasic) ModI(out *Nat, x *Int) <span class="cov8" title="1">{
        result := (*saferith.Int)(x).Mod((*saferith.Modulus)(m))
        *out = *(*Nat)(result)
}</span>

// ModSymmetric sets out = x mod m in the symmetric range [-m/2, m/2).
func (m *ModulusBasic) ModSymmetric(out *Int, x *Nat) <span class="cov8" title="1">{
        (*saferith.Int)(out).SetModSymmetric((*saferith.Nat)(x), (*saferith.Modulus)(m))
}</span>

// Quo sets out = x / m.
func (m *ModulusBasic) Quo(out, x *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(out).Div(
                (*saferith.Nat)(x),
                (*saferith.Modulus)(m),
                m.BitLen(),
        )
}</span>

// ModAdd sets out = (x + y) (mod m).
func (m *ModulusBasic) ModAdd(out, x, y *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(out).ModAdd(
                (*saferith.Nat)(x),
                (*saferith.Nat)(y),
                (*saferith.Modulus)(m),
        )
}</span>

// ModSub sets out = (x - y) (mod m).
func (m *ModulusBasic) ModSub(out, x, y *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(out).ModSub(
                (*saferith.Nat)(x),
                (*saferith.Nat)(y),
                (*saferith.Modulus)(m),
        )
}</span>

func (m *ModulusBasic) modDivOdd(out, x, y *Nat) ct.Bool <span class="cov8" title="1">{
        ok := y.IsNonZero()
        var yr Nat
        yr.Select(ok, NatOne(), y)

        // inv = y^{-1} mod m
        var yInv Nat
        m.ModInv(&amp;yInv, &amp;yr)

        // out = x * inv mod m
        var prod Nat
        m.ModMul(&amp;prod, x, &amp;yInv)

        out.Select(ok, out, &amp;prod)
        return ok
}</span>

func (m *ModulusBasic) modDivEven(out, x, y *Nat) ct.Bool <span class="cov8" title="1">{
        // Grab big.Int views
        mBig := m.Big()
        xr := new(big.Int).Mod((*saferith.Nat)(x).Big(), mBig)
        yr := new(big.Int).Mod((*saferith.Nat)(y).Big(), mBig)

        // d = gcd(yr, m), and s,t with s*yr + t*m = d
        var s, t, d big.Int
        d.GCD(&amp;s, &amp;t, yr, mBig)

        // No solution unless d | xr
        if new(big.Int).Mod(xr, &amp;d).Sign() != 0 </span><span class="cov8" title="1">{
                return ct.False
        }</span>

        // Reduce by d
        <span class="cov8" title="1">xprime := new(big.Int).Quo(xr, &amp;d)
        mprime := new(big.Int).Quo(mBig, &amp;d)

        // From s*yr + t*m = d  s*(yr/d)  1 (mod m/d).
        // So s (mod m') is an inverse of y' = yr/d modulo m'.
        s.Mod(&amp;s, mprime)
        if s.Sign() &lt; 0 </span><span class="cov0" title="0">{
                s.Add(&amp;s, mprime)
        }</span>

        // u0 = x' * (y')^{-1} mod m'
        <span class="cov8" title="1">u0 := new(big.Int).Mod(new(big.Int).Mul(xprime, &amp;s), mprime)

        // Encode back
        outNat := new(saferith.Nat).SetBig(u0, u0.BitLen())
        out.Set((*Nat)(outNat))
        return ct.True</span>
}

// ModDiv sets out = x * y^{-1} (mod m).
func (m *ModulusBasic) ModDiv(out, x, y *Nat) ct.Bool <span class="cov8" title="1">{
        if m.Nat().IsOdd() == ct.True </span><span class="cov8" title="1">{
                return m.modDivOdd(out, x, y)
        }</span> else<span class="cov8" title="1"> {
                return m.modDivEven(out, x, y)
        }</span>
}

func (m *ModulusBasic) modInvOdd(out, x *Nat) ct.Bool <span class="cov8" title="1">{
        (*saferith.Nat)(out).ModInverse(
                (*saferith.Nat)(x),
                (*saferith.Modulus)(m),
        )
        var shouldBeOne Nat
        m.ModMul(&amp;shouldBeOne, out, x)
        return shouldBeOne.IsOne()
}</span>

func (m *ModulusBasic) modInvEven(out, x *Nat) ct.Bool <span class="cov8" title="1">{
        ok := x.IsNonZero() &amp; x.Coprime(m.Nat())
        if ok == ct.True </span><span class="cov8" title="1">{
                (*saferith.Nat)(out).SetBig(
                        new(big.Int).ModInverse((*saferith.Nat)(x).Big(), (*saferith.Modulus)(m).Big()),
                        (*saferith.Modulus)(m).BitLen(),
                )
        }</span>
        <span class="cov8" title="1">return ok</span>
}

// ModInv sets out = x^{-1} (mod m).
func (m *ModulusBasic) ModInv(out, x *Nat) ct.Bool <span class="cov8" title="1">{
        if m.Nat().IsOdd() == ct.True </span><span class="cov8" title="1">{
                return m.modInvOdd(out, x)
        }</span> else<span class="cov8" title="1"> {
                return m.modInvEven(out, x)
        }</span>
}

// ModNeg sets out = -x (mod m).
func (m *ModulusBasic) ModNeg(out, x *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(out).ModNeg((*saferith.Nat)(x), (*saferith.Modulus)(m))
}</span>

func (m *ModulusBasic) modSqrtPrime(out, x *Nat) ct.Bool <span class="cov8" title="1">{
        // Reduce x modulo m to avoid mutating caller inputs and ensure range.
        xr := (*Nat)(new(saferith.Nat).Mod((*saferith.Nat)(x), (*saferith.Modulus)(m)))

        root := (*Nat)(new(saferith.Nat).ModSqrt((*saferith.Nat)(xr), (*saferith.Modulus)(m)))

        var rootSquared Nat
        m.ModMul(&amp;rootSquared, root, root)

        ok := rootSquared.Equal(xr)
        out.Select(ok, out, root)
        return ok
}</span>

func (m *ModulusBasic) modSqrtGeneric(out, x *Nat) ct.Bool <span class="cov8" title="1">{
        reducedXBig := new(saferith.Nat).Mod((*saferith.Nat)(x), (*saferith.Modulus)(m)).Big()
        res := new(big.Int).Sqrt(reducedXBig)
        squaredRes := new(big.Int).Mul(res, res)
        if squaredRes.Cmp(reducedXBig) != 0 </span><span class="cov8" title="1">{
                return ct.False
        }</span>
        // Use the modulus bitlen for consistency
        <span class="cov8" title="1">bitlen := (*saferith.Modulus)(m).BitLen()
        out.Set((*Nat)(new(saferith.Nat).SetBig(res, bitlen)))
        return ct.True</span>
}

// ModSqrt sets out = sqrt(x) (mod m) if it exists.
func (m *ModulusBasic) ModSqrt(out, x *Nat) ct.Bool <span class="cov8" title="1">{
        if m.Nat().IsProbablyPrime() == ct.True </span><span class="cov8" title="1">{
                return m.modSqrtPrime(out, x)
        }</span> else<span class="cov8" title="1"> {
                return m.modSqrtGeneric(out, x)
        }</span>
}

func (m *ModulusBasic) modExpOdd(out, b, exp *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(out).Exp(
                (*saferith.Nat)(b),
                (*saferith.Nat)(exp),
                (*saferith.Modulus)(m),
        )
}</span>

func (m *ModulusBasic) modExpEven(out, b *Nat, exp *big.Int) <span class="cov8" title="1">{
        baseBig := (*saferith.Nat)(b).Big()
        modBig := (*saferith.Modulus)(m).Big()

        result := new(big.Int).Exp(baseBig, exp, modBig)
        bitlen := (*saferith.Modulus)(m).BitLen()
        (*saferith.Nat)(out).SetBig(result, bitlen)
}</span>

// ModExp sets out = base^exp (mod m).
func (m *ModulusBasic) ModExp(out, b, exp *Nat) <span class="cov8" title="1">{
        if m.Nat().IsOdd() == ct.True </span><span class="cov8" title="1">{
                m.modExpOdd(out, b, exp)
        }</span> else<span class="cov8" title="1"> {
                // For even moduli (like 2), we can't use Montgomery multiplication
                // Use big.Int instead
                m.modExpEven(out, b, exp.Big())
        }</span>
}

func (m *ModulusBasic) modExpIOdd(out, b *Nat, exp *Int) <span class="cov8" title="1">{
        (*saferith.Nat)(out).ExpI(
                (*saferith.Nat)(b),
                (*saferith.Int)(exp),
                (*saferith.Modulus)(m),
        )
}</span>

// ModExpI sets out = base^exp (mod m) where exp is an Int.
func (m *ModulusBasic) ModExpI(out, b *Nat, exp *Int) <span class="cov8" title="1">{
        if m.Nat().IsOdd() == ct.True </span><span class="cov8" title="1">{
                m.modExpIOdd(out, b, exp)
        }</span> else<span class="cov8" title="1"> {
                // For even moduli (like 2), we can't use Montgomery multiplication
                // Use big.Int instead
                m.modExpEven(out, b, exp.Big())
        }</span>
}

// ModMultiBaseExp sets out[i] = bases[i]^exp (mod m) for all i.
func (m *ModulusBasic) ModMultiBaseExp(out, bases []*Nat, exp *Nat) <span class="cov8" title="1">{
        if len(bases) != len(out) </span><span class="cov0" title="0">{
                panic("len(bases) != len(out)")</span>
        }
        <span class="cov8" title="1">var wg sync.WaitGroup
        wg.Add(len(bases))
        for i, bi := range bases </span><span class="cov8" title="1">{
                go func(i int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        m.ModExp(out[i], bi, exp)
                }</span>(i)
        }
        <span class="cov8" title="1">wg.Wait()</span>
}

// ModMul sets out = (x * y) (mod m).
func (m *ModulusBasic) ModMul(out, x, y *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(out).ModMul(
                (*saferith.Nat)(x),
                (*saferith.Nat)(y),
                (*saferith.Modulus)(m),
        )
}</span>

// IsInRange returns true if 0 &lt;= x &lt; m.
func (m *ModulusBasic) IsInRange(x *Nat) ct.Bool <span class="cov8" title="1">{
        _, _, lt := (*saferith.Nat)(x).Cmp((*saferith.Modulus)(m).Nat())
        return ct.Bool(lt)
}</span>

// IsInRangeSymmetric returns true if -m/2 &lt;= x &lt; m/2.
func (m *ModulusBasic) IsInRangeSymmetric(x *Int) ct.Bool <span class="cov8" title="1">{
        mod := (*Nat)(((*saferith.Modulus)(m)).Nat()).Lift()
        var x2, modNeg Int
        modNeg.Neg(mod)
        x2.Add(x, x)
        ltn, _, _ := x2.Compare(&amp;modNeg)
        ltp, _, _ := x2.Compare(mod)
        return ltn.Not() &amp; ltp
}</span>

// IsUnit returns true if x is a unit modulo m.
func (m *ModulusBasic) IsUnit(x *Nat) ct.Bool <span class="cov8" title="1">{
        return ct.Bool((*saferith.Nat)(x).IsUnit((*saferith.Modulus)(m)))
}</span>

// BitLen returns the bit length of the modulus.
func (m *ModulusBasic) BitLen() int <span class="cov8" title="1">{
        return (*saferith.Modulus)(m).BitLen()
}</span>

// Nat returns the Nat representation of the modulus.
func (m *ModulusBasic) Nat() *Nat <span class="cov8" title="1">{
        return (*Nat)((*saferith.Modulus)(m).Nat())
}</span>

// SetNat sets m = n where n is a Nat.
func (m *ModulusBasic) SetNat(n *Nat) ct.Bool <span class="cov0" title="0">{
        ok := n.IsNonZero()
        var nn Nat
        nn.Select(ok, NatOne(), n)
        m.Set((*ModulusBasic)(saferith.ModulusFromNat((*saferith.Nat)(&amp;nn))))
        return ok
}</span>

// Bytes returns the big-endian byte representation of the modulus.
func (m *ModulusBasic) Bytes() []byte <span class="cov8" title="1">{
        return (*saferith.Modulus)(m).Bytes()
}</span>

// BytesBE returns the big-endian byte representation of the modulus.
func (m *ModulusBasic) BytesBE() []byte <span class="cov8" title="1">{
        return (*saferith.Modulus)(m).Bytes()
}</span>

// String returns the string representation of the modulus.
func (m *ModulusBasic) String() string <span class="cov8" title="1">{
        return (*saferith.Modulus)(m).String()
}</span>
</pre>
		
		<pre class="file" id="file160" style="display: none">//go:build !purego &amp;&amp; !nobignum

package numct

import (
        "sync"

        "github.com/cronokirby/saferith"

        "github.com/bronlabs/bron-crypto/pkg/base/cgo/boring"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

var bnCtxPool = sync.Pool{
        New: func() any <span class="cov8" title="1">{
                return boring.NewBigNumCtx()
        }</span>,
}

var bnPool = sync.Pool{
        New: func() any <span class="cov8" title="1">{
                return boring.NewBigNum()
        }</span>,
}

// NewModulus creates a new Modulus from a Nat.
// It returns ok = false if m is zero.
// Remarks: it leaks the true length of m.
func NewModulus(m *Nat) (modulus *Modulus, ok ct.Bool) <span class="cov8" title="1">{
        ok = m.IsNonZero()

        defer func() </span><span class="cov8" title="1">{ // saferith panics on zero modulus.
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        ok &amp;= ct.False
                }</span>
        }()

        <span class="cov8" title="1">safeMod := saferith.ModulusFromNat((*saferith.Nat)(m))
        mNum, err := boring.NewBigNum().SetBytes(safeMod.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">var mSub2 Nat
        mSub2.SubCap(m, NewNat(2), -1)
        return &amp;Modulus{ //nolint:exhaustruct // mont is not precomputed here for performance.
                ModulusBasic: (*ModulusBasic)(safeMod),
                mSub2:        &amp;mSub2,
                mNum:         mNum,
                once:         &amp;sync.Once{},
        }, ok</span>
}

// Modulus is a modulus implementation based on BoringSSL's BigNum and saferith.Modulus.
type Modulus struct {
        *ModulusBasic

        mSub2 *Nat
        mNum  *boring.BigNum
        mont  *boring.BigNumMontCtx
        once  *sync.Once
}

func (m *Modulus) cacheMont() <span class="cov8" title="1">{
        // use a temporary BN_CTX to build the mont ctx
        tmp, _ := bnCtxPool.Get().(*boring.BigNumCtx)
        defer bnCtxPool.Put(tmp)
        mont, err := boring.NewBigNumMontCtx(m.mNum, tmp)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">m.mont = mont</span>
}

func (m *Modulus) ensureMont() <span class="cov8" title="1">{
        if m.mont != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">m.once.Do(func() </span><span class="cov8" title="1">{ m.cacheMont() }</span>)
}

func (m *Modulus) modExpOdd(out, base, exp *Nat) <span class="cov8" title="1">{
        m.ensureMont()
        m.Mod(out, base)

        bBytes := out.Bytes()
        eBytes := exp.Bytes()

        bNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(bNum)
        if _, err := bNum.SetBytes(bBytes); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">eNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(eNum)
        if _, err := eNum.SetBytes(eBytes); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">ctx, _ := bnCtxPool.Get().(*boring.BigNumCtx)
        defer bnCtxPool.Put(ctx)

        rNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(rNum)
        if _, err := rNum.Exp(bNum, eNum, m.mNum, m.mont, ctx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">rBytes, err := rNum.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">out.SetBytes(rBytes)</span>
}

// ModExp sets out = base^exp (mod m).
func (m *Modulus) ModExp(out, base, exp *Nat) <span class="cov8" title="1">{
        if m.Nat().IsOdd() == ct.True </span><span class="cov8" title="1">{
                m.modExpOdd(out, base, exp)
        }</span> else<span class="cov8" title="1"> {
                m.ModulusBasic.modExpEven(out, base, exp.Big())
        }</span>
}

func (m *Modulus) modExpIOdd(out, base *Nat, exp *Int) <span class="cov8" title="1">{
        var expAbs, candidate Nat
        expAbs.Abs(exp)
        m.modExpOdd(&amp;candidate, base, &amp;expAbs)

        isNeg := exp.IsNegative()

        var candidateInv Nat
        m.ModInv(&amp;candidateInv, &amp;candidate)

        out.Select(isNeg, &amp;candidate, &amp;candidateInv)
}</span>

// ModExpI sets out = base^exp (mod m) where exp is an Int.
func (m *Modulus) ModExpI(out, base *Nat, exp *Int) <span class="cov8" title="1">{
        if m.Nat().IsOdd() == ct.True </span><span class="cov8" title="1">{
                m.modExpIOdd(out, base, exp)
        }</span> else<span class="cov8" title="1"> {
                m.ModulusBasic.modExpEven(out, base, exp.Big())
        }</span>
}

func (m *Modulus) modMultiBaseExpOdd(out, bases []*Nat, exp *Nat) <span class="cov8" title="1">{
        m.ensureMont()

        eBytes := exp.Bytes()
        eNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(eNum)
        if _, err := eNum.SetBytes(eBytes); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">var wg sync.WaitGroup
        wg.Add(len(bases))
        for i, bi := range bases </span><span class="cov8" title="1">{
                go func(i int) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        m.Mod(out[i], bi)
                        biBytes := out[i].Bytes()
                        biNum, _ := bnPool.Get().(*boring.BigNum)
                        defer bnPool.Put(biNum)
                        if _, err := biNum.SetBytes(biBytes); err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov8" title="1">ctx, _ := bnCtxPool.Get().(*boring.BigNumCtx)
                        defer bnCtxPool.Put(ctx)

                        rNum, _ := bnPool.Get().(*boring.BigNum)
                        defer bnPool.Put(rNum)
                        if _, err := rNum.Exp(biNum, eNum, m.mNum, m.mont, ctx); err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov8" title="1">rBytes, err := rNum.Bytes()
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                        <span class="cov8" title="1">out[i].SetBytes(rBytes)</span>
                }(i)
        }
        <span class="cov8" title="1">wg.Wait()</span>
}

// ModMultiBaseExp sets out[i] = bases[i]^exp (mod m) for all i.
func (m *Modulus) ModMultiBaseExp(out, bases []*Nat, exp *Nat) <span class="cov8" title="1">{
        if len(bases) != len(out) </span><span class="cov0" title="0">{
                panic("len(bases) != len(out)")</span>
        }
        <span class="cov8" title="1">if m.Nat().IsOdd() == ct.True </span><span class="cov8" title="1">{
                m.modMultiBaseExpOdd(out, bases, exp)
        }</span> else<span class="cov0" title="0"> {
                m.ModulusBasic.ModMultiBaseExp(out, bases, exp)
        }</span>
}

func (m *Modulus) modInvOddPrime(out, a *Nat) ct.Bool <span class="cov8" title="1">{
        m.ensureMont()

        // Reduce a modulo m
        var aReduced Nat
        m.Mod(&amp;aReduced, a)

        ok := aReduced.IsNonZero()

        if ok == ct.False </span><span class="cov8" title="1">{ // boringssl panics on zero input
                return ok
        }</span>

        <span class="cov8" title="1">aNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(aNum)
        if _, err := aNum.SetBytes(aReduced.Bytes()); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">ctx, _ := bnCtxPool.Get().(*boring.BigNumCtx)
        defer bnCtxPool.Put(ctx)

        invNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(invNum)
        _, noInverse, err := invNum.Inv(aNum, m.mont, ctx)
        // If noInverse is set, this is expected (not an error condition)
        if noInverse != 0 </span><span class="cov8" title="1">{
                return ct.False
        }</span>
        // Any other error is unexpected
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">invBytes, err := invNum.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">var outCandidate Nat
        outCandidate.SetBytes(invBytes)

        var shouldBeOne Nat
        m.ModMul(&amp;shouldBeOne, &amp;outCandidate, a)

        ok &amp;= shouldBeOne.IsOne()

        out.CondAssign(ok, &amp;outCandidate)
        return ok</span>
}

// ModInv sets out = a^{-1} (mod m).
func (m *Modulus) ModInv(out, a *Nat) ct.Bool <span class="cov8" title="1">{
        ok := a.IsNonZero()
        if m.Nat().IsOdd() == ct.True </span><span class="cov8" title="1">{
                ok &amp;= m.modInvOddPrime(out, a)
                // This should work only for groups whose almost all of its elements are units. This property of the modulus is not secret.
                if ok == ct.False </span><span class="cov8" title="1">{
                        ok = m.ModulusBasic.modInvOdd(out, a)
                }</span>
        } else<span class="cov8" title="1"> {
                ok = m.ModulusBasic.modInvEven(out, a)
        }</span>
        <span class="cov8" title="1">return ok</span>
}

// ModMul sets out = (x * y) (mod m).
func (m *Modulus) ModMul(out, x, y *Nat) <span class="cov8" title="1">{
        xBytes, yBytes := x.Bytes(), y.Bytes()

        xNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(xNum)
        if _, err := xNum.SetBytes(xBytes); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">yNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(yNum)
        if _, err := yNum.SetBytes(yBytes); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">bnCtx, _ := bnCtxPool.Get().(*boring.BigNumCtx)
        defer bnCtxPool.Put(bnCtx)

        outNum, _ := bnPool.Get().(*boring.BigNum)
        defer bnPool.Put(outNum)
        if _, err := outNum.ModMul(xNum, yNum, m.mNum, bnCtx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">outBytes, err := outNum.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">out.SetBytes(outBytes)</span>
}

// Set sets m = v.
func (m *Modulus) Set(v *Modulus) <span class="cov0" title="0">{
        m.ModulusBasic.Set(v.ModulusBasic)
        m.mSub2 = v.mSub2.Clone()
        m.mNum = v.mNum
        m.mont = v.mont
        m.once = v.once
}</span>

// SetNat sets m = n where n is a Nat.
func (m *Modulus) SetNat(n *Nat) ct.Bool <span class="cov8" title="1">{
        mm, ok := NewModulus(n)
        if mm != nil </span><span class="cov8" title="1">{
                *m = *mm
        }</span>
        <span class="cov8" title="1">return ok</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">package numct

import (
        "io"
        "math/big"

        "github.com/cronokirby/saferith"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct/internal"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
)

// NatZero returns a new Nat representing zero.
func NatZero() *Nat <span class="cov8" title="1">{
        return (*Nat)(new(saferith.Nat).SetUint64(0).Resize(1))
}</span>

// NatOne returns a new Nat representing one.
func NatOne() *Nat <span class="cov8" title="1">{
        return (*Nat)(new(saferith.Nat).SetUint64(1).Resize(1))
}</span>

// NatTwo returns a new Nat representing two.
func NatTwo() *Nat <span class="cov8" title="1">{
        return (*Nat)(new(saferith.Nat).SetUint64(2).Resize(2))
}</span>

// NatThree returns a new Nat representing three.
func NatThree() *Nat <span class="cov8" title="1">{
        return (*Nat)(new(saferith.Nat).SetUint64(3).Resize(2))
}</span>

// NewNat returns a new Nat initialised to the given uint64 value.
func NewNat(value uint64) *Nat <span class="cov8" title="1">{
        n := new(Nat)
        n.SetUint64(value)
        return n
}</span>

// NewNatFromSaferith creates a Nat from a saferith.Nat.
func NewNatFromSaferith(n *saferith.Nat) *Nat <span class="cov0" title="0">{
        return (*Nat)(n)
}</span>

// NewNatFromBytes creates a Nat from a big-endian byte slice.
func NewNatFromBytes(n []byte) *Nat <span class="cov8" title="1">{
        return (*Nat)(new(saferith.Nat).SetBytes(n))
}</span>

// NewNatFromBig creates a Nat from a big.Int with the given capacity.
func NewNatFromBig(n *big.Int, capacity int) *Nat <span class="cov8" title="1">{
        return (*Nat)(new(saferith.Nat).SetBig(n, capacity))
}</span>

// Nat is a wrapper around saferith.Nat providing additional methods and occasional improvements.
// This implements the low level constant time interfaces that fiat-crypto implements.
type Nat saferith.Nat

// Set sets n to the value of v.
func (n *Nat) Set(v *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(n).SetNat((*saferith.Nat)(v))
}</span>

// SetZero sets n to zero.
func (n *Nat) SetZero() <span class="cov8" title="1">{
        n.Set(NatZero())
}</span>

// SetOne sets n to one.
func (n *Nat) SetOne() <span class="cov8" title="1">{
        n.Set(NatOne())
}</span>

// Clone returns a copy of n.
func (n *Nat) Clone() *Nat <span class="cov8" title="1">{
        return (*Nat)((*saferith.Nat)(n).Clone())
}</span>

// Lift converts n to an Int.
func (n *Nat) Lift() *Int <span class="cov8" title="1">{
        return (*Int)(new(saferith.Int).SetNat((*saferith.Nat)(n)))
}</span>

// Add sets n = lhs + rhs.
func (n *Nat) Add(lhs, rhs *Nat) <span class="cov8" title="1">{
        n.AddCap(lhs, rhs, -1)
}</span>

// AddCap sets n = lhs + rhs modulo 2^capacity with capacity capacity.
// if capacity &lt; 0, capacity will be max(lhs.AnnouncedLen(), rhs.AnnouncedLen()) + 1.
func (n *Nat) AddCap(lhs, rhs *Nat, capacity int) <span class="cov8" title="1">{
        (*saferith.Nat)(n).Add((*saferith.Nat)(lhs), (*saferith.Nat)(rhs), capacity)
}</span>

// SubCap sets n = lhs - rhs modulo 2^capacity.
// if capacity &lt; 0, capacity will be max(lhs.AnnouncedLen(), rhs.AnnouncedLen()).
func (n *Nat) SubCap(lhs, rhs *Nat, capacity int) <span class="cov8" title="1">{
        (*saferith.Nat)(n).Sub((*saferith.Nat)(lhs), (*saferith.Nat)(rhs), capacity)
}</span>

// Mul sets n = lhs * rhs.
func (n *Nat) Mul(lhs, rhs *Nat) <span class="cov8" title="1">{
        n.MulCap(lhs, rhs, -1)
}</span>

// MulCap sets n = lhs * rhs modulo 2^capacity.
// if capacity &lt; 0, capacity will be lhs.AnnouncedLen() + rhs.AnnouncedLen().
func (n *Nat) MulCap(lhs, rhs *Nat, capacity int) <span class="cov8" title="1">{
        (*saferith.Nat)(n).Mul((*saferith.Nat)(lhs), (*saferith.Nat)(rhs), capacity)
}</span>

// EuclideanDivVarTime sets n to quotient of numerator / denominator.
// If r is not nil, it will be set it to the remainder.
// It returns ok=true if the division was successful, ok=false otherwise (e.g., division by zero).
// The number of bits of the quotient will be
// min(numerator.AnnouncedLen(), numerator.AnnouncedLen() - denominator.TrueLen() + 2) and
// the number of bits of the remainder will be denominator.TrueLen().
func (n *Nat) EuclideanDivVarTime(remainder, numerator, denominator *Nat) ct.Bool <span class="cov8" title="1">{
        if denominator.IsZero() != ct.False </span><span class="cov8" title="1">{
                return ct.False
        }</span>

        <span class="cov8" title="1">nn := (*saferith.Nat)(numerator)
        dd := saferith.ModulusFromNat((*saferith.Nat)(denominator))

        var qq saferith.Nat
        qq.Div(nn, dd, -1)
        ((*saferith.Nat)(n)).SetNat(&amp;qq)
        ((*saferith.Nat)(n)).Resize(min(numerator.AnnouncedLen(), numerator.AnnouncedLen()-dd.BitLen()+2))
        if remainder != nil </span><span class="cov8" title="1">{
                var rr saferith.Nat
                rr.Mul((*saferith.Nat)(denominator), &amp;qq, -1)
                rr.Sub(nn, &amp;rr, -1)
                rr.Resize(dd.BitLen())
                ((*saferith.Nat)(remainder)).SetNat(&amp;rr)
        }</span>

        <span class="cov8" title="1">return ct.True</span>
}

// EuclideanDiv sets n to quotient of numerator / denominator.
// If r is not nil, it will be set it to the remainder.
// It returns ok=1 if the division was successful, ok=0 otherwise (i.e., division by zero).
// The number of bits of the quotient will be numerator.AnnouncedLen() and
// the number of bits of the remainder will be denominator.AnnouncedLen().
func (n *Nat) EuclideanDiv(r, numerator, denominator *Nat) ct.Bool <span class="cov8" title="1">{
        var qq, rr saferith.Nat
        internal.EuclideanDiv(&amp;qq, &amp;rr, (*saferith.Nat)(numerator), (*saferith.Nat)(denominator))
        ok := ((*saferith.Nat)(denominator)).EqZero() ^ 0b1
        ((*saferith.Nat)(n)).CondAssign(ok, &amp;qq)
        if r != nil </span><span class="cov8" title="1">{
                ((*saferith.Nat)(r)).CondAssign(ok, &amp;rr)
        }</span>

        <span class="cov8" title="1">return ct.Bool(ok)</span>
}

// DivVarTime sets n = numerator / denominator.
// If r is not nil, it will be set it to the remainder.
// It returns ok=true if the division was successful, ok=false otherwise (e.g., division by zero).
// The number of bits of the quotient will be
// min(numerator.AnnouncedLen(), numerator.AnnouncedLen() - denominator.TrueLen() + 2) and
// the number of bits of the remainder will be denominator.TrueLen().
func (n *Nat) DivVarTime(remainder, numerator, denominator *Nat) ct.Bool <span class="cov8" title="1">{
        return n.EuclideanDivVarTime(remainder, numerator, denominator)
}</span>

// Div sets n = numerator / denominator.
// If r is not nil, it will be set it to the remainder.
// It returns ok=1 if the division was successful, ok=0 otherwise (i.e., division by zero).
// The number of bits of the quotient will be numerator.AnnouncedLen() and
// the number of bits of the remainder will be denominator.AnnouncedLen().
func (n *Nat) Div(remainder, numerator, denominator *Nat) ct.Bool <span class="cov0" title="0">{
        return n.EuclideanDiv(remainder, numerator, denominator)
}</span>

// Double sets n = x + x.
func (n *Nat) Double(x *Nat) <span class="cov8" title="1">{
        n.Add(x, x)
}</span>

// Increment increments n by 1.
func (n *Nat) Increment() <span class="cov8" title="1">{
        n.Add(n, NatOne())
}</span>

// Decrement decrements n by 1.
func (n *Nat) Decrement() <span class="cov8" title="1">{
        (*saferith.Nat)(n).Sub((*saferith.Nat)(n), (*saferith.Nat)(NatOne()), -1)
}</span>

// Bit returns the i-th bit of n.
func (n *Nat) Bit(i uint) byte <span class="cov8" title="1">{
        return (*saferith.Nat)(n).Byte(int(i/8)) &gt;&gt; (i % 8) &amp; 1
}</span>

// Byte returns the i-th byte of n.
func (n *Nat) Byte(i uint) byte <span class="cov8" title="1">{
        return (*saferith.Nat)(n).Byte(int(i))
}</span>

// Compare compares n with rhs and returns lt, eq, gt (each will be 1 or 0).
func (n *Nat) Compare(rhs *Nat) (lt, eq, gt ct.Bool) <span class="cov8" title="1">{ // TODO: swap order
        sgt, seq, slt := (*saferith.Nat)(n).Cmp((*saferith.Nat)(rhs))
        return ct.Bool(slt), ct.Bool(seq), ct.Bool(sgt)
}</span>

// Equal returns 1 if n == rhs.
func (n *Nat) Equal(rhs *Nat) ct.Bool <span class="cov8" title="1">{
        return ct.Bool((*saferith.Nat)(n).Eq((*saferith.Nat)(rhs)))
}</span>

// IsZero returns 1 if n == 0.
func (n *Nat) IsZero() ct.Bool <span class="cov8" title="1">{
        return ct.Bool((*saferith.Nat)(n).EqZero())
}</span>

// IsNonZero returns 1 if n != 0.
func (n *Nat) IsNonZero() ct.Bool <span class="cov8" title="1">{
        return n.IsZero().Not()
}</span>

// IsOne returns 1 if n == 1.
func (n *Nat) IsOne() ct.Bool <span class="cov8" title="1">{
        return ct.Bool((*saferith.Nat)(n).Eq((*saferith.Nat)(NatOne())))
}</span>

// Coprime returns 1 if n is coprime to x.
func (n *Nat) Coprime(x *Nat) ct.Bool <span class="cov8" title="1">{
        return ct.Bool((*saferith.Nat)(n).Coprime((*saferith.Nat)(x)))
}</span>

// String returns the hex string representation of n.
func (n *Nat) String() string <span class="cov8" title="1">{
        return (*saferith.Nat)(n).String()
}</span>

// TrueLen returns the exact number of bits required to represent n.
func (n *Nat) TrueLen() int <span class="cov8" title="1">{
        return (*saferith.Nat)(n).TrueLen()
}</span>

// AnnouncedLen returns the announced length in bits of n. Safe to be used publicly.
func (n *Nat) AnnouncedLen() int <span class="cov8" title="1">{
        return ((*saferith.Nat)(n).AnnouncedLen())
}</span>

// Select sets n = x0 if choice == 0, n = x1 if choice == 1.
func (n *Nat) Select(choice ct.Choice, x0, x1 *Nat) <span class="cov8" title="1">{
        n.Set(x0)
        (*saferith.Nat)(n).CondAssign(saferith.Choice(choice), (*saferith.Nat)(x1))
}</span>

// CondAssign sets n = x if choice == 1.
func (n *Nat) CondAssign(choice ct.Choice, x *Nat) <span class="cov8" title="1">{
        (*saferith.Nat)(n).CondAssign(saferith.Choice(choice), (*saferith.Nat)(x))
}</span>

// IsOdd returns 1 if n is odd.
func (n *Nat) IsOdd() ct.Bool <span class="cov8" title="1">{
        return ct.Bool((*saferith.Nat)(n).Byte(0) &amp; 0b1)
}</span>

// IsEven returns 1 if n is even.
func (n *Nat) IsEven() ct.Bool <span class="cov8" title="1">{
        return n.IsOdd().Not()
}</span>

// Resize resizes n to have given capacity.
// When capacity &lt; 0, use the current announced length
// When capacity &gt;= 0, use the provided capacity.
func (n *Nat) Resize(capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov0" title="0">{
                capacity = n.AnnouncedLen()
        }</span>
        <span class="cov8" title="1">(*saferith.Nat)(n).Resize(capacity)</span>
}

// Sqrt sets n = sqrt(x) if x is a perfect square, else leaves n unchanged.
// Returns ok = 1 if n is a perfect square.
func (n *Nat) Sqrt(x *Nat) (ok ct.Bool) <span class="cov8" title="1">{
        // Constant-time (w.r.t. announced capacity) integer square root.
        // Work on |x| and assign only if |x| is a perfect square.

        capBits := (x.AnnouncedLen())

        var root saferith.Nat
        var okRes ct.Bool

        // ===== Single-limb fast path (&lt;= 64 bits): 32 fixed rounds =====
        if capBits &lt;= 64 </span><span class="cov8" title="1">{
                u0 := x.Uint64()
                r64 := ct.Isqrt64(u0)
                root.SetUint64(r64).Resize(capBits)

                // Exactness check: r64^2 fits in uint64 because r64 &lt;= 2^32.
                sq := r64 * r64
                okRes = ct.Equal(sq, u0)
        }</span> else<span class="cov8" title="1"> {
                // ===== Multi-limb path: restoring (digit-by-digit) method. =====
                // Runtime depends only on capBits (pairs), not on the value.
                var r saferith.Nat // remainder
                r.SetNat((*saferith.Nat)(x))
                r.Resize(capBits)

                var y saferith.Nat // accumulating root
                y.SetUint64(0)
                y.Resize(capBits)

                pairs := (capBits + 1) / 2 // number of two-bit groups to process

                // b := 1 &lt;&lt; startEven, where startEven is the top even bit &lt; capBits
                var b saferith.Nat
                b.SetUint64(1)
                if pairs &gt; 0 </span><span class="cov8" title="1">{
                        startEven := 2 * (pairs - 1)
                        b.Lsh(&amp;b, uint(startEven), capBits)
                }</span> else<span class="cov0" title="0"> {
                        b.Resize(capBits)
                }</span>

                // Scratch (BoringSSL-style reuse).
                <span class="cov8" title="1">var m saferith.Nat      // y + b
                var yshr saferith.Nat   // y &gt;&gt; 1
                var rMinus saferith.Nat // r - m
                var yPlus saferith.Nat  // (y&gt;&gt;1) + b
                var bshr saferith.Nat   // b &gt;&gt; 2

                for range pairs </span><span class="cov8" title="1">{
                        m.Add(&amp;y, &amp;b, capBits)

                        yshr.Rsh(&amp;y, 1, capBits)

                        rMinus.Sub(&amp;r, &amp;m, capBits)   // r - m
                        yPlus.Add(&amp;yshr, &amp;b, capBits) // (y&gt;&gt;1) + b

                        gt, eq, _ := r.Cmp(&amp;m)
                        ge := gt | eq

                        r.CondAssign(ge, &amp;rMinus)
                        y = yshr
                        y.CondAssign(ge, &amp;yPlus)

                        bshr.Rsh(&amp;b, 2, capBits)
                        b = bshr
                }</span>

                // ok iff remainder is zero.
                <span class="cov8" title="1">var z saferith.Nat
                z.Resize(capBits)
                _, eqZero, _ := r.Cmp(&amp;z)
                okRes = ct.Bool(eqZero)

                root.SetNat(&amp;y)</span>
        }

        <span class="cov8" title="1">ok = okRes

        // Conditionally assign the root.
        n.Select(ok, n, (*Nat)(&amp;root))
        return ok</span>
}

// Lsh left shifts n by shift bits.
func (n *Nat) Lsh(x *Nat, shift uint) <span class="cov8" title="1">{
        n.LshCap(x, shift, -1)
}</span>

// IsProbablyPrime returns 1 if n is probably prime, by applying a BPSW test.
func (n *Nat) IsProbablyPrime() ct.Bool <span class="cov8" title="1">{
        return utils.BoolTo[ct.Bool]((*saferith.Nat)(n).Big().ProbablyPrime(0))
}</span>

// LshCap left shifts n by shift bits with given capacity.
// if capacity &lt; 0, capacity will be x.AnnouncedLen() + shift.
func (n *Nat) LshCap(x *Nat, shift uint, capacity int) <span class="cov8" title="1">{
        (*saferith.Nat)(n).Lsh((*saferith.Nat)(x), shift, capacity)
}</span>

// Rsh right shifts n by shift bits.
func (n *Nat) Rsh(x *Nat, shift uint) <span class="cov8" title="1">{
        n.RshCap(x, shift, -1)
}</span>

// RshCap right shifts n by shift bits with given capacity.
// if capacity &lt; 0, capacity will be x.AnnouncedLen() - shift.
func (n *Nat) RshCap(x *Nat, shift uint, capacity int) <span class="cov8" title="1">{
        (*saferith.Nat)(n).Rsh((*saferith.Nat)(x), shift, capacity)
}</span>

// Uint64 returns the uint64 representation of n.
func (n *Nat) Uint64() uint64 <span class="cov8" title="1">{
        return (*saferith.Nat)(n).Uint64()
}</span>

// SetUint64 sets n to the given uint64 value.
func (n *Nat) SetUint64(x uint64) <span class="cov8" title="1">{
        (*saferith.Nat)(n).SetUint64(x)
}</span>

// Bytes returns the big-endian byte representation of n.
func (n *Nat) Bytes() []byte <span class="cov8" title="1">{
        return (*saferith.Nat)(n).Bytes()
}</span>

// BytesBE returns the big-endian byte representation of n.
func (n *Nat) BytesBE() []byte <span class="cov8" title="1">{
        return n.Bytes()
}</span>

// SetBytes sets n from the big-endian byte slice data.
func (n *Nat) SetBytes(data []byte) (ok ct.Bool) <span class="cov8" title="1">{
        (*saferith.Nat)(n).SetBytes(data)
        return ct.True
}</span>

// FillBytes fills buf with the big-endian byte representation of n and returns buf.
func (n *Nat) FillBytes(buf []byte) []byte <span class="cov8" title="1">{
        return (*saferith.Nat)(n).FillBytes(buf)
}</span>

// HashCode returns a hash code for n.
func (n *Nat) HashCode() base.HashCode <span class="cov8" title="1">{
        return base.DeriveHashCode(n.Bytes())
}</span>

// Big returns the big.Int representation of n.
func (n *Nat) Big() *big.Int <span class="cov8" title="1">{
        return (*saferith.Nat)(n).Big()
}</span>

// And sets n = x &amp; y and returns n.
func (n *Nat) And(x, y *Nat) <span class="cov8" title="1">{
        n.AndCap(x, y, -1)
}</span>

// AndCap sets n = x &amp; y with capacity cap.
func (n *Nat) AndCap(x, y *Nat, capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov8" title="1">{
                capacity = (max(x.AnnouncedLen(), y.AnnouncedLen()))
        }</span>
        <span class="cov8" title="1">capBytes := (capacity + 7) / 8

        xBytes := make([]byte, capBytes)
        yBytes := make([]byte, capBytes)
        zBytes := make([]byte, capBytes)
        (*saferith.Nat)(x).FillBytes(xBytes)
        (*saferith.Nat)(y).FillBytes(yBytes)
        ct.AndBytes(zBytes, xBytes, yBytes)

        (*saferith.Nat)(n).SetBytes(zBytes).Resize(capacity)</span>
}

// Or sets n = x | y.
func (n *Nat) Or(x, y *Nat) <span class="cov8" title="1">{
        n.OrCap(x, y, -1)
}</span>

// OrCap sets n = x | y with capacity cap.
func (n *Nat) OrCap(x, y *Nat, capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov8" title="1">{
                capacity = (max(x.AnnouncedLen(), y.AnnouncedLen()))
        }</span>
        <span class="cov8" title="1">capBytes := (capacity + 7) / 8

        xBytes := make([]byte, capBytes)
        yBytes := make([]byte, capBytes)
        zBytes := make([]byte, capBytes)
        (*saferith.Nat)(x).FillBytes(xBytes)
        (*saferith.Nat)(y).FillBytes(yBytes)
        ct.OrBytes(zBytes, xBytes, yBytes)

        (*saferith.Nat)(n).SetBytes(zBytes).Resize(capacity)</span>
}

// Xor sets n = x ^ y.
func (n *Nat) Xor(x, y *Nat) <span class="cov8" title="1">{
        n.XorCap(x, y, -1)
}</span>

// XorCap sets n = x ^ y with capacity cap.
func (n *Nat) XorCap(x, y *Nat, capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov8" title="1">{
                capacity = (max(x.AnnouncedLen(), y.AnnouncedLen()))
        }</span>
        <span class="cov8" title="1">capBytes := (capacity + 7) / 8

        xBytes := make([]byte, capBytes)
        yBytes := make([]byte, capBytes)
        zBytes := make([]byte, capBytes)
        (*saferith.Nat)(x).FillBytes(xBytes)
        (*saferith.Nat)(y).FillBytes(yBytes)
        ct.XorBytes(zBytes, xBytes, yBytes)

        (*saferith.Nat)(n).SetBytes(zBytes).Resize(capacity)</span>
}

// Not sets n = ^x.
func (n *Nat) Not(x *Nat) <span class="cov8" title="1">{
        n.NotCap(x, x.AnnouncedLen())
}</span>

// NotCap sets n = ^x with capacity cap.
// For compatibility with big.Int.Not, use the announced capacity of x.
func (n *Nat) NotCap(x *Nat, capacity int) <span class="cov8" title="1">{
        if capacity &lt; 0 </span><span class="cov0" title="0">{
                capacity = (x.AnnouncedLen())
        }</span>
        <span class="cov8" title="1">capBytes := (capacity + 7) / 8

        xBytes := make([]byte, capBytes)
        zBytes := make([]byte, capBytes)
        (*saferith.Nat)(x).FillBytes(xBytes)
        ct.NotBytes(zBytes, xBytes)

        (*saferith.Nat)(n).SetBytes(zBytes).Resize(capacity)</span>
}

// Abs sets n to |i|.
func (n *Nat) Abs(i *Int) <span class="cov8" title="1">{
        abs := (*saferith.Int)(i).Abs()
        ((*saferith.Nat)(n)).SetNat(abs)
}</span>

// SetRandomRangeLH sets n to a random value in the range [lowInclusive, highExclusive).
func (n *Nat) SetRandomRangeLH(lowInclusive, highExclusive *Nat, prng io.Reader) error <span class="cov8" title="1">{
        var errs []error
        if lowInclusive == nil </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("lowInclusive must not be nil"))
        }</span>
        <span class="cov8" title="1">if highExclusive == nil </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("highExclusive must not be nil"))
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("prng must not be nil"))
        }</span>
        <span class="cov8" title="1">if lt, _, _ := lowInclusive.Compare(highExclusive); lt == ct.False </span><span class="cov8" title="1">{
                errs = append(errs, ErrInvalidArgument.WithMessage("max must be greater than low"))
        }</span>
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return errs2.Join(errs...)
        }</span>

        <span class="cov8" title="1">var interval Nat
        interval.SubCap(highExclusive, lowInclusive, (highExclusive.AnnouncedLen()))
        var r Nat
        err := r.SetRandomRangeH(&amp;interval, prng)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">var result Nat
        result.AddCap(&amp;r, lowInclusive, (highExclusive.AnnouncedLen()))
        n.Set(&amp;result)
        return nil</span>
}

// SetRandomRangeH sets n to a random value in the range [0, highExclusive).
// This simply uses rejection sampling to generate a random value in [0, highExclusive)
// but masks out bits that are too high to be in the range so sampling rejection happens with
// relatively low probability (~0.5).
func (n *Nat) SetRandomRangeH(highExclusive *Nat, prng io.Reader) error <span class="cov8" title="1">{
        var errs []error
        if prng == nil </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("prng must not be nil"))
        }</span>
        <span class="cov8" title="1">if highExclusive == nil </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("high bound must not be nil"))
        }</span>
        <span class="cov8" title="1">if zero := highExclusive.IsZero(); zero != ct.False </span><span class="cov0" title="0">{
                errs = append(errs, ErrInvalidArgument.WithMessage("high bound must be non-zero"))
        }</span>
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return errs2.Join(errs...)
        }</span>

        <span class="cov8" title="1">var mask Nat
        mask.Set(highExclusive)
        for i := 1; i &lt; highExclusive.AnnouncedLen(); i &lt;&lt;= 1 </span><span class="cov8" title="1">{
                var shifted Nat
                shifted.Rsh(&amp;mask, uint(i))
                mask.Or(&amp;mask, &amp;shifted)
        }</span>

        <span class="cov8" title="1">var result Nat
        for </span><span class="cov8" title="1">{
                var dataNat Nat
                data := make([]byte, (highExclusive.AnnouncedLen()+7)/8)
                _, err := io.ReadFull(prng, data)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("failed to read random bytes")
                }</span>
                <span class="cov8" title="1">dataNat.SetBytes(data)
                dataNat.Resize(highExclusive.AnnouncedLen())
                result.And(&amp;dataNat, &amp;mask)

                // this happens with probability ~0.5
                if lt, _, _ := result.Compare(highExclusive); lt != ct.False </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">n.Set(&amp;result)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">//go:build !purego &amp;&amp; !nobignum

package numct

import (
        "github.com/bronlabs/bron-crypto/pkg/base/cgo/boring"
        "github.com/cronokirby/saferith"
)

// GCD sets n = gcd(x, y) using boringssl based implementation.
func (n *Nat) GCD(x, y *Nat) <span class="cov8" title="1">{
        c := min(((*saferith.Nat)(x)).AnnouncedLen(), ((*saferith.Nat)(y)).AnnouncedLen())

        var u, v, tu, tv, t, shift saferith.Nat
        shift.SetUint64(1).Resize(c)
        u.SetNat((*saferith.Nat)(x))
        v.SetNat((*saferith.Nat)(y))
        for range c </span><span class="cov8" title="1">{
                uEven := saferith.Choice(u.Byte(0)&amp;0b1) ^ 0b1
                vEven := saferith.Choice(v.Byte(0)&amp;0b1) ^ 0b1

                t.Lsh(&amp;shift, 1, c)
                shift.CondAssign(uEven&amp;vEven, &amp;t)

                tu.Rsh(&amp;u, 1, u.AnnouncedLen())
                tv.Rsh(&amp;v, 1, v.AnnouncedLen())
                u.CondAssign(uEven&amp;vEven, &amp;tu)
                v.CondAssign(uEven&amp;vEven, &amp;tv)
        }</span>

        <span class="cov8" title="1">uBytes, vBytes := u.Bytes(), v.Bytes()
        xNum, err := boring.NewBigNum().SetBytes(uBytes)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">yNum, err := boring.NewBigNum().SetBytes(vBytes)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">bnCtx := boring.NewBigNumCtx()
        outNum, err := boring.NewBigNum().Gcd(xNum, yNum, bnCtx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">outBytes, err := outNum.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">((*saferith.Nat)(n)).SetBytes(outBytes)
        ((*saferith.Nat)(n)).Mul((*saferith.Nat)(n), &amp;shift, max(x.AnnouncedLen(), y.AnnouncedLen()))</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">//go:build !purego &amp;&amp; !nobignum

package numct

import (
        "github.com/bronlabs/bron-crypto/pkg/base/cgo/boring"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

func LCM(out, a, b *Nat) <span class="cov8" title="1">{
        if a.IsZero()|b.IsZero() == ct.True </span><span class="cov8" title="1">{
                out.SetZero()
                return
        }</span>
        <span class="cov8" title="1">aBytes, bBytes := a.Bytes(), b.Bytes()
        aNum, err := boring.NewBigNum().SetBytes(aBytes)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">bNum, err := boring.NewBigNum().SetBytes(bBytes)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">bnCtx := boring.NewBigNumCtx()
        outNum, err := boring.NewBigNum().Lcm(aNum, bNum, bnCtx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">outBytes, err := outNum.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">out.SetBytes(outBytes)</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package znstar

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*RSAGroupKnownOrder)(nil)
        _ cbor.Unmarshaler = (*RSAGroupKnownOrder)(nil)

        _ cbor.Marshaler   = (*RSAGroupElementKnownOrder)(nil)
        _ cbor.Unmarshaler = (*RSAGroupElementKnownOrder)(nil)

        _ cbor.Marshaler   = (*RSAGroupUnknownOrder)(nil)
        _ cbor.Unmarshaler = (*RSAGroupUnknownOrder)(nil)

        _ cbor.Marshaler   = (*RSAGroupElementUnknownOrder)(nil)
        _ cbor.Unmarshaler = (*RSAGroupElementUnknownOrder)(nil)

        _ cbor.Marshaler   = (*PaillierGroupKnownOrder)(nil)
        _ cbor.Unmarshaler = (*PaillierGroupKnownOrder)(nil)

        _ cbor.Marshaler   = (*PaillierGroupElementKnownOrder)(nil)
        _ cbor.Unmarshaler = (*PaillierGroupElementKnownOrder)(nil)

        _ cbor.Marshaler   = (*PaillierGroupUnknownOrder)(nil)
        _ cbor.Unmarshaler = (*PaillierGroupUnknownOrder)(nil)

        _ cbor.Marshaler   = (*PaillierGroupElementUnknownOrder)(nil)
        _ cbor.Unmarshaler = (*PaillierGroupElementUnknownOrder)(nil)
)

const (
        RSAGroupKnownOrderTag = 5010 + iota
        RSAGroupKnownOrderElementTag
        RSAGroupUnknownOrderTag
        RSAGroupUnknownOrderElementTag
        PaillierGroupKnownOrderTag
        PaillierGroupKnownOrderElementTag
        PaillierGroupUnknownOrderTag
        PaillierGroupUnknownOrderElementTag
)

func init() <span class="cov8" title="1">{
        serde.Register[*RSAGroupKnownOrder](RSAGroupKnownOrderTag)
        serde.Register[*RSAGroupElementKnownOrder](RSAGroupKnownOrderElementTag)
        serde.Register[*RSAGroupUnknownOrder](RSAGroupUnknownOrderTag)
        serde.Register[*RSAGroupElementUnknownOrder](RSAGroupUnknownOrderElementTag)
        serde.Register[*PaillierGroupKnownOrder](PaillierGroupKnownOrderTag)
        serde.Register[*PaillierGroupElementKnownOrder](PaillierGroupKnownOrderElementTag)
        serde.Register[*PaillierGroupUnknownOrder](PaillierGroupUnknownOrderTag)
        serde.Register[*PaillierGroupElementUnknownOrder](PaillierGroupUnknownOrderElementTag)
}</span>

type rsaGroupKnownOrderDTO struct {
        P *num.NatPlus `cbor:"p"`
        Q *num.NatPlus `cbor:"q"`
}

type rsaGroupUnknownOrderDTO struct {
        Modulus *num.NatPlus `cbor:"modulus"`
}

type rsaGroupUnknownOrderElementDTO struct {
        V          *num.Uint              `cbor:"v"`
        Arithmetic *modular.SimpleModulus `cbor:"arithmetic"`
}

type rsaGroupKnownOrderElementDTO struct {
        V          *num.Uint                `cbor:"v"`
        Arithmetic *modular.OddPrimeFactors `cbor:"arithmetic"`
}

type paillierGroupKnownOrderDTO struct {
        P *num.NatPlus `cbor:"p"`
        Q *num.NatPlus `cbor:"q"`
}

type paillierGroupUnknownOrderDTO struct {
        N *num.NatPlus `cbor:"n"`
}

type paillierGroupKnownOrderElementDTO struct {
        V          *num.Uint                      `cbor:"v"`
        Arithmetic *modular.OddPrimeSquareFactors `cbor:"arithmetic"`
}

type paillierGroupUnknownOrderElementDTO struct {
        V          *num.Uint              `cbor:"v"`
        Arithmetic *modular.SimpleModulus `cbor:"arithmetic"`
        N          *num.NatPlus           `cbor:"n"`
}

// ========== CBOR Serialisation ==========.

func (pg *PaillierGroup[X]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        var tag uint64
        switch any(pg.arith).(type) </span>{
        case *modular.OddPrimeSquareFactors:<span class="cov8" title="1">
                tag = PaillierGroupKnownOrderTag
                dto := &amp;paillierGroupKnownOrderDTO{
                        P: num.NPlus().FromModulusCT(any(pg.arith).(*modular.OddPrimeSquareFactors).P.Factor), //nolint:errcheck // false positive
                        Q: num.NPlus().FromModulusCT(any(pg.arith).(*modular.OddPrimeSquareFactors).Q.Factor), //nolint:errcheck // false positive
                }
                return serde.MarshalCBORTagged(dto, tag)</span>
        case *modular.SimpleModulus:<span class="cov8" title="1">
                tag = PaillierGroupUnknownOrderTag
                dto := &amp;paillierGroupUnknownOrderDTO{
                        N: pg.n,
                }
                return serde.MarshalCBORTagged(dto, tag)</span>
        default:<span class="cov0" title="0">
                panic("unknown arithmetic type for PaillierGroup")</span>
        }
}

func (pg *PaillierGroup[X]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        switch any(pg.arith).(type) </span>{
        case *modular.OddPrimeSquareFactors:<span class="cov8" title="1">
                dto, err := serde.UnmarshalCBOR[paillierGroupKnownOrderDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">reconstructed, err := NewPaillierGroup(dto.P, dto.Q)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*pg = *any(reconstructed).(*PaillierGroup[X]) //nolint:errcheck // false positive
                return nil</span>
        case *modular.SimpleModulus:<span class="cov8" title="1">
                dto, err := serde.UnmarshalCBOR[paillierGroupUnknownOrderDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">n2 := dto.N.Square()
                reconstructed, err := NewPaillierGroupOfUnknownOrder(n2, dto.N)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*pg = *any(reconstructed).(*PaillierGroup[X]) //nolint:errcheck // false positive
                return nil</span>
        default:<span class="cov0" title="0">
                panic("unknown arithmetic type in UnmarshalCBOR")</span>
        }
}

func (u *PaillierGroupElement[X]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        var tag uint64
        switch any(u.arith).(type) </span>{
        case *modular.OddPrimeSquareFactors:<span class="cov8" title="1">
                tag = PaillierGroupKnownOrderElementTag
                dto := &amp;paillierGroupKnownOrderElementDTO{
                        V:          u.v,
                        Arithmetic: any(u.arith).(*modular.OddPrimeSquareFactors), //nolint:errcheck // false positive
                }
                return serde.MarshalCBORTagged(dto, tag)</span>
        case *modular.SimpleModulus:<span class="cov8" title="1">
                tag = PaillierGroupUnknownOrderElementTag
                dto := &amp;paillierGroupUnknownOrderElementDTO{
                        V:          u.v,
                        Arithmetic: any(u.arith).(*modular.SimpleModulus), //nolint:errcheck // false positive
                        N:          u.n,
                }
                return serde.MarshalCBORTagged(dto, tag)</span>
        default:<span class="cov0" title="0">
                panic("unknown arithmetic type for PaillierGroupElement")</span>
        }
}

func (u *PaillierGroupElement[X]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        switch any(u.arith).(type) </span>{
        case *modular.OddPrimeSquareFactors:<span class="cov8" title="1">
                dto, err := serde.UnmarshalCBOR[paillierGroupKnownOrderElementDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">p := num.NPlus().FromModulusCT(dto.Arithmetic.P.Factor)
                q := num.NPlus().FromModulusCT(dto.Arithmetic.Q.Factor)
                g, err := NewPaillierGroup(p, q)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">elem, err := g.FromUint(dto.V)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">*u = *any(elem).(*PaillierGroupElement[X]) //nolint:errcheck // false positive
                return nil</span>
        case *modular.SimpleModulus:<span class="cov8" title="1">
                dto, err := serde.UnmarshalCBOR[paillierGroupUnknownOrderElementDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">n2 := dto.N.Square()
                g, err := NewPaillierGroupOfUnknownOrder(n2, dto.N)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">elem, err := g.FromUint(dto.V)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*u = *any(elem).(*PaillierGroupElement[X]) //nolint:errcheck // false positive
                return nil</span>
        default:<span class="cov0" title="0">
                // For initial unmarshal when arith is zero value, try both
                if dtoKnown, err := serde.UnmarshalCBOR[paillierGroupKnownOrderElementDTO](data); err == nil </span><span class="cov0" title="0">{
                        p := num.NPlus().FromModulusCT(dtoKnown.Arithmetic.P.Factor)
                        q := num.NPlus().FromModulusCT(dtoKnown.Arithmetic.Q.Factor)
                        g, err := NewPaillierGroup(p, q)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">elem, err := g.FromUint(dtoKnown.V)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">*u = *any(elem).(*PaillierGroupElement[X]) //nolint:errcheck // false positive
                        return nil</span>
                }
                <span class="cov0" title="0">dto, err := serde.UnmarshalCBOR[paillierGroupUnknownOrderElementDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">n2 := dto.N.Square()
                g, err := NewPaillierGroupOfUnknownOrder(n2, dto.N)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">elem, err := g.FromUint(dto.V)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*u = *any(elem).(*PaillierGroupElement[X]) //nolint:errcheck // false positive
                return nil</span>
        }
}

func (rg *RSAGroup[X]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        // Determine tag based on arithmetic type
        var tag uint64
        switch any(rg.arith).(type) </span>{
        case *modular.OddPrimeFactors:<span class="cov8" title="1">
                tag = RSAGroupKnownOrderTag
                dto := &amp;rsaGroupKnownOrderDTO{
                        P: num.NPlus().FromModulusCT(any(rg.arith).(*modular.OddPrimeFactors).Params.P), //nolint:errcheck // false positive
                        Q: num.NPlus().FromModulusCT(any(rg.arith).(*modular.OddPrimeFactors).Params.Q), //nolint:errcheck // false positive
                }
                return serde.MarshalCBORTagged(dto, tag)</span>
        case *modular.SimpleModulus:<span class="cov8" title="1">
                tag = RSAGroupUnknownOrderTag
                dto := &amp;rsaGroupUnknownOrderDTO{
                        Modulus: rg.Modulus(),
                }
                return serde.MarshalCBORTagged(dto, tag)</span>
        default:<span class="cov0" title="0">
                panic("unknown arithmetic type for RSAGroup")</span>
        }
}

func (rg *RSAGroup[X]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        // Determine which type based on X
        switch any(rg.arith).(type) </span>{
        case *modular.OddPrimeFactors:<span class="cov8" title="1">
                dto, err := serde.UnmarshalCBOR[rsaGroupKnownOrderDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">reconstructed, err := NewRSAGroup(dto.P, dto.Q)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*rg = *any(reconstructed).(*RSAGroup[X]) //nolint:errcheck // false positive
                return nil</span>
        case *modular.SimpleModulus:<span class="cov8" title="1">
                dto, err := serde.UnmarshalCBOR[rsaGroupUnknownOrderDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">reconstructed, err := NewRSAGroupOfUnknownOrder(dto.Modulus)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*rg = *any(reconstructed).(*RSAGroup[X]) //nolint:errcheck // false positive
                return nil</span>
        default:<span class="cov0" title="0">
                panic("unknown arithmetic type in UnmarshalCBOR")</span>
        }
}

func (u *RSAGroupElement[X]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        var tag uint64
        switch any(u.arith).(type) </span>{
        case *modular.OddPrimeFactors:<span class="cov8" title="1">
                tag = RSAGroupKnownOrderElementTag
                dto := &amp;rsaGroupKnownOrderElementDTO{
                        V:          u.v,
                        Arithmetic: any(u.arith).(*modular.OddPrimeFactors), //nolint:errcheck // false positive
                }
                return serde.MarshalCBORTagged(dto, tag)</span>
        case *modular.SimpleModulus:<span class="cov8" title="1">
                tag = RSAGroupUnknownOrderElementTag
                dto := &amp;rsaGroupUnknownOrderElementDTO{
                        V:          u.v,
                        Arithmetic: any(u.arith).(*modular.SimpleModulus), //nolint:errcheck // false positive
                }
                return serde.MarshalCBORTagged(dto, tag)</span>
        default:<span class="cov0" title="0">
                panic("unknown arithmetic type for RSAGroupElement")</span>
        }
}

func (u *RSAGroupElement[X]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        switch any(u.arith).(type) </span>{
        case *modular.OddPrimeFactors:<span class="cov8" title="1">
                dto, err := serde.UnmarshalCBOR[rsaGroupKnownOrderElementDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">p := num.NPlus().FromModulusCT(dto.Arithmetic.Params.P)
                q := num.NPlus().FromModulusCT(dto.Arithmetic.Params.Q)
                g, err := NewRSAGroup(p, q)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">elem, err := g.FromUint(dto.V)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">*u = *any(elem).(*RSAGroupElement[X]) //nolint:errcheck // false positive
                return nil</span>
        case *modular.SimpleModulus:<span class="cov8" title="1">
                dto, err := serde.UnmarshalCBOR[rsaGroupUnknownOrderElementDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">g, err := NewRSAGroupOfUnknownOrder(dto.V.Modulus())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">elem, err := g.FromUint(dto.V)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*u = *any(elem).(*RSAGroupElement[X]) //nolint:errcheck // false positive
                return nil</span>
        default:<span class="cov0" title="0">
                // For initial unmarshal when arith is zero value, try both
                if dtoKnown, err := serde.UnmarshalCBOR[rsaGroupKnownOrderElementDTO](data); err == nil </span><span class="cov0" title="0">{
                        p := num.NPlus().FromModulusCT(dtoKnown.Arithmetic.Params.P)
                        q := num.NPlus().FromModulusCT(dtoKnown.Arithmetic.Params.Q)
                        g, err := NewRSAGroup(p, q)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">elem, err := g.FromUint(dtoKnown.V)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">*u = *any(elem).(*RSAGroupElement[X]) //nolint:errcheck // false positive
                        return nil</span>
                }
                <span class="cov0" title="0">dto, err := serde.UnmarshalCBOR[rsaGroupUnknownOrderElementDTO](data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">g, err := NewRSAGroupOfUnknownOrder(dto.V.Modulus())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">elem, err := g.FromUint(dto.V)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">*u = *any(elem).(*RSAGroupElement[X]) //nolint:errcheck // false positive
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file165" style="display: none">package znstar

import (
        "fmt"
        "io"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

type unitWrapper[A modular.Arithmetic] interface {
        set(*num.Uint, A, *num.NatPlus)
        Arithmetic() A
        Modulus() *num.NatPlus
        IsUnknownOrder() bool
        base.Transparent[*num.Uint]
}

type unitWrapperPtrConstraint[A modular.Arithmetic, WT any] interface {
        *WT
        unitWrapper[A]
}

type UnitGroupTrait[A modular.Arithmetic, W unitWrapperPtrConstraint[A, WT], WT any] struct {
        zMod  *num.ZMod
        arith A
        n     *num.NatPlus
}

func (g *UnitGroupTrait[A, W, WT]) Name() string <span class="cov8" title="1">{
        return fmt.Sprintf("U(Z/%sZ)*", g.Modulus().String())
}</span>

func (g *UnitGroupTrait[A, W, WT]) Order() cardinal.Cardinal <span class="cov8" title="1">{
        return g.arith.MultiplicativeOrder()
}</span>

func (g *UnitGroupTrait[A, W, WT]) OpIdentity() W <span class="cov0" title="0">{
        return g.One()
}</span>

func (g *UnitGroupTrait[A, W, WT]) One() W <span class="cov8" title="1">{
        var u WT
        W(&amp;u).set(g.zMod.One(), g.arith, g.n)
        return W(&amp;u)
}</span>

func (g *UnitGroupTrait[A, W, WT]) Random(prng io.Reader) (W, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                r, err := g.zMod.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
                <span class="cov8" title="1">var u WT
                W(&amp;u).set(r, g.arith, g.n)
                if W(&amp;u).Value().Lift().Coprime(g.Modulus().Lift()) </span><span class="cov8" title="1">{
                        return W(&amp;u), nil
                }</span>
        }
}

func (g *UnitGroupTrait[A, W, WT]) Hash(input []byte) (W, error) <span class="cov8" title="1">{
        xof, err := blake2b.NewXOF(uint32(g.WideElementSize()), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if _, err := xof.Write(input); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">digest := make([]byte, g.WideElementSize())
        var x, v numct.Nat
        for </span><span class="cov8" title="1">{
                if _, err = io.ReadFull(xof, digest); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
                <span class="cov8" title="1">if ok := x.SetBytes(digest); ok == ct.False </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("failed to interpret hash digest as Nat")
                }</span>
                // Perform modular reduction using the modulus from n
                <span class="cov8" title="1">g.zMod.ModulusCT().Mod(&amp;v, &amp;x)

                vNat, err := num.N().FromNatCT(&amp;v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>

                <span class="cov8" title="1">if g.zMod.Modulus().Nat().Coprime(vNat) </span><span class="cov8" title="1">{
                        uv, err := g.zMod.FromNat(vNat)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err)
                        }</span>
                        <span class="cov8" title="1">var zn WT
                        W(&amp;zn).set(uv, g.arith, g.n)
                        return W(&amp;zn), nil</span>
                }
        }
}

func (g *UnitGroupTrait[A, W, WT]) Modulus() *num.NatPlus <span class="cov8" title="1">{
        return g.zMod.Modulus()
}</span>

func (g *UnitGroupTrait[A, W, WT]) ModulusCT() *numct.Modulus <span class="cov8" title="1">{
        return g.zMod.Modulus().ModulusCT()
}</span>

func (g *UnitGroupTrait[A, W, WT]) ElementSize() int <span class="cov8" title="1">{
        return g.zMod.ElementSize()
}</span>

func (g *UnitGroupTrait[A, W, WT]) WideElementSize() int <span class="cov8" title="1">{
        return g.zMod.WideElementSize()
}</span>

func (g *UnitGroupTrait[A, W, WT]) FromNatCT(input *numct.Nat) (W, error) <span class="cov8" title="1">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("input must not be nil")
        }</span>
        <span class="cov8" title="1">elem, err := g.zMod.FromNatCT(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create element from nat")
        }</span>
        <span class="cov8" title="1">var out WT
        W(&amp;out).set(elem, g.arith, g.n)
        if !W(&amp;out).Value().Lift().Coprime(g.Modulus().Lift()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("input is not a unit")
        }</span>
        <span class="cov8" title="1">return W(&amp;out), nil</span>
}

func (g *UnitGroupTrait[A, W, WT]) FromUint(input *num.Uint) (W, error) <span class="cov8" title="1">{
        if input == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("input must not be nil")
        }</span>
        <span class="cov8" title="1">if !g.Modulus().Equal(input.Modulus()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("input is not in the same modulus")
        }</span>
        <span class="cov8" title="1">var out WT
        W(&amp;out).set(input.Clone(), g.arith, g.n)
        if !W(&amp;out).Value().Lift().Coprime(g.Modulus().Lift()) </span><span class="cov8" title="1">{
                return nil, ErrValue.WithMessage("input is not a unit")
        }</span>
        <span class="cov8" title="1">return W(&amp;out), nil</span>
}

func (g *UnitGroupTrait[A, W, WT]) FromBytes(input []byte) (W, error) <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("input must not be empty")
        }</span>
        <span class="cov0" title="0">v, err := g.zMod.FromBytes(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create unit from bytes")
        }</span>
        <span class="cov0" title="0">var out WT
        W(&amp;out).set(v, g.arith, g.n)
        if !W(&amp;out).Value().Lift().Coprime(g.Modulus().Lift()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("input is not a unit")
        }</span>
        <span class="cov0" title="0">return W(&amp;out), nil</span>
}

func (g *UnitGroupTrait[A, W, WT]) FromCardinal(input cardinal.Cardinal) (W, error) <span class="cov0" title="0">{
        elem, err := g.zMod.FromCardinal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create element from cardinal")
        }</span>
        <span class="cov0" title="0">var out WT
        W(&amp;out).set(elem, g.arith, g.n)
        if !W(&amp;out).Value().Lift().Coprime(g.Modulus().Lift()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("input is not a unit")
        }</span>
        <span class="cov0" title="0">return W(&amp;out), nil</span>
}

func (g *UnitGroupTrait[A, W, WT]) FromUint64(input uint64) (W, error) <span class="cov0" title="0">{
        elem, err := g.zMod.FromCardinal(cardinal.New(input))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create element from uint64")
        }</span>
        <span class="cov0" title="0">var out WT
        W(&amp;out).set(elem, g.arith, g.n)
        if !W(&amp;out).Value().Lift().Coprime(g.Modulus().Lift()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("input is not a unit")
        }</span>

        <span class="cov0" title="0">return W(&amp;out), nil</span>
}

func (g *UnitGroupTrait[A, W, WT]) AmbientGroup() *num.ZMod <span class="cov0" title="0">{
        return g.zMod
}</span>

func (g *UnitGroupTrait[A, W, WT]) AmbientStructure() algebra.Structure[*num.Uint] <span class="cov0" title="0">{
        return g.zMod
}</span>

func (*UnitGroupTrait[A, W, WT]) ScalarStructure() algebra.Structure[*num.Int] <span class="cov0" title="0">{
        return num.Z()
}</span>

func (g *UnitGroupTrait[A, W, WT]) Arithmetic() modular.Arithmetic <span class="cov0" title="0">{
        return g.arith
}</span>
</pre>
		
		<pre class="file" id="file166" style="display: none">package znstar

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

const PaillierKeyLen = base.IFCKeyLength

// SamplePaillierGroup generates a Paillier group with modulus of given bitlen.
func SamplePaillierGroup(keyLen uint, prng io.Reader) (*PaillierGroupKnownOrder, error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("prng")
        }</span>
        <span class="cov8" title="1">p, q, err := nt.GeneratePrimePair(num.NPlus(), keyLen/2, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to generate prime pair")
        }</span>
        <span class="cov8" title="1">return NewPaillierGroup(p, q)</span>
}

// NewPaillierGroup creates a Paillier group with known order from the given primes p and q.
func NewPaillierGroup(p, q *num.NatPlus) (*PaillierGroupKnownOrder, error) <span class="cov8" title="1">{
        if p == nil || q == nil </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("p and q must not be nil")
        }</span>
        <span class="cov8" title="1">if p.TrueLen() != q.TrueLen() </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("p and q must have the same length")
        }</span>
        <span class="cov8" title="1">if p.TrueLen() &lt; PaillierKeyLen/2 </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("p and q must be at least %d bits each", PaillierKeyLen/2)
        }</span>
        <span class="cov8" title="1">if !p.IsProbablyPrime() </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("p must be prime")
        }</span>
        <span class="cov8" title="1">if !q.IsProbablyPrime() </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("q must be prime")
        }</span>
        <span class="cov8" title="1">n := p.Mul(q)
        zMod, err := num.NewZMod(n.Square())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create ZMod")
        }</span>
        <span class="cov8" title="1">exp, ok := modular.NewOddPrimeSquareFactors(p.Value(), q.Value())
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("failed to create OddPrimeFactors")
        }</span>
        <span class="cov8" title="1">return &amp;PaillierGroupKnownOrder{
                UnitGroupTrait: UnitGroupTrait[*modular.OddPrimeSquareFactors, *PaillierGroupElement[*modular.OddPrimeSquareFactors], PaillierGroupElement[*modular.OddPrimeSquareFactors]]{
                        zMod:  zMod,
                        arith: exp,
                        n:     n,
                },
        }, nil</span>
}

// NewPaillierGroupOfUnknownOrder creates a Paillier group with unknown order from the given modulus n^2 and n.
func NewPaillierGroupOfUnknownOrder(n2, n *num.NatPlus) (*PaillierGroupUnknownOrder, error) <span class="cov8" title="1">{
        if n.TrueLen() &lt; PaillierKeyLen-1 </span><span class="cov8" title="1">{
                return nil, ErrValue.WithMessage("modulus n must be at least %d bits", PaillierKeyLen-1)
        }</span>
        <span class="cov8" title="1">if !n.Mul(n).Equal(n2) </span><span class="cov8" title="1">{
                return nil, ErrValue.WithMessage("n isn't sqrt of n")
        }</span>
        <span class="cov8" title="1">zMod, err := num.NewZMod(n2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create ZMod")
        }</span>
        <span class="cov8" title="1">arith, ok := modular.NewSimple(zMod.Modulus().ModulusCT())
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("failed to create SimpleModulus")
        }</span>

        <span class="cov8" title="1">return &amp;PaillierGroupUnknownOrder{
                UnitGroupTrait: UnitGroupTrait[*modular.SimpleModulus, *PaillierGroupElement[*modular.SimpleModulus], PaillierGroupElement[*modular.SimpleModulus]]{
                        zMod:  zMod,
                        arith: arith,
                        n:     n,
                },
        }, nil</span>
}

// ArithmeticPaillier defines the supported arithmetic types for Paillier groups.
type ArithmeticPaillier interface {
        *modular.SimpleModulus | *modular.OddPrimeSquareFactors
        modular.Arithmetic
}

type (
        // PaillierGroupKnownOrder defines a Paillier group with known order.
        PaillierGroupKnownOrder = PaillierGroup[*modular.OddPrimeSquareFactors]
        // PaillierGroupUnknownOrder defines a Paillier group with unknown order.
        PaillierGroupUnknownOrder = PaillierGroup[*modular.SimpleModulus]

        // PaillierGroupElementKnownOrder defines a Paillier group element with known order.
        PaillierGroupElementKnownOrder = PaillierGroupElement[*modular.OddPrimeSquareFactors]
        // PaillierGroupElementUnknownOrder defines a Paillier group element with unknown order.
        PaillierGroupElementUnknownOrder = PaillierGroupElement[*modular.SimpleModulus]
)

// PaillierGroup defines a Paillier group structure.
// X is the arithmetic type used for the group and determines whether the group has known or unknown order.
type PaillierGroup[X ArithmeticPaillier] struct {
        UnitGroupTrait[X, *PaillierGroupElement[X], PaillierGroupElement[X]]
}

// Equal checks if two Paillier groups are equal.
func (g *PaillierGroup[X]) Equal(other *PaillierGroup[X]) bool <span class="cov8" title="1">{
        return g.zMod.Modulus().Equal(other.zMod.Modulus()) &amp;&amp; g.Order().IsUnknown() == other.Order().IsUnknown()
}</span>

// N returns the Paillier modulus n.
func (g *PaillierGroup[X]) N() *num.NatPlus <span class="cov8" title="1">{
        return g.n
}</span>

// EmbedRSA embeds an RSA unit into the Paillier group as a Paillier unit.
func (g *PaillierGroup[X]) EmbedRSA(u *RSAGroupElementUnknownOrder) (*PaillierGroupElement[X], error) <span class="cov8" title="1">{
        if u == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("u")
        }</span>
        <span class="cov8" title="1">if !g.n.Equal(u.Modulus()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("unit is not in the correct RSA group")
        }</span>
        <span class="cov8" title="1">v, err := num.NewUintGivenModulus(u.Value().Value(), g.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to embed RSA unit into Paillier unit")
        }</span>
        <span class="cov8" title="1">return &amp;PaillierGroupElement[X]{
                UnitTrait: UnitTrait[X, *PaillierGroupElement[X], PaillierGroupElement[X]]{
                        v:     v,
                        arith: g.arith,
                        n:     g.n,
                },
        }, nil</span>
}

// NthResidue computes the n-th residue of a Paillier group element of unknown order.
func (g *PaillierGroup[X]) NthResidue(u *PaillierGroupElementUnknownOrder) (*PaillierGroupElement[X], error) <span class="cov8" title="1">{
        if u == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("argument must not be nil")
        }</span>
        <span class="cov8" title="1">if !u.Modulus().Equal(g.Modulus()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("argument must be in the paillier group with modulus equal to the Paillier modulus")
        }</span>
        <span class="cov8" title="1">pu, err := g.FromNatCT(u.Value().Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to lift rsaUnit to Paillier group")
        }</span>
        <span class="cov8" title="1">lift, ok := any(g.arith).(interface {
                ExpToN(out, base *numct.Nat) //nolint:revive // base shadows an import but here it's clearer.
        })
        if !ok </span><span class="cov0" title="0">{
                return pu.Exp(g.n.Nat()), nil
        }</span>
        <span class="cov8" title="1">var out numct.Nat
        lift.ExpToN(&amp;out, pu.Value().Value())
        v, err := num.NewUintGivenModulus(&amp;out, g.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create unit from lifted value")
        }</span>
        <span class="cov8" title="1">return &amp;PaillierGroupElement[X]{
                UnitTrait: UnitTrait[X, *PaillierGroupElement[X], PaillierGroupElement[X]]{
                        v:     v,
                        arith: g.arith,
                        n:     g.n,
                },
        }, nil</span>
}

// Representative computes the representative of a plaintext in the Paillier group. It is equivalent to computing (1 + m*n) mod n^2.
func (g *PaillierGroup[X]) Representative(plaintext *numct.Int) (*PaillierGroupElement[X], error) <span class="cov8" title="1">{
        if g.N().ModulusCT().IsInRangeSymmetric(plaintext) == ct.False </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("plaintext is out of range: |plaintext| &gt;= n/2")
        }</span>
        <span class="cov8" title="1">var shiftedPlaintext numct.Nat
        g.N().ModulusCT().ModI(&amp;shiftedPlaintext, plaintext)
        var out numct.Nat
        g.ModulusCT().ModMul(&amp;out, &amp;shiftedPlaintext, g.N().Value())
        out.Increment()
        return g.FromNatCT(&amp;out)</span>
}

// ForgetOrder returns a Paillier group with unknown order.
func (g *PaillierGroup[X]) ForgetOrder() *PaillierGroupUnknownOrder <span class="cov8" title="1">{
        arith, ok := modular.NewSimple(g.zMod.Modulus().ModulusCT())
        if ok == ct.False </span><span class="cov0" title="0">{
                panic(ErrFailed.WithMessage("failed to create SimpleModulus"))</span>
        }
        <span class="cov8" title="1">return &amp;PaillierGroupUnknownOrder{
                UnitGroupTrait: UnitGroupTrait[*modular.SimpleModulus, *PaillierGroupElement[*modular.SimpleModulus], PaillierGroupElement[*modular.SimpleModulus]]{
                        zMod:  g.zMod,
                        arith: arith,
                        n:     g.n,
                },
        }</span>
}

// PaillierGroupElement defines a Paillier group element.
// X is the arithmetic type used for the group element and determines whether the group has known or unknown order.
type PaillierGroupElement[X ArithmeticPaillier] struct {
        UnitTrait[X, *PaillierGroupElement[X], PaillierGroupElement[X]]
}

// Clone creates a copy of the Paillier group element.
func (u *PaillierGroupElement[X]) Clone() *PaillierGroupElement[X] <span class="cov0" title="0">{
        return &amp;PaillierGroupElement[X]{
                UnitTrait: UnitTrait[X, *PaillierGroupElement[X], PaillierGroupElement[X]]{
                        v:     u.v.Clone(),
                        arith: u.arith,
                        n:     u.n,
                },
        }
}</span>

// Structure returns the Paillier group structure of the element.
func (u *PaillierGroupElement[X]) Structure() algebra.Structure[*PaillierGroupElement[X]] <span class="cov0" title="0">{
        return &amp;PaillierGroup[X]{
                UnitGroupTrait: UnitGroupTrait[X, *PaillierGroupElement[X], PaillierGroupElement[X]]{
                        zMod:  u.v.Group(),
                        arith: u.arith,
                        n:     u.n,
                },
        }
}</span>

// LearnOrder converts a Paillier group element of unknown order to one with known order.
func (u *PaillierGroupElement[X]) LearnOrder(g *PaillierGroupKnownOrder) (*PaillierGroupElementKnownOrder, error) <span class="cov8" title="1">{
        if g == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("g")
        }</span>
        <span class="cov8" title="1">if !u.n.Equal(g.n) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("unit is not in the correct Paillier group")
        }</span>
        <span class="cov8" title="1">return &amp;PaillierGroupElementKnownOrder{
                UnitTrait: UnitTrait[*modular.OddPrimeSquareFactors, *PaillierGroupElementKnownOrder, PaillierGroupElementKnownOrder]{
                        v:     u.v.Clone(),
                        arith: g.arith,
                        n:     g.n,
                },
        }, nil</span>
}

// ForgetOrder converts a Paillier group element with known order to one with unknown order.
func (u *PaillierGroupElement[X]) ForgetOrder() *PaillierGroupElementUnknownOrder <span class="cov8" title="1">{
        arith, ok := modular.NewSimple(u.v.Group().Modulus().ModulusCT())
        if ok == ct.False </span><span class="cov0" title="0">{
                panic(ErrFailed.WithMessage("failed to create SimpleModulus"))</span>
        }
        <span class="cov8" title="1">return &amp;PaillierGroupElementUnknownOrder{
                UnitTrait: UnitTrait[*modular.SimpleModulus, *PaillierGroupElementUnknownOrder, PaillierGroupElementUnknownOrder]{
                        v:     u.v.Clone(),
                        arith: arith,
                        n:     u.n,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">package znstar

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
)

const RSAKeyLen = base.IFCKeyLength

// SampleRSAGroup generates an RSA group with keyLen of the given bit length.
func SampleRSAGroup(keyLen uint, prng io.Reader) (*RSAGroupKnownOrder, error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("prng")
        }</span>
        <span class="cov8" title="1">p, q, err := nt.GeneratePrimePair(num.NPlus(), keyLen/2, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to generate prime pair")
        }</span>
        <span class="cov8" title="1">return NewRSAGroup(p, q)</span>
}

// SampleRSAGroup generates an RSA group with random primes of the given bit length.
func NewRSAGroup(p, q *num.NatPlus) (*RSAGroupKnownOrder, error) <span class="cov8" title="1">{
        if p == nil || q == nil </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("p and q must not be nil")
        }</span>
        <span class="cov8" title="1">if p.TrueLen() != q.TrueLen() </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("p and q must have the same length")
        }</span>
        <span class="cov8" title="1">if p.TrueLen() &lt; RSAKeyLen/2 </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("p and q must be at least %d bits each", RSAKeyLen/2)
        }</span>
        <span class="cov8" title="1">if !p.IsProbablyPrime() </span><span class="cov8" title="1">{
                return nil, ErrValue.WithMessage("p must be prime")
        }</span>
        <span class="cov8" title="1">if !q.IsProbablyPrime() </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("q must be prime")
        }</span>
        <span class="cov8" title="1">n := p.Mul(q)
        zMod, err := num.NewZMod(n)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create ZMod")
        }</span>
        <span class="cov8" title="1">arith, ok := modular.NewOddPrimeFactors(p.Value(), q.Value())
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("failed to create OddPrimeFactors")
        }</span>
        <span class="cov8" title="1">return &amp;RSAGroupKnownOrder{
                UnitGroupTrait: UnitGroupTrait[*modular.OddPrimeFactors, *RSAGroupElement[*modular.OddPrimeFactors], RSAGroupElement[*modular.OddPrimeFactors]]{
                        zMod:  zMod,
                        arith: arith,
                        n:     n,
                },
        }, nil</span>
}

// NewRSAGroupOfUnknownOrder creates an RSA group with unknown order from the given modulus m.
func NewRSAGroupOfUnknownOrder(m *num.NatPlus) (*RSAGroupUnknownOrder, error) <span class="cov8" title="1">{
        if m.TrueLen() &lt; RSAKeyLen </span><span class="cov8" title="1">{
                return nil, ErrValue.WithMessage("modulus must be at least %d bits", RSAKeyLen)
        }</span>
        <span class="cov8" title="1">zMod, err := num.NewZMod(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create ZMod")
        }</span>
        <span class="cov8" title="1">arith, ok := modular.NewSimple(zMod.Modulus().ModulusCT())
        if ok == ct.False </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("failed to create SimpleModulus")
        }</span>
        <span class="cov8" title="1">return &amp;RSAGroupUnknownOrder{
                UnitGroupTrait: UnitGroupTrait[*modular.SimpleModulus, *RSAGroupElement[*modular.SimpleModulus], RSAGroupElement[*modular.SimpleModulus]]{
                        zMod:  zMod,
                        arith: arith,
                        n:     m,
                },
        }, nil</span>
}

// ArithmeticRSA defines the arithmetic types used in RSA groups.
type ArithmeticRSA interface {
        *modular.SimpleModulus | *modular.OddPrimeFactors
        modular.Arithmetic
}

type (
        // RSAGroupKnownOrder defines an RSA group with known order.
        RSAGroupKnownOrder = RSAGroup[*modular.OddPrimeFactors]
        // RSAGroupUnknownOrder defines an RSA group with unknown order.
        RSAGroupUnknownOrder = RSAGroup[*modular.SimpleModulus]

        // RSAGroupElementKnownOrder defines an RSA group element with known order.
        RSAGroupElementKnownOrder = RSAGroupElement[*modular.OddPrimeFactors]
        // RSAGroupElementUnknownOrder defines an RSA group element with unknown order.
        RSAGroupElementUnknownOrder = RSAGroupElement[*modular.SimpleModulus]
)

// RSAGroup defines an RSA unit group.
// X is the arithmetic type used for the group and determines whether the group has known or unknown order.
type RSAGroup[X ArithmeticRSA] struct {
        UnitGroupTrait[X, *RSAGroupElement[X], RSAGroupElement[X]]
}

// Equal checks if two RSA groups are equal.
func (g *RSAGroup[X]) Equal(other *RSAGroup[X]) bool <span class="cov8" title="1">{
        return g.zMod.Modulus().Equal(other.zMod.Modulus()) &amp;&amp; g.Order().IsUnknown() == other.Order().IsUnknown()
}</span>

// ForgetOrder converts an RSA group with known order to one with unknown order.
func (g *RSAGroup[X]) ForgetOrder() *RSAGroupUnknownOrder <span class="cov8" title="1">{
        arith, ok := modular.NewSimple(g.zMod.Modulus().ModulusCT())
        if ok == ct.False </span><span class="cov0" title="0">{
                panic(ErrFailed.WithMessage("failed to create SimpleModulus"))</span>
        }
        <span class="cov8" title="1">return &amp;RSAGroupUnknownOrder{
                UnitGroupTrait: UnitGroupTrait[*modular.SimpleModulus, *RSAGroupElement[*modular.SimpleModulus], RSAGroupElement[*modular.SimpleModulus]]{
                        zMod:  g.zMod,
                        arith: arith,
                        n:     g.n,
                },
        }</span>
}

// RSAGroupElement defines an RSA group element.
// X is the arithmetic type used for the group element and determines whether the group has known or unknown order.
type RSAGroupElement[X ArithmeticRSA] struct {
        UnitTrait[X, *RSAGroupElement[X], RSAGroupElement[X]]
}

// Clone creates a copy of the RSA group element.
func (u *RSAGroupElement[X]) Clone() *RSAGroupElement[X] <span class="cov0" title="0">{
        return &amp;RSAGroupElement[X]{
                UnitTrait: UnitTrait[X, *RSAGroupElement[X], RSAGroupElement[X]]{
                        v:     u.v.Clone(),
                        arith: u.arith,
                        n:     u.n,
                },
        }
}</span>

// Structure returns the RSA group structure of the element.
func (u *RSAGroupElement[X]) Structure() algebra.Structure[*RSAGroupElement[X]] <span class="cov0" title="0">{
        return &amp;RSAGroup[X]{
                UnitGroupTrait: UnitGroupTrait[X, *RSAGroupElement[X], RSAGroupElement[X]]{
                        zMod:  u.v.Group(),
                        arith: u.arith,
                        n:     u.n,
                },
        }
}</span>

// LearnOrder converts an RSA group element of unknown order to one with known order.
func (u *RSAGroupElement[X]) LearnOrder(g *RSAGroupKnownOrder) (*RSAGroupElementKnownOrder, error) <span class="cov8" title="1">{
        if g == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("g")
        }</span>
        <span class="cov8" title="1">if !u.v.Group().Modulus().Equal(g.zMod.Modulus()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("unit is not in the correct RSA group")
        }</span>
        <span class="cov8" title="1">return &amp;RSAGroupElementKnownOrder{
                UnitTrait: UnitTrait[*modular.OddPrimeFactors, *RSAGroupElementKnownOrder, RSAGroupElementKnownOrder]{
                        v:     u.v.Clone(),
                        arith: g.arith,
                        n:     g.n,
                },
        }, nil</span>
}

// ForgetOrder converts an RSA group element with known order to one with unknown order.
func (u *RSAGroupElement[X]) ForgetOrder() *RSAGroupElementUnknownOrder <span class="cov8" title="1">{
        arith, ok := modular.NewSimple(u.v.Group().Modulus().ModulusCT())
        if ok == ct.False </span><span class="cov0" title="0">{
                panic(ErrFailed.WithMessage("failed to create SimpleModulus"))</span>
        }
        <span class="cov8" title="1">return &amp;RSAGroupElementUnknownOrder{
                UnitTrait: UnitTrait[*modular.SimpleModulus, *RSAGroupElementUnknownOrder, RSAGroupElementUnknownOrder]{
                        v:     u.v.Clone(),
                        arith: arith,
                        n:     u.n,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package znstar

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

type UnitTrait[A modular.Arithmetic, W unitWrapperPtrConstraint[A, WT], WT any] struct {
        v     *num.Uint
        arith A
        n     *num.NatPlus
}

func (u *UnitTrait[A, W, WT]) Value() *num.Uint <span class="cov8" title="1">{
        return u.v
}</span>

func (u *UnitTrait[A, W, WT]) Arithmetic() A <span class="cov8" title="1">{
        return u.arith
}</span>

func (u *UnitTrait[A, W, WT]) set(v *num.Uint, arith A, n *num.NatPlus) <span class="cov8" title="1">{
        u.v = v
        u.arith = arith
        u.n = n
}</span>

func (u *UnitTrait[A, W, WT]) IsUnknownOrder() bool <span class="cov8" title="1">{
        return u.arith.MultiplicativeOrder().IsUnknown()
}</span>

func (u *UnitTrait[A, W, WT]) Modulus() *num.NatPlus <span class="cov8" title="1">{
        return u.v.Modulus()
}</span>

func (u *UnitTrait[A, W, WT]) ModulusCT() *numct.Modulus <span class="cov8" title="1">{
        return u.arith.Modulus()
}</span>

func (u *UnitTrait[A, W, WT]) EqualModulus(other W) bool <span class="cov8" title="1">{
        return u.Modulus().Equal(other.Modulus())
}</span>

func (u *UnitTrait[A, W, WT]) Equal(other W) bool <span class="cov8" title="1">{
        return u.v.Equal(other.Value()) &amp;&amp; u.EqualModulus(other)
}</span>

func (u *UnitTrait[A, W, WT]) Op(other W) W <span class="cov0" title="0">{
        return u.Mul(other)
}</span>

func (u *UnitTrait[A, W, WT]) mustBeValid(other W) <span class="cov8" title="1">{
        if !u.EqualModulus(other) </span><span class="cov8" title="1">{
                panic("cannot multiply units with different moduli")</span>
        }
        <span class="cov8" title="1">if u.IsUnknownOrder() != other.IsUnknownOrder() </span><span class="cov0" title="0">{
                panic("cannot multiply units with different knowledge of order")</span>
        }
}

func (u *UnitTrait[A, W, WT]) Mul(other W) W <span class="cov8" title="1">{
        u.mustBeValid(other)
        var outCt numct.Nat
        u.arith.ModMul(&amp;outCt, u.v.Value(), other.Value().Value())
        v, err := num.NewUintGivenModulus(&amp;outCt, u.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">var out WT
        W(&amp;out).set(v, u.arith, u.n)
        return W(&amp;out)</span>
}

func (u *UnitTrait[A, W, WT]) Exp(exponent *num.Nat) W <span class="cov8" title="1">{
        var outCt numct.Nat
        u.arith.ModExp(&amp;outCt, u.v.Value(), exponent.Value())
        v, err := num.NewUintGivenModulus(&amp;outCt, u.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">var out WT
        W(&amp;out).set(v, u.arith, u.n)
        return W(&amp;out)</span>
}

func (u *UnitTrait[A, W, WT]) ExpBounded(exponent *num.Nat, bits uint) W <span class="cov0" title="0">{
        ex := exponent.Value().Clone()
        ex.Resize(int(bits))
        var outCt numct.Nat
        u.arith.ModExp(&amp;outCt, u.v.Value(), ex)
        v, err := num.NewUintGivenModulus(&amp;outCt, u.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">var out WT
        W(&amp;out).set(v, u.arith, u.n)
        return W(&amp;out)</span>
}

func (u *UnitTrait[A, W, WT]) ExpI(exponent *num.Int) W <span class="cov0" title="0">{
        var outCt numct.Nat
        u.arith.ModExpI(&amp;outCt, u.v.Value(), exponent.Value())
        v, err := num.NewUintGivenModulus(&amp;outCt, u.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">var out WT
        W(&amp;out).set(v, u.arith, u.n)
        return W(&amp;out)</span>
}

func (u *UnitTrait[A, W, WT]) ExpIBounded(exponent *num.Int, bits uint) W <span class="cov0" title="0">{
        ex := exponent.Value().Clone()
        ex.Resize(int(bits))
        var outCt numct.Nat
        u.arith.ModExpI(&amp;outCt, u.v.Value(), ex)
        v, err := num.NewUintGivenModulus(&amp;outCt, u.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">var out WT
        W(&amp;out).set(v, u.arith, u.n)
        return W(&amp;out)</span>
}

func (u *UnitTrait[A, W, WT]) Square() W <span class="cov0" title="0">{
        var outCt numct.Nat
        u.arith.ModMul(&amp;outCt, u.v.Value(), u.v.Value())
        v, err := num.NewUintGivenModulus(&amp;outCt, u.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">var out WT
        W(&amp;out).set(v, u.arith, u.n)
        return W(&amp;out)</span>
}

func (u *UnitTrait[A, W, WT]) TryInv() (W, error) <span class="cov8" title="1">{
        return u.Inv(), nil
}</span>

func (u *UnitTrait[A, W, WT]) Inv() W <span class="cov8" title="1">{
        var outCt numct.Nat
        u.arith.ModInv(&amp;outCt, u.v.Value())
        v, err := num.NewUintGivenModulus(&amp;outCt, u.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">var out WT
        W(&amp;out).set(v, u.arith, u.n)
        return W(&amp;out)</span>
}

func (u *UnitTrait[A, W, WT]) TryOpInv() (W, error) <span class="cov0" title="0">{
        return u.Inv(), nil
}</span>

func (u *UnitTrait[A, W, WT]) OpInv() W <span class="cov0" title="0">{
        return u.Inv()
}</span>

func (u *UnitTrait[A, W, WT]) IsOpIdentity() bool <span class="cov0" title="0">{
        return u.IsOne()
}</span>

func (u *UnitTrait[A, W, WT]) IsOne() bool <span class="cov8" title="1">{
        return u.v.IsOne()
}</span>

func (u *UnitTrait[A, W, WT]) TryDiv(other W) (W, error) <span class="cov8" title="1">{
        return u.Div(other), nil
}</span>

func (u *UnitTrait[A, W, WT]) Div(other W) W <span class="cov8" title="1">{
        u.mustBeValid(other)
        var outCt numct.Nat
        u.arith.ModDiv(&amp;outCt, u.v.Value(), other.Value().Value())
        v, err := num.NewUintGivenModulus(&amp;outCt, u.ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">var out WT
        W(&amp;out).set(v, u.arith, u.n)
        return W(&amp;out)</span>
}

func (u *UnitTrait[A, W, WT]) HashCode() base.HashCode <span class="cov0" title="0">{
        return u.v.HashCode().Combine(u.v.HashCode())
}</span>

func (*UnitTrait[A, W, WT]) IsTorsionFree() bool <span class="cov0" title="0">{
        return true
}</span>

func (u *UnitTrait[A, W, WT]) ScalarOp(scalar *num.Int) W <span class="cov0" title="0">{
        return u.ExpI(scalar)
}</span>

func (u *UnitTrait[A, W, WT]) ScalarExp(scalar *num.Int) W <span class="cov0" title="0">{
        return u.ExpI(scalar)
}</span>

func (u *UnitTrait[A, W, WT]) Cardinal() cardinal.Cardinal <span class="cov0" title="0">{
        return u.v.Cardinal()
}</span>

func (u *UnitTrait[A, W, WT]) Bytes() []byte <span class="cov0" title="0">{
        return u.v.Bytes()
}</span>

func (u *UnitTrait[A, W, WT]) String() string <span class="cov0" title="0">{
        return u.v.String()
}</span>
</pre>
		
		<pre class="file" id="file169" style="display: none">package base

import (
        "golang.org/x/exp/constraints"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

type (
        // PartialOrdering represents a partial ordering result.
        // It can take values: Incomparable, LessThan, Equal, GreaterThan.
        PartialOrdering int8
        // Ordering represents a total ordering result.
        // It can take values: LessThan, Equal, GreaterThan.
        Ordering int8
)

const (
        Incomparable PartialOrdering = -2
        LessThan     PartialOrdering = -1
        Equal        PartialOrdering = 0
        GreaterThan  PartialOrdering = 1
)

func orderString(o int) string <span class="cov8" title="1">{
        switch o </span>{
        case -2:<span class="cov8" title="1">
                return "Incomparable"</span>
        case 0:<span class="cov8" title="1">
                return "Equal"</span>
        case -1:<span class="cov8" title="1">
                return "LessThan"</span>
        case 1:<span class="cov8" title="1">
                return "GreaterThan"</span>
        default:<span class="cov0" title="0">
                return "Invalid"</span>
        }
}

// String returns the string representation of the PartialOrdering.
func (o PartialOrdering) String() string <span class="cov8" title="1">{
        return orderString(int(o))
}</span>

// String returns the string representation of the Ordering.
func (o Ordering) String() string <span class="cov8" title="1">{
        return orderString(int(o))
}</span>

// Is checks if the PartialOrdering is equal to the given Ordering.
func (o PartialOrdering) Is(other Ordering) bool <span class="cov8" title="1">{
        return o == PartialOrdering(other)
}</span>

// Is checks if the Ordering is equal to the given PartialOrdering.
func (o Ordering) Is(other PartialOrdering) bool <span class="cov8" title="1">{
        return other != Incomparable &amp;&amp; PartialOrdering(o) == other
}</span>

// IsLessThan checks if the PartialOrdering represents LessThan.
func (o PartialOrdering) IsLessThan() bool <span class="cov8" title="1">{
        return o == LessThan
}</span>

// IsLessThan checks if the Ordering represents LessThan.
func (o Ordering) IsLessThan() bool <span class="cov8" title="1">{
        return o == Ordering(LessThan)
}</span>

// IsGreaterThan checks if the PartialOrdering represents GreaterThan.
func (o PartialOrdering) IsGreaterThan() bool <span class="cov8" title="1">{
        return o == GreaterThan
}</span>

// IsGreaterThan checks if the Ordering represents GreaterThan.
func (o Ordering) IsGreaterThan() bool <span class="cov8" title="1">{
        return o == Ordering(GreaterThan)
}</span>

// IsEqual checks if the PartialOrdering represents Equal.
func (o PartialOrdering) IsEqual() bool <span class="cov8" title="1">{
        return o == Equal
}</span>

// IsEqual checks if the Ordering represents Equal.
func (o Ordering) IsEqual() bool <span class="cov8" title="1">{
        return o == Ordering(Equal)
}</span>

// IsIncomparable checks if the PartialOrdering represents Incomparable.
func (o PartialOrdering) IsIncomparable() bool <span class="cov8" title="1">{
        return o == Incomparable
}</span>

// Comparable represents types that can be compared.
type Comparable[E any] interface {
        // IsLessThanOrEqual checks if the receiver is less than or equal to rhs.
        IsLessThanOrEqual(rhs E) bool
}

// WithInternalPartialCompareMethod allows types to implement their own PartialCompare method.
type WithInternalPartialCompareMethod[E any] interface {
        // PartialCompare compares the receiver with rhs and returns a PartialOrdering.
        PartialCompare(rhs E) PartialOrdering
}

// WithInternalCompareMethod allows types to implement their own Compare method.
type WithInternalCompareMethod[E any] interface {
        // Compare compares the receiver with rhs and returns an Ordering.
        Compare(rhs E) Ordering
}

// PartialCompare compares two elements and returns their PartialOrdering.
// It prefers ct.Comparable if available for constant-time comparison.
func PartialCompare[E Comparable[E]](x, y E) PartialOrdering <span class="cov8" title="1">{
        // If the type implements ct.Comparable, use it for constant-time comparison
        if cmp, ok := any(x).(ct.Comparable[E]); ok </span><span class="cov8" title="1">{
                lt, eq, gt := cmp.Compare(y)
                return ParseOrderingFromMasks(lt, eq, gt)
        }</span>
        // Fallback: allow internal PartialCompare
        <span class="cov8" title="1">if xx, okx := any(x).(WithInternalPartialCompareMethod[E]); okx </span><span class="cov8" title="1">{
                return xx.PartialCompare(y)
        }</span>
        // Constant-time-ish fallback: always evaluate both directions
        <span class="cov8" title="1">xLeY := x.IsLessThanOrEqual(y)
        yLeX := y.IsLessThanOrEqual(x)
        switch </span>{
        case xLeY &amp;&amp; yLeX:<span class="cov8" title="1">
                return Equal</span>
        case xLeY:<span class="cov8" title="1">
                return LessThan</span>
        case yLeX:<span class="cov8" title="1">
                return GreaterThan</span>
        default:<span class="cov0" title="0">
                return Incomparable</span>
        }
}

// Compare compares two elements and returns their Ordering.
// It panics if the elements are Incomparable.
// It prefers ct.Comparable if available for constant-time comparison.
func Compare[E Comparable[E]](x, y E) Ordering <span class="cov8" title="1">{
        // Prefer ct.Comparable if available for constant-time
        if cmp, ok := any(x).(ct.Comparable[E]); ok </span><span class="cov8" title="1">{
                out := ParseOrderingFromMasks(cmp.Compare(y))
                if out == Incomparable </span><span class="cov0" title="0">{
                        panic(ErrIsIncomparable)</span>
                }
                <span class="cov8" title="1">return Ordering(out)</span>
        }
        // Fallback: allow internal Compare
        <span class="cov8" title="1">if xx, okx := any(x).(WithInternalCompareMethod[E]); okx </span><span class="cov8" title="1">{
                return xx.Compare(y)
        }</span>
        <span class="cov8" title="1">out := PartialCompare(x, y)
        if out == Incomparable </span><span class="cov0" title="0">{
                panic(ErrIsIncomparable)</span>
        }
        <span class="cov8" title="1">return Ordering(out)</span>
}

// ParseOrderingFromMasks parses a PartialOrdering from comparison masks.
func ParseOrderingFromMasks[F constraints.Integer](lt, eq, gt F) PartialOrdering <span class="cov8" title="1">{
        if gt != 0 </span><span class="cov8" title="1">{
                return GreaterThan
        }</span>
        <span class="cov8" title="1">if eq != 0 </span><span class="cov8" title="1">{
                return Equal
        }</span>
        <span class="cov8" title="1">if lt != 0 </span><span class="cov8" title="1">{
                return LessThan
        }</span>
        <span class="cov8" title="1">return Incomparable</span>
}

var (
        ErrIsIncomparable = errs2.New("elements are incomparable")
)
</pre>
		
		<pre class="file" id="file170" style="display: none">package polynomials

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

type moduleValuedPolynomialDTO[ME algebra.ModuleElement[ME, S], S algebra.RingElement[S]] struct {
        Coeffs []ME `cbor:"coefficients"`
}

func (p *ModuleValuedPolynomial[ME, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;moduleValuedPolynomialDTO[ME, S]{
                Coeffs: p.coeffs,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal polynomial")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (p *ModuleValuedPolynomial[ME, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*moduleValuedPolynomialDTO[ME, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(dto.Coeffs) == 0 </span><span class="cov0" title="0">{
                return ErrSerialisationFailed.WithMessage("empty coefficients")
        }</span>
        <span class="cov0" title="0">p.coeffs = dto.Coeffs
        return nil</span>
}

type polynomialDTO[RE algebra.RingElement[RE]] struct {
        Coeffs []RE `cbor:"coefficients"`
}

func (p *Polynomial[RE]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;polynomialDTO[RE]{
                Coeffs: p.coeffs,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal polynomial")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (p *Polynomial[RE]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*polynomialDTO[RE]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(dto.Coeffs) == 0 </span><span class="cov0" title="0">{
                return ErrSerialisationFailed.WithMessage("empty coefficients")
        }</span>
        <span class="cov0" title="0">p.coeffs = dto.Coeffs
        return nil</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">package lagrange

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials"
)

func InterpolateAt[FE algebra.FiniteFieldElement[FE]](nodes, values []FE, at FE) (FE, error) <span class="cov8" title="1">{
        var nilFE FE
        field := algebra.StructureMustBeAs[algebra.FiniteField[FE]](at.Structure())
        if len(nodes) != len(values) </span><span class="cov8" title="1">{
                return nilFE, polynomials.ErrLengthMismatch.WithMessage("nodes and values")
        }</span>
        <span class="cov8" title="1">if field == nil </span><span class="cov0" title="0">{
                return nilFE, polynomials.ErrValidation.WithMessage("field is nil")
        }</span>
        <span class="cov8" title="1">basis, err := BasisAt(nodes, at)
        if err != nil </span><span class="cov8" title="1">{
                return *new(FE), errs2.Wrap(err).WithMessage("could not create basis set")
        }</span>
        <span class="cov8" title="1">out := field.Zero()
        for i, yi := range values </span><span class="cov8" title="1">{
                out = out.Add(basis.Coefficients()[i].Mul(yi))
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func InterpolateInExponentAt[C algebra.ModuleElement[C, S], S algebra.FiniteFieldElement[S]](
        module algebra.FiniteModule[C, S],
        nodes []S,
        values []C,
        at S,
) (C, error) <span class="cov8" title="1">{
        if len(nodes) != len(values) </span><span class="cov8" title="1">{
                return *new(C), polynomials.ErrLengthMismatch.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if module == nil </span><span class="cov8" title="1">{
                return *new(C), polynomials.ErrValidation.WithMessage("module is nil")
        }</span>

        <span class="cov8" title="1">basisCoeffs, err := BasisAt(nodes, at)
        if err != nil </span><span class="cov8" title="1">{
                return *new(C), errs2.Wrap(err).WithMessage("could not compute basis at point")
        }</span>

        <span class="cov8" title="1">out := module.OpIdentity()
        for i, basisCoeff := range basisCoeffs.Coefficients() </span><span class="cov8" title="1">{
                out = out.Op(values[i].ScalarOp(basisCoeff))
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func BasisAt[FE algebra.FiniteFieldElement[FE]](xs []FE, at FE) (*polynomials.Polynomial[FE], error) <span class="cov8" title="1">{
        var err error
        coeffField := algebra.StructureMustBeAs[algebra.FiniteField[FE]](at.Structure())
        one := coeffField.One()
        terms := make([]FE, len(xs))
        for i := range xs </span><span class="cov8" title="1">{
                num := one
                den := one
                for j := range xs </span><span class="cov8" title="1">{
                        if i == j </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">num = num.Mul(at.Sub(xs[j]))    // (at - xj)
                        den = den.Mul(xs[i].Sub(xs[j]))</span> // (xi - xj)
                }
                <span class="cov8" title="1">terms[i], err = num.TryDiv(den)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, errs2.Wrap(err).WithMessage("could not divide numerator by denominator")
                }</span>
        }
        <span class="cov8" title="1">polyRing, err := polynomials.NewPolynomialRing(coeffField)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create polynomial ring")
        }</span>
        <span class="cov8" title="1">poly, err := polyRing.New(terms...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create polynomial")
        }</span>
        <span class="cov8" title="1">return poly, nil</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">package polynomials

import (
        "encoding/binary"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra/crtp"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
)

type PolynomialRing[RE algebra.RingElement[RE]] struct {
        ring algebra.FiniteRing[RE]
}

func (r *PolynomialRing[RE]) RandomPolynomial(degree int, prng io.Reader) (*Polynomial[RE], error) <span class="cov8" title="1">{
        constantTerm, err := r.ring.Random(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to sample random constant term")
        }</span>
        <span class="cov8" title="1">poly, err := r.RandomPolynomialWithConstantTerm(degree, constantTerm, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create random polynomial with constant term")
        }</span>
        <span class="cov8" title="1">return poly, nil</span>
}

func (r *PolynomialRing[RE]) RandomPolynomialWithConstantTerm(degree int, constantTerm RE, prng io.Reader) (*Polynomial[RE], error) <span class="cov8" title="1">{
        if degree &lt; 0 </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("degree is negative")
        }</span>

        <span class="cov8" title="1">var err error
        coeffs := make([]RE, degree+1)
        coeffs[0] = constantTerm.Clone()
        for i := 1; i &lt; degree; i++ </span><span class="cov8" title="1">{
                coeffs[i], err = r.ring.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to sample random coefficient")
                }</span>
        }
        <span class="cov8" title="1">coeffs[degree], err = algebrautils.RandomNonIdentity(r.ring, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to sample random leading coefficient")
        }</span>
        <span class="cov8" title="1">p := &amp;Polynomial[RE]{
                coeffs: coeffs,
        }
        return p, nil</span>
}

func (r *PolynomialRing[RE]) New(coeffs ...RE) (*Polynomial[RE], error) <span class="cov8" title="1">{
        if len(coeffs) == 0 </span><span class="cov8" title="1">{
                coeffs = []RE{r.ring.Zero()}
        }</span>
        <span class="cov8" title="1">for _, c := range coeffs </span><span class="cov8" title="1">{
                if utils.IsNil(c) </span><span class="cov8" title="1">{
                        return nil, ErrValidation.WithStackFrame()
                }</span>
        }

        <span class="cov8" title="1">return &amp;Polynomial[RE]{
                coeffs: coeffs,
        }, nil</span>
}

func (r *PolynomialRing[RE]) Name() string <span class="cov8" title="1">{
        return fmt.Sprintf("PolynomialRing[%s]", r.ring.Name())
}</span>

func (*PolynomialRing[RE]) Order() algebra.Cardinal <span class="cov8" title="1">{
        return cardinal.Infinite()
}</span>

func (r *PolynomialRing[RE]) FromBytes(inBytes []byte) (*Polynomial[RE], error) <span class="cov8" title="1">{
        if len(inBytes) == 0 </span><span class="cov8" title="1">{
                return nil, ErrValidation.WithMessage("empty input")
        }</span>

        <span class="cov8" title="1">coeffSize := r.ring.ElementSize()
        if len(inBytes)%coeffSize != 0 </span><span class="cov8" title="1">{
                return nil, ErrValidation.WithMessage("invalid input length")
        }</span>
        <span class="cov8" title="1">numCoeffs := len(inBytes) / coeffSize
        coeffs := make([]RE, numCoeffs)
        for i := range numCoeffs </span><span class="cov8" title="1">{
                start := i * coeffSize
                end := start + coeffSize
                var err error
                coeffs[i], err = r.ring.FromBytes(inBytes[start:end])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not parse coefficient")
                }</span>
        }
        <span class="cov8" title="1">poly, err := r.New(coeffs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create polynomial")
        }</span>
        <span class="cov8" title="1">return poly, nil</span>
}

func (*PolynomialRing[RE]) ElementSize() int <span class="cov8" title="1">{
        return -1
}</span>

func (r *PolynomialRing[RE]) Characteristic() algebra.Cardinal <span class="cov8" title="1">{
        return r.ring.Characteristic()
}</span>

func (r *PolynomialRing[RE]) OpIdentity() *Polynomial[RE] <span class="cov8" title="1">{
        return r.Zero()
}</span>

func (r *PolynomialRing[RE]) One() *Polynomial[RE] <span class="cov8" title="1">{
        return &amp;Polynomial[RE]{
                coeffs: []RE{r.ring.One()},
        }
}</span>

func (r *PolynomialRing[RE]) Zero() *Polynomial[RE] <span class="cov8" title="1">{
        return &amp;Polynomial[RE]{
                coeffs: []RE{r.ring.Zero()},
        }
}</span>

func (r *PolynomialRing[RE]) IsDomain() bool <span class="cov8" title="1">{
        return r.ring.IsDomain()
}</span>

func (r *PolynomialRing[RE]) ScalarStructure() algebra.Structure[RE] <span class="cov8" title="1">{
        return r.ring
}</span>

func NewPolynomialRing[RE algebra.RingElement[RE]](ring algebra.FiniteRing[RE]) (*PolynomialRing[RE], error) <span class="cov8" title="1">{
        r := &amp;PolynomialRing[RE]{
                ring: ring,
        }
        return r, nil
}</span>

type Polynomial[RE algebra.RingElement[RE]] struct {
        coeffs []RE
}

func (p *Polynomial[RE]) Coefficients() []RE <span class="cov8" title="1">{
        return p.coeffs
}</span>

func (p *Polynomial[RE]) CoefficientStructure() algebra.Ring[RE] <span class="cov8" title="1">{
        if len(p.coeffs) == 0 </span><span class="cov0" title="0">{
                panic("internal error: empty coeffs")</span>
        }
        <span class="cov8" title="1">return algebra.StructureMustBeAs[algebra.Ring[RE]](p.coeffs[0].Structure())</span>
}

func (p *Polynomial[RE]) Eval(at RE) RE <span class="cov8" title="1">{
        ring := algebra.StructureMustBeAs[algebra.FiniteRing[RE]](at.Structure())
        // although we always require a polynomial to have at least one coefficient (even if it's zero), we do not panic here
        if len(p.coeffs) == 0 </span><span class="cov0" title="0">{
                return ring.Zero()
        }</span>

        <span class="cov8" title="1">out := p.coeffs[len(p.coeffs)-1].Clone()
        for i := len(p.coeffs) - 2; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                out = out.Mul(at).Add(p.coeffs[i])
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (p *Polynomial[RE]) Structure() algebra.Structure[*Polynomial[RE]] <span class="cov8" title="1">{
        if len(p.coeffs) == 0 </span><span class="cov0" title="0">{
                panic("internal error: empty coeffs")</span>
        }

        <span class="cov8" title="1">underlyingRing := algebra.StructureMustBeAs[algebra.FiniteRing[RE]](p.coeffs[0].Structure())
        return &amp;PolynomialRing[RE]{
                ring: underlyingRing,
        }</span>
}

func (p *Polynomial[RE]) Bytes() []byte <span class="cov8" title="1">{
        out := make([]byte, 0, len(p.coeffs)*p.CoefficientStructure().ElementSize())
        for _, coeff := range p.coeffs </span><span class="cov8" title="1">{
                out = append(out, coeff.Bytes()...)
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (p *Polynomial[RE]) Clone() *Polynomial[RE] <span class="cov8" title="1">{
        clone := &amp;Polynomial[RE]{
                coeffs: make([]RE, len(p.coeffs)),
        }
        for i, c := range p.coeffs </span><span class="cov8" title="1">{
                clone.coeffs[i] = c.Clone()
        }</span>
        <span class="cov8" title="1">return clone</span>
}

func (p *Polynomial[RE]) Equal(rhs *Polynomial[RE]) bool <span class="cov8" title="1">{
        for i := range min(len(p.coeffs), len(rhs.coeffs)) </span><span class="cov8" title="1">{
                if !p.coeffs[i].Equal(rhs.coeffs[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for i := len(p.coeffs); i &lt; max(len(p.coeffs), len(rhs.coeffs)); i++ </span><span class="cov8" title="1">{
                if !rhs.coeffs[i].IsZero() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for i := len(rhs.coeffs); i &lt; max(len(p.coeffs), len(rhs.coeffs)); i++ </span><span class="cov8" title="1">{
                if !p.coeffs[i].IsZero() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (p *Polynomial[RE]) HashCode() base.HashCode <span class="cov8" title="1">{
        h := base.HashCode(0)
        for _, c := range p.coeffs </span><span class="cov8" title="1">{
                h ^= c.HashCode()
        }</span>
        <span class="cov8" title="1">return h</span>
}

func (p *Polynomial[RE]) String() string <span class="cov8" title="1">{
        repr := "["
        for _, c := range p.coeffs </span><span class="cov8" title="1">{
                repr += fmt.Sprintf("%s, ", c.String())
        }</span>
        <span class="cov8" title="1">repr += "]"
        return repr</span>
}

func (p *Polynomial[RE]) Op(e *Polynomial[RE]) *Polynomial[RE] <span class="cov8" title="1">{
        return p.Add(e)
}</span>

func (p *Polynomial[RE]) OtherOp(e *Polynomial[RE]) *Polynomial[RE] <span class="cov8" title="1">{
        return p.Mul(e)
}</span>

func (p *Polynomial[RE]) Add(e *Polynomial[RE]) *Polynomial[RE] <span class="cov8" title="1">{
        coeffs := make([]RE, max(len(p.coeffs), len(e.coeffs)))
        for i := range min(len(p.coeffs), len(e.coeffs)) </span><span class="cov8" title="1">{
                coeffs[i] = p.coeffs[i].Add(e.coeffs[i])
        }</span>
        <span class="cov8" title="1">for i := len(p.coeffs); i &lt; max(len(p.coeffs), len(e.coeffs)); i++ </span><span class="cov8" title="1">{
                coeffs[i] = e.coeffs[i].Clone()
        }</span>
        <span class="cov8" title="1">for i := len(e.coeffs); i &lt; max(len(p.coeffs), len(e.coeffs)); i++ </span><span class="cov8" title="1">{
                coeffs[i] = p.coeffs[i].Clone()
        }</span>
        <span class="cov8" title="1">return &amp;Polynomial[RE]{
                coeffs: coeffs,
        }</span>
}

func (p *Polynomial[RE]) Double() *Polynomial[RE] <span class="cov8" title="1">{
        return p.Add(p)
}</span>

func (p *Polynomial[RE]) Mul(e *Polynomial[RE]) *Polynomial[RE] <span class="cov8" title="1">{
        ring := algebra.StructureMustBeAs[algebra.FiniteRing[RE]](p.coeffs[0].Structure())
        coeffs := make([]RE, len(p.coeffs)+len(e.coeffs)-1)
        for i := range coeffs </span><span class="cov8" title="1">{
                coeffs[i] = ring.Zero()
        }</span>

        <span class="cov8" title="1">for l := range len(p.coeffs) </span><span class="cov8" title="1">{
                for r := range len(e.coeffs) </span><span class="cov8" title="1">{
                        coeffs[l+r] = coeffs[l+r].Add(p.coeffs[l].Mul(e.coeffs[r]))
                }</span>
        }
        <span class="cov8" title="1">return &amp;Polynomial[RE]{
                coeffs: coeffs,
        }</span>
}

func (p *Polynomial[RE]) Square() *Polynomial[RE] <span class="cov8" title="1">{
        return p.Mul(p)
}</span>

func (p *Polynomial[RE]) IsOpIdentity() bool <span class="cov8" title="1">{
        return p.IsZero()
}</span>

func (p *Polynomial[RE]) TryOpInv() (*Polynomial[RE], error) <span class="cov8" title="1">{
        return p.Neg(), nil
}</span>

func (p *Polynomial[RE]) IsOne() bool <span class="cov8" title="1">{
        if len(p.coeffs) &lt; 1 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i := len(p.coeffs) - 1; i &gt;= 1; i-- </span><span class="cov0" title="0">{
                if !p.coeffs[i].IsZero() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return p.coeffs[0].IsOne()</span>
}

func (*Polynomial[RE]) TryInv() (*Polynomial[RE], error) <span class="cov8" title="1">{
        return nil, ErrOperationNotSupported.WithStackFrame()
}</span>

func (*Polynomial[RE]) TryDiv(e *Polynomial[RE]) (*Polynomial[RE], error) <span class="cov8" title="1">{
        return nil, ErrOperationNotSupported.WithStackFrame()
}</span>

func (p *Polynomial[RE]) IsZero() bool <span class="cov8" title="1">{
        if len(p.coeffs) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">for _, c := range p.coeffs </span><span class="cov8" title="1">{
                if !c.IsZero() </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (p *Polynomial[RE]) TryNeg() (*Polynomial[RE], error) <span class="cov8" title="1">{
        return p.Neg(), nil
}</span>

func (p *Polynomial[RE]) TrySub(e *Polynomial[RE]) (*Polynomial[RE], error) <span class="cov8" title="1">{
        return p.Sub(e), nil
}</span>

func (p *Polynomial[RE]) OpInv() *Polynomial[RE] <span class="cov8" title="1">{
        return p.Neg()
}</span>

func (p *Polynomial[RE]) Neg() *Polynomial[RE] <span class="cov8" title="1">{
        coeffs := make([]RE, len(p.coeffs))
        for i, c := range p.coeffs </span><span class="cov8" title="1">{
                coeffs[i] = c.Neg()
        }</span>
        <span class="cov8" title="1">return &amp;Polynomial[RE]{
                coeffs: coeffs,
        }</span>
}

func (p *Polynomial[RE]) Sub(e *Polynomial[RE]) *Polynomial[RE] <span class="cov8" title="1">{
        return p.Add(e.Neg())
}</span>

func (p *Polynomial[RE]) Degree() int <span class="cov8" title="1">{
        for i := len(p.coeffs) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if !p.coeffs[i].IsZero() </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (p *Polynomial[RE]) ConstantTerm() RE <span class="cov8" title="1">{
        return p.coeffs[0]
}</span>

func (p *Polynomial[RE]) Derivative() *Polynomial[RE] <span class="cov8" title="1">{
        ring := algebra.StructureMustBeAs[algebra.FiniteRing[RE]](p.coeffs[0].Structure())
        if len(p.coeffs) &lt;= 1 </span><span class="cov8" title="1">{
                return &amp;Polynomial[RE]{
                        coeffs: []RE{ring.Zero()},
                }
        }</span>
        <span class="cov8" title="1">derivCoeffs := make([]RE, len(p.coeffs)-1)
        for i := 1; i &lt; len(p.coeffs); i++ </span><span class="cov8" title="1">{
                // Create properly sized big-endian bytes for the index
                elemSize := ring.ElementSize()
                indexBytes := make([]byte, elemSize)
                binary.BigEndian.PutUint64(indexBytes[elemSize-8:], uint64(i))
                rb, err := ring.FromBytes(indexBytes)
                if err != nil </span><span class="cov0" title="0">{
                        panic("internal error: could not create ring element from uint64")</span>
                }
                <span class="cov8" title="1">derivCoeffs[i-1] = p.coeffs[i].Mul(rb)</span>
        }
        <span class="cov8" title="1">return &amp;Polynomial[RE]{
                coeffs: derivCoeffs,
        }</span>
}

func (p *Polynomial[RE]) EuclideanDiv(q *Polynomial[RE]) (quot, rem *Polynomial[RE], err error) <span class="cov8" title="1">{
        coeffField, err := algebra.StructureAs[crtp.Field[RE]](p.coeffs[0].Structure())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("coefficients ring is not a field")
        }</span>
        <span class="cov8" title="1">if q.IsZero() </span><span class="cov8" title="1">{
                return nil, nil, ErrDivisionByZero.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if p.IsZero() </span><span class="cov0" title="0">{
                zero := coeffField.Zero()
                return &amp;Polynomial[RE]{coeffs: []RE{zero}}, &amp;Polynomial[RE]{coeffs: []RE{zero.Clone()}}, nil
        }</span>

        <span class="cov8" title="1">rem = p.Clone()
        degQ := q.Degree()
        degR := rem.Degree()
        if degR &lt; degQ </span><span class="cov8" title="1">{
                return &amp;Polynomial[RE]{coeffs: []RE{coeffField.Zero()}}, rem, nil
        }</span>

        <span class="cov8" title="1">quotCoeffs := make([]RE, degR-degQ+1)
        for i := range quotCoeffs </span><span class="cov8" title="1">{
                quotCoeffs[i] = coeffField.Zero()
        }</span>

        <span class="cov8" title="1">lcQ := q.coeffs[degQ]
        for degR &gt;= degQ </span><span class="cov8" title="1">{
                lcR := rem.coeffs[degR]
                factor, err := lcR.TryDiv(lcQ)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("failed to divide leading coefficients")
                }</span>

                <span class="cov8" title="1">shift := degR - degQ
                quotCoeffs[shift] = factor

                for i := 0; i &lt;= degQ; i++ </span><span class="cov8" title="1">{
                        rem.coeffs[i+shift] = rem.coeffs[i+shift].Sub(q.coeffs[i].Mul(factor))
                }</span>

                <span class="cov8" title="1">for degR &gt;= 0 &amp;&amp; rem.coeffs[degR].IsZero() </span><span class="cov8" title="1">{
                        degR--
                }</span>
        }

        <span class="cov8" title="1">if degR &lt; 0 </span><span class="cov8" title="1">{
                rem = &amp;Polynomial[RE]{coeffs: []RE{coeffField.Zero()}}
        }</span> else<span class="cov8" title="1"> {
                rem = &amp;Polynomial[RE]{coeffs: rem.coeffs[:degR+1]}
        }</span>

        <span class="cov8" title="1">quot = &amp;Polynomial[RE]{coeffs: quotCoeffs}
        for len(quot.coeffs) &gt; 1 &amp;&amp; quot.coeffs[len(quot.coeffs)-1].IsZero() </span><span class="cov0" title="0">{
                quot.coeffs = quot.coeffs[:len(quot.coeffs)-1]
        }</span>

        <span class="cov8" title="1">return quot, rem, nil</span>
}

func (p *Polynomial[RE]) EuclideanValuation() algebra.Cardinal <span class="cov8" title="1">{
        deg := p.Degree()
        if deg &lt;= 0 </span><span class="cov8" title="1">{
                return cardinal.New(0)
        }</span>
        <span class="cov8" title="1">return cardinal.New(uint64(deg))</span>
}

func (p *Polynomial[RE]) IsConstant() bool <span class="cov8" title="1">{
        return p.Degree() == 0
}</span>

func (p *Polynomial[RE]) IsMonic() bool <span class="cov8" title="1">{
        deg := p.Degree()
        return deg &gt;= 0 &amp;&amp; p.coeffs[deg].IsOne()
}</span>

func (p *Polynomial[RE]) LeadingCoefficient() RE <span class="cov8" title="1">{
        deg := p.Degree()
        if deg &lt; 0 </span><span class="cov8" title="1">{
                return p.CoefficientStructure().Zero()
        }</span>
        <span class="cov8" title="1">return p.coeffs[deg]</span>
}

func (p *Polynomial[RE]) ScalarOp(s RE) *Polynomial[RE] <span class="cov8" title="1">{
        return p.ScalarMul(s)
}</span>

func (p *Polynomial[RE]) ScalarMul(s RE) *Polynomial[RE] <span class="cov8" title="1">{
        coeffs := make([]RE, len(p.coeffs))
        for i, c := range p.coeffs </span><span class="cov8" title="1">{
                coeffs[i] = c.Mul(s)
        }</span>
        <span class="cov8" title="1">return &amp;Polynomial[RE]{
                coeffs: coeffs,
        }</span>
}

func (p *Polynomial[RE]) IsTorsionFree() bool <span class="cov8" title="1">{
        _, err := algebra.StructureAs[crtp.Field[RE]](p.coeffs[0].Structure())
        return err == nil
}</span>

func (p *Polynomial[RE]) ScalarStructure() algebra.Ring[RE] <span class="cov8" title="1">{
        return p.CoefficientStructure()
}</span>
</pre>
		
		<pre class="file" id="file173" style="display: none">package polynomials

import (
        "encoding/binary"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/cardinal"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
)

func LiftPolynomial[ME algebra.ModuleElement[ME, RE], RE algebra.RingElement[RE]](poly *Polynomial[RE], baseElem algebra.ModuleElement[ME, RE]) (*ModuleValuedPolynomial[ME, RE], error) <span class="cov8" title="1">{
        coeffs := make([]ME, len(poly.coeffs))
        for i, c := range poly.coeffs </span><span class="cov8" title="1">{
                coeffs[i] = baseElem.ScalarOp(c)
        }</span>

        <span class="cov8" title="1">p := &amp;ModuleValuedPolynomial[ME, RE]{
                coeffs: coeffs,
        }
        return p, nil</span>
}

type PolynomialModule[ME algebra.ModuleElement[ME, S], S algebra.RingElement[S]] struct {
        module algebra.FiniteModule[ME, S]
}

func NewPolynomialModule[ME algebra.ModuleElement[ME, S], S algebra.RingElement[S]](module algebra.FiniteModule[ME, S]) (*PolynomialModule[ME, S], error) <span class="cov8" title="1">{
        if module == nil </span><span class="cov8" title="1">{
                return nil, ErrValidation.WithMessage("nil module")
        }</span>
        <span class="cov8" title="1">return &amp;PolynomialModule[ME, S]{module: module}, nil</span>
}

func (m *PolynomialModule[ME, S]) New(coeffs ...ME) (*ModuleValuedPolynomial[ME, S], error) <span class="cov8" title="1">{
        if len(coeffs) &lt; 1 </span><span class="cov8" title="1">{
                return m.OpIdentity(), nil
        }</span>
        <span class="cov8" title="1">for _, c := range coeffs </span><span class="cov8" title="1">{
                if utils.IsNil(c) </span><span class="cov8" title="1">{
                        return nil, ErrValidation.WithStackFrame()
                }</span>
        }

        <span class="cov8" title="1">return &amp;ModuleValuedPolynomial[ME, S]{
                coeffs: coeffs,
        }, nil</span>
}

func (m *PolynomialModule[ME, S]) Name() string <span class="cov8" title="1">{
        return fmt.Sprintf("PolynomialModule[%s, %s]", m.module.Name(), m.module.ScalarStructure().Name())
}</span>

func (m *PolynomialModule[ME, S]) RandomModuleValuedPolynomial(degree int, prng io.Reader) (*ModuleValuedPolynomial[ME, S], error) <span class="cov8" title="1">{
        if degree &lt; 0 </span><span class="cov8" title="1">{
                return nil, ErrValidation.WithMessage("negative degree")
        }</span>
        <span class="cov8" title="1">finiteModule := algebra.StructureMustBeAs[algebra.FiniteModule[ME, S]](m.module)
        constantTerm, err := finiteModule.Random(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to sample random constant term")
        }</span>
        <span class="cov8" title="1">poly, err := m.RandomModuleValuedPolynomialWithConstantTerm(degree, constantTerm, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create random polynomial with constant term")
        }</span>
        <span class="cov8" title="1">return poly, nil</span>
}

func (m *PolynomialModule[ME, S]) RandomModuleValuedPolynomialWithConstantTerm(degree int, constantTerm ME, prng io.Reader) (*ModuleValuedPolynomial[ME, S], error) <span class="cov8" title="1">{
        if degree &lt; 0 </span><span class="cov8" title="1">{
                return nil, ErrValidation.WithMessage("negative degree")
        }</span>

        <span class="cov8" title="1">finiteModule := algebra.StructureMustBeAs[algebra.FiniteModule[ME, S]](m.module)
        coeffs := make([]ME, degree+1)
        coeffs[0] = constantTerm.Clone()
        if degree == 0 </span><span class="cov8" title="1">{
                return &amp;ModuleValuedPolynomial[ME, S]{coeffs: coeffs}, nil
        }</span>
        <span class="cov8" title="1">for i := 1; i &lt; degree; i++ </span><span class="cov8" title="1">{
                var err error
                coeffs[i], err = finiteModule.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to sample random coefficient")
                }</span>
        }
        <span class="cov8" title="1">leading, err := algebrautils.RandomNonIdentity(finiteModule, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to sample random leading coefficient")
        }</span>
        <span class="cov8" title="1">coeffs[degree] = leading

        return &amp;ModuleValuedPolynomial[ME, S]{
                coeffs: coeffs,
        }, nil</span>
}

func (*PolynomialModule[ME, S]) Order() algebra.Cardinal <span class="cov8" title="1">{
        return cardinal.Infinite()
}</span>

func (m *PolynomialModule[ME, S]) FromBytes(bytes []byte) (*ModuleValuedPolynomial[ME, S], error) <span class="cov8" title="1">{
        coeffSize := m.module.ElementSize()
        if len(bytes) == 0 </span><span class="cov8" title="1">{
                return m.OpIdentity(), nil
        }</span>
        <span class="cov8" title="1">if (len(bytes) % coeffSize) != 0 </span><span class="cov8" title="1">{
                return nil, ErrValidation.WithMessage("invalid input length")
        }</span>

        <span class="cov8" title="1">numCoeffs := len(bytes) / coeffSize
        coeffs := make([]ME, numCoeffs)
        for i := range numCoeffs </span><span class="cov8" title="1">{
                start := i * coeffSize
                end := start + coeffSize
                c, err := m.module.FromBytes(bytes[start:end])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to deserialize coefficient")
                }</span>
                <span class="cov8" title="1">coeffs[i] = c</span>
        }
        <span class="cov8" title="1">poly, err := m.New(coeffs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create polynomial from deserialized coefficients")
        }</span>
        <span class="cov8" title="1">return poly, nil</span>
}

func (*PolynomialModule[ME, S]) ElementSize() int <span class="cov8" title="1">{
        return -1
}</span>

func (m *PolynomialModule[ME, S]) OpIdentity() *ModuleValuedPolynomial[ME, S] <span class="cov8" title="1">{
        return &amp;ModuleValuedPolynomial[ME, S]{coeffs: []ME{m.module.OpIdentity()}}
}</span>

func (m *PolynomialModule[ME, S]) ScalarStructure() algebra.Structure[S] <span class="cov8" title="1">{
        return m.module.ScalarStructure()
}</span>

func (m *PolynomialModule[ME, S]) MultiScalarOp(scalars []S, elements []*ModuleValuedPolynomial[ME, S]) (*ModuleValuedPolynomial[ME, S], error) <span class="cov8" title="1">{
        if len(scalars) != len(elements) </span><span class="cov8" title="1">{
                return nil, ErrLengthMismatch.WithMessage("scalar and elements mismatch")
        }</span>
        <span class="cov8" title="1">if len(scalars) == 0 </span><span class="cov8" title="1">{
                return nil, ErrValidation.WithMessage("empty input")
        }</span>

        <span class="cov8" title="1">out := m.OpIdentity()
        for i, pi := range elements </span><span class="cov8" title="1">{
                out = out.Op(pi.ScalarOp(scalars[i]))
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

type ModuleValuedPolynomial[ME algebra.ModuleElement[ME, S], S algebra.RingElement[S]] struct {
        coeffs []ME
}

func (p *ModuleValuedPolynomial[ME, S]) Structure() algebra.Structure[*ModuleValuedPolynomial[ME, S]] <span class="cov8" title="1">{
        if len(p.coeffs) == 0 </span><span class="cov0" title="0">{
                panic("internal error: empty coeffs")</span>
        }

        <span class="cov8" title="1">module := algebra.StructureMustBeAs[algebra.FiniteModule[ME, S]](p.coeffs[0].Structure())
        return &amp;PolynomialModule[ME, S]{
                module: module,
        }</span>
}

func (p *ModuleValuedPolynomial[ME, S]) CoefficientStructure() algebra.FiniteModule[ME, S] <span class="cov8" title="1">{
        if len(p.coeffs) == 0 </span><span class="cov0" title="0">{
                panic("internal error: empty coeffs")</span>
        }
        <span class="cov8" title="1">return algebra.StructureMustBeAs[algebra.FiniteModule[ME, S]](p.coeffs[0].Structure())</span>
}

func (p *ModuleValuedPolynomial[ME, S]) ScalarStructure() algebra.Ring[S] <span class="cov8" title="1">{
        return algebra.StructureMustBeAs[algebra.Ring[S]](p.CoefficientStructure().ScalarStructure())
}</span>

func (p *ModuleValuedPolynomial[ME, S]) ConstantTerm() ME <span class="cov8" title="1">{
        return p.coeffs[0]
}</span>

func (p *ModuleValuedPolynomial[ME, S]) IsConstant() bool <span class="cov8" title="1">{
        return p.Degree() &lt;= 0
}</span>

func (p *ModuleValuedPolynomial[ME, S]) LeadingCoefficient() ME <span class="cov8" title="1">{
        deg := p.Degree()
        if deg &lt; 0 </span><span class="cov8" title="1">{
                return p.CoefficientStructure().OpIdentity()
        }</span>
        <span class="cov8" title="1">return p.coeffs[deg]</span>
}

func (p *ModuleValuedPolynomial[ME, S]) PolynomialOp(poly *Polynomial[S]) *ModuleValuedPolynomial[ME, S] <span class="cov8" title="1">{
        if len(p.coeffs) == 0 || len(poly.coeffs) == 0 </span><span class="cov0" title="0">{
                return p.Clone()
        }</span>
        <span class="cov8" title="1">module := p.CoefficientStructure()
        coeffs := make([]ME, len(p.coeffs)+len(poly.coeffs)-1)
        for i := range coeffs </span><span class="cov8" title="1">{
                coeffs[i] = module.OpIdentity()
        }</span>
        <span class="cov8" title="1">for i := range p.coeffs </span><span class="cov8" title="1">{
                for j := range poly.coeffs </span><span class="cov8" title="1">{
                        coeffs[i+j] = coeffs[i+j].Op(p.coeffs[i].ScalarOp(poly.coeffs[j]))
                }</span>
        }
        <span class="cov8" title="1">return &amp;ModuleValuedPolynomial[ME, S]{
                coeffs: coeffs,
        }</span>
}

func (p *ModuleValuedPolynomial[ME, S]) Derivative() *ModuleValuedPolynomial[ME, S] <span class="cov8" title="1">{
        if len(p.coeffs) &lt;= 1 </span><span class="cov8" title="1">{
                return &amp;ModuleValuedPolynomial[ME, S]{
                        coeffs: []ME{p.CoefficientStructure().OpIdentity()},
                }
        }</span>
        <span class="cov8" title="1">ring := algebra.StructureMustBeAs[algebra.FiniteRing[S]](p.ScalarStructure())
        derivCoeffs := make([]ME, len(p.coeffs)-1)
        for i := 1; i &lt; len(p.coeffs); i++ </span><span class="cov8" title="1">{
                // Create properly sized big-endian bytes for the index
                elemSize := ring.ElementSize()
                indexBytes := make([]byte, elemSize)
                binary.BigEndian.PutUint64(indexBytes[elemSize-8:], uint64(i))
                rb, err := ring.FromBytes(indexBytes)
                if err != nil </span><span class="cov0" title="0">{
                        panic("internal error: could not create ring element from uint64")</span>
                }
                <span class="cov8" title="1">derivCoeffs[i-1] = p.coeffs[i].ScalarOp(rb)</span>
        }
        <span class="cov8" title="1">return &amp;ModuleValuedPolynomial[ME, S]{
                coeffs: derivCoeffs,
        }</span>
}

func (p *ModuleValuedPolynomial[ME, S]) Bytes() []byte <span class="cov8" title="1">{
        out := make([]byte, 0, len(p.coeffs)*p.CoefficientStructure().ElementSize())
        for _, c := range p.coeffs </span><span class="cov8" title="1">{
                out = append(out, c.Bytes()...)
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (p *ModuleValuedPolynomial[ME, S]) Clone() *ModuleValuedPolynomial[ME, S] <span class="cov8" title="1">{
        coeffs := make([]ME, len(p.coeffs))
        for i, c := range p.coeffs </span><span class="cov8" title="1">{
                coeffs[i] = c.Clone()
        }</span>
        <span class="cov8" title="1">return &amp;ModuleValuedPolynomial[ME, S]{
                coeffs: coeffs,
        }</span>
}

func (p *ModuleValuedPolynomial[ME, S]) Equal(rhs *ModuleValuedPolynomial[ME, S]) bool <span class="cov8" title="1">{
        for i := range min(len(p.coeffs), len(rhs.coeffs)) </span><span class="cov8" title="1">{
                if !p.coeffs[i].Equal(rhs.coeffs[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for i := len(p.coeffs); i &lt; max(len(p.coeffs), len(rhs.coeffs)); i++ </span><span class="cov8" title="1">{
                if !rhs.coeffs[i].IsOpIdentity() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">for i := len(rhs.coeffs); i &lt; max(len(p.coeffs), len(rhs.coeffs)); i++ </span><span class="cov8" title="1">{
                if !p.coeffs[i].IsOpIdentity() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (p *ModuleValuedPolynomial[ME, S]) HashCode() base.HashCode <span class="cov8" title="1">{
        h := base.HashCode(0)
        for _, c := range p.coeffs </span><span class="cov8" title="1">{
                h ^= c.HashCode()
        }</span>
        <span class="cov8" title="1">return h</span>
}

func (p *ModuleValuedPolynomial[ME, S]) String() string <span class="cov8" title="1">{
        repr := "["
        for _, c := range p.coeffs </span><span class="cov8" title="1">{
                repr += fmt.Sprintf("%s, ", c.String())
        }</span>
        <span class="cov8" title="1">repr += "]"
        return repr</span>
}

func (p *ModuleValuedPolynomial[ME, S]) Op(e *ModuleValuedPolynomial[ME, S]) *ModuleValuedPolynomial[ME, S] <span class="cov8" title="1">{
        coeffs := make([]ME, max(len(p.coeffs), len(e.coeffs)))
        for i := range min(len(p.coeffs), len(e.coeffs)) </span><span class="cov8" title="1">{
                coeffs[i] = p.coeffs[i].Op(e.coeffs[i])
        }</span>
        <span class="cov8" title="1">for i := len(p.coeffs); i &lt; max(len(p.coeffs), len(e.coeffs)); i++ </span><span class="cov8" title="1">{
                coeffs[i] = e.coeffs[i].Clone()
        }</span>
        <span class="cov8" title="1">for i := len(e.coeffs); i &lt; max(len(p.coeffs), len(e.coeffs)); i++ </span><span class="cov8" title="1">{
                coeffs[i] = p.coeffs[i].Clone()
        }</span>

        <span class="cov8" title="1">return &amp;ModuleValuedPolynomial[ME, S]{
                coeffs: coeffs,
        }</span>
}

func (p *ModuleValuedPolynomial[ME, S]) OpElement(e ME) *ModuleValuedPolynomial[ME, S] <span class="cov8" title="1">{
        clone := p.Clone()
        clone.coeffs[0] = clone.coeffs[0].Op(e)
        return clone
}</span>

func (p *ModuleValuedPolynomial[ME, S]) IsOpIdentity() bool <span class="cov8" title="1">{
        for _, c := range p.coeffs </span><span class="cov8" title="1">{
                if !c.IsOpIdentity() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (p *ModuleValuedPolynomial[ME, S]) TryOpInv() (*ModuleValuedPolynomial[ME, S], error) <span class="cov8" title="1">{
        return p.OpInv(), nil
}</span>

func (p *ModuleValuedPolynomial[ME, S]) OpInv() *ModuleValuedPolynomial[ME, S] <span class="cov8" title="1">{
        coeffs := make([]ME, len(p.coeffs))
        for i, c := range p.coeffs </span><span class="cov8" title="1">{
                coeffs[i] = c.OpInv()
        }</span>

        <span class="cov8" title="1">return &amp;ModuleValuedPolynomial[ME, S]{
                coeffs: coeffs,
        }</span>
}

func (p *ModuleValuedPolynomial[ME, S]) ScalarOp(actor S) *ModuleValuedPolynomial[ME, S] <span class="cov8" title="1">{
        coeffs := make([]ME, len(p.coeffs))
        for i := 0; i &lt; len(coeffs); i++ </span><span class="cov8" title="1">{
                coeffs[i] = p.coeffs[i].ScalarOp(actor)
        }</span>

        <span class="cov8" title="1">return &amp;ModuleValuedPolynomial[ME, S]{
                coeffs: coeffs,
        }</span>
}

func (p *ModuleValuedPolynomial[ME, S]) IsTorsionFree() bool <span class="cov8" title="1">{
        for i := range p.coeffs </span><span class="cov8" title="1">{
                if !p.coeffs[i].IsTorsionFree() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (p *ModuleValuedPolynomial[ME, S]) Eval(at S) ME <span class="cov8" title="1">{
        out := p.coeffs[len(p.coeffs)-1].Clone()
        for i := len(p.coeffs) - 2; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                out = out.ScalarOp(at).Op(p.coeffs[i])
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (p *ModuleValuedPolynomial[ME, S]) Degree() int <span class="cov8" title="1">{
        for i := len(p.coeffs) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if !p.coeffs[i].IsOpIdentity() </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (p *ModuleValuedPolynomial[ME, S]) Coefficients() []ME <span class="cov8" title="1">{
        return p.coeffs
}</span>
</pre>
		
		<pre class="file" id="file174" style="display: none">package fkechacha20

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/prng/csprng"
        "github.com/bronlabs/bron-crypto/thirdparty/golang/crypto/chacha20"
)

// Prng uses a fast-erasure version of `chacha20` stream cipher as a Prng.
type Prng struct {
        chacha *chacha20.FastKeyErasureCipher
        seeded bool
}

// NewPrng generates a Fast-erasure PRNG using Chacha20 from a
// seed of 256 bits of length and an optional salt.
func NewPrng(seed, salt []byte) (*Prng, error) <span class="cov8" title="1">{
        chachaPrng := new(Prng)
        if err := chachaPrng.Reseed(seed, salt); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("Could not create ChachaPRNG")
        }</span>
        <span class="cov8" title="1">return chachaPrng, nil</span>
}

// New returns a new ChachaPRNG with the provided seed and salt.
func (*Prng) New(seed, salt []byte) (csprng.SeedableCSPRNG, error) <span class="cov0" title="0">{
        return NewPrng(seed, salt)
}</span>

// Generate fills the buffer with pseudo-random bytes. This PRNG does not use
// the `salt` parameter other than in the instantiation.
func (c *Prng) Generate(buffer, salt []byte) error <span class="cov8" title="1">{
        if !c.seeded </span><span class="cov0" title="0">{
                return ErrRandomSample.WithMessage("not seeded")
        }</span>
        <span class="cov8" title="1">c.chacha.XORKeyStream(buffer, buffer)
        return nil</span>
}

// Read fills the buffer with pseudo-random bytes.
func (c *Prng) Read(buffer []byte) (n int, err error) <span class="cov8" title="1">{
        if err = c.Generate(buffer, nil); err != nil </span><span class="cov0" title="0">{
                return 0, errs2.Wrap(err).WithMessage("Could not Generate bytes on ChachaPRNG")
        }</span>
        <span class="cov8" title="1">return len(buffer), nil</span>
}

// Reseed refreshes the PRNG with the provided seed material. For ChachaPRNG, it is equivalent to `ResetState`.
func (c *Prng) Reseed(seed, salt []byte) (err error) <span class="cov8" title="1">{
        if len(seed) &gt; chacha20.KeySize || len(salt) &gt; chacha20.NonceSizeX </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("invalid chacha seed or salt length (%d, %d)", len(seed), len(salt))
        }</span>

        <span class="cov8" title="1">var key [chacha20.KeySize]byte
        copy(key[:], seed)
        var nonce [chacha20.NonceSizeX]byte
        copy(nonce[:], salt)
        c.chacha, err = chacha20.NewFastErasureCipher(key[:], nonce[:])
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("Could not create ChachaPRNG")
        }</span>
        <span class="cov8" title="1">c.seeded = true
        return nil</span>
}

// Seed re-initialises the prng.
func (c *Prng) Seed(seed, salt []byte) error <span class="cov8" title="1">{
        err := c.Reseed(seed, salt)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("Could not re-initialise ChachaPRNG")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (*Prng) SecurityStrength() int <span class="cov0" title="0">{
        return chacha20.KeySize
}</span>

var (
        ErrInvalidArgument = errs2.New("ChachaPRNG invalid argument")
        ErrRandomSample    = errs2.New("ChachaPRNG random sample error")
)
</pre>
		
		<pre class="file" id="file175" style="display: none">package nist

import (
        crand "crypto/rand"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/prng/csprng"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils"
)

const (
        // ivKey is the initial key used to initialise the PRNG.
        ivKey = string(
                "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f" +
                        "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f",
        )
        // Parameters defined at Table 3 of section 10.2.1 in SP800-90A Rev. 1.
        // Note that lower values than those specified in the standard are set for
        // `reseed_interval` and `max_number_of_bits_per_request` to force reseeding
        // more frequently andt limit a single states exposure to an attacker, respectively.
        //------------- Parameter ---------//---- Value in SP800-90A  ---//--- Name/s in SP800-90A ---//.
        reseedInterval                 = 1 &lt;&lt; 12  // 2^48 times   //  `reseed_interval`
        maxNumberOfBytesDF             = 512 &gt;&gt; 3 // 512 bits     //  `max_number_of_bits`
        maxNumberOfBytesRequest        = 1 &lt;&lt; 10  // 2^19 bits    //  `max_number_of_bits_per_request`
        maxLength               uint64 = 1 &lt;&lt; 32  // 2^35 bits    //  `max_length`, `max_additional_input_length`,
        // .                                               //   `max_personalization_string_length`.
)

// PrngNist corresponds to an instantiated PRNG based on a block cipher from NIST SP-800-90A rev. 1.
type PrngNist struct {
        entropySource io.Reader // Source used to sample truly random seeds
        ctrDrbg       *CtrDRBG  // Internal PRNG based on AES block cipher in CTR mode.
}

// NewNistPRNG creates a PRNG as specified in SP-800-90A section 10.2. The PRNG uses
// the AES block cipher. The general instantiation is specified in section 9.1.
// The `keySize` parameter must be one of {16, 24, 32} for the corresponding AES
// block cipher. There are two truly random elements to seed this PRNG:
//
//  1. A fresh entropyInput of &gt;=`AesKeySize` Bytes. Sampled from entropySource (AesKeySize Bytes) if not provided.
//  2. A fresh nonce with &gt;=`AesKeySize/2` Bytes. Sampled from entropySource (AesBlockSize Bytes) if not provided.
//
// The (optional) `personalization` can be used to "salt" this PRNG. In the
// context of MPC protocols, the SessionID could be used.
func NewNistPRNG(keySize int, entropySource io.Reader, entropyInput, nonce, personalization []byte) (prng *PrngNist, err error) <span class="cov8" title="1">{
        NistPrng := new(PrngNist)
        // 1. IF (requested_security_strength &gt; ... --&gt; Skipped, security_strength = keyLen.
        // 2. IF prediction_resistance_flag... --&gt; Skipped, No prediction resistance.
        // 3. IF (len(personalization_string) &gt; max_personalization_string_length) --&gt; error.
        errors := []error{}
        if uint64(len(personalization)) &gt; maxLength </span><span class="cov0" title="0">{
                errors = append(errors, ErrInvalidArgument.WithMessage("personalisation too large"))
        }</span>
        // 4. Set security_strength = keyLen.
        <span class="cov8" title="1">if (keySize != 16) &amp;&amp; (keySize != 24) &amp;&amp; (keySize != 32) </span><span class="cov0" title="0">{
                errors = append(errors, ErrInvalidKey.WithMessage("keySize must be one of {16 (AES128), 24 (AES192), 32 (AES256)}"))
        }</span>
        <span class="cov8" title="1">securityStrength := keySize
        if securityStrength*8 &lt; base.ComputationalSecurityBits </span><span class="cov0" title="0">{
                errors = append(errors, ErrInvalidKey.WithMessage("keySize too small for computational security of %d bits", base.ComputationalSecurityBits))
        }</span>
        // 5. Nil step.
        <span class="cov8" title="1">if entropySource != nil </span><span class="cov0" title="0">{
                NistPrng.entropySource = entropySource
        }</span> else<span class="cov8" title="1"> { // Default: use the OS-wide global, shared instance of a CS-RNG.
                NistPrng.entropySource = crand.Reader
        }</span>
        // 6&amp;7. (status, entropy_input) = Get_entropy_input (security_strength, min_length,
        // max_length, prediction_resistance_request).
        // .    IF (status != SUCCESS)--&gt; return (status, Invalid).
        <span class="cov8" title="1">switch entropyInputLen := len(entropyInput); </span>{
        case entropyInputLen == 0:<span class="cov0" title="0"> // Sample entropyInput if not provided
                entropyInput = make([]byte, securityStrength)
                if _, err := io.ReadFull(NistPrng.entropySource, entropyInput); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, errs2.Wrap(err))
                }</span>
        case entropyInputLen &lt; securityStrength:<span class="cov0" title="0">
                errors = append(errors, ErrInvalidEntropy.WithMessage("entropyInput too small"))</span>
        case uint64(entropyInputLen) &gt; maxLength:<span class="cov0" title="0">
                errors = append(errors, ErrInvalidEntropy.WithMessage("entropyInput too large"))</span>
        }
        // 8. Obtain a nonce if not provided.
        <span class="cov8" title="1">switch nonceLen := len(nonce); </span>{
        case nonceLen == 0:<span class="cov8" title="1"> // Sample nonce if not provided
                nonce = make([]byte, securityStrength/2)
                if _, err = io.ReadFull(NistPrng.entropySource, nonce); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, errs2.Wrap(err))
                }</span>
        case nonceLen &lt; securityStrength/2:<span class="cov0" title="0">
                errors = append(errors, ErrInvalidNonce.WithMessage("nonce too small"))</span>
        }
        // Join errors if any
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, errs2.Join(errors...)
        }</span>
        // 9. initial_working_state = Instantiate_algorithm(entropy_input, nonce,
        // personalization_string, security_strength).
        <span class="cov8" title="1">NistPrng.ctrDrbg = NewCtrDRBG(keySize)
        if err = NistPrng.ctrDrbg.Instantiate(entropyInput, nonce, personalization); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return NistPrng, nil</span>
}

// Reseed will reseed the PRNG as specified in SP-800-90A section 9.2. It uses
// truly random inputs as seed material:
//
//        A) A fresh entropyInput of at least keySize Bytes. If not provided, sampled from entropySource.
//        B) An optional additionalInput, acting as an additional personalization string (see `NewPRNG`). Can be left empty.
//
// The entropyInput length must be at least keySize Bytes .
func (prg *PrngNist) Reseed(entropyInput, additionalInput []byte) (err error) <span class="cov8" title="1">{
        errors := []error{}
        // 1. Using state_handle, obtain the current internal state. --&gt; implicit.
        // 2. IF prediction_resistance_flag... --&gt; Skipped, implicit.
        // 3. IF len(additional_input) &gt; max_additional_input_length: return EEROR_FLAG
        if uint64(len(additionalInput)) &gt; maxLength </span><span class="cov0" title="0">{
                errors = append(errors, ErrInvalidArgument.WithMessage("additionalInput too large"))
        }</span>
        // 4&amp;5. (status, entropy_input) = Get_entropy_input (security_strength, min_length,
        // max_length, prediction_resistance_request).
        // .    IF (status != SUCCESS)--&gt; return (status, Invalid).
        <span class="cov8" title="1">switch entropyInputLen := len(entropyInput); </span>{
        case entropyInputLen == 0:<span class="cov0" title="0"> // Sample entropyInput if not provided
                entropyInput = make([]byte, prg.SecurityStrength())
                if prg.entropySource == nil </span><span class="cov0" title="0">{
                        errors = append(errors, ErrInvalidEntropy.WithMessage("cannot reseed without external entropy"))
                }</span>
                <span class="cov0" title="0">if _, err := io.ReadFull(prg.entropySource, entropyInput); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, errs2.Wrap(err))
                }</span>
        case entropyInputLen &lt; prg.SecurityStrength():<span class="cov0" title="0">
                errors = append(errors, ErrInvalidEntropy.WithMessage("entropyInput too small"))</span>
        case uint64(entropyInputLen) &gt; maxLength:<span class="cov0" title="0">
                errors = append(errors, ErrInvalidEntropy.WithMessage("entropyInput too large"))</span>
        }
        // Join errors if any
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return errs2.Join(errors...)
        }</span>
        // 6. new_working_state = Reseed_algorithm(working_state, entropy_input,
        // additional_input).
        <span class="cov8" title="1">if err = prg.ctrDrbg.Reseed(entropyInput, additionalInput); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Generate samples `len(buffer)` random bytes and stores them in `buffer`,
// as specified in SP-800-90A section 9.3. The buffer length must be at most
//
// If the PRNG needs reseeding, it will be carried out automatically if the prng
// was initialised with an `entropySource`, raising an error otherwise.
func (prg *PrngNist) Generate(buffer, additionalInput []byte) error <span class="cov8" title="1">{
        errors := []error{}
        if len(buffer) == 0 </span><span class="cov0" title="0">{
                errors = append(errors, ErrInvalidArgument.WithMessage("buffer length must be &gt; 0"))
        }</span>
        // 1. Using state_handle... --&gt; implicit.
        // 2. IF (requested_number_of_bits &gt; max_number_of_bits_per_request):
        // .        return (ERROR_FLAG, Nil).
        <span class="cov8" title="1">if len(buffer) &gt; maxNumberOfBytesRequest </span><span class="cov0" title="0">{
                errors = append(errors, ErrInvalidArgument.WithMessage("too many bytes requested"))
        }</span>
        // 3. IF requested_security_strength &gt; security_strength... --&gt; implicit.
        // 4. IF (length of the additional_input &gt; max_additional_input_length):
        // .        return (ERROR_FLAG, Nil).
        <span class="cov8" title="1">if uint64(len(additionalInput)) &gt; maxLength </span><span class="cov0" title="0">{
                errors = append(errors, ErrInvalidArgument.WithMessage("additionalInput too large"))
        }</span>
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return errs2.Join(errors...)
        }</span>
        // 5. If prediction_resistance_request is set... --&gt; implicit.
        // 6. Clear the reseed_required_flag.
        <span class="cov8" title="1">var reseedRequired bool
dataGeneration:
        // 8. (status, pseudorandom_bits, new_working_state) = Generate_algorithm(
        // working_state, requested_number_of_bits, additional_input).
        switch err := prg.ctrDrbg.Generate(buffer, additionalInput); </span>{
        case err != nil &amp;&amp; prg.entropySource != nil:<span class="cov0" title="0">
                // 9. If status indicates that a reseed is required, then
                // 9.1. Set the reseed_required_flag.
                // 9.2. If the prediction_resistance_flag... --&gt; implicit.
                // 9.3. Go to step 7.
                reseedRequired = true</span>
        case err != nil:<span class="cov0" title="0">
                return errs2.Wrap(err)</span>
        default:<span class="cov8" title="1"> // no errors
                reseedRequired = false</span>
        }
        // 7. If reseed_required_flag is set, then reseed.
        <span class="cov8" title="1">if reseedRequired </span><span class="cov0" title="0">{
                // 7.1. status = Reseed_function(state_handle, ..., additional_input).
                if err := prg.Reseed(nil, additionalInput); err != nil </span><span class="cov0" title="0">{
                        // 7.2. IF (status != SUCCESS), then return (status, Nil).
                        return errs2.Wrap(err)
                }</span>
                // 7.3 Using state_handle... --&gt; implicit.
                // 7.4. additional_input = Nil.
                <span class="cov0" title="0">additionalInput = nil
                // 7.5. Clear the reseed_required_flag --&gt; implicit.
                goto dataGeneration</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Read will sample `len(buffer)` random bytes and store them in `buffer`.
//
// It splits the buffer in chunks of `maxNumberOfBytesRequest` bytes, and calls
// `Generate` on each chunk. If the PRNG needs reseeding, it will be carried out
// automatically if the prng was initialised with an `entropySource`, raising an
// error otherwise.
func (prg *PrngNist) Read(buffer []byte) (n int, err error) <span class="cov8" title="1">{
        numRequests := mathutils.CeilDiv(len(buffer), maxNumberOfBytesRequest)
        for i := range numRequests </span><span class="cov8" title="1">{
                end := min((i+1)*maxNumberOfBytesRequest, len(buffer))
                requestBuffer := buffer[i*maxNumberOfBytesRequest : end]
                if err := prg.Generate(requestBuffer, nil); err != nil </span><span class="cov0" title="0">{
                        return n, errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return len(buffer), nil</span>
}

// SecurityStrength returns the computational security parameter of this prng (in Bytes).
// Equates to the length of the key used in the internal AES block cipher.
func (prg *PrngNist) SecurityStrength() int <span class="cov8" title="1">{
        return prg.ctrDrbg.keySize
}</span>

// Seed re-instantiates the PRNG with a new seed (`entropyInput`) and salt (`nonce`).
func (prg *PrngNist) Seed(entropyInput, nonce []byte) (err error) <span class="cov8" title="1">{
        errors := []error{}
        // Check seed and nonce
        switch entropyInputLen := len(entropyInput); </span>{
        case entropyInputLen &lt; prg.SecurityStrength():<span class="cov0" title="0">
                errors = append(errors, ErrInvalidEntropy.WithMessage("entropyInput too small"))</span>
        case uint64(entropyInputLen) &gt; maxLength:<span class="cov0" title="0">
                errors = append(errors, ErrInvalidEntropy.WithMessage("entropyInput too large"))</span>
        }
        <span class="cov8" title="1">switch nonceLen := len(nonce); </span>{
        case nonceLen == 0:<span class="cov0" title="0"> // Sample nonce if not provided
                nonce = make([]byte, prg.SecurityStrength()/2)
                if _, err = io.ReadFull(prg.entropySource, nonce); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, errs2.Wrap(err))
                }</span>
        case nonceLen &lt; prg.SecurityStrength()/2:<span class="cov0" title="0">
                errors = append(errors, ErrInvalidNonce.WithMessage("nonce too small"))</span>
        }
        // Join errors if any
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return errs2.Join(errors...)
        }</span>
        // Re-instantiate
        <span class="cov8" title="1">if err = prg.ctrDrbg.Instantiate(entropyInput, nonce, nil); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// New returns a new NistPRNG with the provided seed and salt.
func (prg *PrngNist) New(seed, salt []byte) (csprng.SeedableCSPRNG, error) <span class="cov0" title="0">{
        return NewNistPRNG(prg.SecurityStrength(), prg.entropySource, seed, salt, nil)
}</span>

// Clone returns a copy of this NistPRNG.
func (prg *PrngNist) Clone() *PrngNist <span class="cov0" title="0">{
        return &amp;PrngNist{
                entropySource: prg.entropySource,
                ctrDrbg:       prg.ctrDrbg.Clone(),
        }
}</span>
</pre>
		
		<pre class="file" id="file176" style="display: none">package nist

import (
        "crypto/aes"
        "crypto/cipher"
        "encoding/binary"
        "math/bits"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils"
)

type CtrDRBG struct {
        aesBlockCipher cipher.Block
        vLo            uint64
        vHi            uint64
        key            []byte
        keySize        int
        reseedCounter  uint64
}

// NewCtrDRBG creates a new CTR_DRBG instance for a given keySize.
func NewCtrDRBG(keySize int) *CtrDRBG <span class="cov8" title="1">{
        return &amp;CtrDRBG{
                aesBlockCipher: nil,
                vLo:            0,
                vHi:            0,
                key:            make([]byte, keySize),
                keySize:        keySize,
                reseedCounter:  0,
        }
}</span>

// Clone returns a copy of the CTR_DRBG.
func (ctrDrbg *CtrDRBG) Clone() *CtrDRBG <span class="cov0" title="0">{
        aesBlockCipher, err := aes.NewCipher(ctrDrbg.key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error() + ", Failed to create block cipher in clone.")</span>
        }
        <span class="cov0" title="0">return &amp;CtrDRBG{
                aesBlockCipher: aesBlockCipher,
                vLo:            ctrDrbg.vLo,
                vHi:            ctrDrbg.vHi,
                key:            append(make([]byte, 0, ctrDrbg.keySize), ctrDrbg.key...),
                keySize:        ctrDrbg.keySize,
                reseedCounter:  ctrDrbg.reseedCounter,
        }</span>
}

// KeySize returns the key length of the internal block cipher.
func (ctrDrbg *CtrDRBG) KeySize() int <span class="cov0" title="0">{
        return ctrDrbg.keySize
}</span>

// BlockSize returns the block size of the internal block cipher.
func (*CtrDRBG) BlockSize() int <span class="cov0" title="0">{
        return aes.BlockSize
}</span>

// SeedSize returns the length of the seed material, equal to KeySize + BlockSize.
func (ctrDrbg *CtrDRBG) SeedSize() int <span class="cov8" title="1">{
        return ctrDrbg.keySize + aes.BlockSize
}</span>

// setKey sets the key of the internal block cipher to `key`. If `key` is nil,
// the key is set to all zeros.
func (ctrDrbg *CtrDRBG) SetKey(key []byte) (err error) <span class="cov8" title="1">{
        switch len(key) </span>{
        case 0:<span class="cov8" title="1">
                ctrDrbg.key = make([]byte, ctrDrbg.keySize)</span>
        case ctrDrbg.keySize:<span class="cov8" title="1">
                if n := copy(ctrDrbg.key, key); n != ctrDrbg.keySize </span><span class="cov0" title="0">{
                        return ErrInvalidKey.WithMessage("key copy went wrong")
                }</span>
        default:<span class="cov0" title="0">
                return ErrInvalidKey.WithMessage("key has wrong length")</span>
        }
        <span class="cov8" title="1">ctrDrbg.aesBlockCipher, err = aes.NewCipher(ctrDrbg.key)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// update updates the internal state of the CTR_DRBG using the provided_data.
// It implements CTR_DRBG_Update as described in SP800-90A section 10.2.1.2.
func (ctrDrbg *CtrDRBG) Update(providedData []byte) (err error) <span class="cov8" title="1">{
        // +. Treat providedData==nil as SeedSize zeroed bytes.
        if (len(providedData) != ctrDrbg.SeedSize()) &amp;&amp; (len(providedData) != 0) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("provided data has the wrong length (%d != %d)", len(providedData), ctrDrbg.SeedSize())
        }</span>
        // 1. temp = Nil
        // +. Allocate space for temp
        <span class="cov8" title="1">tempBlocks := mathutils.CeilDiv(ctrDrbg.SeedSize(), aes.BlockSize)
        temp := make([]byte, tempBlocks*aes.BlockSize)
        // 2. WHILE (len(temp) &lt; seedLen) DO
        for i := range tempBlocks </span><span class="cov8" title="1">{
                // 2.1. V = (V+1) mod 2^blocklen
                var c uint64
                ctrDrbg.vLo, c = bits.Add64(ctrDrbg.vLo, 1, 0)
                ctrDrbg.vHi, _ = bits.Add64(ctrDrbg.vHi, 0, c)
                vBytes := slices.Concat(binary.BigEndian.AppendUint64(nil, ctrDrbg.vHi), binary.BigEndian.AppendUint64(nil, ctrDrbg.vLo))
                // 2.2. output_block = Block_Encrypt(Key, V).
                // 2.3. temp = temp || output_block.
                tempBlock := temp[i*aes.BlockSize : (i+1)*aes.BlockSize]
                ctrDrbg.aesBlockCipher.Encrypt(tempBlock, vBytes)
        }</span>
        // 3. temp = leftmost(temp, seedLen)
        <span class="cov8" title="1">temp = temp[:ctrDrbg.SeedSize()]
        // 4. temp = temp  provided_data.
        if len(providedData) &gt; 0 </span><span class="cov8" title="1">{ // +. If providedData is all zeros (nil), temp is unaffected.
                for j := 0; j &lt; len(temp); j++ </span><span class="cov8" title="1">{
                        temp[j] ^= providedData[j]
                }</span>
        }
        // 5. Key = leftmost(temp, keylen).
        <span class="cov8" title="1">if err = ctrDrbg.SetKey(temp[:ctrDrbg.keySize]); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        // 6. V = rightmost (temp, blocklen).
        <span class="cov8" title="1">vBytes := temp[ctrDrbg.keySize:]
        ctrDrbg.vHi = binary.BigEndian.Uint64(vBytes[0:8])
        ctrDrbg.vLo = binary.BigEndian.Uint64(vBytes[8:16])
        return nil</span>
}

// Instantiate prepares the PRNG for its use. The entropy input may or may not
// have full entropy; in either case, a nonce is required. The total input length
// must be equal to `.seedLength()`. The nonce must conform to SP800-90A section
// 8.6.7. This function implements CTR_DRBG_Instantiate_algorithm as specified
// in SP800-90A section 10.2.1.3.2.
func (ctrDrbg *CtrDRBG) Instantiate(entropyInput, nonce, personalizationString []byte) (err error) <span class="cov8" title="1">{
        // 1. seed_material = entropy_input || nonce || personalization_string.
        seedMaterial := make([]byte, 0, len(entropyInput)+len(nonce)+len(personalizationString))
        seedMaterial = append(seedMaterial, entropyInput...)
        seedMaterial = append(seedMaterial, nonce...)
        seedMaterial = append(seedMaterial, personalizationString...)
        // 2. seed_material = df(seed_material, seedlen).
        seedMaterial, err = ctrDrbg.BlockCipherDF(seedMaterial, ctrDrbg.SeedSize())
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        // 3. Key = 0^keylen.
        <span class="cov8" title="1">if err = ctrDrbg.SetKey(nil); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        // 4. V = 0^blocklen.
        <span class="cov8" title="1">ctrDrbg.vLo = 0
        ctrDrbg.vHi = 0
        // 5. (Key, V) = CTR_DRBG_Update(seed_material, Key, V).
        if err = ctrDrbg.Update(seedMaterial); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        // 6. reseed_counter = 1.
        <span class="cov8" title="1">ctrDrbg.reseedCounter = 1
        return nil</span>
}

// Reseed refreshes the PRNG with a new seed and prepares it for its use. It
// implements CTR_DRBG_Reseed_algorithm, specified in SP800-90A section 10.2.1.4.2.
func (ctrDrbg *CtrDRBG) Reseed(entropyInput, additionalInput []byte) (err error) <span class="cov8" title="1">{
        // 1. seed_material = entropy_input || additional_input.
        seedMaterial := make([]byte, 0, len(entropyInput)+len(additionalInput))
        seedMaterial = append(seedMaterial, entropyInput...)
        seedMaterial = append(seedMaterial, additionalInput...)
        // 2. seed_material = Block_Cipher_df(seed_material, seedlen).
        seedMaterial, err = ctrDrbg.BlockCipherDF(seedMaterial, ctrDrbg.SeedSize())
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        // 3. (Key, V) = CTR_DRBG_Update (seed_material, Key, V).
        <span class="cov8" title="1">if err = ctrDrbg.Update(seedMaterial); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        // 4. reseed_counter = 1.
        <span class="cov8" title="1">ctrDrbg.reseedCounter = 1
        return nil</span>
}

// generate generates pseudorandom bits employing a derivation function. It
// implements CTR_DRBG_Generate_algorithm, described in SP800-90A section 10.2.1.5.2.
func (ctrDrbg *CtrDRBG) Generate(outputBuffer, additionalInput []byte) (err error) <span class="cov8" title="1">{
        // +. Get the requested_number_of_bits from the length of the output buffer.
        requestedNumberOfBytes := len(outputBuffer)
        requestedNumberOfBlocks := mathutils.CeilDiv(requestedNumberOfBytes, aes.BlockSize)
        // 1. IF (reseed_counter &gt; reseed_interval), then return an indication that a
        // reseed is required.
        if ctrDrbg.reseedCounter &gt; reseedInterval </span><span class="cov0" title="0">{
                return ErrInvalidEntropy.WithMessage("PRNG must be reseeded before generating more bits.")
        }</span>
        // 2. IF (additional_input != Nil), then
        <span class="cov8" title="1">if len(additionalInput) &gt; 0 </span><span class="cov8" title="1">{
                // 2.1. additional_input = Block_Cipher_df(additional_input, seedlen).
                additionalInput, err = ctrDrbg.BlockCipherDF(additionalInput, ctrDrbg.SeedSize())
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err)
                }</span>
                // 2.2. (Key, V) = CTR_DRBG_Update(additional_input, Key, V).
                <span class="cov8" title="1">if err = ctrDrbg.Update(additionalInput); err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err)
                }</span>
        } else<span class="cov8" title="1"> { // ELSE additional_input = 0^seedlen. (Implicit, set to nil instead)
                additionalInput = nil
        }</span>
        // 3. temp = Nil.
        // +. Allocate space for all the requested blocks.
        <span class="cov8" title="1">temp := make([]byte, requestedNumberOfBlocks*aes.BlockSize)
        // 4. WHILE(len(temp) &lt; requested_number_of_bits) DO
        for i := range requestedNumberOfBlocks </span><span class="cov8" title="1">{
                // 4.1. V = (V+1) mod 2^blocklen.
                var c uint64
                ctrDrbg.vLo, c = bits.Add64(ctrDrbg.vLo, 1, 0)
                ctrDrbg.vHi, _ = bits.Add64(ctrDrbg.vHi, 0, c)
                vBytes := slices.Concat(binary.BigEndian.AppendUint64(nil, ctrDrbg.vHi), binary.BigEndian.AppendUint64(nil, ctrDrbg.vLo))
                // 4.2. output_block = Block_Encrypt(Key, V).
                // 4.3. temp = temp || output_block.
                outputBlock := temp[i*aes.BlockSize : (i+1)*aes.BlockSize]
                ctrDrbg.aesBlockCipher.Encrypt(outputBlock, vBytes)
        }</span>
        // 5. returned_bits = leftmost(temp, requested_number_of_bits).
        <span class="cov8" title="1">copy(outputBuffer, temp[:requestedNumberOfBytes])
        // 6. (Key, V) = CTR_DRBG_Update(additional_input, Key, V).
        if err = ctrDrbg.Update(additionalInput); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        // 7. reseed_counter = reseed_counter + 1.
        <span class="cov8" title="1">ctrDrbg.reseedCounter++
        return nil</span>
}

/* .--------------------------- AUXILIARY FUNCTIONS ------------------------. */

// BlockCipherDF implements the derivation function `Block_Cipher_df` as specified
// in SP800-90A section 10.3.2.
func (ctrDrbg *CtrDRBG) BlockCipherDF(inputString []byte, noOfBytesToReturn int) (requestedBytes []byte, err error) <span class="cov8" title="1">{
        // 1. IF (no_of_bits_to_return &gt; max_number_of_bits): return ERROR_FLAG, Nil
        if noOfBytesToReturn &gt; maxNumberOfBytesDF </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("no_of_bits_to_return &gt; max_number_of_bits")
        }</span>
        // 2. L = len(input_string)/8.
        <span class="cov8" title="1">l := uint32(len(inputString))
        // 3. N = no_of_bits_to_return/8.
        n := uint32(noOfBytesToReturn)
        // 5. Pad S with zeros, if necessary.
        // WHILE (len (S) mod outlen) != 0, DO {S = S || 0x00}
        sBlocks := mathutils.CeilDiv(int(4+4+l+1), aes.BlockSize)
        s := make([]byte, sBlocks*aes.BlockSize) // Allocate l, n, inputString, 0x80 and zero pads of #5
        // 4. Prepend the string length and the requested length of the output to the
        //   input_string. S = L || N || input_string || 0x80.
        binary.BigEndian.PutUint32(s[:4], l)
        binary.BigEndian.PutUint32(s[4:8], n)
        copy(s[8:8+l], inputString)
        s[8+l] = 0x80
        // 6. temp = Nil.
        // +. Calculate `len(temp)` and initialise `temp` buffer deterministically.
        tempBlocks := mathutils.CeilDiv(ctrDrbg.SeedSize(), aes.BlockSize)
        temp := make([]byte, tempBlocks*aes.BlockSize) // Allocate space for key and iv.
        // 7. i = 0 (uint32) --&gt; In #9.
        // 8. K = leftmost(0x00010203...1D1E1F, keylen).
        aesCipher, err := aes.NewCipher([]byte(ivKey)[:ctrDrbg.keySize])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        // 9. WHILE (len(temp) &lt; keylen + outlen), DO
        // +. Copy the `S` in the BCC input only once. It remains static.
        <span class="cov8" title="1">ivNs := make([]byte, aes.BlockSize, aes.BlockSize+len(s))
        ivNs = append(ivNs, s...) // (IV || S), with uninitialized IV.
        for i := range tempBlocks </span><span class="cov8" title="1">{
                // 9.1. IV = i || 0^(outlen - len(i)).
                if i &gt; 0 </span><span class="cov8" title="1">{
                        clear(ivNs[:aes.BlockSize])
                }</span>
                <span class="cov8" title="1">binary.BigEndian.PutUint32(ivNs[:aes.BlockSize], uint32(i))
                // 9.2. temp = temp || BCC (K, (IV || S)).
                BCC(aesCipher, ivNs, temp[i*aes.BlockSize:(i+1)*aes.BlockSize])</span>
                // 9.3. i = i + 1.
        }
        // 10. K = leftmost(temp, keylen).
        <span class="cov8" title="1">aesCipher, err = aes.NewCipher(temp[:ctrDrbg.keySize])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        // 11. X = select (temp, keylen+1, keylen+outlen).
        <span class="cov8" title="1">var x, xOut []byte
        x = temp[ctrDrbg.keySize:ctrDrbg.SeedSize()]
        // 12) temp = Nil.
        // +. Calculate the output size and initialise `temp` buffer deterministically.
        requestedBlocks := mathutils.CeilDiv(noOfBytesToReturn, aes.BlockSize)
        requestedBytes = make([]byte, requestedBlocks*aes.BlockSize)
        // 13. WHILE (len(temp) &lt; number_of_bits_to_return) DO
        for i := range requestedBlocks </span><span class="cov8" title="1">{
                // 13.1. X = Block_Encrypt (K, X).
                // 13.2. temp = temp || X.
                xOut = requestedBytes[i*aes.BlockSize : (i+1)*aes.BlockSize]
                aesCipher.Encrypt(xOut, x)
                x = xOut
        }</span>
        // 14. requested_bits = leftmost (temp, number_of_bits_to_return).
        <span class="cov8" title="1">requestedBytes = requestedBytes[:noOfBytesToReturn]
        return requestedBytes, nil</span>
}

// BCC (Block Cipher Chain) implements a chained encryption using the provided
// block cipher. Function specified in SP800-90A section 10.3.3. The block cipher
// has been previously initialised with the key. Given a `data` input of length
// `n*aes.BlockSize` bytes, encrypts all the blocks in a chain using the (AES)
// block cipher, yielding a single block of aes.BlockSize bytes as output.
func BCC(aesCipher cipher.Block, data, outputBlock []byte) <span class="cov8" title="1">{
        // +. Validate inputs and initialise auxiliary variables.
        if (len(data)%aes.BlockSize != 0) || (len(outputBlock) != aes.BlockSize) </span><span class="cov0" title="0">{
                panic("input/output length of wrong size")</span>
        }
        <span class="cov8" title="1">var dataBlock []byte
        inputBlock := make([]byte, aes.BlockSize)
        // 1. chaining_value = 0^outlen. Set the first chaining value to outlen zeros.
        clear(outputBlock) // chaining_value
        // 2. n = len(data)/outlen.
        n := len(data) / aes.BlockSize
        // 4. For i = 1 to n do
        for i := range n </span><span class="cov8" title="1">{
                // 3. Split data into n blocks of outlen bits each, from left to right.
                dataBlock = data[i*aes.BlockSize : (i+1)*aes.BlockSize]
                // 4.1. input_block = chaining_value  block[i].
                for j := range aes.BlockSize </span><span class="cov8" title="1">{
                        inputBlock[j] = outputBlock[j] ^ dataBlock[j]
                }</span>
                // 4.2. chaining_value = Block_Encrypt(Key, input_block).
                <span class="cov8" title="1">aesCipher.Encrypt(outputBlock, inputBlock)</span>
        }
}
</pre>
		
		<pre class="file" id="file177" style="display: none">package testutils

import (
        "bufio"
        "bytes"
        "fmt"
        "io"
        "os"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/prng/csprng/nist"
)

const (
        // Test file names.
        FileDRGBVectorsNoReseed = "testutils/drbgtestvectors/drbgvectors_no_reseed/CTR_DRBG.rsp"
        FILEDRGBVectorsPRFalse  = "testutils/drbgtestvectors/drbgvectors_pr_false/CTR_DRBG.rsp"
        // Test file constants.
        testHeaderLine = "[AES-%d %s df]" // Indicates the beginning of a new AES-based test
        maxTestCount   = 14               // Number of tests per case
)

/*.--------------------------- NIST Test Helper -----------------------------.*/

// NistTestConfig contains the configuration of a set NIST test cases to be scanned.
type NistTestConfig struct {
        PredictionResistance     bool
        EntropyInputLen          int
        NonceLen                 int
        PersonalizationStringLen int
        AdditionalInputLen       int
        ReturnedBitsLen          int
}

// NistTestCase contains the state of a NIST test case.
type NistTestCase struct {
        Count                 int
        EntropyInput          []byte
        Nonce                 []byte
        PersonalizationStr    []byte
        EntropyInputReseed    []byte
        AdditionalInputReseed []byte
        AdditionalInput1      []byte
        AdditionalInput2      []byte
        ReturnedBits          []byte
}

func NewNistTestCase(config *NistTestConfig) *NistTestCase <span class="cov0" title="0">{
        return &amp;NistTestCase{
                Count:                 0,
                EntropyInput:          make([]byte, (config.EntropyInputLen &gt;&gt; 3)),
                Nonce:                 make([]byte, (config.NonceLen &gt;&gt; 3)),
                PersonalizationStr:    make([]byte, (config.PersonalizationStringLen &gt;&gt; 3)),
                EntropyInputReseed:    make([]byte, (config.EntropyInputLen &gt;&gt; 3)),
                AdditionalInputReseed: make([]byte, (config.AdditionalInputLen &gt;&gt; 3)),
                AdditionalInput1:      make([]byte, (config.AdditionalInputLen &gt;&gt; 3)),
                AdditionalInput2:      make([]byte, (config.AdditionalInputLen &gt;&gt; 3)),
                ReturnedBits:          make([]byte, (config.ReturnedBitsLen &gt;&gt; 3)),
        }
}</span>

type NistTestHelper struct {
        // Fixed test parameters
        AesKeySize    int
        UseDf         bool
        isNewTestExpr string

        Config *NistTestConfig // Scanned test config
        State  *NistTestCase   // Scanned test state

        FileScanner *bufio.Scanner

        // Internal Counters
        LineNo  int
        TestNo  int
        CountNo int
}

// NewNistTestHelper creates a new NistTestHelper instance for the given file. The test
// parameters are fixed for the entire file:
//   - AesKeySize: {128, 192, 256}
//   - UseDf: {true, false}
func NewNistTestHelper(f *os.File, AesKeySize int, UseDf bool) *NistTestHelper <span class="cov0" title="0">{
        return &amp;NistTestHelper{
                AesKeySize: AesKeySize,
                UseDf:      UseDf,
                isNewTestExpr: fmt.Sprintf(testHeaderLine,
                        AesKeySize,
                        map[bool]string{true: "use", false: "no"}[UseDf]),
                Config: &amp;NistTestConfig{
                        PredictionResistance:     false,
                        EntropyInputLen:          0,
                        NonceLen:                 0,
                        PersonalizationStringLen: 0,
                        AdditionalInputLen:       0,
                        ReturnedBitsLen:          0,
                },
                State:       nil,
                FileScanner: bufio.NewScanner(f),
                LineNo:      0,
                TestNo:      0,
                CountNo:     0,
        }
}</span>

// Scan advances the Scanner to the next line. Returns false if it reaches EOF.
func (nistTest *NistTestHelper) Scan() bool <span class="cov0" title="0">{
        scanResult := nistTest.FileScanner.Scan()
        nistTest.LineNo++
        return scanResult
}</span>

// IsNewTestCase returns true if the current line is the start of a new test. Example
// of a new test line:
//
//        [AES-256, use df]
func (nistTest *NistTestHelper) IsNewTestCase() bool <span class="cov0" title="0">{
        return nistTest.FileScanner.Text() == nistTest.isNewTestExpr
}</span>

// Sscanf scans the current line and parses it according to the format string.
func (nistTest *NistTestHelper) Sscanf(canBeEmpty bool, format string, a ...any) error <span class="cov0" title="0">{
        scanResult := nistTest.FileScanner.Scan()
        nistTest.LineNo++
        if !scanResult &amp;&amp; !canBeEmpty </span><span class="cov0" title="0">{
                return errs2.New("Expected line %d not to be empty", nistTest.LineNo)
        }</span>
        <span class="cov0" title="0">line := nistTest.FileScanner.Text()
        fixedPartMatches := (format == "") || (line == format[:len(format)-2]) // -2 to remove the %d|%x
        _, err := fmt.Sscanf(line, format, a...)
        if err != nil &amp;&amp; (!canBeEmpty || !fixedPartMatches) </span><span class="cov0" title="0">{
                return errs2.New("Error parsing line %d: %s", nistTest.LineNo, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ScanTestConfig reads the test configuration from the current line.
// An example of a test configuration is:
//
//        [PredictionResistance = False]
//        [EntropyInputLen = 256]
//        [NonceLen = 128]
//        [PersonalizationStringLen = 0]
//        [AdditionalInputLen = 0]
//        [ReturnedBitsLen = 512]
func (nistTest *NistTestHelper) ScanTestConfig() error <span class="cov0" title="0">{
        if err := nistTest.Sscanf(false, "[PredictionResistance = %t]", &amp;nistTest.Config.PredictionResistance); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(false, "[EntropyInputLen = %d]", &amp;nistTest.Config.EntropyInputLen); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(false, "[NonceLen = %d]", &amp;nistTest.Config.NonceLen); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(false, "[PersonalizationStringLen = %d]", &amp;nistTest.Config.PersonalizationStringLen); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(false, "[AdditionalInputLen = %d]", &amp;nistTest.Config.AdditionalInputLen); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(false, "[ReturnedBitsLen = %d]", &amp;nistTest.Config.ReturnedBitsLen); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        // Scan the empty line after the test config
        <span class="cov0" title="0">if !nistTest.Scan() </span><span class="cov0" title="0">{
                return errs2.New("Expected line %d not to be empty", nistTest.LineNo)
        }</span>
        // Initialise test state
        <span class="cov0" title="0">nistTest.State = NewNistTestCase(nistTest.Config)
        return nil</span>
}

// ScanTestCase reads the test case from the current line. An example of a test
// case is:
//
//        COUNT = 0
//        EntropyInput = 36401940fa8b1fba91a1661f211d78a0b9389a74e5bccfece8d766af1a6d3b14
//        Nonce = 496f25b0f1301b4f501be30380a137eb
//        PersonalizationString =
//        AdditionalInput =
//        AdditionalInput =
//        ReturnedBits = 5862eb38bd558dd978a696e6df164782ddd887e7e9a6c9f3f1fbafb78941b535a64912dfd224c6dc7454e5250b3d97165e16260c2faf1cc7735cb75fb4f07e1d
func (nistTest *NistTestHelper) ScanTestCase(withReseed bool) error <span class="cov0" title="0">{
        if err := nistTest.Sscanf(false, "COUNT = %d", &amp;nistTest.State.Count); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(false, "EntropyInput = %x", &amp;nistTest.State.EntropyInput); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(false, "Nonce = %x", &amp;nistTest.State.Nonce); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(true, "PersonalizationString = %x", &amp;nistTest.State.PersonalizationStr); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if withReseed </span><span class="cov0" title="0">{
                if err := nistTest.Sscanf(true, "EntropyInputReseed = %x", &amp;nistTest.State.EntropyInputReseed); err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err)
                }</span>
                <span class="cov0" title="0">if err := nistTest.Sscanf(true, "AdditionalInputReseed = %x", &amp;nistTest.State.AdditionalInputReseed); err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err)
                }</span>
        }
        <span class="cov0" title="0">if err := nistTest.Sscanf(true, "AdditionalInput = %x", &amp;nistTest.State.AdditionalInput1); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(true, "AdditionalInput = %x", &amp;nistTest.State.AdditionalInput2); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := nistTest.Sscanf(false, "ReturnedBits = %x", &amp;nistTest.State.ReturnedBits); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

/*.------------------------- PRNG Run Methods -------------------------------.*/
// RunInit initialises a prng with the current test case.
func (nistTest *NistTestHelper) RunInit(AesKeySize int) (*nist.PrngNist, error) <span class="cov0" title="0">{
        if nistTest.State.Count != nistTest.CountNo </span><span class="cov0" title="0">{
                return nil, errs2.New("TestState.Count != CountNo (%d != %d)", nistTest.State.Count, nistTest.CountNo)
        }</span>
        <span class="cov0" title="0">prng, err := nist.NewNistPRNG(AesKeySize, nil, nistTest.State.EntropyInput, nistTest.State.Nonce, nistTest.State.PersonalizationStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return prng, nil</span>
}

// RunGenerate generates the next `len(buffer)` random bytes using `aditionalInput`
// and stores them in `buffer`.
func (nistTest *NistTestHelper) RunGenerate(prng *nist.PrngNist, buffer []byte) error <span class="cov0" title="0">{
        if err := prng.Generate(buffer, nistTest.State.AdditionalInput1); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if err := prng.Generate(buffer, nistTest.State.AdditionalInput2); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RunReseed seeds the prng with the provided entropy and the additional input.
func (nistTest *NistTestHelper) RunReseed(prng *nist.PrngNist, buffer []byte) error <span class="cov0" title="0">{
        if err := prng.Reseed(nistTest.State.EntropyInputReseed, nistTest.State.AdditionalInputReseed); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RunRead reads the next `len(buffer)` random bytes and stores them in `buffer`.
func (*NistTestHelper) RunRead(prng *nist.PrngNist, buffer []byte) error <span class="cov0" title="0">{
        if _, err := io.ReadFull(prng, buffer); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">if _, err := io.ReadFull(prng, buffer); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

/*.----------------------- Nist Test Run Methods ----------------------------.*/
// RunNistTestCases runs the NIST test suite for the given file and parameters.
func RunNistTestCases(f *os.File, AesKeySize int, useDf, withReseed bool) error <span class="cov0" title="0">{
        nistTest := NewNistTestHelper(f, AesKeySize, useDf)
        for nistTest.Scan() </span><span class="cov0" title="0">{
                if nistTest.IsNewTestCase() </span><span class="cov0" title="0">{
                        // Scan test config
                        if err := nistTest.ScanTestConfig(); err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err)
                        }</span>
                        <span class="cov0" title="0">returnedBits := make([]byte, nistTest.Config.ReturnedBitsLen/8)

                        for nistTest.CountNo = 0; nistTest.CountNo &lt; maxTestCount; nistTest.CountNo++ </span><span class="cov0" title="0">{
                                // Scan test state
                                if err := nistTest.ScanTestCase(withReseed); err != nil </span><span class="cov0" title="0">{
                                        return errs2.Wrap(err)
                                }</span>
                                // Run initialisation
                                <span class="cov0" title="0">prng, err := nistTest.RunInit(AesKeySize)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errs2.Wrap(err)
                                }</span>
                                // Run reseed
                                <span class="cov0" title="0">if withReseed </span><span class="cov0" title="0">{
                                        if err := nistTest.RunReseed(prng, returnedBits); err != nil </span><span class="cov0" title="0">{
                                                return errs2.Wrap(err)
                                        }</span>
                                }
                                // Run generation
                                <span class="cov0" title="0">if err := nistTest.RunGenerate(prng, returnedBits); err != nil </span><span class="cov0" title="0">{
                                        return errs2.Wrap(err)
                                }</span>
                                // Check test results
                                <span class="cov0" title="0">if !bytes.Equal(nistTest.State.ReturnedBits, returnedBits) </span><span class="cov0" title="0">{
                                        return errs2.Wrap(err)
                                }</span>
                                // Scan empty line
                                <span class="cov0" title="0">if err := nistTest.Sscanf(true, ""); err != nil </span><span class="cov0" title="0">{
                                        return errs2.Wrap(err)
                                }</span>
                        }
                        <span class="cov0" title="0">nistTest.TestNo++</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// RunNistValidationTest runs the NIST test suite for both the seeded and non-seeded cases.
func RunNistValidationTest(keySize int, useDf bool) (err error) <span class="cov0" title="0">{
        for _, caseParams := range []struct {
                withReseed bool
                fName      string
        }{
                {withReseed: false, fName: FileDRGBVectorsNoReseed},
                {withReseed: true, fName: FILEDRGBVectorsPRFalse},
        } </span><span class="cov0" title="0">{
                // Open test data file
                f, err := os.Open(caseParams.fName)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err)
                }</span>
                // Run tests
                <span class="cov0" title="0">if err := RunNistTestCases(f, keySize, useDf, caseParams.withReseed); err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err)
                }</span>
                // Close test data file
                <span class="cov0" title="0">if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">package rfc8937

import (
        "crypto/hkdf"
        "crypto/sha3"
        "fmt"
        "io"
        "slices"
        "sync/atomic"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
)

// hashFunc implies L = 32 bytes.
var hashFunc = sha3.New256

type WrappedReader struct {
        salt    []byte
        counter atomic.Uint64
        wrapee  io.Reader
}

func Wrap[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](prng io.Reader, signer *ecdsa.Signer[P, B, S], uniqueDeviceID []byte) (*WrappedReader, error) <span class="cov8" title="1">{
        if !signer.IsDeterministic() </span><span class="cov0" title="0">{
                return nil, ErrSignerDeterminism.WithMessage("signer must be deterministic")
        }</span>

        <span class="cov8" title="1">sig, err := signer.Sign(uniqueDeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrUniqueDeviceIDSignature.WithMessage("could not sign unique device id")
        }</span>
        <span class="cov8" title="1">salt, err := hashing.Hash(hashFunc, slices.Concat(sig.R().Bytes(), sig.S().Bytes()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrHashingUniqueDeviceID.WithMessage("could not hash unique device id signature")
        }</span>

        <span class="cov8" title="1">return &amp;WrappedReader{
                salt:    salt,
                counter: atomic.Uint64{},
                wrapee:  prng,
        }, nil</span>
}

func (r *WrappedReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        l := hashFunc().Size()
        g := make([]byte, l)
        _, err = io.ReadFull(r.wrapee, g)
        if err != nil </span><span class="cov0" title="0">{
                return n, ErrRandomSample.WithMessage("could not read from wrapped reader")
        }</span>
        <span class="cov8" title="1">key, err := hkdf.Extract(hashFunc, g, r.salt)
        if err != nil </span><span class="cov0" title="0">{
                return 0, ErrExtractKey.WithMessage("HKDF-Extract failed")
        }</span>

        <span class="cov8" title="1">tag2 := r.counter.Add(1)
        gPrime, err := hkdf.Expand(hashFunc, key, fmt.Sprintf("%d", tag2), len(p))
        if err != nil </span><span class="cov0" title="0">{
                return 0, ErrExpandKey.WithMessage("HKDF-Expand failed")
        }</span>
        <span class="cov8" title="1">copy(p, gPrime)
        return len(gPrime), nil</span>
}

var (
        ErrSignerDeterminism       = errs2.New("signer must be deterministic")
        ErrUniqueDeviceIDSignature = errs2.New("could not sign unique device id")
        ErrHashingUniqueDeviceID   = errs2.New("could not hash signed unique device id")
        ErrRandomSample            = errs2.New("could not read from wrapped reader")
        ErrExtractKey              = errs2.New("could not extract key")
        ErrExpandKey               = errs2.New("could not expand key")
)
</pre>
		
		<pre class="file" id="file179" style="display: none">package testutils

import (
        "bytes"
        "crypto/sha256"
        "io"
        "sync"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/prng/csprng"
        "github.com/stretchr/testify/require"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
)

type MockReader struct {
        index int
        seed  []byte
}

var (
        mockRngInitonce sync.Once
        mockRng         MockReader
)

func NewMockReader() <span class="cov0" title="0">{
        mockRng.index = 0
        mockRng.seed = make([]byte, 32)
        for i := range mockRng.seed </span><span class="cov0" title="0">{
                mockRng.seed[i] = 1
        }</span>
}

func TestRng() *MockReader <span class="cov0" title="0">{
        mockRngInitonce.Do(NewMockReader)
        return &amp;mockRng
}</span>

func (m *MockReader) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        limit := len(m.seed)
        for i := range p </span><span class="cov0" title="0">{
                p[i] = m.seed[m.index]
                m.index++
                m.index %= limit
        }</span>
        <span class="cov0" title="0">n = len(p)
        return n, nil</span>
}

func Sha256Sum(input string) []byte <span class="cov0" title="0">{
        res := sha256.Sum256([]byte(input))
        return res[:]
}</span>

func PrngTester(t *testing.T, keyLength, seedLength int, prngGenerator func(seed, salt []byte) (csprng.SeedableCSPRNG, error)) <span class="cov0" title="0">{
        t.Helper()

        // hardcoded random 32B keys
        keys := [][]byte{
                Sha256Sum("One Ring to rule them all.")[:keyLength],
                Sha256Sum("One Ring to find them,")[:keyLength],
                Sha256Sum("One Ring to bring them all")[:keyLength],
                Sha256Sum("and in the darkness bind them.")[:keyLength],
        }
        // hardcoded random 32B nonces
        nonces := [][]byte{
                Sha256Sum("The world has changed. I see it in the water.")[:seedLength],
                Sha256Sum("I feel it in the Earth. I smell it in the air.")[:seedLength],
                Sha256Sum("Much that once was is lost,")[:seedLength],
                Sha256Sum("For none now live who remember it. -- Galadriel")[:seedLength],
        }
        for i := range keys </span><span class="cov0" title="0">{
                // create a new PRNG
                prng, err := prngGenerator(keys[i], nonces[i])
                require.NoError(t, err)
                // generate 100B of buffer data
                buffer := make([]byte, 100)
                _, err = io.ReadFull(prng, buffer)
                require.NoError(t, err)
                // Reset and generate same 120B of buffer data
                buffer2 := make([]byte, 120)
                err = prng.Seed(keys[i], nonces[i])
                require.NoError(t, err)
                _, err = io.ReadFull(prng, buffer2)
                require.NoError(t, err)
                // Create anew generate 200B of buffer data. Check equality of first 120B
                buffer3 := make([]byte, 200)
                prng2, err := prngGenerator(keys[i], nonces[i])
                require.NoError(t, err)
                _, err = prng2.Read(buffer3)
                require.NoError(t, err)
                // Seed with a different key and nonce and generate 200B of buffer data.
                buffer4 := make([]byte, 200)
                randomKey := make([]byte, 32)
                randomNonce := make([]byte, 16)
                err = prng.Seed(randomKey, randomNonce)
                require.NoError(t, err)
                _, err = io.ReadFull(prng, buffer4)
                require.NoError(t, err)
                // compare with expected
                require.True(t, bytes.Equal(buffer, buffer2[:100]))
                require.True(t, bytes.Equal(buffer2, buffer3[:120]))
                require.False(t, bytes.Equal(buffer, buffer4[:100]))
                require.False(t, bytes.Equal(buffer2, buffer4[:120]))
                require.False(t, bytes.Equal(buffer3, buffer4))
        }</span>

        // Test that two calls to the same PRNG do not generate the same data
        <span class="cov0" title="0">minBufferSize, maxBufferSize := 24, 100
        prng, err := prngGenerator(keys[0], nil)
        require.NoError(t, err)
        for bufferSize := minBufferSize; bufferSize &lt;= maxBufferSize; bufferSize++ </span><span class="cov0" title="0">{
                buffer := make([]byte, bufferSize)
                _, err = io.ReadFull(prng, buffer)
                require.NoError(t, err)
                buffer2 := make([]byte, bufferSize)
                _, err = io.ReadFull(prng, buffer2)
                require.NoError(t, err)
                require.False(t, bytes.Equal(buffer, buffer2),
                        "PRNG generated the same data twice for buffer size %d", bufferSize)
        }</span>

        // Test that the output of a PRNG is not all zeros (this should be a very rare event)
        <span class="cov0" title="0">prng, err = prngGenerator(keys[0], nil)
        require.NoError(t, err)
        for bufferSize := minBufferSize; bufferSize &lt;= maxBufferSize; bufferSize++ </span><span class="cov0" title="0">{
                buffer := make([]byte, bufferSize)
                _, err = io.ReadFull(prng, buffer)
                require.NoError(t, err)
                require.False(t, ct.SliceIsZero(buffer) == 1,
                        "PRNG generated all zeros for buffer size %d", bufferSize)
        }</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">package csprng

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

var (
        ErrConstructionFailed = errs2.New("failed to construct new prng")
        ErrReadFailed         = errs2.New("failed to read from prng")
        ErrGenerateFailed     = errs2.New("failed to generate from prng")
        ErrSeedFailed         = errs2.New("failed to seed prng")
        ErrReseedFailed       = errs2.New("failed to reseed prng")
)

// Provide a thread-safe version for PRNGs.
type ThreadSafePrng struct {
        prng SeedableCSPRNG
        mu   sync.Mutex
}

// NewThreadSafePrng returns a thread-safe version of the provided PRNG.
func NewThreadSafePrng(prng SeedableCSPRNG) (threadSafePrng SeedableCSPRNG) <span class="cov0" title="0">{
        return &amp;ThreadSafePrng{
                prng: prng,
                mu:   sync.Mutex{},
        }
}</span>

// Read pseudo-random bytes, to use like `crand.Read()`.
func (tsp *ThreadSafePrng) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        tsp.mu.Lock()
        defer tsp.mu.Unlock()
        n, err = tsp.prng.Read(p)
        if err != nil </span><span class="cov0" title="0">{
                return 0, ErrReadFailed.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return n, nil</span>
}

// Read pseudo-random bytes. Salts the read with `readSalt` if provided.
func (tsp *ThreadSafePrng) Generate(buffer, readSalt []byte) error <span class="cov0" title="0">{
        tsp.mu.Lock()
        defer tsp.mu.Unlock()
        if err := tsp.prng.Generate(buffer, readSalt); err != nil </span><span class="cov0" title="0">{
                return ErrGenerateFailed.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Reseed the PRNG with a new seed and salt. It does not reset the state.
func (tsp *ThreadSafePrng) Reseed(seed, salt []byte) error <span class="cov0" title="0">{
        tsp.mu.Lock()
        defer tsp.mu.Unlock()
        if err := tsp.prng.Reseed(seed, salt); err != nil </span><span class="cov0" title="0">{
                return ErrReseedFailed.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Returns the security strength of the PRNG (in bytes).
func (tsp *ThreadSafePrng) SecurityStrength() int <span class="cov0" title="0">{
        return tsp.prng.SecurityStrength()
}</span>

// Reset the internal state of the PRNG.
func (tsp *ThreadSafePrng) Seed(seed, salt []byte) error <span class="cov0" title="0">{
        tsp.mu.Lock()
        defer tsp.mu.Unlock()
        if err := tsp.prng.Seed(seed, salt); err != nil </span><span class="cov0" title="0">{
                return ErrSeedFailed.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Generate a new PRNG with the provided seed and salt. Does not need locking, as only fixed values are used.
func (tsp *ThreadSafePrng) New(seed, salt []byte) (SeedableCSPRNG, error) <span class="cov0" title="0">{
        tsp.mu.Lock()
        defer tsp.mu.Unlock()
        prng, err := tsp.prng.New(seed, salt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrConstructionFailed.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return NewThreadSafePrng(prng), nil</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">package pcg

import (
        "encoding/binary"
        mrand "math/rand/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/prng"
)

var (
        ErrInvalidSeedLength = errs2.New("seed length is not 8 bytes")
        ErrInvalidSaltLength = errs2.New("salt length is not 8 bytes")
)

type seededReader struct {
        v *mrand.PCG
}

// New creates a new PCG PRNG seeded with the given seed and salt.
func New(seed, salt uint64) prng.SeedablePRNG <span class="cov8" title="1">{
        return &amp;seededReader{v: mrand.NewPCG(seed, salt)}
}</span>

// NewRandomised creates a new PCG PRNG with random seed and salt.
func NewRandomised() prng.SeedablePRNG <span class="cov8" title="1">{
        return &amp;seededReader{v: mrand.NewPCG(mrand.Uint64(), mrand.Uint64())} //nolint:gosec // weak prng is intentional.
}</span>

// Read fills the provided byte slice p with random bytes.
func (r *seededReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        for i := range p </span><span class="cov8" title="1">{
                p[i] = byte(r.v.Uint64())
        }</span>
        <span class="cov8" title="1">return len(p), nil</span>
}

// Seed resets the internal state of the PRNG with the provided seed and salt.
func (r *seededReader) Seed(seed, salt []byte) error <span class="cov8" title="1">{
        if err := r.validateSeedInputs(seed, salt); err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("invalid inputs")
        }</span>
        <span class="cov8" title="1">seedUint64 := binary.LittleEndian.Uint64(seed)
        saltUint64 := binary.LittleEndian.Uint64(salt)
        r.v.Seed(seedUint64, saltUint64)
        return nil</span>
}

func (*seededReader) validateSeedInputs(seed, salt []byte) error <span class="cov8" title="1">{
        validationErrs := []error{}
        if len(seed) != 8 </span><span class="cov8" title="1">{
                validationErrs = append(validationErrs, ErrInvalidSeedLength)
        }</span>
        <span class="cov8" title="1">if len(salt) != 8 </span><span class="cov8" title="1">{
                validationErrs = append(validationErrs, ErrInvalidSaltLength)
        }</span>
        <span class="cov8" title="1">return errs2.Join(validationErrs...)</span>
}

// New generates a new PRNG of the same type with the provided seed and salt.
func (*seededReader) New(seed, salt []byte) (prng.SeedablePRNG, error) <span class="cov8" title="1">{
        seedUint64 := binary.LittleEndian.Uint64(seed)
        saltUint64 := binary.LittleEndian.Uint64(salt)
        return New(seedUint64, saltUint64), nil
}</span>
</pre>
		
		<pre class="file" id="file182" style="display: none">package serde

import (
        "reflect"

        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

const (
        DefaultMaxArrayElements = 131072
        DefaultMaxMapPairs      = 131072
        DefaultMaxNestedLevels  = 32
)

var (
        enc cbor.EncMode
        dec cbor.DecMode

        // Global TagSet for type registration.
        tags = cbor.NewTagSet()

        ErrSerialisation   = errs2.New("serialisation error")
        ErrDeserialisation = errs2.New("deserialisation error")
)

// Register registers the concrete type parameter T with a fixed CBOR tag.
func Register[T any](tag uint64) <span class="cov0" title="0">{
        var zero T
        typ := reflect.TypeOf(zero)
        if typ == nil </span><span class="cov0" title="0">{
                panic("serde.RegisterWithTag: nil type for generic parameter T")</span>
        }
        <span class="cov0" title="0">if err := tags.Add(
                cbor.TagOptions{DecTag: cbor.DecTagOptional, EncTag: cbor.EncTagRequired},
                typ,
                tag,
        ); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // ensure enc/dec modes see the new tag
        <span class="cov0" title="0">updateModes()</span>
}

func init() <span class="cov0" title="0">{ //nolint:gochecknoinits // necessary for setup
        updateModes()
}</span>

func updateModes() <span class="cov0" title="0">{
        var err error
        enc, err = cbor.CoreDetEncOptions().EncModeWithTags(tags)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">decOptions := cbor.DecOptions{ //nolint:exhaustruct // readability
                DupMapKey:                cbor.DupMapKeyEnforcedAPF,
                TimeTag:                  cbor.DecTagRequired,
                MaxNestedLevels:          DefaultMaxNestedLevels,
                MaxArrayElements:         DefaultMaxArrayElements,
                MaxMapPairs:              DefaultMaxMapPairs,
                IndefLength:              cbor.IndefLengthForbidden,
                TagsMd:                   cbor.TagsAllowed,       // default
                IntDec:                   cbor.IntDecConvertNone, // default
                MapKeyByteString:         cbor.MapKeyByteStringForbidden,
                ExtraReturnErrors:        cbor.ExtraDecErrorUnknownField,
                UTF8:                     cbor.UTF8RejectInvalid, // default
                FieldNameMatching:        cbor.FieldNameMatchingCaseSensitive,
                BigIntDec:                cbor.BigIntDecodePointer,
                ByteStringToString:       cbor.ByteStringToStringForbidden,  // default
                FieldNameByteString:      cbor.FieldNameByteStringForbidden, // default
                UnrecognizedTagToAny:     cbor.UnrecognizedTagContentToAny,
                TimeTagToAny:             cbor.TimeTagToRFC3339,
                NaN:                      cbor.NaNDecodeForbidden,
                Inf:                      cbor.InfDecodeForbidden,
                ByteStringToTime:         cbor.ByteStringToTimeForbidden,
                ByteStringExpectedFormat: cbor.ByteStringExpectedFormatNone, // default
                BignumTag:                cbor.BignumTagForbidden,
                BinaryUnmarshaler:        cbor.BinaryUnmarshalerByteString,
                TextUnmarshaler:          cbor.TextUnmarshalerNone,
        }
        dec, err = decOptions.DecModeWithTags(tags)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// MarshalCBOR serialises the given value to CBOR format.
func MarshalCBOR[T any](t T) ([]byte, error) <span class="cov0" title="0">{
        data, err := enc.Marshal(t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrSerialisation
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// MarshalCBORTagged serialises the given value to CBOR format with the specified tag.
func MarshalCBORTagged[T any](t T, tag uint64) ([]byte, error) <span class="cov0" title="0">{
        wrapped := cbor.Tag{
                Number:  tag,
                Content: t,
        }
        data, err := enc.Marshal(wrapped)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrSerialisation
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR deserialises the given CBOR data into the specified type.
func UnmarshalCBOR[T any](data []byte) (T, error) <span class="cov0" title="0">{
        var t T
        err := dec.Unmarshal(data, &amp;t)
        if err != nil </span><span class="cov0" title="0">{
                return t, ErrDeserialisation
        }</span>
        <span class="cov0" title="0">return t, nil</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">package base

import ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"

type (
        // HashCode represents a 64-bit hash code.
        HashCode = ds.HashCode
        // Equatable represents a type that can be compared for equality.
        Equatable[T any] = ds.Equatable[T]
        // Clonable represents a type that can be cloned.
        Clonable[T any] = ds.Clonable[T]
        // Hashable represents a type that can be hashed and compared for equality.
        Hashable[T any] = ds.Hashable[T]
)

// DeriveHashCode derives a HashCode from one or more byte slices.
func DeriveHashCode[T ~[]byte](xs ...T) HashCode <span class="cov0" title="0">{
        return ds.DeriveHashCode(xs...)
}</span>

// Transparent represents a type that can expose an underlying value of type V.
type Transparent[V any] interface {
        Value() V
}

// HashableStructure represents a structure that can hash byte slices into elements of type E.
type HashableStructure[E any] interface {
        // Hash hashes the input byte slice and returns an element of type E.
        Hash([]byte) (E, error)
}

// BytesLike represents types that can provide a byte slice representation.
// TODO: move to transcripts package
type BytesLike interface {
        // Bytes returns the byte slice representation of the receiver.
        Bytes() []byte
}

// BytesLikeFactory represents a factory for creating elements of type E from byte slices.
// TODO: move back to algebra, and only keep element size
type BytesLikeFactory[E any] interface {
        // FromBytes creates an element of type E from the given byte slice.
        FromBytes([]byte) (E, error)
        // If elemnts are atomic, ElementSize returns the **exact** number of bytes (implementation-dependent) required to represent an element.
        // If elements are collections of atomic elements, ElementSize returns the size of an individual element.
        // If elements are variable size, ElementSize returns -1.
        ElementSize() int
}
</pre>
		
		<pre class="file" id="file184" style="display: none">package algebrautils

import (
        "io"
        "math/bits"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
)

// RandomNonIdentity samples a random element from the given finite monoid that is not the identity element.
func RandomNonIdentity[M interface {
        algebra.FiniteStructure[E]
        algebra.Monoid[E]
}, E algebra.MonoidElement[E]](m M, prng io.Reader) (E, error) <span class="cov8" title="1">{
        validationErrors := []error{}
        if utils.IsNil(m) </span><span class="cov8" title="1">{
                validationErrors = append(validationErrors, ErrArgumentIsNil.WithMessage("monoid"))
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov8" title="1">{
                validationErrors = append(validationErrors, ErrArgumentIsNil.WithMessage("prng"))
        }</span>
        <span class="cov8" title="1">if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                return *new(E), errs2.Join(validationErrors...)
        }</span>
        <span class="cov8" title="1">var err error
        out := m.OpIdentity()
        for out.IsOpIdentity() </span><span class="cov8" title="1">{
                out, err = m.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return *new(E), errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// Fold applies the binary operation of the given operand type to all provided elements, returning the final result.
func Fold[S algebra.Operand[S]](first S, rest ...S) S <span class="cov8" title="1">{
        if len(rest) == 0 </span><span class="cov8" title="1">{
                return first
        }</span>
        <span class="cov8" title="1">return iterutils.Reduce(slices.Values(rest), first, func(acc S, e S) S </span><span class="cov8" title="1">{
                return acc.Op(e)
        }</span>)
}

// Sum applies the addition operation of the given summand type to all provided elements, returning the final result.
func Sum[S algebra.Summand[S]](first S, rest ...S) S <span class="cov8" title="1">{
        if len(rest) == 0 </span><span class="cov8" title="1">{
                return first
        }</span>
        <span class="cov8" title="1">return iterutils.Reduce(slices.Values(rest), first, func(acc S, e S) S </span><span class="cov8" title="1">{
                return acc.Add(e)
        }</span>)
}

// Prod applies the multiplication operation of the given multiplicand type to all provided elements, returning the final result.
func Prod[M algebra.Multiplicand[M]](first M, rest ...M) M <span class="cov8" title="1">{
        if len(rest) == 0 </span><span class="cov8" title="1">{
                return first
        }</span>
        <span class="cov8" title="1">return iterutils.Reduce(slices.Values(rest), first, func(acc M, e M) M </span><span class="cov8" title="1">{
                return acc.Mul(e)
        }</span>)
}

// ScalarMul computes the scalar multiplication of the given base element by the given exponent using a fixed-window method.
func ScalarMul[E algebra.MonoidElement[E], S algebra.Numeric](base E, exponent S) E <span class="cov8" title="1">{
        monoid := algebra.StructureMustBeAs[algebra.Monoid[E]](base.Structure())

        precomputed := make([]E, 16)
        precomputed[0] = monoid.OpIdentity()
        precomputed[1] = base
        for i := 2; i &lt; 16; i += 2 </span><span class="cov8" title="1">{
                precomputed[i] = precomputed[i/2].Op(precomputed[i/2])
                precomputed[i+1] = precomputed[i].Op(base)
        }</span>

        <span class="cov8" title="1">res := monoid.OpIdentity()
        exponentBigEndianBytes := exponent.BytesBE()
        for _, si := range exponentBigEndianBytes </span><span class="cov8" title="1">{
                res = res.Op(res)
                res = res.Op(res)
                res = res.Op(res)
                res = res.Op(res)
                w := (si &gt;&gt; 4) &amp; 0b1111
                res = res.Op(precomputed[w])

                res = res.Op(res)
                res = res.Op(res)
                res = res.Op(res)
                res = res.Op(res)
                w = si &amp; 0b1111
                res = res.Op(precomputed[w])
        }</span>

        <span class="cov8" title="1">return res</span>
}

// MultiScalarMul performs a Pippenger-style multi-scalar multiplication:
//
//        sum_i scalars[i] * points[i]
//
// using a fixed window size w.
//
// It assumes S.Bytes() is big-endian. Bits are extracted in LSB-first order.
func MultiScalarMul[E algebra.MonoidElement[E], S algebra.Numeric](
        scalars []S,
        points []E,
) E <span class="cov8" title="1">{
        n := len(points)
        if n == 0 </span><span class="cov8" title="1">{
                panic("MultiScalarMul: no points")</span>
        }
        <span class="cov8" title="1">if n != len(scalars) </span><span class="cov8" title="1">{
                panic("MultiScalarMul: number of points and scalars must be equal")</span>
        }

        <span class="cov8" title="1">monoid := algebra.StructureMustBeAs[algebra.Monoid[E]](points[0].Structure())

        // Use naive method for small n.
        if n &lt;= 7 </span><span class="cov8" title="1">{
                acc := monoid.OpIdentity()
                for i := range n </span><span class="cov8" title="1">{
                        acc = acc.Op(ScalarMul(points[i], scalars[i]))
                }</span>
                <span class="cov8" title="1">return acc</span>
        }

        // Precompute scalar bytes and max bit length.
        <span class="cov8" title="1">scalarBytes := make([][]byte, n)
        maxBits := 0
        for i, s := range scalars </span><span class="cov8" title="1">{
                b := s.BytesBE()
                scalarBytes[i] = b
                if numBits := len(b) * 8; numBits &gt; maxBits </span><span class="cov8" title="1">{
                        maxBits = numBits
                }</span>
        }
        <span class="cov8" title="1">if maxBits == 0 </span><span class="cov0" title="0">{
                // All scalars are zero.
                return monoid.OpIdentity()
        }</span>

        // Choose window size w.
        // A heuristic: w  log2(n), but clamp to [2, 16].
        <span class="cov8" title="1">w := 0
        if n &gt; 0 </span><span class="cov8" title="1">{
                w = bits.Len(uint(n)) // log2(n) rounded up
        }</span>
        <span class="cov8" title="1">if w &lt; 2 </span><span class="cov0" title="0">{
                w = 2
        }</span>
        <span class="cov8" title="1">if w &gt; 16 </span><span class="cov0" title="0">{
                w = 16
        }</span>

        <span class="cov8" title="1">windowSize := 1 &lt;&lt; w
        numWindows := (maxBits + w - 1) / w // ceil(maxBits / w)

        // Helper: get window of w bits starting at bit position `start` (LSB = bit 0).
        getWindow := func(b []byte, start int) uint </span><span class="cov8" title="1">{
                if len(b) == 0 </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov8" title="1">var acc uint
                for k := range w </span><span class="cov8" title="1">{
                        bitIndex := start + k
                        byteCount := len(b)
                        byteIndexFromLSB := bitIndex / 8
                        if byteIndexFromLSB &gt;= byteCount </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">byteIndex := byteCount - 1 - byteIndexFromLSB
                        shift := uint(bitIndex % 8)
                        bit := (b[byteIndex] &gt;&gt; shift) &amp; 1
                        acc |= uint(bit) &lt;&lt; uint(k)</span>
                }
                <span class="cov8" title="1">return acc</span>
        }

        <span class="cov8" title="1">acc := monoid.OpIdentity()
        for wIdx := numWindows - 1; wIdx &gt;= 0; wIdx-- </span><span class="cov8" title="1">{
                for range w </span><span class="cov8" title="1">{
                        acc = acc.Op(acc)
                }</span>
                <span class="cov8" title="1">buckets := make([]E, windowSize)
                for i := range buckets </span><span class="cov8" title="1">{
                        buckets[i] = monoid.OpIdentity()
                }</span>
                <span class="cov8" title="1">startBit := wIdx * w
                for i := range n </span><span class="cov8" title="1">{
                        win := getWindow(scalarBytes[i], startBit)
                        if win == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">buckets[win] = buckets[win].Op(points[i])</span>
                }

                // Summation by running sum from highest bucket down.
                // This gives: sum_{k=1}^{windowSize-1} k * bucket_k
                // with only ~windowSize additions.
                <span class="cov8" title="1">running := monoid.OpIdentity()
                for k := windowSize - 1; k &gt; 0; k-- </span><span class="cov8" title="1">{
                        if isIdentity := buckets[k].IsOpIdentity(); !isIdentity </span><span class="cov8" title="1">{
                                running = running.Op(buckets[k])
                        }</span>
                        <span class="cov8" title="1">acc = acc.Op(running)</span>
                }
        }

        <span class="cov8" title="1">return acc</span>
}

var ErrArgumentIsNil = errs2.New("argument is nil")
</pre>
		
		<pre class="file" id="file185" style="display: none">package utils

import (
        "reflect"

        "golang.org/x/exp/constraints"
)

// BoolTo casts a bool to any integer type.
func BoolTo[T constraints.Integer](b bool) T <span class="cov8" title="1">{
        if b </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// IsNil returns true if the given value is nil.
func IsNil[T any](v T) bool <span class="cov8" title="1">{
        val := reflect.ValueOf(v)
        if !val.IsValid() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">kind := val.Kind()
        return (kind == reflect.Ptr || kind == reflect.Interface) &amp;&amp; val.IsNil()</span>
}

// LeadingZeroBytes returns the count of 0x00 prefix bytes.
func LeadingZeroBytes(b []byte) int <span class="cov8" title="1">{
        i := 0
        for i &lt; len(b) &amp;&amp; b[i] == 0 </span><span class="cov8" title="1">{
                i++
        }</span>
        <span class="cov8" title="1">return i</span>
}

// ImplementsX checks if the given value v implements the interface X.
func ImplementsX[X, T any](v T) (X, bool) <span class="cov8" title="1">{
        // try value
        if x, ok := any(v).(X); ok </span><span class="cov8" title="1">{
                return x, true
        }</span>
        // try pointer (covers methods with pointer receivers)
        <span class="cov8" title="1">vv := v
        if x, ok := any(&amp;vv).(X); ok </span><span class="cov8" title="1">{
                return x, true
        }</span>
        <span class="cov8" title="1">return *new(X), false</span>
}

// Binomial computes the binomial coefficient "n choose k".
func Binomial(n, k int) int <span class="cov8" title="1">{
        // (n,k) = (n, n-k)
        if k &gt; n/2 </span><span class="cov8" title="1">{
                k = n - k
        }</span>
        <span class="cov8" title="1">b := 1
        for i := 1; i &lt;= k; i++ </span><span class="cov8" title="1">{
                b = (n - k + i) * b / i
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">package iterutils

import (
        "iter"
)

// Contains checks if the given value is present in the sequence.
func Contains[In comparable](seq iter.Seq[In], v In) bool <span class="cov8" title="1">{
        for v2 := range seq </span><span class="cov8" title="1">{
                if v == v2 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Contains2 checks if the given key-value pair is present in the sequence.
func Contains2[K comparable, V comparable](seq iter.Seq2[K, V], k K, v V) bool <span class="cov8" title="1">{
        for k2, v2 := range seq </span><span class="cov8" title="1">{
                if k == k2 &amp;&amp; v == v2 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ConstainsFunc checks if the given value is present in the sequence using a custom equality function.
func ContainsFunc[In any](seq iter.Seq[In], v In, f func(In, In) bool) bool <span class="cov8" title="1">{
        for v2 := range seq </span><span class="cov8" title="1">{
                if f(v, v2) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func ContainsFunc2[K any, V any](seq iter.Seq2[K, V], k K, v V, f func(K, V, K, V) bool) bool <span class="cov8" title="1">{
        for k2, v2 := range seq </span><span class="cov8" title="1">{
                if f(k, v, k2, v2) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Empty returns an empty sequence of the given value type.
func Empty[V any]() iter.Seq[V] <span class="cov8" title="1">{
        return func(yield func(V) bool) </span>{<span class="cov8" title="1">
                // Do nothing, effectively yielding no values.
        }</span>
}

// Empty2 returns an empty sequence of key-value pairs of the given key and value types.
func Empty2[K, V any]() iter.Seq2[K, V] <span class="cov8" title="1">{
        return func(yield func(K, V) bool) </span>{<span class="cov8" title="1">
                // Do nothing, effectively yielding no key-value pairs.
        }</span>
}

// Map applies the given function to each element of the input sequence and returns a new sequence of the results.
func Map[In, Out any](seq iter.Seq[In], f func(In) Out) iter.Seq[Out] <span class="cov8" title="1">{
        return func(yield func(Out) bool) </span><span class="cov8" title="1">{
                for in := range seq </span><span class="cov8" title="1">{
                        if !yield(f(in)) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Map2 applies the given function to each key-value pair of the input sequence and returns a new sequence of the results.
func Map2[KIn, KOut, VIn, VOut any](seq iter.Seq2[KIn, VIn], f func(KIn, VIn) (KOut, VOut)) iter.Seq2[KOut, VOut] <span class="cov8" title="1">{
        return func(yield func(KOut, VOut) bool) </span><span class="cov8" title="1">{
                for k, v := range seq </span><span class="cov8" title="1">{
                        if !yield(f(k, v)) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// MapKeys2 applies the given function to each key of the input key-value pair sequence and returns a new sequence with transformed keys.
func MapKeys2[KIn, KOut, V any](seq iter.Seq2[KIn, V], f func(KIn, V) KOut) iter.Seq2[KOut, V] <span class="cov8" title="1">{
        return func(yield func(KOut, V) bool) </span><span class="cov8" title="1">{
                for k, v := range seq </span><span class="cov8" title="1">{
                        if !yield(f(k, v), v) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// MapValues2 applies the given function to each value of the input key-value pair sequence and returns a new sequence with transformed values.
func MapValues2[K, VIn, VOut any](seq iter.Seq2[K, VIn], f func(K, VIn) VOut) iter.Seq2[K, VOut] <span class="cov8" title="1">{
        return func(yield func(K, VOut) bool) </span><span class="cov8" title="1">{
                for k, v := range seq </span><span class="cov8" title="1">{
                        if !yield(k, f(k, v)) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Concat concatenates multiple sequences of the same value type into a single sequence.
func Concat[V any](seqs ...iter.Seq[V]) iter.Seq[V] <span class="cov8" title="1">{
        return func(yield func(V) bool) </span><span class="cov8" title="1">{
                for _, seq := range seqs </span><span class="cov8" title="1">{
                        for e := range seq </span><span class="cov8" title="1">{
                                if !yield(e) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

// Concat2 concatenates multiple sequences of key-value pairs into a single sequence.
func Concat2[K, V any](seqs ...iter.Seq2[K, V]) iter.Seq2[K, V] <span class="cov8" title="1">{
        return func(yield func(K, V) bool) </span><span class="cov8" title="1">{
                for _, seq := range seqs </span><span class="cov8" title="1">{
                        for k, v := range seq </span><span class="cov8" title="1">{
                                if !yield(k, v) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

// Flatten flattens a sequence of sequences into a single sequence by yielding all elements from each inner sequence.
func Flatten[V any](seq iter.Seq[iter.Seq[V]]) iter.Seq[V] <span class="cov8" title="1">{
        return func(yield func(V) bool) </span><span class="cov8" title="1">{
                for s := range seq </span><span class="cov8" title="1">{
                        for v := range s </span><span class="cov8" title="1">{
                                if !yield(v) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

// Flatten2 flattens a sequence of key-value pair sequences into a single key-value pair sequence.
func Flatten2[K, V any](seq iter.Seq[iter.Seq2[K, V]]) iter.Seq2[K, V] <span class="cov8" title="1">{
        return func(yield func(K, V) bool) </span><span class="cov8" title="1">{
                for s := range seq </span><span class="cov8" title="1">{
                        for k, v := range s </span><span class="cov8" title="1">{
                                if !yield(k, v) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

// Any checks if any element in the sequence satisfies the given predicate function.
func Any[V any](seq iter.Seq[V], f func(V) bool) bool <span class="cov8" title="1">{
        for v := range seq </span><span class="cov8" title="1">{
                if f(v) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Any2 checks if any key-value pair in the sequence satisfies the given predicate function.
func Any2[K, V any](seq iter.Seq2[K, V], f func(K, V) bool) bool <span class="cov8" title="1">{
        for k, v := range seq </span><span class="cov8" title="1">{
                if f(k, v) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// All checks if all elements in the sequence satisfy the given predicate function.
func All[V any](seq iter.Seq[V], f func(V) bool) bool <span class="cov8" title="1">{
        for v := range seq </span><span class="cov8" title="1">{
                if !f(v) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// All2 checks if all key-value pairs in the sequence satisfy the given predicate function.
func All2[K, V any](seq iter.Seq2[K, V], f func(K, V) bool) bool <span class="cov8" title="1">{
        for k, v := range seq </span><span class="cov8" title="1">{
                if !f(k, v) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Equal checks if two sequences of the same value type are equal.
func Equal[V comparable](x, y iter.Seq[V]) bool <span class="cov8" title="1">{
        for z := range Zip(x, y) </span><span class="cov8" title="1">{
                if z.Ok1 != z.Ok2 || z.V1 != z.V2 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Equal2 checks if two sequences of key-value pairs are equal.
func Equal2[K, V comparable](x, y iter.Seq2[K, V]) bool <span class="cov8" title="1">{
        for z := range Zip2(x, y) </span><span class="cov8" title="1">{
                if z.Ok1 != z.Ok2 || z.K1 != z.K2 || z.V1 != z.V2 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// EqualFunc checks if two sequences are equal using a custom equality function.
func EqualFunc[V1, V2 any](x iter.Seq[V1], y iter.Seq[V2], f func(V1, V2) bool) bool <span class="cov8" title="1">{
        for z := range Zip(x, y) </span><span class="cov8" title="1">{
                if z.Ok1 != z.Ok2 || !f(z.V1, z.V2) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// EqualFunc2 checks if two sequences of key-value pairs are equal using a custom equality function.
func EqualFunc2[K1, V1, K2, V2 any](x iter.Seq2[K1, V1], y iter.Seq2[K2, V2], f func(K1, V1, K2, V2) bool) bool <span class="cov8" title="1">{
        for z := range Zip2(x, y) </span><span class="cov8" title="1">{
                if z.Ok1 != z.Ok2 || !f(z.K1, z.V1, z.K2, z.V2) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Filter filters the elements of the sequence based on the given predicate function.
func Filter[V any](seq iter.Seq[V], f func(V) bool) iter.Seq[V] <span class="cov8" title="1">{
        return func(yield func(V) bool) </span><span class="cov8" title="1">{
                for v := range seq </span><span class="cov8" title="1">{
                        if f(v) &amp;&amp; !yield(v) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Filter2 filters the key-value pairs of the sequence based on the given predicate function.
func Filter2[K, V any](seq iter.Seq2[K, V], f func(K, V) bool) iter.Seq2[K, V] <span class="cov8" title="1">{
        return func(yield func(K, V) bool) </span><span class="cov8" title="1">{
                for k, v := range seq </span><span class="cov8" title="1">{
                        if f(k, v) &amp;&amp; !yield(k, v) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// Truncate limits the sequence to the first n elements.
func Truncate[V any](seq iter.Seq[V], n int) iter.Seq[V] <span class="cov8" title="1">{
        return func(yield func(V) bool) </span><span class="cov8" title="1">{
                if n &lt;= 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">for v := range seq </span><span class="cov8" title="1">{
                        if !yield(v) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">n--
                        if n &lt;= 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
}

// Truncate2 limits the sequence of key-value pairs to the first n elements.
func Truncate2[K, V any](seq iter.Seq2[K, V], n int) iter.Seq2[K, V] <span class="cov8" title="1">{
        return func(yield func(K, V) bool) </span><span class="cov8" title="1">{
                if n &lt;= 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">for k, v := range seq </span><span class="cov8" title="1">{
                        if !yield(k, v) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">n--
                        if n &lt;= 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
}

// Reduce reduces the sequence to a single value by applying the given binary function.
func Reduce[Accum, V any](seq iter.Seq[V], accum Accum, f func(Accum, V) Accum) Accum <span class="cov8" title="1">{
        for v := range seq </span><span class="cov8" title="1">{
                accum = f(accum, v)
        }</span>
        <span class="cov8" title="1">return accum</span>
}

// Reduce2 reduces the sequence of key-value pairs to a single value by applying the given binary function.
func Reduce2[Accum, K, V any](seq iter.Seq2[K, V], accum Accum, f func(Accum, K, V) Accum) Accum <span class="cov8" title="1">{
        for k, v := range seq </span><span class="cov8" title="1">{
                accum = f(accum, k, v)
        }</span>
        <span class="cov8" title="1">return accum</span>
}

// ReduceOrError reduces the sequence to a single value by applying the given binary function that can return an error.
func ReduceOrError[Accum, V any](seq iter.Seq[V], accum Accum, f func(Accum, V) (Accum, error)) (Accum, error) <span class="cov8" title="1">{
        var err error
        for v := range seq </span><span class="cov8" title="1">{
                accum, err = f(accum, v)
                if err != nil </span><span class="cov8" title="1">{
                        return accum, err
                }</span>
        }
        <span class="cov8" title="1">return accum, nil</span>
}

// ReduceOrError2 reduces the sequence of key-value pairs to a single value by applying the given binary function that can return an error.
func ReduceOrError2[Accum, K, V any](seq iter.Seq2[K, V], accum Accum, f func(Accum, K, V) (Accum, error)) (Accum, error) <span class="cov8" title="1">{
        var err error
        for k, v := range seq </span><span class="cov8" title="1">{
                accum, err = f(accum, k, v)
                if err != nil </span><span class="cov8" title="1">{
                        return accum, err
                }</span>
        }
        <span class="cov8" title="1">return accum, nil</span>
}

// ZipTruncate zips two sequences together, stopping when the shorter sequence is exhausted.
func ZipTruncate[V1, V2 any](x iter.Seq[V1], y iter.Seq[V2]) iter.Seq2[V1, V2] <span class="cov8" title="1">{
        return func(yield func(z1 V1, z2 V2) bool) </span><span class="cov8" title="1">{
                next, stop := iter.Pull(y)
                defer stop()
                v2, ok := next()
                for v1 := range x </span><span class="cov8" title="1">{
                        if !ok || !yield(v1, v2) </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">v2, ok = next()</span>
                }
        }
}

// Zipped represents a pair of values from two sequences, along with flags indicating their presence.
type Zipped[V1, V2 any] struct {
        V1  V1
        Ok1 bool // whether V1 is present (if not, it will be false)
        V2  V2
        Ok2 bool // whether V2 is present (if not, it will be false)
}

// Zip zips two sequences together, yielding pairs of values along with presence flags.
func Zip[V1, V2 any](x iter.Seq[V1], y iter.Seq[V2]) iter.Seq[Zipped[V1, V2]] <span class="cov8" title="1">{
        return func(yield func(z Zipped[V1, V2]) bool) </span><span class="cov8" title="1">{
                next, stop := iter.Pull(y)
                defer stop()
                v2, ok2 := next()
                for v1 := range x </span><span class="cov8" title="1">{
                        if !yield(Zipped[V1, V2]{v1, true, v2, ok2}) </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">v2, ok2 = next()</span>
                }
                <span class="cov8" title="1">var zv1 V1
                for ok2 </span><span class="cov0" title="0">{
                        if !yield(Zipped[V1, V2]{zv1, false, v2, ok2}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">v2, ok2 = next()</span>
                }
        }
}

// Zipped2 represents a pair of key-value pairs from two sequences, along with flags indicating their presence.
type Zipped2[K1, V1, K2, V2 any] struct {
        K1  K1
        V1  V1
        Ok1 bool // whether K1, V1 are present (if not, they will be false)
        K2  K2
        V2  V2
        Ok2 bool // whether K2, V2 are present (if not, they will be false)
}

// Zip2 zips two sequences of key-value pairs together, yielding pairs of key-value pairs along with presence flags.
func Zip2[K1, V1, K2, V2 any](x iter.Seq2[K1, V1], y iter.Seq2[K2, V2]) iter.Seq[Zipped2[K1, V1, K2, V2]] <span class="cov8" title="1">{
        return func(yield func(z Zipped2[K1, V1, K2, V2]) bool) </span><span class="cov8" title="1">{
                next, stop := iter.Pull2(y)
                defer stop()
                k2, v2, ok2 := next()
                for k1, v1 := range x </span><span class="cov8" title="1">{
                        if !yield(Zipped2[K1, V1, K2, V2]{k1, v1, true, k2, v2, ok2}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">k2, v2, ok2 = next()</span>
                }
                <span class="cov8" title="1">var zk1 K1
                var zv1 V1
                for ok2 </span><span class="cov0" title="0">{
                        if !yield(Zipped2[K1, V1, K2, V2]{zk1, zv1, false, k2, v2, ok2}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">k2, v2, ok2 = next()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file187" style="display: none">package maputils

import "maps"

// MapKeys applies the given function to each key of the input map and returns a new map with the transformed keys and original values.
func MapKeys[KIn, KOut comparable, V any](input map[KIn]V, f func(KIn) KOut) map[KOut]V <span class="cov8" title="1">{
        out := make(map[KOut]V)
        for k, v := range input </span><span class="cov8" title="1">{
                out[f(k)] = v
        }</span>
        <span class="cov8" title="1">return out</span>
}

// MapValues applies the given function to each value of the input map and returns a new map with the original keys and transformed values.
func MapValues[K comparable, VIn, VOut any](input map[K]VIn, f func(K, VIn) VOut) map[K]VOut <span class="cov8" title="1">{
        out := make(map[K]VOut)
        for k, v := range input </span><span class="cov8" title="1">{
                out[k] = f(k, v)
        }</span>
        <span class="cov8" title="1">return out</span>
}

// JoinOrError merges two maps into one. If a key exists in both maps, the provided duplication function is called to resolve the conflict.
func JoinOrError[K comparable, V any](left, right map[K]V, dup func(K, *V, *V) (V, error)) (map[K]V, error) <span class="cov8" title="1">{
        out := maps.Clone(left)
        var err error
        for k, v := range right </span><span class="cov8" title="1">{
                if existing, exists := out[k]; exists </span><span class="cov8" title="1">{
                        if out[k], err = dup(k, &amp;existing, &amp;v); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        out[k] = v
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// Join merges two maps into one. If a key exists in both maps, the provided duplication function is called to resolve the conflict.
func Join[K comparable, V any](left, right map[K]V, dup func(K, *V, *V) V) map[K]V <span class="cov8" title="1">{
        out, _ := JoinOrError(left, right, func(k K, v1, v2 *V) (V, error) </span><span class="cov8" title="1">{
                return dup(k, v1, v2), nil
        }</span>)
        <span class="cov8" title="1">return out</span>
}

// IsSubMap checks if the 'sub' map is a submap of the 'super' map using the provided equality function for values.
func IsSubMap[K comparable, V any](sub, super map[K]V, eq func(a, b V) bool) bool <span class="cov8" title="1">{
        if len(sub) &gt; len(super) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for k, v := range sub </span><span class="cov8" title="1">{
                if sv, exists := super[k]; !exists || !eq(v, sv) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">package mathutils

import (
        "encoding/binary"
        "io"
        "math/bits"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// RandomUint64 samples a random uint64 from the provided PRNG.
func RandomUint64(prng io.Reader) (uint64, error) <span class="cov0" title="0">{
        var data [8]byte
        _, err := io.ReadFull(prng, data[:])
        if err != nil </span><span class="cov0" title="0">{
                return 0, errs2.Wrap(err).WithMessage("failed to read random bytes")
        }</span>

        <span class="cov0" title="0">return binary.LittleEndian.Uint64(data[:]), nil</span>
}

// RandomUint64Range samples a random uint64 in the range [0, bound) from the provided PRNG.
func RandomUint64Range(prng io.Reader, bound uint64) (uint64, error) <span class="cov0" title="0">{
        // RandomUint64Range algorithm is slightly tricky. It rejects values that would result in an uneven distribution
        // (due to the fact that 2^64 is not divisible by n). The probability of a value being rejected depends on n.
        // The worst case is n=2^63+1, for which the probability of a reject is 1/2,
        // and the expected number of iterations before the loop terminates is 2.
        for </span><span class="cov0" title="0">{
                randBits, err := RandomUint64(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, errs2.Wrap(err).WithMessage("failed to sample random uint64")
                }</span>
                <span class="cov0" title="0">val := randBits % bound
                if (randBits - val) &gt;= (bound - 1) </span><span class="cov0" title="0">{
                        return val, nil
                }</span>
        }
}

// CeilDiv returns `ceil(numerator/denominator) for integer inputs. Equivalently,
// it returns `x`, the smallest integer that satisfies `(x*b) &gt;= a`.
func CeilDiv(numerator, denominator int) int <span class="cov8" title="1">{
        return (numerator - 1 + denominator) / denominator
}</span>

// FloorLog2 return floor(log2(x)).
func FloorLog2(x int) int <span class="cov8" title="1">{
        return 63 - bits.LeadingZeros64(uint64(x))
}</span>

// CeilLog2 return ceil(log2(x)).
func CeilLog2(x int) int <span class="cov8" title="1">{
        return 64 - bits.LeadingZeros64(uint64(x)-1)
}</span>
</pre>
		
		<pre class="file" id="file189" style="display: none">package nocopy

import (
        "sync/atomic"
        "unsafe"
)

// CopyChecker holds back pointer to itself to detect object copying.
type CopyChecker uintptr

// Check panics if the object has been copied since the last call to Check.
func (c *CopyChecker) Check() <span class="cov0" title="0">{
        // Check if c has been copied in three steps:
        // 1. The first comparison is the fast-path. If c has been initialised and not copied, this will return immediately. Otherwise, c is either not initialised, or has been copied.
        // 2. Ensure c is initialised. If the CAS succeeds, we're done. If it fails, c was either initialised concurrently and we simply lost the race, or c has been copied.
        // 3. Do step 1 again. Now that c is definitely initialised, if this fails, c was copied.
        if uintptr(*c) != uintptr(unsafe.Pointer(c)) &amp;&amp;
                !atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c))) &amp;&amp;
                uintptr(*c) != uintptr(unsafe.Pointer(c)) </span><span class="cov0" title="0">{

                panic("object is copied")</span>
        }
}

// NoCopy may be added to structs which must not be copied
// after the first use.
//
// See https://golang.org/issues/8005#issuecomment-190753527
// for details.
//
// Note that it must not be embedded, due to the Lock and Unlock methods.
type NoCopy struct{}

// Lock is a no-op used by -copylocks checker from `go vet`.
func (*NoCopy) Lock()   {<span class="cov0" title="0">}</span>
func (*NoCopy) Unlock() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file190" style="display: none">package sliceutils

import (
        "iter"

        "github.com/bronlabs/bron-crypto/pkg/base/utils"
)

// Combinations generates all k-combinations of the input slice s.
func Combinations[S ~[]T, T any](s S, k uint) iter.Seq[S] <span class="cov8" title="1">{
        if k &gt; uint(len(s)) </span><span class="cov8" title="1">{
                return func(yield func(S) bool) </span><span class="cov8" title="1">{
                        _ = yield(S{})
                }</span>
        }

        <span class="cov8" title="1">return func(yield func(S) bool) </span><span class="cov8" title="1">{
                n := len(s)
                combinations := utils.Binomial(n, int(k))
                data := make([]int, k)
                for i := range data </span><span class="cov8" title="1">{
                        data[i] = i
                }</span>

                <span class="cov8" title="1">result := mapElements(s, data)
                if proceed := yield(result); !proceed </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">for i := 1; i &lt; combinations; i++ </span><span class="cov8" title="1">{
                        nextCombination(data, n, int(k))
                        result := mapElements(s, data)
                        if proceed := yield(result); !proceed </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// KCoveringCombinations generates all combinations of the input slice s with sizes from k to len(s).
func KCoveringCombinations[S ~[]T, T any](s S, k uint) iter.Seq[S] <span class="cov8" title="1">{
        return func(yield func(S) bool) </span><span class="cov8" title="1">{
                for i := k; i &lt;= uint(len(s)); i++ </span><span class="cov8" title="1">{
                        for comb := range Combinations(s, i) </span><span class="cov8" title="1">{
                                if proceed := yield(comb); !proceed </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
        }
}

func nextCombination(s []int, n, k int) <span class="cov8" title="1">{
        for j := k - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                if s[j] == n+j-k </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">s[j]++
                for l := j + 1; l &lt; k; l++ </span><span class="cov8" title="1">{
                        s[l] = s[j] + l - j
                }</span>
                <span class="cov8" title="1">break</span>
        }
}

func mapElements[S ~[]T, T any](input S, indices []int) []T <span class="cov8" title="1">{
        result := make(S, len(indices))
        for i, index := range indices </span><span class="cov8" title="1">{
                result[i] = input[index]
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file191" style="display: none">package sliceutils

import (
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils"
)

// MapOrError applies the function f to each element of the input slice in,.
func MapOrError[SIn ~[]TIn, TIn, TOut any](in SIn, f func(TIn) (TOut, error)) (out []TOut, err error) <span class="cov8" title="1">{
        out = make([]TOut, len(in))
        for i, in := range in </span><span class="cov8" title="1">{
                out[i], err = f(in)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// MapCast applies the function f to each element of the input slice in,
// casting the output slice to the desired type S.
func MapCast[S ~[]TOut, TOut any, SIn ~[]TIn, TIn any](in SIn, f func(TIn) TOut) S <span class="cov8" title="1">{
        return slices.Collect(iterutils.Map(slices.Values(in), f))
}</span>

// Map applies the function f to each element of the input slice in,
// returning a slice of the output type.
func Map[TOut any, SIn ~[]TIn, TIn any](in SIn, f func(TIn) TOut) []TOut <span class="cov8" title="1">{
        return MapCast[[]TOut](in, f)
}</span>

// Filter returns a new slice containing only the elements of xs that satisfy the predicate.
func Filter[S ~[]T, T any](xs S, predicate func(T) bool) S <span class="cov8" title="1">{
        return slices.Collect(iterutils.Filter(slices.Values(xs), predicate))
}</span>

// Reduce reduces the slice xs to a single value by applying the binary function f cumulatively.
func Reduce[S ~[]T, T any](xs S, initial T, f func(T, T) T) T <span class="cov8" title="1">{
        return iterutils.Reduce(slices.Values(xs), initial, f)
}</span>

// Repeat creates a slice of length n, filled with the value x.
func Repeat[S ~[]T, T any](x T, n int) S <span class="cov8" title="1">{
        out := make(S, n)
        for i := range n </span><span class="cov8" title="1">{
                out[i] = x
        }</span>
        <span class="cov8" title="1">return out</span>
}

// Reversed returns a new slice that is the reverse of the input slice.
func Reversed[S ~[]T, T any](xs S) S <span class="cov8" title="1">{
        sx := slices.Clone(xs)
        slices.Reverse(sx)
        return sx
}</span>

// Reverse reverses the input slice in place and returns it.
func Reverse[S ~[]T, T any](xs S) S <span class="cov8" title="1">{
        slices.Reverse(xs)
        return xs
}</span>

// Shuffle uses Fisher-Yates algorithm to produce a random permutation of the input.
// https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithmreally
// It ought not be called with relatively big len(xs) (e.g. that doesn't fit in 32 bits).
// Not only will it take a very long time, but with 2! possible permutations,
// there's no way that any PRNG can have a big enough internal state to
// generate even a minuscule percentage of the possible permutations.
func Shuffle[S ~[]T, T any](xs S, prng io.Reader) (S, error) <span class="cov8" title="1">{
        if len(xs) == 0 </span><span class="cov8" title="1">{
                return xs, nil
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov8" title="1">{
                return nil, ErrArgumentIsNil.WithMessage("prng")
        }</span>

        <span class="cov8" title="1">for i := uint64(len(xs)) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                j, err := mathutils.RandomUint64Range(prng, i+1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to sample random uint64 in range")
                }</span>
                <span class="cov8" title="1">xs[j], xs[i] = xs[i], xs[j]</span>
        }
        <span class="cov8" title="1">return xs, nil</span>
}

// Shuffled returns a new slice that is a random permutation of the input slice.
func Shuffled[S ~[]T, T any](xs S, prng io.Reader) (S, error) <span class="cov8" title="1">{
        clone := make(S, len(xs))
        copy(clone, xs)
        return Shuffle(clone, prng)
}</span>

// PadToLeft pads the input slice xs to the left with zero values to reach the desired padLength.
func PadToLeft[S ~[]T, T any](xs S, padLength int) S <span class="cov8" title="1">{
        if padLength &lt; 0 </span><span class="cov8" title="1">{
                return xs
        }</span>
        <span class="cov8" title="1">out := make(S, len(xs)+padLength)
        copy(out[padLength:], xs)
        return out</span>
}

// PadToLeftWith pads the input slice xs to the left with the specified pad value to reach the desired padLength.
func PadToLeftWith[S ~[]T, T any](xs S, padLength int, pad T) S <span class="cov8" title="1">{
        out := PadToLeft(xs, padLength)
        for i := range padLength </span><span class="cov8" title="1">{
                out[i] = pad
        }</span>
        <span class="cov8" title="1">return out</span>
}

// PadToRight pads the input slice xs to the right with zero values to reach the desired padLength.
func PadToRight[S ~[]T, T any](xs S, padLength int) S <span class="cov8" title="1">{
        if padLength &lt; 0 </span><span class="cov8" title="1">{
                return xs
        }</span>
        <span class="cov8" title="1">out := make(S, len(xs)+padLength)
        copy(out[:len(xs)], xs)
        return out</span>
}

// PadToRightWith pads the input slice xs to the right with the specified pad value to reach the desired padLength.
func PadToRightWith[S ~[]T, T any](xs S, padLength int, pad T) S <span class="cov8" title="1">{
        out := PadToRight(xs, padLength)
        for i := len(xs); i &lt; len(out); i++ </span><span class="cov8" title="1">{
                out[i] = pad
        }</span>
        <span class="cov8" title="1">return out</span>
}

// Count returns the number of elements in xs that satisfy the predicate.
func Count[S ~[]T, T any](xs S, predicate func(T) bool) int <span class="cov8" title="1">{
        count := 0
        for _, x := range xs </span><span class="cov8" title="1">{
                if predicate(x) </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// CountUnique returns the number of unique elements in xs.
func CountUnique[S ~[]T, T comparable](xs S) int <span class="cov8" title="1">{
        seen := make(map[T]struct{})
        count := 0
        for _, x := range xs </span><span class="cov8" title="1">{
                if _, exists := seen[x]; !exists </span><span class="cov8" title="1">{
                        seen[x] = struct{}{}
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// CountUniqueFunc returns the number of unique elements in xs using the provided equality function.
func CountUniqueFunc[S ~[]T, T any](xs S, equal func(T, T) bool) int <span class="cov8" title="1">{
        seen := make([]T, 0, len(xs))
        count := 0
        for _, x := range xs </span><span class="cov8" title="1">{
                found := false
                for _, y := range seen </span><span class="cov8" title="1">{
                        if equal(x, y) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        seen = append(seen, x)
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

// Any returns true if any element in xs satisfies the predicate.
func Any[S ~[]T, T any](xs S, predicate func(T) bool) bool <span class="cov8" title="1">{
        return Count(xs, predicate) &gt; 0
}</span>

// All returns true if all elements in xs satisfy the predicate.
func All[S ~[]T, T any](xs S, predicate func(T) bool) bool <span class="cov8" title="1">{
        return Count(xs, predicate) == len(xs)
}</span>

// IsAllUnique returns true if all elements in xs are unique.
func IsAllUnique[S ~[]T, T comparable](xs S) bool <span class="cov8" title="1">{
        return CountUnique(xs) == len(xs)
}</span>

// IsAllUniqueFunc returns true if all elements in xs are unique using the provided equality function.
func IsAllUniqueFunc[S ~[]T, T any](xs S, equal func(T, T) bool) bool <span class="cov8" title="1">{
        return CountUniqueFunc(xs, equal) == len(xs)
}</span>

// IsSubSet returns true if all elements of sub are present in sup.
func IsSubSet[SB, SP ~[]T, T comparable](sub SB, sup SP) bool <span class="cov8" title="1">{
        if len(sub) &gt; len(sup) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, x := range sub </span><span class="cov8" title="1">{
                found := false
                for _, y := range sup </span><span class="cov8" title="1">{
                        if x == y </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsSubSetFunc returns true if all elements of sub are present in sup using the provided equality function.
func IsSubSetFunc[SB, SP ~[]T, T any](sub SB, sup SP, equal func(T, T) bool) bool <span class="cov8" title="1">{
        if len(sub) &gt; len(sup) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, x := range sub </span><span class="cov8" title="1">{
                found := false
                for _, y := range sup </span><span class="cov8" title="1">{
                        if equal(x, y) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// IsSuperSet returns true if ss contains all elements of s.
func IsSuperSet[T comparable](ss, s []T) bool <span class="cov8" title="1">{
        for _, si := range s </span><span class="cov8" title="1">{
                if !slices.Contains(ss, si) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// ContainsFunc returns true if xs contains the element x using the provided equality function.
func ContainsFunc[S ~[]T, T any](xs S, x T, equal func(T, T) bool) bool <span class="cov8" title="1">{
        for _, y := range xs </span><span class="cov8" title="1">{
                if equal(x, y) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Fold reduces the slice rest to a single value by applying the binary function f cumulatively, starting with initial.
func Fold[T, U any](f func(acc U, x T) U, initial U, rest ...T) U <span class="cov8" title="1">{
        accumulator := func(acc U, x T) (U, error) </span><span class="cov8" title="1">{ return f(acc, x), nil }</span>
        <span class="cov8" title="1">out, err := FoldOrError(accumulator, initial, rest...)
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err))</span>
        }
        <span class="cov8" title="1">return out</span>
}

// FoldOrError reduces the slice rest to a single value by applying the binary function f cumulatively, starting with initial.
func FoldOrError[T, U any](f func(acc U, x T) (U, error), initial U, rest ...T) (U, error) <span class="cov8" title="1">{
        if len(rest) == 0 </span><span class="cov8" title="1">{
                return initial, nil
        }</span>
        <span class="cov8" title="1">out := initial
        var err error
        for _, x := range rest </span><span class="cov8" title="1">{
                out, err = f(out, x)
                if err != nil </span><span class="cov8" title="1">{
                        return *new(U), errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// Fill fills the slice s with the value x.
func Fill[T any](s []T, x T) <span class="cov8" title="1">{
        for i := range s </span><span class="cov8" title="1">{
                s[i] = x
        }</span>
}

var ErrArgumentIsNil = errs2.New("argument is nil")
</pre>
		
		<pre class="file" id="file192" style="display: none">package hash_comm

import (
        "hash"
        "io"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/commitments"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/network"
)

var (
        _ commitments.Commitment = Commitment{}
        _ commitments.Message    = Message(nil)
        _ commitments.Witness    = Witness{}
        _ commitments.Key        = Key{}

        // HmacFunc defines the hash function used to instantiate the HMAC-based commitments.
        HmacFunc = blake2b.New256
)

const (
        KeySize    = 32
        DigestSize = 32

        // Name identifies the hash-based commitment scheme.
        Name commitments.Name = "KMACBasedCommitmentScheme"
)

type (
        // Commitment is the hash digest produced by the commitment algorithm.
        Commitment [DigestSize]byte
        // Message is an arbitrary byte slice being committed.
        Message []byte
        // Witness is the random nonce mixed into the commitment.
        Witness [DigestSize]byte
        // Key is the secret HMAC key derived from the CRS.
        Key [KeySize]byte
)

// Bytes returns the raw commitment digest bytes.
func (c Commitment) Bytes() []byte <span class="cov0" title="0">{
        return c[:]
}</span>

// Bytes returns the raw witness bytes.
func (w Witness) Bytes() []byte <span class="cov0" title="0">{
        return w[:]
}</span>

func (k Key) hmacInit() hash.Hash <span class="cov8" title="1">{
        hmac, err := HmacFunc(k[:])
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err).WithMessage("cannot create HMAC hash function"))</span>
        }
        <span class="cov8" title="1">return hmac</span>
}

// NewKeyFromCRSBytes derives a commitment key from the SID, domain separation tag and CRS transcripts.
func NewKeyFromCRSBytes(sid network.SID, dst string, crs ...[]byte) (Key, error) <span class="cov0" title="0">{
        if ct.SliceIsZero(sid[:]) == 1 </span><span class="cov0" title="0">{
                return Key{}, ErrInvalidArgument.WithMessage("SID cannot be zero")
        }</span>
        <span class="cov0" title="0">if dst == "" </span><span class="cov0" title="0">{
                return Key{}, ErrInvalidArgument.WithMessage("dst cannot be empty")
        }</span>
        <span class="cov0" title="0">hasher, err := blake2b.New256(sid[:])
        if err != nil </span><span class="cov0" title="0">{
                return Key{}, errs2.Wrap(err).WithMessage("cannot create hash")
        }</span>
        <span class="cov0" title="0">h := func() hash.Hash </span><span class="cov0" title="0">{ return hasher }</span>
        <span class="cov0" title="0">out, err := hashing.HashPrefixedLength(h, append(crs, []byte(dst))...)
        if err != nil </span><span class="cov0" title="0">{
                return Key{}, errs2.Wrap(err).WithMessage("cannot hash CRS")
        }</span>
        <span class="cov0" title="0">var key Key
        copy(key[:], out)
        return key, nil</span>
}

// NewScheme constructs the hash-based commitment scheme with the provided key.
func NewScheme(key Key) (*Scheme, error) <span class="cov8" title="1">{
        if ct.SliceIsZero(key[:]) == 1 </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("key cannot be zero")
        }</span>
        <span class="cov8" title="1">return &amp;Scheme{key: key}, nil</span>
}

// Scheme bundles the hash-based committer and verifier using a shared key.
type Scheme struct {
        key Key
}

// Name returns the identifier of the hash-based commitment scheme.
func (*Scheme) Name() commitments.Name <span class="cov0" title="0">{
        return Name
}</span>

// Committer returns a committer initialised with the scheme key.
func (s *Scheme) Committer() *Committer <span class="cov8" title="1">{
        return &amp;Committer{s.key.hmacInit()}
}</span>

// Verifier returns a verifier compatible with commitments produced by the scheme.
func (s *Scheme) Verifier() *Verifier <span class="cov8" title="1">{
        committingParty := &amp;Committer{s.key.hmacInit()}
        generic := commitments.NewGenericVerifier(committingParty, func(c1, c2 Commitment) bool </span><span class="cov8" title="1">{
                return ct.SliceEqual(c1[:], c2[:]) == 1
        }</span>)
        <span class="cov8" title="1">out := &amp;Verifier{GenericVerifier: *generic}
        return out</span>
}

// Key returns the scheme key material.
func (s *Scheme) Key() Key <span class="cov0" title="0">{
        return s.key
}</span>

// Committer computes hash-based commitments with an HMAC keyed by the CRS output.
type Committer struct {
        hmac hash.Hash
}

// CommitWithWitness commits to the message using caller-supplied witness randomness.
func (c *Committer) CommitWithWitness(message Message, witness Witness) (commitment Commitment, err error) <span class="cov8" title="1">{
        c.hmac.Write(witness[:])
        c.hmac.Write(message)
        out := c.hmac.Sum(nil)
        c.hmac.Reset()
        if len(out) != DigestSize </span><span class="cov0" title="0">{
                return commitment, ErrFailed.WithMessage("invalid commitment length, expected %d bytes, got %d", DigestSize, len(out))
        }</span>
        <span class="cov8" title="1">copy(commitment[:], out)
        return commitment, nil</span>
}

// Commit samples fresh witness randomness and computes a commitment to the message.
func (c *Committer) Commit(message Message, prng io.Reader) (commitment Commitment, witness Witness, err error) <span class="cov8" title="1">{
        if _, err = io.ReadFull(prng, witness[:]); err != nil </span><span class="cov0" title="0">{
                return commitment, witness, errs2.Wrap(err).WithMessage("cannot sample witness")
        }</span>

        <span class="cov8" title="1">commitment, err = c.CommitWithWitness(message, witness)
        if err != nil </span><span class="cov0" title="0">{
                return Commitment{}, Witness{}, errs2.Wrap(err).WithMessage("cannot compute commitment")
        }</span>

        <span class="cov8" title="1">return commitment, witness, nil</span>
}

// Verifier checks commitments against provided messages and witnesses.
type Verifier struct {
        commitments.GenericVerifier[*Committer, Witness, Message, Commitment]
}
</pre>
		
		<pre class="file" id="file193" style="display: none">package pedersen

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
)

// Commitment represents a Pedersen commitment value held in the prime order group.
type Commitment[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        v E
}

type commitmentDTO[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        V E `cbor:"v"`
}

// NewCommitment wraps the provided group element as a commitment, rejecting the identity element.
func NewCommitment[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]](v E) (*Commitment[E, S], error) <span class="cov8" title="1">{
        if v.IsOpIdentity() </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("commitment value cannot be the identity element")
        }</span>
        <span class="cov8" title="1">return &amp;Commitment[E, S]{v: v}, nil</span>
}

// Value returns the underlying group element of the commitment.
func (c *Commitment[E, S]) Value() E <span class="cov8" title="1">{
        return c.v
}</span>

// Equal reports whether both commitments hold the same group element (and handles nils).
func (c *Commitment[E, S]) Equal(other *Commitment[E, S]) bool <span class="cov8" title="1">{
        if c == nil || other == nil </span><span class="cov8" title="1">{
                return c == other
        }</span>
        <span class="cov8" title="1">return c.v.Equal(other.v)</span>
}

// Op combines two commitments using the group operation.
func (c *Commitment[E, S]) Op(other *Commitment[E, S]) *Commitment[E, S] <span class="cov8" title="1">{
        if other == nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov8" title="1">return &amp;Commitment[E, S]{v: c.v.Op(other.v)}</span>
}

// ScalarOp raises the commitment to the given message scalar.
func (c *Commitment[E, S]) ScalarOp(message *Message[S]) *Commitment[E, S] <span class="cov8" title="1">{
        if message == nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov8" title="1">return &amp;Commitment[E, S]{v: c.v.ScalarOp(message.v)}</span>
}

// ReRandomiseWith blinds the commitment using the provided witness randomness.
func (c *Commitment[E, S]) ReRandomiseWith(key *Key[E, S], r *Witness[S]) (*Commitment[E, S], error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("witness cannot be nil")
        }</span>
        <span class="cov8" title="1">if key == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("key cannot be nil")
        }</span>
        <span class="cov8" title="1">if c == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("commitment cannot be nil")
        }</span>
        <span class="cov8" title="1">newCom, err := NewCommitment(c.v.Op(key.h.ScalarOp(r.v)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot re-randomise commitment")
        }</span>
        <span class="cov8" title="1">return newCom, nil</span>
}

// ReRandomise samples fresh randomness and blinds the commitment, returning the new commitment and witness.
func (c *Commitment[E, S]) ReRandomise(key *Key[E, S], prng io.Reader) (*Commitment[E, S], *Witness[S], error) <span class="cov8" title="1">{
        if key == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrInvalidArgument.WithMessage("key cannot be nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrInvalidArgument.WithMessage("prng cannot be nil")
        }</span>

        <span class="cov8" title="1">group := algebra.StructureMustBeAs[algebra.PrimeGroup[E, S]](key.h.Structure())
        field := algebra.StructureMustBeAs[algebra.PrimeField[S]](group.ScalarStructure())
        wv, err := algebrautils.RandomNonIdentity(field, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot generate random witness")
        }</span>
        <span class="cov8" title="1">witness, err := NewWitness(wv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create witness")
        }</span>
        <span class="cov8" title="1">commitment, err := c.ReRandomiseWith(key, witness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot re-randomise commitment with witness")
        }</span>
        <span class="cov8" title="1">return commitment, witness, nil</span>
}

// Clone returns a deep copy of the commitment.
func (c *Commitment[E, S]) Clone() *Commitment[E, S] <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;Commitment[E, S]{v: c.v.Clone()}</span>
}

// HashCode returns a hash of the commitment for use in maps or sets.
func (c *Commitment[E, S]) HashCode() base.HashCode <span class="cov8" title="1">{
        return c.v.HashCode()
}</span>

// Bytes serialises the commitment to its canonical byte representation.
func (c *Commitment[E, S]) Bytes() []byte <span class="cov0" title="0">{
        return c.v.Bytes()
}</span>

// MarshalCBOR encodes the commitment into CBOR format.
func (c *Commitment[E, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;commitmentDTO[E, S]{
                V: c.v,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Pedersen commitment")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR decodes a CBOR commitment into the receiver.
func (c *Commitment[E, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*commitmentDTO[E, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("failed to unmarshal Pedersen commitment")
        }</span>
        <span class="cov0" title="0">c2, err := NewCommitment(dto.V)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*c = *c2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">package pedersen

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// Committer produces Pedersen commitments using the provided key.
type Committer[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        key *Key[E, S]
}

// Commit samples fresh randomness and commits to a message, returning the commitment and witness.
func (c *Committer[E, S]) Commit(message *Message[S], prng io.Reader) (*Commitment[E, S], *Witness[S], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrInvalidArgument.WithMessage("prng cannot be nil")
        }</span>
        <span class="cov8" title="1">if message == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrInvalidArgument.WithMessage("message cannot be nil")
        }</span>

        <span class="cov8" title="1">group := algebra.StructureMustBeAs[algebra.PrimeGroup[E, S]](c.key.h.Structure())
        field := algebra.StructureMustBeAs[algebra.PrimeField[S]](group.ScalarStructure())
        wv, err := field.Random(prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot generate random witness")
        }</span>
        <span class="cov8" title="1">witness := &amp;Witness[S]{v: wv}
        com, err := c.CommitWithWitness(message, witness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot commit with witness")
        }</span>
        <span class="cov8" title="1">return com, witness, nil</span>
}

// CommitWithWitness commits to a message using caller-supplied witness randomness.
func (c *Committer[E, S]) CommitWithWitness(message *Message[S], witness *Witness[S]) (*Commitment[E, S], error) <span class="cov8" title="1">{
        if message == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("message cannot be nil")
        }</span>
        <span class="cov8" title="1">if witness == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("witness cannot be nil")
        }</span>

        // TODO: change to multiscalar op? (for two ops, we gain almost nothing)
        // Compute g^m * h^r
        <span class="cov8" title="1">v := c.key.g.ScalarOp(message.v).Op(c.key.h.ScalarOp(witness.v))
        return &amp;Commitment[E, S]{v: v}, nil</span>
}
</pre>
		
		<pre class="file" id="file195" style="display: none">package pedersen

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

// Key holds the generators defining a Pedersen commitment CRS.
type Key[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        g E
        h E
}

type keyDTO[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        G E
        H E
}

// NewCommitmentKey validates and constructs a Pedersen key from two independent generators.
func NewCommitmentKey[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]](g, h E) (*Key[E, S], error) <span class="cov8" title="1">{
        if g.IsOpIdentity() || h.IsOpIdentity() </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("g or h cannot be the identity element")
        }</span>
        <span class="cov8" title="1">if g.Equal(h) </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("g and h cannot be equal")
        }</span>

        <span class="cov8" title="1">k := &amp;Key[E, S]{
                g: g,
                h: h,
        }
        return k, nil</span>
}

// G returns the first generator.
func (k *Key[E, S]) G() E <span class="cov8" title="1">{
        return k.g
}</span>

// H returns the second generator used for hiding randomness.
func (k *Key[E, S]) H() E <span class="cov8" title="1">{
        return k.h
}</span>

// Bytes concatenates the encoded generators.
func (k *Key[E, S]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(k.g.Bytes(), k.h.Bytes())
}</span>

// Group exposes the prime group structure shared by the generators.
func (k *Key[E, S]) Group() algebra.PrimeGroup[E, S] <span class="cov0" title="0">{
        return algebra.StructureMustBeAs[algebra.PrimeGroup[E, S]](k.g.Structure())
}</span>

// MarshalCBOR encodes the key into CBOR format.
func (k *Key[E, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;keyDTO[E, S]{
                G: k.g,
                H: k.h,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Pedersen key")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR decodes a CBOR-encoded key into the receiver.
func (k *Key[E, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*keyDTO[E, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("failed to unmarshal Pedersen key")
        }</span>
        <span class="cov0" title="0">k2, err := NewCommitmentKey(dto.G, dto.H)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create commitment key")
        }</span>

        <span class="cov0" title="0">*k = *k2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file196" style="display: none">package pedersen

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

// Message wraps a scalar plaintext committed with Pedersen commitments.
type Message[S algebra.PrimeFieldElement[S]] struct {
        v S
}

type messageDTO[S algebra.PrimeFieldElement[S]] struct {
        V S `cbor:"v"`
}

// NewMessage constructs a message from the provided scalar value.
func NewMessage[S algebra.PrimeFieldElement[S]](v S) *Message[S] <span class="cov8" title="1">{
        return &amp;Message[S]{
                v: v,
        }
}</span>

// Value returns the underlying scalar.
func (m *Message[S]) Value() S <span class="cov8" title="1">{
        return m.v
}</span>

// Op adds another message in the underlying field.
func (m *Message[S]) Op(other *Message[S]) *Message[S] <span class="cov8" title="1">{
        return m.Add(other)
}</span>

// Add performs field addition with another message.
func (m *Message[S]) Add(other *Message[S]) *Message[S] <span class="cov8" title="1">{
        if other == nil </span><span class="cov8" title="1">{
                return m
        }</span>
        <span class="cov8" title="1">return &amp;Message[S]{
                v: m.v.Add(other.v),
        }</span>
}

// OtherOp multiplies with another message in the field.
func (m *Message[S]) OtherOp(other *Message[S]) *Message[S] <span class="cov8" title="1">{
        return m.Mul(other)
}</span>

// Mul multiplies two messages in the underlying field.
func (m *Message[S]) Mul(other *Message[S]) *Message[S] <span class="cov8" title="1">{
        if other == nil </span><span class="cov8" title="1">{
                return m
        }</span>
        <span class="cov8" title="1">return &amp;Message[S]{
                v: m.v.Mul(other.v),
        }</span>
}

// Clone returns a deep copy of the message.
func (m *Message[S]) Clone() *Message[S] <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;Message[S]{
                v: m.v.Clone(),
        }</span>
}

// Equal reports whether the two messages represent the same scalar (and handles nils).
func (m *Message[S]) Equal(other *Message[S]) bool <span class="cov8" title="1">{
        if m == nil || other == nil </span><span class="cov8" title="1">{
                return m == other
        }</span>
        <span class="cov8" title="1">return m.v.Equal(other.v)</span>
}

// HashCode returns a hash of the message value.
func (m *Message[S]) HashCode() base.HashCode <span class="cov8" title="1">{
        return m.v.HashCode()
}</span>

// Bytes serialises the message to bytes using the scalar encoding.
func (m *Message[S]) Bytes() []byte <span class="cov0" title="0">{
        return m.v.Bytes()
}</span>

// MarshalCBOR encodes the message into CBOR format.
func (m *Message[S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;messageDTO[S]{
                V: m.v,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Pedersen message")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR decodes a CBOR message into the receiver.
func (m *Message[S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*messageDTO[S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("failed to unmarshal Pedersen message")
        }</span>

        <span class="cov0" title="0">m2 := NewMessage(dto.V)
        *m = *m2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file197" style="display: none">package pedersen

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/commitments"
)

// Scheme wires together the Pedersen CRS with its committer and verifier.
type Scheme[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        key *Key[E, S]
}

// NewScheme validates and constructs a Pedersen commitment scheme from the provided key.
func NewScheme[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]](key *Key[E, S]) (*Scheme[E, S], error) <span class="cov8" title="1">{
        if key == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("key cannot be nil")
        }</span>

        <span class="cov8" title="1">s := &amp;Scheme[E, S]{
                key: key,
        }
        return s, nil</span>
}

// Name returns the identifier of the Pedersen commitment scheme.
func (*Scheme[_, _]) Name() commitments.Name <span class="cov8" title="1">{
        return Name
}</span>

// Committer returns a committer configured with the scheme key.
func (s *Scheme[E, S]) Committer() *Committer[E, S] <span class="cov8" title="1">{
        return &amp;Committer[E, S]{
                key: s.key,
        }
}</span>

// Verifier returns a verifier compatible with commitments produced by this scheme.
func (s *Scheme[E, S]) Verifier() *Verifier[E, S] <span class="cov8" title="1">{
        committingParty := &amp;Committer[E, S]{
                key: s.key,
        }
        generic := commitments.NewGenericVerifier(committingParty, func(c1, c2 *Commitment[E, S]) bool </span><span class="cov8" title="1">{
                return c1.Equal(c2)
        }</span>)
        <span class="cov8" title="1">v := &amp;Verifier[E, S]{
                GenericVerifier: *generic,
        }
        return v</span>
}

// Key exposes the scheme CRS.
func (s *Scheme[E, S]) Key() *Key[E, S] <span class="cov0" title="0">{
        return s.key
}</span>

// Group returns the prime group used by the scheme.
func (s *Scheme[E, S]) Group() algebra.PrimeGroup[E, S] <span class="cov0" title="0">{
        return s.key.Group()
}</span>
</pre>
		
		<pre class="file" id="file198" style="display: none">package pedersen

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

// Witness holds the randomness used to hide the committed message.
type Witness[S algebra.PrimeFieldElement[S]] struct {
        v S
}

type witnessDTO[S algebra.PrimeFieldElement[S]] struct {
        V S `cbor:"w"`
}

// NewWitness constructs a witness, rejecting zero values to prevent degenerate commitments.
func NewWitness[S algebra.PrimeFieldElement[S]](v S) (*Witness[S], error) <span class="cov8" title="1">{
        if v.IsZero() </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("witness value cannot be zero")
        }</span>
        <span class="cov8" title="1">w := &amp;Witness[S]{
                v: v,
        }
        return w, nil</span>
}

// Value returns the witness scalar.
func (w *Witness[S]) Value() S <span class="cov8" title="1">{
        return w.v
}</span>

// Op adds two witnesses in the field.
func (w *Witness[S]) Op(other *Witness[S]) *Witness[S] <span class="cov8" title="1">{
        return w.Add(other)
}</span>

// Add performs field addition with another witness.
func (w *Witness[S]) Add(other *Witness[S]) *Witness[S] <span class="cov8" title="1">{
        if other == nil </span><span class="cov0" title="0">{
                return w
        }</span>
        <span class="cov8" title="1">return &amp;Witness[S]{
                v: w.v.Add(other.v),
        }</span>
}

// OtherOp multiplies with another witness in the field.
func (w *Witness[S]) OtherOp(other *Witness[S]) *Witness[S] <span class="cov8" title="1">{
        return w.Mul(other)
}</span>

// Mul multiplies two witnesses in the underlying field.
func (w *Witness[S]) Mul(other *Witness[S]) *Witness[S] <span class="cov8" title="1">{
        if other == nil </span><span class="cov0" title="0">{
                return w
        }</span>
        <span class="cov8" title="1">return &amp;Witness[S]{
                v: w.v.Mul(other.v),
        }</span>
}

// Equal reports whether the two witnesses hold the same scalar (and handles nils).
func (w *Witness[S]) Equal(other *Witness[S]) bool <span class="cov8" title="1">{
        if w == nil || other == nil </span><span class="cov8" title="1">{
                return w == other
        }</span>
        <span class="cov8" title="1">return w.v.Equal(other.v)</span>
}

// Clone returns a deep copy of the witness.
func (w *Witness[S]) Clone() *Witness[S] <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;Witness[S]{
                v: w.v.Clone(),
        }</span>
}

// HashCode returns a hash of the witness value.
func (w *Witness[S]) HashCode() base.HashCode <span class="cov8" title="1">{
        return w.v.HashCode()
}</span>

// MarshalCBOR encodes the witness into CBOR format.
func (w *Witness[S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;witnessDTO[S]{
                V: w.v,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Pedersen witness")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR decodes a CBOR witness into the receiver.
func (w *Witness[S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*witnessDTO[S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot unmarshal witness")
        }</span>

        <span class="cov0" title="0">w2, err := NewWitness(dto.V)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*w = *w2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file199" style="display: none">package commitments

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

var (
        ErrVerificationFailed = errs2.New("verification failed")
)

func NewGenericVerifier[T Committer[W, M, C], W Witness, M Message, C Commitment](committer T, commitmentsAreEqual func(c1, c2 C) bool) *GenericVerifier[T, W, M, C] <span class="cov0" title="0">{
        return &amp;GenericVerifier[T, W, M, C]{committer: committer, commitmentsAreEqual: commitmentsAreEqual}
}</span>

type GenericVerifier[T Committer[W, M, C], W Witness, M Message, C Commitment] struct {
        committer           T
        commitmentsAreEqual func(c1, c2 C) bool
}

// Verify verifies correctness of the commitment.
func (v *GenericVerifier[T, W, M, C]) Verify(commitment C, message M, witness W) error <span class="cov0" title="0">{
        recomputed, err := v.committer.CommitWithWitness(message, witness)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot recompute commitment")
        }</span>
        <span class="cov0" title="0">if !v.commitmentsAreEqual(recomputed, commitment) </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("commitment does not match")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file200" style="display: none">package hpke

import (
        "crypto/cipher"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/encryption"
        "github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal"
)

type (
        // ModeID is a one-byte value indicating the HPKE mode, defined in RFC 9180 Table 1.
        // The four modes provide different authentication guarantees:
        //   - Base (0x00): No sender authentication
        //   - PSK (0x01): Sender authenticated via pre-shared key
        //   - Auth (0x02): Sender authenticated via asymmetric key
        //   - AuthPSK (0x03): Sender authenticated via both PSK and asymmetric key
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5
        ModeID = internal.ModeID

        // AEADID is a two-byte value identifying the AEAD algorithm, defined in RFC 9180 Table 3.
        // HPKE supports AES-128-GCM, AES-256-GCM, ChaCha20Poly1305, and an export-only mode.
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-7.3
        AEADID = internal.AEADID

        // KDFID is a two-byte value identifying the key derivation function, defined in RFC 9180 Table 2.
        // HPKE uses HKDF with either SHA-256 or SHA-512 as the underlying hash.
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-7.2
        KDFID = internal.KDFID

        // KEMID is a two-byte value identifying the key encapsulation mechanism, defined in RFC 9180 Table 2.
        // This implementation supports DHKEM(P-256, HKDF-SHA256) and DHKEM(X25519, HKDF-SHA256).
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-7.1
        KEMID = internal.KEMID

        // PrivateKey represents a KEM private key, which is a scalar in the underlying elliptic curve's
        // scalar field. The private key is used for decapsulation and, in authenticated modes, to prove
        // the sender's identity.
        PrivateKey[S algebra.PrimeFieldElement[S]] = internal.PrivateKey[S]

        // PublicKey represents a KEM public key, which is a point on the underlying elliptic curve.
        // The public key is used for encapsulation and to identify the recipient.
        PublicKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] = internal.PublicKey[P, B, S]

        // Capsule is the encapsulated key transmitted from sender to receiver, represented as an
        // ephemeral public key. In DHKEM, the capsule is the serialised ephemeral public key (enc)
        // that allows the receiver to derive the same shared secret.
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1
        Capsule[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] = internal.PublicKey[P, B, S]

        // Ciphertext is the encrypted message produced by HPKE's AEAD encryption.
        // It contains both the encrypted plaintext and the authentication tag.
        Ciphertext []byte

        // Message is the plaintext input to or output from HPKE encryption/decryption.
        Message = []byte

        // CipherSuite specifies the combination of KEM, KDF, and AEAD algorithms used for HPKE.
        // The suite identifier is computed as concat("HPKE", I2OSP(kem_id, 2), I2OSP(kdf_id, 2), I2OSP(aead_id, 2)).
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1
        CipherSuite = internal.CipherSuite

        // SenderContext holds the encryption context established by the sender after key encapsulation.
        // It provides the Seal method for encrypting messages and Export for deriving additional secrets.
        // The context maintains sequence numbers to ensure unique nonces for each encryption operation.
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2
        SenderContext[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] = internal.SenderContext[P, B, S]

        // ReceiverContext holds the decryption context established by the receiver after key decapsulation.
        // It provides the Open method for decrypting messages and Export for deriving additional secrets.
        // The context maintains sequence numbers that must match the sender's for successful decryption.
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2
        ReceiverContext[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] = internal.ReceiverContext[P, B, S]
)

const (
        // Name is the identifier for the HPKE encryption scheme.
        Name encryption.Name = "HPKE"

        // HPKE Modes (RFC 9180 Section 5, Table 1)
        // These modes determine the authentication properties of the HPKE context.

        // Base mode (mode_base = 0x00) provides encryption without sender authentication.
        // The recipient cannot verify the sender's identity.
        Base ModeID = internal.Base

        // PSk mode (mode_psk = 0x01) authenticates the sender via a pre-shared key.
        // Both parties must possess the same PSK and PSK ID. The recipient can verify
        // the sender possessed the PSK, but PSK compromise allows impersonation.
        PSk ModeID = internal.PSk

        // Auth mode (mode_auth = 0x02) authenticates the sender via an asymmetric key pair.
        // The sender's private key is used in the encapsulation, allowing the recipient
        // to verify the sender's identity using the sender's public key.
        Auth ModeID = internal.Auth

        // AuthPSk mode (mode_auth_psk = 0x03) combines PSK and asymmetric authentication.
        // The sender is authenticated via both mechanisms, providing defence in depth.
        AuthPSk ModeID = internal.AuthPSk

        // AEAD Algorithm Identifiers (RFC 9180 Section 7.3, Table 3).

        // AEAD_RESERVED (0x0000) is reserved and MUST NOT be used.
        AEAD_RESERVED AEADID = internal.AEAD_RESERVED

        // AEAD_AES_128_GCM (0x0001) specifies AES-128-GCM with Nk=16, Nn=12, Nt=16.
        AEAD_AES_128_GCM AEADID = internal.AEAD_AES_128_GCM

        // AEAD_AES_256_GCM (0x0002) specifies AES-256-GCM with Nk=32, Nn=12, Nt=16.
        AEAD_AES_256_GCM AEADID = internal.AEAD_AES_256_GCM

        // AEAD_CHACHA_20_POLY_1305 (0x0003) specifies ChaCha20Poly1305 with Nk=32, Nn=12, Nt=16.
        AEAD_CHACHA_20_POLY_1305 AEADID = internal.AEAD_CHACHA_20_POLY_1305

        // AEAD_EXPORT_ONLY (0xFFFF) indicates that the AEAD is not used for encryption;
        // only the Export interface is available. This is useful for key derivation scenarios.
        AEAD_EXPORT_ONLY AEADID = internal.AEAD_EXPORT_ONLY

        // KDF Algorithm Identifiers (RFC 9180 Section 7.2, Table 2).

        // KDF_HKDF_RESERVED (0x0000) is reserved and MUST NOT be used.
        KDF_HKDF_RESERVED KDFID = internal.KDF_HKDF_RESERVED

        // KDF_HKDF_SHA256 (0x0001) specifies HKDF-SHA256 with Nh=32.
        KDF_HKDF_SHA256 KDFID = internal.KDF_HKDF_SHA256

        // KDF_HKDF_SHA512 (0x0003) specifies HKDF-SHA512 with Nh=64.
        KDF_HKDF_SHA512 KDFID = internal.KDF_HKDF_SHA512

        // KEM Algorithm Identifiers (RFC 9180 Section 7.1, Table 2).

        // DHKEM_RESERVED (0x0000) is reserved and MUST NOT be used.
        DHKEM_RESERVED KEMID = internal.DHKEM_RESERVED

        // DHKEM_P256_HKDF_SHA256 (0x0010) specifies DHKEM(P-256, HKDF-SHA256)
        // with Nsecret=32, Nenc=65, Npk=65, Nsk=32.
        DHKEM_P256_HKDF_SHA256 KEMID = internal.DHKEM_P256_HKDF_SHA256

        // DHKEM_X25519_HKDF_SHA256 (0x0020) specifies DHKEM(X25519, HKDF-SHA256)
        // with Nsecret=32, Nenc=32, Npk=32, Nsk=32.
        DHKEM_X25519_HKDF_SHA256 KEMID = internal.DHKEM_X25519_HKDF_SHA256
)

var (
        // NewCipherSuite creates a new CipherSuite from the specified KEM, KDF, and AEAD identifiers.
        // Returns an error if any identifier is reserved (0x0000) or invalid.
        //
        // See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1
        NewCipherSuite = internal.NewCipherSuite
)

// NewScheme creates a new HPKE scheme parameterised by the given elliptic curve and cipher suite.
// The curve determines the KEM (key encapsulation mechanism), while the cipher suite specifies
// the KDF (key derivation function) and AEAD (authenticated encryption) algorithms.
//
// The scheme provides factory methods for creating encrypters, decrypters, and direct access
// to KEM/DEM operations for more advanced use cases.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html
func NewScheme[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](curve curves.Curve[P, B, S], cipherSuite *CipherSuite) (*Scheme[P, B, S], error) <span class="cov8" title="1">{
        if curve == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>
        <span class="cov8" title="1">if cipherSuite == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>
        <span class="cov8" title="1">kdf, err := internal.NewKDF(cipherSuite.KDFID())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">dhkem, err := internal.NewDHKEM(curve, kdf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">aead, err := internal.NewAEAD(cipherSuite.AEADID())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Scheme[P, B, S]{
                curve:       curve,
                kdf:         kdf,
                dhkem:       dhkem,
                aead:        aead,
                cipherSuite: cipherSuite,
        }, nil</span>
}

// Scheme is the main HPKE scheme type, parameterised by the elliptic curve point type.
// It combines a KEM, KDF, and AEAD to provide hybrid public-key encryption as specified
// in RFC 9180. The scheme supports all four HPKE modes: Base, PSK, Auth, and AuthPSK.
type Scheme[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        curve       curves.Curve[P, B, S]
        kdf         *internal.KDFScheme
        dhkem       *internal.DHKEMScheme[P, B, S]
        aead        *internal.AEADScheme
        cipherSuite *CipherSuite
}

// Name returns the scheme identifier "HPKE".
func (*Scheme[P, B, S]) Name() encryption.Name <span class="cov0" title="0">{
        return Name
}</span>

// KEM returns a key encapsulation mechanism instance for this scheme.
// In HPKE, the KEM is used to establish a shared secret between sender and receiver.
// Use WithSenderPrivateKey option to enable authenticated encapsulation (Auth mode).
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4
func (s *Scheme[P, B, S]) KEM(opts ...encryption.KEMOption[*KEM[P, B, S], *PublicKey[P, B, S], *Capsule[P, B, S]]) (*KEM[P, B, S], error) <span class="cov0" title="0">{
        kem := &amp;KEM[P, B, S]{
                v:                s.dhkem,
                senderPrivateKey: nil,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(kem); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }

        <span class="cov0" title="0">return kem, nil</span>
}

// DEM returns a data encapsulation mechanism instance for this scheme.
// The DEM uses the receiver's private key to decapsulate the shared secret from a capsule.
// Use WithSenderPublicKey option to enable authenticated decapsulation (Auth mode).
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4
func (s *Scheme[P, B, S]) DEM(receiverPrivateKey *PrivateKey[S], opts ...encryption.DEMOption[*DEM[P, B, S], *Capsule[P, B, S]]) (*DEM[P, B, S], error) <span class="cov0" title="0">{
        if receiverPrivateKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>
        <span class="cov0" title="0">dem := &amp;DEM[P, B, S]{
                v:                  s.dhkem,
                receiverPrivateKey: receiverPrivateKey,
                senderPublicKey:    nil,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(dem); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }
        <span class="cov0" title="0">return dem, nil</span>
}

// AEAD returns an AEAD cipher instance initialised with the given symmetric key.
// This provides direct access to the underlying AEAD algorithm (AES-GCM or ChaCha20Poly1305)
// for use cases requiring manual key management outside the standard HPKE flow.
func (s *Scheme[P, B, S]) AEAD(key *encryption.SymmetricKey) (cipher.AEAD, error) <span class="cov0" title="0">{
        if key == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>
        <span class="cov0" title="0">out, err := s.aead.New(key.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// CipherSuite returns the cipher suite used by this scheme.
func (s *Scheme[P, B, S]) CipherSuite() *CipherSuite <span class="cov0" title="0">{
        return s.cipherSuite
}</span>

// Keygen creates a key generator for this HPKE scheme.
// The key generator produces key pairs compatible with the scheme's KEM algorithm.
// Key generation follows RFC 9180 Section 4, using DeriveKeyPair with random IKM.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4
func (s *Scheme[P, B, S]) Keygen(opts ...KeyGeneratorOption[P, B, S]) (*KeyGenerator[P, B, S], error) <span class="cov8" title="1">{
        kg := &amp;KeyGenerator[P, B, S]{
                dhkem: s.dhkem,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(kg); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return kg, nil</span>
}

// Encrypter creates an HPKE encrypter that can seal messages to a recipient's public key.
// The encrypter establishes a fresh sender context for each encryption, unless caching
// is enabled via EncryptingWhileCachingRecentContextualInfo.
//
// Available options configure the HPKE mode:
//   - EncryptingWithApplicationInfo: Set application-specific info parameter
//   - EncryptingWithAuthentication: Enable Auth mode with sender's private key
//   - EncryptingWithPreSharedKey: Enable PSK mode with pre-shared key
//   - EncryptingWithAuthPSK: Enable AuthPSK mode with both
//   - EncryptingWhileCachingRecentContextualInfo: Cache context for Export
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-6
func (s *Scheme[P, B, S]) Encrypter(opts ...encryption.EncrypterOption[*Encrypter[P, B, S], *PublicKey[P, B, S], Message, Ciphertext, *Capsule[P, B, S]]) (*Encrypter[P, B, S], error) <span class="cov8" title="1">{
        encrypter := &amp;Encrypter[P, B, S]{ //nolint:exhaustruct // set later and/or by options.
                suite: s.cipherSuite,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(encrypter); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return encrypter, nil</span>
}

// Decrypter creates an HPKE decrypter that can open messages encrypted to the receiver's public key.
// The decrypter requires the receiver's private key and the capsule (ephemeral public key) from
// the sender. The receiver context is established during construction based on the configured mode.
//
// Required option:
//   - DecryptingWithCapsule: The capsule (enc) received from the sender
//
// Mode-specific options:
//   - DecryptingWithApplicationInfo: Set application-specific info parameter (must match sender)
//   - DecryptingWithAuthentication: Enable Auth mode with sender's public key
//   - DecryptingWithPreSharedKey: Enable PSK mode with pre-shared key
//   - DecryptingWithAuthPSK: Enable AuthPSK mode with both
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-6
func (s *Scheme[P, B, S]) Decrypter(receiverPrivateKey *PrivateKey[S], opts ...encryption.DecrypterOption[*Decrypter[P, B, S], Message, Ciphertext]) (*Decrypter[P, B, S], error) <span class="cov8" title="1">{
        if receiverPrivateKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>
        <span class="cov8" title="1">decrypter := &amp;Decrypter[P, B, S]{ //nolint:exhaustruct // set later and/or by options.
                suite:      s.cipherSuite,
                privateKey: receiverPrivateKey,
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if err := opt(decrypter); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">if decrypter.ephemeralPublicKey == nil </span><span class="cov0" title="0">{
                return nil, errs2.New("capsule (ephemeral public key) must be provided")
        }</span>
        <span class="cov8" title="1">var ctx *ReceiverContext[P, B, S]
        var err error
        switch decrypter.Mode() </span>{
        case Base:<span class="cov8" title="1">
                ctx, err = SetupBaseR(s.cipherSuite, receiverPrivateKey, decrypter.ephemeralPublicKey, decrypter.info)</span>
        case PSk:<span class="cov0" title="0">
                ctx, err = SetupPSKR(s.cipherSuite, receiverPrivateKey, decrypter.ephemeralPublicKey, decrypter.psk.Bytes(), decrypter.pskID, decrypter.info)</span>
        case Auth:<span class="cov0" title="0">
                ctx, err = SetupAuthR(s.cipherSuite, receiverPrivateKey, decrypter.ephemeralPublicKey, decrypter.senderPublicKey, decrypter.info)</span>
        case AuthPSk:<span class="cov0" title="0">
                ctx, err = SetupAuthPSKR(s.cipherSuite, receiverPrivateKey, decrypter.ephemeralPublicKey, decrypter.senderPublicKey, decrypter.psk.Bytes(), decrypter.pskID, decrypter.info)</span>
        default:<span class="cov0" title="0">
                return nil, ErrNotSupported.WithMessage("HPKE mode")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">decrypter.ctx = ctx
        return decrypter, nil</span>
}
</pre>
		
		<pre class="file" id="file201" style="display: none">package internal

import (
        "crypto/aes"
        "crypto/cipher"

        "golang.org/x/crypto/chacha20poly1305"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

type AEADID uint16

// https://www.rfc-editor.org/rfc/rfc9180.html#name-authenticated-encryption-wi
const (
        AEAD_RESERVED            AEADID = 0x0000
        AEAD_AES_128_GCM         AEADID = 0x0001
        AEAD_AES_256_GCM         AEADID = 0x0002
        AEAD_CHACHA_20_POLY_1305 AEADID = 0x0003
        AEAD_EXPORT_ONLY         AEADID = 0xffff
)

//nolint:exhaustive // reserved and export only will not have have parameters below.
var (
        // https://www.rfc-editor.org/rfc/rfc9180.html#name-authenticated-encryption-wi
        nks = map[AEADID]int{
                AEAD_AES_128_GCM:         16,
                AEAD_AES_256_GCM:         32,
                AEAD_CHACHA_20_POLY_1305: 32,
        }
        nns = map[AEADID]int{
                AEAD_AES_128_GCM:         12,
                AEAD_AES_256_GCM:         12,
                AEAD_CHACHA_20_POLY_1305: 12,
        }
        nts = map[AEADID]int{
                AEAD_AES_128_GCM:         16,
                AEAD_AES_256_GCM:         16,
                AEAD_CHACHA_20_POLY_1305: 16,
        }
        aeads = map[AEADID]*AEADScheme{
                AEAD_AES_128_GCM:         NewAEADAES128GCMScheme(),
                AEAD_AES_256_GCM:         NewAEADAES256GCMScheme(),
                AEAD_CHACHA_20_POLY_1305: NewAEADChaCha20Poly1305Scheme(),
        }
)

func NewAEAD(id AEADID) (*AEADScheme, error) <span class="cov8" title="1">{
        aead, exists := aeads[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrNotSupported.WithMessage("AEAD with ID %d is not supported", id)
        }</span>
        <span class="cov8" title="1">return aead, nil</span>
}

type AEADScheme struct {
        id AEADID
}

// NewAEADAES128GCMScheme returns an instantiation of AEAD_AES_128_GCM.
func NewAEADAES128GCMScheme() *AEADScheme <span class="cov8" title="1">{
        return &amp;AEADScheme{
                id: AEAD_AES_128_GCM,
        }
}</span>

// NewAEADAES256GCMScheme returns an instantiation of AEAD_AES_256_GCM.
func NewAEADAES256GCMScheme() *AEADScheme <span class="cov8" title="1">{
        return &amp;AEADScheme{
                id: AEAD_AES_256_GCM,
        }
}</span>

// NewAEADChaCha20Poly1305Scheme returns an instantiation of AEAD_CHACHA_20_POLY_1305.
func NewAEADChaCha20Poly1305Scheme() *AEADScheme <span class="cov8" title="1">{
        return &amp;AEADScheme{
                id: AEAD_CHACHA_20_POLY_1305,
        }
}</span>

// New accepts a key and returns the corresponding AEAD cipher to the type of the scheme, which can then Seal or Open.
func (s *AEADScheme) New(key []byte) (cipher.AEAD, error) <span class="cov8" title="1">{
        if len(key) != s.Nk() </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("key length is %d whereas it should be %d", len(key), s.Nk())
        }</span>

        <span class="cov8" title="1">if s.isAES() </span><span class="cov8" title="1">{
                block, err := aes.NewCipher(key)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>

                <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>

                <span class="cov8" title="1">return gcm, nil</span>
        }

        <span class="cov8" title="1">chacha, err := chacha20poly1305.New(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return chacha, nil</span>
}

// ID returns the AEAD Id as per https://www.rfc-editor.org/rfc/rfc9180.html#name-authenticated-encryption-wi
func (s *AEADScheme) ID() AEADID <span class="cov8" title="1">{
        return s.id
}</span>

// Nk returns the length in bytes of a key for this algorithm.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.3.2.3
func (s *AEADScheme) Nk() int <span class="cov8" title="1">{
        return nks[s.ID()]
}</span>

// Nn returns the length in bytes of a nonce for this algorithm.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.3.2.4
func (s *AEADScheme) Nn() int <span class="cov8" title="1">{
        return nns[s.ID()]
}</span>

// Nt returns the length in bytes of the authentication tag for this algorithm.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.3.2.5
func (s *AEADScheme) Nt() int <span class="cov0" title="0">{
        return nts[s.ID()]
}</span>

func (s *AEADScheme) isAES() bool <span class="cov8" title="1">{
        return s.ID() == AEAD_AES_128_GCM || s.ID() == AEAD_AES_256_GCM
}</span>
</pre>
		
		<pre class="file" id="file202" style="display: none">package internal

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/key_agreement/dh/dhc"
)

type privateKeyDTO[S algebra.PrimeFieldElement[S]] struct {
        SK dhc.ExtendedPrivateKey[S] `cbor:"sk"`
}

func (sk *PrivateKey[S]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;privateKeyDTO[S]{
                SK: sk.ExtendedPrivateKey,
        }
        return serde.MarshalCBOR(dto)
}</span>

func (sk *PrivateKey[S]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[privateKeyDTO[S]](data)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">sk.ExtendedPrivateKey = dto.SK
        return nil</span>
}

type publicKeyDTO[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        PK dhc.PublicKey[P, B, S] `cbor:"pk"`
}

func (pk *PublicKey[P, B, S]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;publicKeyDTO[P, B, S]{
                PK: pk.PublicKey,
        }
        return serde.MarshalCBOR(dto)
}</span>

func (pk *PublicKey[P, B, S]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[publicKeyDTO[P, B, S]](data)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">pk.PublicKey = dto.PK
        return nil</span>
}

type cipherSuiteDTO struct {
        KDF  KDFID  `cbor:"kdf"`
        KEM  KEMID  `cbor:"kem"`
        AEAD AEADID `cbor:"aead"`
}

func (c *CipherSuite) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;cipherSuiteDTO{
                KDF:  c.kdf,
                KEM:  c.kem,
                AEAD: c.aead,
        }
        return serde.MarshalCBOR(dto)
}</span>

func (c *CipherSuite) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[cipherSuiteDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if dto.KDF == KDF_HKDF_RESERVED </span><span class="cov8" title="1">{
                return ErrNotSupported.WithMessage("invalid cipher suite: reserved KDF")
        }</span>
        <span class="cov8" title="1">if dto.KDF != KDF_HKDF_SHA256 &amp;&amp; dto.KDF != KDF_HKDF_SHA512 </span><span class="cov0" title="0">{
                return ErrNotSupported.WithMessage("invalid cipher suite: unknown KDF")
        }</span>
        <span class="cov8" title="1">if dto.KEM == DHKEM_RESERVED </span><span class="cov8" title="1">{
                return ErrNotSupported.WithMessage("invalid cipher suite: reserved KEM")
        }</span>
        <span class="cov8" title="1">if dto.KEM != DHKEM_P256_HKDF_SHA256 &amp;&amp; dto.KEM != DHKEM_X25519_HKDF_SHA256 </span><span class="cov0" title="0">{
                return ErrNotSupported.WithMessage("invalid cipher suite: unknown KEM")
        }</span>
        <span class="cov8" title="1">if dto.AEAD == AEAD_RESERVED </span><span class="cov8" title="1">{
                return ErrNotSupported.WithMessage("invalid cipher suite: reserved AEAD")
        }</span>
        <span class="cov8" title="1">if dto.AEAD != AEAD_AES_128_GCM &amp;&amp; dto.AEAD != AEAD_AES_256_GCM &amp;&amp; dto.AEAD != AEAD_CHACHA_20_POLY_1305 &amp;&amp; dto.AEAD != AEAD_EXPORT_ONLY </span><span class="cov0" title="0">{
                return ErrNotSupported.WithMessage("invalid cipher suite: unknown AEAD")
        }</span>
        <span class="cov8" title="1">c.kdf = dto.KDF
        c.kem = dto.KEM
        c.aead = dto.AEAD
        return nil</span>
}
</pre>
		
		<pre class="file" id="file203" style="display: none">package internal

import (
        "crypto"
        "crypto/hmac"
        "encoding/binary"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

type KDFID uint16

// https://www.rfc-editor.org/rfc/rfc9180.html#name-key-derivation-functions-kd
const (
        KDF_HKDF_RESERVED KDFID = 0x0000
        KDF_HKDF_SHA256   KDFID = 0x0001
        KDF_HKDF_SHA512   KDFID = 0x0003
)

//nolint:exhaustive // reserved will not have have parameters below.
var (
        // https://www.rfc-editor.org/rfc/rfc9180.html#name-key-derivation-functions-kd
        nhs = map[KDFID]int{
                KDF_HKDF_SHA256: 32,
                KDF_HKDF_SHA512: 64,
        }
        kdfs = map[KDFID]*KDFScheme{
                KDF_HKDF_SHA256: NewKDFSHA256(),
                KDF_HKDF_SHA512: NewKDFSHA512(),
        }
)

type KDFScheme struct {
        hash crypto.Hash
}

// NewKDF returns a KDFScheme corresponding to the given KDFID.
func NewKDF(id KDFID) (*KDFScheme, error) <span class="cov8" title="1">{
        kdf, exists := kdfs[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrNotSupported.WithMessage("KDF with ID %d is not supported", id)
        }</span>

        <span class="cov8" title="1">return kdf, nil</span>
}

// NewKDFSHA256 returns an instantiation of HKDF-SHA256 scheme.
func NewKDFSHA256() *KDFScheme <span class="cov8" title="1">{
        return &amp;KDFScheme{
                hash: crypto.SHA256,
        }
}</span>

// NewKDFSHA512 returns an instantiation of HKDF-SHA512 scheme.
func NewKDFSHA512() *KDFScheme <span class="cov8" title="1">{
        return &amp;KDFScheme{
                hash: crypto.SHA512,
        }
}</span>

// ID returns the KDF ID as per https://www.rfc-editor.org/rfc/rfc9180.html#name-key-derivation-functions-kd
func (s *KDFScheme) ID() KDFID <span class="cov8" title="1">{
        switch s.hash </span>{ //nolint:exhaustive // intentional, for readability.
        case crypto.SHA256:<span class="cov8" title="1">
                return KDF_HKDF_SHA256</span>
        case crypto.SHA512:<span class="cov8" title="1">
                return KDF_HKDF_SHA512</span>
        default:<span class="cov0" title="0">
                panic(ErrNotSupported.WithMessage("hash %s is not supported", s.hash.String()))</span>
        }
}

// Hash hashes messages using the underlying hash function of the kdf.
func (s *KDFScheme) Hash(messages ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        digest, err := hashing.Hash(s.hash.New, messages...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov0" title="0">return digest, nil</span>
}

// Extract extracts a pseudorandom key of fixed length Nh bytes from input keying material ikm and an optional byte string salt.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.2.2.1
func (s *KDFScheme) Extract(salt, ikm []byte) []byte <span class="cov8" title="1">{
        h := hmac.New(s.hash.New, salt) // salt optional
        h.Write(ikm)
        return h.Sum(nil)
}</span>

// Expand expands a pseudorandom key prk using optional string info into L bytes of output keying material.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.2.2.2
func (s *KDFScheme) Expand(prk, info []byte, L int) []byte <span class="cov8" title="1">{
        out := []byte{}
        T := []byte{}
        i := byte(1)
        for len(out) &lt; L </span><span class="cov8" title="1">{
                block := slices.Concat(T, info) // info is optional
                block = append(block, i)

                h := hmac.New(s.hash.New, prk)
                h.Write(block)

                T = h.Sum(nil)
                out = append(out, T...)
                i++
        }</span>

        <span class="cov8" title="1">return out[:L]</span>
}

// Nh returns the output size of the Extract() function in bytes.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.2.2.3
func (s *KDFScheme) Nh() int <span class="cov8" title="1">{
        return nhs[s.ID()]
}</span>

// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-10
func (s *KDFScheme) labeledExtract(suiteID, salt, label, ikm []byte) []byte <span class="cov8" title="1">{
        labeledIkm := slices.Concat(
                []byte(version), suiteID, label, ikm,
        )
        return s.Extract(salt, labeledIkm)
}</span>

// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-10
func (s *KDFScheme) labeledExpand(suiteID, prk, label, info []byte, L int) []byte <span class="cov8" title="1">{
        if L &gt; (1 &lt;&lt; 16) </span><span class="cov0" title="0">{
                panic("Expand length cannot be larger than 2^16")</span>
        }

        <span class="cov8" title="1">lengthBuffer := make([]byte, 2)
        binary.BigEndian.PutUint16(lengthBuffer, uint16(L))
        labeledInfo := slices.Concat(
                lengthBuffer, []byte(version), suiteID, label, info,
        )
        return s.Expand(prk, labeledInfo, L)</span>
}
</pre>
		
		<pre class="file" id="file204" style="display: none">package internal

import (
        "encoding/binary"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/curve25519"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/p256"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        dh "github.com/bronlabs/bron-crypto/pkg/key_agreement/dh/dhc"
)

type KEMID uint16

// https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism
const (
        DHKEM_RESERVED           KEMID = 0x0000
        DHKEM_P256_HKDF_SHA256   KEMID = 0x0010
        DHKEM_X25519_HKDF_SHA256 KEMID = 0x0020
        P256BitMask                    = 0xff
)

// https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism
//
//nolint:exhaustive // reserved will not have have parameters below.
var (
        nSecrets = map[KEMID]int{
                DHKEM_P256_HKDF_SHA256:   32,
                DHKEM_X25519_HKDF_SHA256: 32,
        }
        nEncs = map[KEMID]int{
                DHKEM_P256_HKDF_SHA256:   65,
                DHKEM_X25519_HKDF_SHA256: 32,
        }
        nPKs = map[KEMID]int{
                DHKEM_P256_HKDF_SHA256:   65,
                DHKEM_X25519_HKDF_SHA256: 32,
        }
        nSKs = map[KEMID]int{
                DHKEM_P256_HKDF_SHA256:   32,
                DHKEM_X25519_HKDF_SHA256: 32,
        }
)

func NewDHKEM[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](curve curves.Curve[P, B, S], kdf *KDFScheme) (*DHKEMScheme[P, B, S], error) <span class="cov8" title="1">{
        if curve == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("curve is nil")
        }</span>
        <span class="cov8" title="1">if curve.Name() != p256.NewCurve().Name() &amp;&amp; curve.Name() != curve25519.NewPrimeSubGroup().Name() </span><span class="cov0" title="0">{
                return nil, ErrNotSupported.WithMessage("unsupported curve: %s", curve.Name())
        }</span>
        <span class="cov8" title="1">if kdf == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("kdf is nil")
        }</span>
        <span class="cov8" title="1">return &amp;DHKEMScheme[P, B, S]{
                curve: curve,
                kdf:   kdf,
        }, nil</span>
}

type DHKEMScheme[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        curve curves.Curve[P, B, S]
        kdf   *KDFScheme
}

// ID returns KEM ID as per https://www.rfc-editor.org/rfc/rfc9180.html#name-key-encapsulation-mechanism
func (s *DHKEMScheme[P, B, S]) ID() KEMID <span class="cov8" title="1">{
        switch s.curve.Name() </span>{
        case p256.NewCurve().Name():<span class="cov8" title="1">
                return DHKEM_P256_HKDF_SHA256</span>
        case curve25519.NewPrimeSubGroup().Name():<span class="cov8" title="1">
                return DHKEM_X25519_HKDF_SHA256</span>
        default:<span class="cov0" title="0">
                panic("unsupported curve")</span>
        }
}

func NewP256HKDFSha256KEM() *DHKEMScheme[*p256.Point, *p256.BaseFieldElement, *p256.Scalar] <span class="cov8" title="1">{
        return &amp;DHKEMScheme[*p256.Point, *p256.BaseFieldElement, *p256.Scalar]{
                curve: p256.NewCurve(),
                kdf:   NewKDFSHA256(),
        }
}</span>

func NewX25519HKDFSha256KEM() *DHKEMScheme[*curve25519.PrimeSubGroupPoint, *curve25519.BaseFieldElement, *curve25519.Scalar] <span class="cov8" title="1">{
        return &amp;DHKEMScheme[*curve25519.PrimeSubGroupPoint, *curve25519.BaseFieldElement, *curve25519.Scalar]{
                curve: curve25519.NewPrimeSubGroup(),
                kdf:   NewKDFSHA256(),
        }
}</span>

// GenerateKeyPair is a randomised algorithm to generate a key pair.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.1
func (s *DHKEMScheme[P, B, S]) GenerateKeyPair(prng io.Reader) (*PrivateKey[S], *PublicKey[P, B, S], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>

        <span class="cov8" title="1">ikm, err := s.produceIKM(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">privateKey, publicKey, err := s.DeriveKeyPair(ikm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return privateKey, publicKey, nil</span>
}

// DeriveKeyPair is a deterministic algorithm to derive a key pair (skX, pkX) from the byte string ikm, where ikm SHOULD have at least Nsk bytes of entropy.
// https://www.rfc-editor.org/rfc/rfc9180.html#name-derivekeypair
func (s *DHKEMScheme[P, B, S]) DeriveKeyPair(ikm []byte) (*PrivateKey[S], *PublicKey[P, B, S], error) <span class="cov8" title="1">{
        if len(ikm) &lt; s.NSk() </span><span class="cov8" title="1">{
                return nil, nil, ErrInvalidLength.WithMessage("ikm length(=%d) &lt; Nsk(=%d)", len(ikm), s.NSk())
        }</span>
        <span class="cov8" title="1">var skBytes []byte
        var skv S
        var err error

        switch s.curve.Name() </span>{
        case p256.NewCurve().Name():<span class="cov8" title="1">
                dpkPrk := s.kdf.labeledExtract(s.suiteID(), nil, []byte("dkp_prk"), ikm)
                counter := uint8(0)
                skv = s.curve.ScalarField().Zero()
                for skv.IsZero() || err != nil </span><span class="cov8" title="1">{
                        skBytes = s.kdf.labeledExpand(s.suiteID(), dpkPrk, []byte("candidate"), []byte{counter}, s.NSk())
                        skBytes[0] &amp;= P256BitMask

                        skv, err = s.curve.ScalarField().FromBytes(skBytes)
                        counter++
                }</span>
        case curve25519.NewPrimeSubGroup().Name():<span class="cov8" title="1">
                dkpPrk := s.kdf.labeledExtract(s.suiteID(), nil, []byte("dkp_prk"), ikm)
                skBytes = s.kdf.labeledExpand(s.suiteID(), dkpPrk, []byte("sk"), nil, s.NSk())
                skv, err = algebra.StructureMustBeAs[interface {
                        algebra.PrimeField[S]
                        FromClampedBytes([]byte) (S, error)
                }](s.curve.ScalarStructure()).FromClampedBytes(skBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, nil, ErrNotSupported.WithMessage("curve %s not supported", s.curve.Name())</span>
        }
        <span class="cov8" title="1">sk, err := NewPrivateKey(s.curve.ScalarField(), skBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">pk, err := NewPublicKey(s.curve.ScalarBaseMul(skv))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return sk, pk, nil</span>
}

// Encap is a randomised algorithm to generate an ephemeral, fixed-length symmetric key (the KEM shared secret) and a fixed-length encapsulation of that key that can be decapsulated by the holder of the private key corresponding to pkR. This function can raise an EncapError on encapsulation failure.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.5
func (s *DHKEMScheme[P, B, S]) Encap(receiverPublicKey *PublicKey[P, B, S], prng io.Reader) (sharedSecret []byte, ephemeralPublicKey *PublicKey[P, B, S], err error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>

        <span class="cov8" title="1">ikmE, err := s.produceIKM(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">sharedSecret, ephemeralPublicKey, err = s.EncapWithIKM(receiverPublicKey, ikmE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return sharedSecret, ephemeralPublicKey, nil</span>
}

func (s *DHKEMScheme[P, B, S]) EncapWithIKM(receiverPublicKey *PublicKey[P, B, S], ikmE []byte) (sharedSecret []byte, ephemeralPublicKey *PublicKey[P, B, S], err error) <span class="cov8" title="1">{
        if receiverPublicKey == nil || ikmE == nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if receiverPublicKey.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidPublicKey.WithMessage("receiver public key is identity")
        }</span>
        <span class="cov8" title="1">if !receiverPublicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidPublicKey.WithMessage("Public Key not in the prime subgroup")
        }</span>

        <span class="cov8" title="1">ephemeralPrivateKey, ephemeralPublicKey, err := s.DeriveKeyPair(ikmE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">dhReceiverPublicKey, err := dh.NewPublicKey(receiverPublicKey.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">dhKey, err := dh.DeriveSharedSecret(&amp;ephemeralPrivateKey.ExtendedPrivateKey, dhReceiverPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">enc := ephemeralPublicKey.Bytes()
        pkRm := receiverPublicKey.Bytes()

        kemContext := make([]byte, len(enc)+len(pkRm))
        copy(kemContext, enc)
        copy(kemContext[len(enc):], pkRm)
        sharedSecret = s.extractAndExpand(dhKey.Bytes(), kemContext)
        return sharedSecret, ephemeralPublicKey, nil</span>
}

// Decap is a deterministic algorithm using the private key skR to recover the ephemeral symmetric key (the KEM shared secret) from its encapsulated representation enc. This function can raise a DecapError on decapsulation failure.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.6
func (s *DHKEMScheme[P, B, S]) Decap(receiverPrivateKey *PrivateKey[S], ephemeralPublicKey *PublicKey[P, B, S]) (sharedSecret []byte, err error) <span class="cov8" title="1">{
        if receiverPrivateKey == nil || ephemeralPublicKey == nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if ephemeralPublicKey.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, ErrInvalidPublicKey.WithMessage("ephemeral public key is identity")
        }</span>
        <span class="cov8" title="1">if !ephemeralPublicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidPublicKey.WithMessage("Public Key not in the prime subgroup")
        }</span>

        <span class="cov8" title="1">curve := algebra.StructureMustBeAs[curves.Curve[P, B, S]](ephemeralPublicKey.Value().Structure())

        enc := ephemeralPublicKey.Bytes()

        dhEphemeralPublicKey, err := dh.NewPublicKey(ephemeralPublicKey.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">dhKey, err := dh.DeriveSharedSecret(&amp;receiverPrivateKey.ExtendedPrivateKey, dhEphemeralPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">receiverPublicKey, err := NewPublicKey(curve.ScalarBaseMul(receiverPrivateKey.Value()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">pkRm := receiverPublicKey.Bytes()
        kemContext := make([]byte, len(enc)+len(pkRm))
        copy(kemContext, enc)
        copy(kemContext[len(enc):], pkRm)

        sharedSecret = s.extractAndExpand(dhKey.Bytes(), kemContext)
        return sharedSecret, nil</span>
}

// AuthEncap is the same as Encap(), and the outputs encode an assurance that the KEM shared secret was generated by the holder of the private key skS.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.7
func (s *DHKEMScheme[P, B, S]) AuthEncap(receiverPublicKey *PublicKey[P, B, S], senderPrivateKey *PrivateKey[S], prng io.Reader) (sharedSecret []byte, ephemeralPublicKey *PublicKey[P, B, S], err error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>

        <span class="cov8" title="1">ikmE, err := s.produceIKM(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">sharedSecret, ephemeralPublicKey, err = s.AuthEncapWithIKM(receiverPublicKey, senderPrivateKey, ikmE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return sharedSecret, ephemeralPublicKey, nil</span>
}

func (s *DHKEMScheme[P, B, S]) AuthEncapWithIKM(receiverPublicKey *PublicKey[P, B, S], senderPrivateKey *PrivateKey[S], ikmE []byte) (sharedSecret []byte, ephemeralPublicKey *PublicKey[P, B, S], err error) <span class="cov8" title="1">{
        if receiverPublicKey == nil || senderPrivateKey == nil || ikmE == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("arguments can't be nil")
        }</span>
        <span class="cov8" title="1">if receiverPublicKey.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidPublicKey.WithMessage("receiver public key is identity")
        }</span>
        <span class="cov8" title="1">if !receiverPublicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidPublicKey.WithMessage("Public Key not in the prime subgroup")
        }</span>

        <span class="cov8" title="1">curve := algebra.StructureMustBeAs[curves.Curve[P, B, S]](receiverPublicKey.Value().Structure())

        ephemeralPrivateKey, ephemeralPublicKey, err := s.DeriveKeyPair(ikmE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">dhReceiverPublicKey, err := dh.NewPublicKey(receiverPublicKey.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">dhER, err := dh.DeriveSharedSecret(&amp;ephemeralPrivateKey.ExtendedPrivateKey, dhReceiverPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">dhSR, err := dh.DeriveSharedSecret(&amp;senderPrivateKey.ExtendedPrivateKey, dhReceiverPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">dhERBytes := dhER.Bytes()
        dhSRBytes := dhSR.Bytes()
        dhBytes := make([]byte, len(dhERBytes)+len(dhSRBytes))
        copy(dhBytes, dhERBytes)
        copy(dhBytes[len(dhERBytes):], dhSRBytes)

        enc := ephemeralPublicKey.Bytes()
        pkRm := receiverPublicKey.Bytes()
        senderPublicKey, err := NewPublicKey(curve.ScalarBaseMul(senderPrivateKey.Value()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">pkSm := senderPublicKey.Bytes()
        kemContext := make([]byte, len(enc)+len(pkRm)+len(pkSm))
        copy(kemContext, enc)
        copy(kemContext[len(enc):], pkRm)
        copy(kemContext[len(enc)+len(pkRm):], pkSm)

        sharedSecret = s.extractAndExpand(dhBytes, kemContext)
        return sharedSecret, ephemeralPublicKey, nil</span>
}

// AuthDecap is the same as Decap(), and the recipient is assured that the KEM shared secret was generated by the holder of the private key skS.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.8
func (s *DHKEMScheme[P, B, S]) AuthDecap(receiverPrivateKey *PrivateKey[S], senderPublicKey, ephemeralPublicKey *PublicKey[P, B, S]) (sharedSecret []byte, err error) <span class="cov8" title="1">{
        if receiverPrivateKey == nil || senderPublicKey == nil || ephemeralPublicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("arguments can't be nil")
        }</span>
        <span class="cov8" title="1">if !senderPublicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidPublicKey.WithMessage("Public Key not in the prime subgroup")
        }</span>
        <span class="cov8" title="1">if !ephemeralPublicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidPublicKey.WithMessage("Public Key not in the prime subgroup")
        }</span>

        <span class="cov8" title="1">curve := algebra.StructureMustBeAs[curves.Curve[P, B, S]](ephemeralPublicKey.Value().Structure())

        dhEphemeralPublicKey, err := dh.NewPublicKey(ephemeralPublicKey.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">dhSenderPublicKey, err := dh.NewPublicKey(senderPublicKey.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">dhRE, err := dh.DeriveSharedSecret(&amp;receiverPrivateKey.ExtendedPrivateKey, dhEphemeralPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">dhRS, err := dh.DeriveSharedSecret(&amp;receiverPrivateKey.ExtendedPrivateKey, dhSenderPublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">dhREBytes := dhRE.Bytes()
        dhRSBytes := dhRS.Bytes()
        dhBytes := make([]byte, len(dhREBytes)+len(dhRSBytes))
        copy(dhBytes, dhREBytes)
        copy(dhBytes[len(dhREBytes):], dhRSBytes)

        enc := ephemeralPublicKey.Bytes()
        receiverPK, err := NewPublicKey(curve.ScalarBaseMul(receiverPrivateKey.Value()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">pkRm := receiverPK.Bytes()
        pkSm := senderPublicKey.Bytes()
        kemContext := make([]byte, len(enc)+len(pkRm)+len(pkSm))
        copy(kemContext, enc)
        copy(kemContext[len(enc):], pkRm)
        copy(kemContext[len(enc)+len(pkRm):], pkSm)

        sharedSecret = s.extractAndExpand(dhBytes, kemContext)
        return sharedSecret, nil</span>
}

// NSecret is the length in bytes of a KEM shared secret produced by this KEM.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.9
func (s *DHKEMScheme[P, B, S]) NSecret() int <span class="cov8" title="1">{
        return nSecrets[s.ID()]
}</span>

// NEnc is the length in bytes of an encapsulated key produced by this KEM.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.10
func (s *DHKEMScheme[P, B, S]) NEnc() int <span class="cov8" title="1">{
        return nEncs[s.ID()]
}</span>

// NPk is the length in bytes of an encoded public key for this KEM.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.11
func (s *DHKEMScheme[P, B, S]) NPk() int <span class="cov8" title="1">{
        return nPKs[s.ID()]
}</span>

// NSk is the length in bytes of an encoded private key for this KEM.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4-2.1.2.12
func (s *DHKEMScheme[P, B, S]) NSk() int <span class="cov8" title="1">{
        return nSKs[s.ID()]
}</span>

// extractAndExpand is an internal method used in other methods of DHKEM.
// https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1-4
func (s *DHKEMScheme[P, B, S]) extractAndExpand(dhBytes, kmContext []byte) []byte <span class="cov8" title="1">{
        eaePrk := s.kdf.labeledExtract(s.suiteID(), nil, []byte("eae_prk"), dhBytes)
        sharedSecret := s.kdf.labeledExpand(s.suiteID(), eaePrk, []byte("shared_secret"), kmContext, s.kdf.Nh())
        return sharedSecret
}</span>

func (s *DHKEMScheme[P, B, S]) suiteID() []byte <span class="cov8" title="1">{
        idBuffer := make([]byte, 2)
        binary.BigEndian.PutUint16(idBuffer, uint16(s.ID()))
        return append([]byte("KEM"), idBuffer...)
}</span>

func (s *DHKEMScheme[P, B, S]) produceIKM(prng io.Reader) ([]byte, error) <span class="cov8" title="1">{
        ikm := make([]byte, s.NSk())
        if _, err := io.ReadFull(prng, ikm); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return ikm, nil</span>
}
</pre>
		
		<pre class="file" id="file205" style="display: none">package internal

import (
        "crypto/cipher"
        "crypto/subtle"
        "encoding/binary"
        "io"
        "math"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/key_agreement/dh/dhc"
)

const version = "HPKE-v1"

type (
        PrivateKey[S algebra.PrimeFieldElement[S]] struct {
                dhc.ExtendedPrivateKey[S]
        }
        PublicKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
                dhc.PublicKey[P, B, S]
        }
)

func (sk *PrivateKey[S]) Bytes() []byte <span class="cov8" title="1">{
        out, err := dhc.SerialiseExtendedPrivateKey(&amp;sk.ExtendedPrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err))</span>
        }
        <span class="cov8" title="1">return out</span>
}

func (sk *PrivateKey[S]) Equal(other *PrivateKey[S]) bool <span class="cov0" title="0">{
        if sk == nil || other == nil </span><span class="cov0" title="0">{
                return sk == other
        }</span>
        <span class="cov0" title="0">return sk.ExtendedPrivateKey.Equal(&amp;other.ExtendedPrivateKey)</span>
}

func (pk *PublicKey[P, B, S]) Bytes() []byte <span class="cov8" title="1">{
        out, err := dhc.SerialisePublicKey(&amp;pk.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(errs2.Wrap(err))</span>
        }
        <span class="cov8" title="1">return out</span>
}

func (pk *PublicKey[P, B, S]) Clone() *PublicKey[P, B, S] <span class="cov0" title="0">{
        return &amp;PublicKey[P, B, S]{PublicKey: *pk.PublicKey.Clone()}
}</span>

func (pk *PublicKey[P, B, S]) Equal(other *PublicKey[P, B, S]) bool <span class="cov8" title="1">{
        if pk == nil || other == nil </span><span class="cov0" title="0">{
                return pk == other
        }</span>
        <span class="cov8" title="1">return pk.PublicKey.Equal(&amp;other.PublicKey)</span>
}

func NewPrivateKey[S algebra.PrimeFieldElement[S]](sf algebra.PrimeField[S], ikm []byte) (*PrivateKey[S], error) <span class="cov8" title="1">{
        seed, err := dhc.NewPrivateKey(ikm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">sk, err := dhc.ExtendPrivateKey(seed, sf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;PrivateKey[S]{ExtendedPrivateKey: *sk}, nil</span>
}

func NewPublicKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](v P) (*PublicKey[P, B, S], error) <span class="cov8" title="1">{
        out, err := dhc.NewPublicKey(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;PublicKey[P, B, S]{PublicKey: *out}, nil</span>
}

type ModeID byte

const (
        Base    ModeID = 0x00
        PSk     ModeID = 0x01
        Auth    ModeID = 0x02
        AuthPSk ModeID = 0x03
)

type ContextRole byte

const (
        SenderRole ContextRole = iota
        ReceiverRole
)

func NewCipherSuite(kem KEMID, kdf KDFID, aead AEADID) (*CipherSuite, error) <span class="cov8" title="1">{
        if kem == DHKEM_RESERVED </span><span class="cov8" title="1">{
                return nil, ErrNotSupported.WithMessage("invalid KEM ID")
        }</span>
        <span class="cov8" title="1">if kdf == KDF_HKDF_RESERVED </span><span class="cov8" title="1">{
                return nil, ErrNotSupported.WithMessage("invalid KDF ID")
        }</span>
        <span class="cov8" title="1">if aead == AEAD_RESERVED </span><span class="cov8" title="1">{
                return nil, ErrNotSupported.WithMessage("invalid AEAD ID")
        }</span>
        <span class="cov8" title="1">return &amp;CipherSuite{
                kem:  kem,
                kdf:  kdf,
                aead: aead,
        }, nil</span>
}

type CipherSuite struct {
        kdf  KDFID
        kem  KEMID
        aead AEADID
}

func (c *CipherSuite) KDFID() KDFID <span class="cov8" title="1">{
        return c.kdf
}</span>

func (c *CipherSuite) KEMID() KEMID <span class="cov8" title="1">{
        return c.kem
}</span>

func (c *CipherSuite) AEADID() AEADID <span class="cov8" title="1">{
        return c.aead
}</span>

func (c *CipherSuite) ID() []byte <span class="cov8" title="1">{
        suiteID := make([]byte, 6)
        binary.BigEndian.PutUint16(suiteID, uint16(c.kem))
        binary.BigEndian.PutUint16(suiteID[2:], uint16(c.kdf))
        binary.BigEndian.PutUint16(suiteID[4:], uint16(c.aead))
        return append([]byte("HPKE"), suiteID...)
}</span>

// https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-13
type KeyScheduleContext struct {
        Mode      ModeID
        PskIDHash []byte // size Nh
        InfoHash  []byte // size Nh
}

func (ksc *KeyScheduleContext) Marshal() []byte <span class="cov8" title="1">{
        return slices.Concat([]byte{byte(ksc.Mode)}, ksc.PskIDHash, ksc.InfoHash)
}</span>

type context struct {
        role           ContextRole
        suite          *CipherSuite
        key            []byte
        exporterSecret []byte

        baseNonce nonce
        sequence  uint64

        aead          cipher.AEAD
        nonces        ds.MutableSet[nonce]
        keyScheduling *KeyScheduleContext
        secret        []byte
}

var _ base.Hashable[nonce] = (*nonce)(nil)

type nonce []byte

func (n nonce) Equal(other nonce) bool <span class="cov8" title="1">{
        return subtle.ConstantTimeCompare(n, other) == 1
}</span>

func (n nonce) HashCode() base.HashCode <span class="cov8" title="1">{
        return base.DeriveHashCode(n)
}</span>

// https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-12
func (c *context) computeNonce() ([]byte, error) <span class="cov8" title="1">{
        Nn := aeads[c.suite.aead].Nn()
        buf := make([]byte, 8) // because sequence is uint64
        binary.BigEndian.PutUint64(buf, c.sequence)
        newNonce := make(nonce, Nn)
        copy(newNonce, c.baseNonce)
        // https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-6
        subtle.XORBytes(newNonce[Nn-8:], c.baseNonce[Nn-8:], buf) // length of sequence (uint64) is smaller than Nn. So we treat as zero-padded.
        if c.nonces.Contains(newNonce) </span><span class="cov8" title="1">{
                return nil, ErrInvalidNonce.WithMessage("nonce reuse detected")
        }</span>
        <span class="cov8" title="1">c.nonces.Add(newNonce)
        return newNonce, nil</span>
}

func (c *context) incrementSeq() error <span class="cov8" title="1">{
        // https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2-6
        // Implementations MAY use a sequence number that is shorter than the nonce length (padding on the left with zero), but MUST raise an error if the sequence number overflows.
        // The default check of the rfc ((1&lt;&lt;(8*Nn))-1) is larger than uint64, so no point in copying the rfc.
        if c.sequence == math.MaxUint64 </span><span class="cov0" title="0">{
                return ErrInvalidNonce.WithMessage("sequence number will overflow")
        }</span>
        <span class="cov8" title="1">c.sequence++
        return nil</span>
}

// export takes as input a context string exporter_context and a desired length L in bytes, and produces a secret derived from the internal exporter secret using the corresponding KDF Expand function. This is an interface for exporting secrets from the encryption context using a variable-length pseudorandom function (PRF), similar to the TLS 1.3 exporter interface
// https://www.rfc-editor.org/rfc/rfc9180.html#name-secret-export
func (c *context) export(exporterContext []byte, L int) ([]byte, error) <span class="cov8" title="1">{
        kdf := kdfs[c.suite.kdf]
        if L &gt; 255*kdf.Nh() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("L is out of range")
        }</span>
        <span class="cov8" title="1">return kdf.labeledExpand(c.suite.ID(), c.exporterSecret, []byte("sec"), exporterContext, L), nil</span>
}

// keySchedule translates the protocol inputs into an encryption context.
// - mode: A one-byte value indicating the HPKE mode, defined in Table 1.
// - shared_secret: A KEM shared secret generated for this transaction.
// - info: Application-supplied information (optional; default value "").
// - psk A pre-shared key (PSK) held by both the sender and the recipient (optional; default value "").
// - psk_id: An identifier for the PSK (optional; default value "").
// https://www.rfc-editor.org/rfc/rfc9180.html#name-creating-the-encryption-con
func keySchedule(role ContextRole, cipherSuite *CipherSuite, mode ModeID, sharedSecret, info, psk, pskID []byte) (*context, *KeyScheduleContext, error) <span class="cov8" title="1">{
        if err := verifyPSKInputs(mode, psk, pskID); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">var err error
        kdf := kdfs[cipherSuite.kdf]
        aead := aeads[cipherSuite.aead]
        pskIDHash := kdf.labeledExtract(cipherSuite.ID(), nil, []byte("psk_id_hash"), pskID)
        infoHash := kdf.labeledExtract(cipherSuite.ID(), nil, []byte("info_hash"), info)
        keyScheduleContext := &amp;KeyScheduleContext{
                Mode:      mode,
                PskIDHash: pskIDHash,
                InfoHash:  infoHash,
        }
        keyScheduleContextMarshaled := keyScheduleContext.Marshal()
        secret := kdf.labeledExtract(cipherSuite.ID(), sharedSecret, []byte("secret"), psk)

        ctx := &amp;context{
                role:  role,
                suite: cipherSuite,

                keyScheduling:  keyScheduleContext,
                secret:         secret,
                exporterSecret: kdf.labeledExpand(cipherSuite.ID(), secret, []byte("exp"), keyScheduleContextMarshaled, kdf.Nh()),
                nonces:         hashset.NewHashable[nonce](),
        }

        // https://www.rfc-editor.org/rfc/rfc9180.html#section-5.3-4
        if cipherSuite.aead != AEAD_EXPORT_ONLY </span><span class="cov8" title="1">{
                ctx.key = kdf.labeledExpand(cipherSuite.ID(), secret, []byte("key"), keyScheduleContextMarshaled, aead.Nk())
                ctx.baseNonce = kdf.labeledExpand(cipherSuite.ID(), secret, []byte("base_nonce"), keyScheduleContextMarshaled, aead.Nn())

                ctx.aead, err = aead.New(ctx.key)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err)
                }</span>
        }

        <span class="cov8" title="1">return ctx, keyScheduleContext, nil</span>
}

// https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1-10
func verifyPSKInputs(mode ModeID, psk, pskID []byte) error <span class="cov8" title="1">{
        gotPsk := psk != nil
        gotPskID := pskID != nil
        if gotPsk != gotPskID </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("either psk and pskID should both be nil, or none should be nil")
        }</span>
        <span class="cov8" title="1">if gotPsk &amp;&amp; (mode == Base || mode == Auth) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("psk argument provided when not needed")
        }</span>
        <span class="cov8" title="1">if !gotPsk &amp;&amp; (mode == PSk || mode == AuthPSk) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("missing required psk input")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type SenderContext[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        Capsule *PublicKey[P, B, S]
        ctx     *context
}

func NewSenderContext[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](mode ModeID, suite *CipherSuite, receiverPublicKey *PublicKey[P, B, S], senderPrivateKey *PrivateKey[S], info, psk, pskID []byte, prng io.Reader) (*SenderContext[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("ciphersuite is nil")
        }</span>

        <span class="cov8" title="1">curve := algebra.StructureMustBeAs[curves.Curve[P, B, S]](receiverPublicKey.Value().Structure())
        kdf, err := NewKDF(suite.kdf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">kem, err := NewDHKEM(curve, kdf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">var sharedSecret []byte
        var ephemeralPublicKey *PublicKey[P, B, S]
        if mode == Auth || mode == AuthPSk </span><span class="cov0" title="0">{
                sharedSecret, ephemeralPublicKey, err = kem.AuthEncap(receiverPublicKey, senderPrivateKey, prng)
        }</span> else<span class="cov8" title="1"> {
                if senderPrivateKey != nil </span><span class="cov0" title="0">{
                        return nil, ErrNotSupported.WithMessage("sender private key unsupported")
                }</span>

                <span class="cov8" title="1">sharedSecret, ephemeralPublicKey, err = kem.Encap(receiverPublicKey, prng)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">ctx, _, err := keySchedule(SenderRole, suite, mode, sharedSecret, info, psk, pskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return &amp;SenderContext[P, B, S]{
                Capsule: ephemeralPublicKey,
                ctx:     ctx,
        }, nil</span>
}

func (s *SenderContext[P, B, S]) Seal(plaintext, additionalData []byte) (ciphertext []byte, err error) <span class="cov8" title="1">{
        nonce, err := s.ctx.computeNonce()
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">ciphertext = s.ctx.aead.Seal(nil, nonce, plaintext, additionalData)
        if err := s.ctx.incrementSeq(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return ciphertext, nil</span>
}

// Export takes as input a context string exporter_context and a desired length L in bytes, and produces a secret derived from the internal exporter secret using the corresponding KDF Expand function. This is an interface for exporting secrets from the encryption context using a variable-length pseudorandom function (PRF), similar to the TLS 1.3 exporter interface
// https://www.rfc-editor.org/rfc/rfc9180.html#name-secret-export
func (s *SenderContext[P, B, S]) Export(exporterContext []byte, L int) ([]byte, error) <span class="cov8" title="1">{
        return s.ctx.export(exporterContext, L)
}</span>

type ReceiverContext[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        ctx     *context
        capsule *PublicKey[P, B, S]
}

func NewReceiverContext[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](mode ModeID, suite *CipherSuite, receiverPrivatekey *PrivateKey[S], ephemeralPublicKey, senderPublicKey *PublicKey[P, B, S], info, psk, pskID []byte) (*ReceiverContext[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("ciphersuite is nil")
        }</span>

        <span class="cov8" title="1">curve := algebra.StructureMustBeAs[curves.Curve[P, B, S]](ephemeralPublicKey.Value().Structure())
        kdf, err := NewKDF(suite.kdf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">kem, err := NewDHKEM(curve, kdf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">var sharedSecret []byte
        if mode == Auth || mode == AuthPSk </span><span class="cov0" title="0">{
                sharedSecret, err = kem.AuthDecap(receiverPrivatekey, senderPublicKey, ephemeralPublicKey)
        }</span> else<span class="cov8" title="1"> {
                if senderPublicKey != nil </span><span class="cov0" title="0">{
                        return nil, ErrNotSupported.WithMessage("sender public key unsupported")
                }</span>

                <span class="cov8" title="1">sharedSecret, err = kem.Decap(receiverPrivatekey, ephemeralPublicKey)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">ctx, _, err := keySchedule(ReceiverRole, suite, mode, sharedSecret, info, psk, pskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return &amp;ReceiverContext[P, B, S]{
                ctx:     ctx,
                capsule: ephemeralPublicKey,
        }, nil</span>
}

func (r *ReceiverContext[P, B, S]) Open(ciphertext, additionalData []byte) (plaintext []byte, err error) <span class="cov8" title="1">{
        nonce, err := r.ctx.computeNonce()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">plaintext, err = r.ctx.aead.Open(nil, nonce, ciphertext, additionalData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">if err := r.ctx.incrementSeq(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}

// Export takes as input a context string exporter_context and a desired length L in bytes, and produces a secret derived from the internal exporter secret using the corresponding KDF Expand function. This is an interface for exporting secrets from the encryption context using a variable-length pseudorandom function (PRF), similar to the TLS 1.3 exporter interface
// https://www.rfc-editor.org/rfc/rfc9180.html#name-secret-export
func (r *ReceiverContext[P, B, S]) Export(exporterContext []byte, L int) ([]byte, error) <span class="cov8" title="1">{
        return r.ctx.export(exporterContext, L)
}</span>

func (r *ReceiverContext[P, B, S]) Capsule() *PublicKey[P, B, S] <span class="cov0" title="0">{
        return r.capsule
}</span>
</pre>
		
		<pre class="file" id="file206" style="display: none">package internal

import (
        "encoding/hex"
)

func DeHex_Testing(h string) []byte <span class="cov8" title="1">{ //nolint:staticcheck // _Testing suffix is more clear.
        result, _ := hex.DecodeString(h)
        return result
}</span>

type SetupInfo_Testing struct { //nolint:staticcheck // _Testing suffix is more clear.
        Mode   ModeID
        KEMID  KEMID
        KDFID  KDFID
        AEADID AEADID

        Info               []byte
        IkmE               []byte
        PkEm               []byte
        SkEm               []byte
        IkmR               []byte
        PkRm               []byte
        SkRm               []byte
        Enc                []byte
        SharedSecret       []byte
        KeyScheduleContext []byte
        Secret             []byte
        Key                []byte
        BaseNonce          []byte
        ExporterSecret     []byte

        PSk   []byte
        PSkID []byte

        IkmS []byte
        PkSm []byte
        SkSm []byte
}

type EncryptionInfo_Testing struct { //nolint:staticcheck // _Testing suffix is more clear.
        Seq   uint64
        Pt    []byte
        Aad   []byte
        Nonce []byte
        Ct    []byte
}

type ExportInfo_Testing struct { //nolint:staticcheck // _Testing suffix is more clear.
        ExporterContext []byte
        L               int
        ExportedValue   []byte
}

type SuiteInfo_Testing struct { //nolint:staticcheck // _Testing suffix is more clear.
        Mode        ModeID
        Setup       *SetupInfo_Testing
        Encryptions []*EncryptionInfo_Testing
        Exports     []*ExportInfo_Testing
}

type Suite_Testing struct { //nolint:staticcheck // _Testing suffix is more clear.
        Name string
        Info []*SuiteInfo_Testing
}

var TestVectors = []*Suite_Testing{
        {
                Name: "DHKEM(P-256, HKDF-SHA256), HKDF-SHA256, AES-128-GCM",
                Info: []*SuiteInfo_Testing{
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.3.1
                        {
                                Mode: Base,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Base,
                                        KEMID:              DHKEM_P256_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_AES_128_GCM,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("4270e54ffd08d79d5928020af4686d8f6b7d35dbe470265f1f5aa22816ce860e"),
                                        PkEm:               DeHex_Testing("04a92719c6195d5085104f469a8b9814d5838ff72b60501e2c4466e5e67b325ac98536d7b61a1af4b78e5b7f951c0900be863c403ce65c9bfcb9382657222d18c4"),
                                        SkEm:               DeHex_Testing("4995788ef4b9d6132b249ce59a77281493eb39af373d236a1fe415cb0c2d7beb"),
                                        IkmR:               DeHex_Testing("668b37171f1072f3cf12ea8a236a45df23fc13b82af3609ad1e354f6ef817550"),
                                        PkRm:               DeHex_Testing("04fe8c19ce0905191ebc298a9245792531f26f0cece2460639e8bc39cb7f706a826a779b4cf969b8a0e539c7f62fb3d30ad6aa8f80e30f1d128aafd68a2ce72ea0"),
                                        SkRm:               DeHex_Testing("f3ce7fdae57e1a310d87f1ebbde6f328be0a99cdbcadf4d6589cf29de4b8ffd2"),
                                        Enc:                DeHex_Testing("04a92719c6195d5085104f469a8b9814d5838ff72b60501e2c4466e5e67b325ac98536d7b61a1af4b78e5b7f951c0900be863c403ce65c9bfcb9382657222d18c4"),
                                        SharedSecret:       DeHex_Testing("c0d26aeab536609a572b07695d933b589dcf363ff9d93c93adea537aeabb8cb8"),
                                        KeyScheduleContext: DeHex_Testing("00b88d4e6d91759e65e87c470e8b9141113e9ad5f0c8ceefc1e088c82e6980500798e486f9c9c09c9b5c753ac72d6005de254c607d1b534ed11d493ae1c1d9ac85"),
                                        Secret:             DeHex_Testing("2eb7b6bf138f6b5aff857414a058a3f1750054a9ba1f72c2cf0684a6f20b10e1"),
                                        Key:                DeHex_Testing("868c066ef58aae6dc589b6cfdd18f97e"),
                                        BaseNonce:          DeHex_Testing("4e0bc5018beba4bf004cca59"),
                                        ExporterSecret:     DeHex_Testing("14ad94af484a7ad3ef40e9f3be99ecc6fa9036df9d4920548424df127ee0d99f"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("4e0bc5018beba4bf004cca59"),
                                                Ct:    DeHex_Testing("5ad590bb8baa577f8619db35a36311226a896e7342a6d836d8b7bcd2f20b6c7f9076ac232e3ab2523f39513434"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("4e0bc5018beba4bf004cca58"),
                                                Ct:    DeHex_Testing("fa6f037b47fc21826b610172ca9637e82d6e5801eb31cbd3748271affd4ecb06646e0329cbdf3c3cd655b28e82"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("4e0bc5018beba4bf004cca5b"),
                                                Ct:    DeHex_Testing("895cabfac50ce6c6eb02ffe6c048bf53b7f7be9a91fc559402cbc5b8dcaeb52b2ccc93e466c28fb55fed7a7fec"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("4e0bc5018beba4bf004cca5d"),
                                                Ct:    DeHex_Testing("8787491ee8df99bc99a246c4b3216d3d57ab5076e18fa27133f520703bc70ec999dd36ce042e44f0c3169a6a8f"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("4e0bc5018beba4bf004ccaa6"),
                                                Ct:    DeHex_Testing("2ad71c85bf3f45c6eca301426289854b31448bcf8a8ccb1deef3ebd87f60848aa53c538c30a4dac71d619ee2cd"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("4e0bc5018beba4bf004ccb59"),
                                                Ct:    DeHex_Testing("10f179686aa2caec1758c8e554513f16472bd0a11e2a907dde0b212cbe87d74f367f8ffe5e41cd3e9962a6afb2"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("5e9bc3d236e1911d95e65b576a8a86d478fb827e8bdfe77b741b289890490d4d"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("6cff87658931bda83dc857e6353efe4987a201b849658d9b047aab4cf216e796"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("d8f1ea7942adbba7412c6d431c62d01371ea476b823eb697e1f6e6cae1dab85a"),
                                        },
                                },
                        },

                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.3.2
                        {
                                Mode: PSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode: PSk,

                                        KDFID:  KDF_HKDF_SHA256,
                                        KEMID:  DHKEM_P256_HKDF_SHA256,
                                        AEADID: AEAD_AES_128_GCM,

                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("2afa611d8b1a7b321c761b483b6a053579afa4f767450d3ad0f84a39fda587a6"),
                                        PkEm:               DeHex_Testing("04305d35563527bce037773d79a13deabed0e8e7cde61eecee403496959e89e4d0ca701726696d1485137ccb5341b3c1c7aaee90a4a02449725e744b1193b53b5f"),
                                        SkEm:               DeHex_Testing("57427244f6cc016cddf1c19c8973b4060aa13579b4c067fd5d93a5d74e32a90f"),
                                        IkmR:               DeHex_Testing("d42ef874c1913d9568c9405407c805baddaffd0898a00f1e84e154fa787b2429"),
                                        PkRm:               DeHex_Testing("040d97419ae99f13007a93996648b2674e5260a8ebd2b822e84899cd52d87446ea394ca76223b76639eccdf00e1967db10ade37db4e7db476261fcc8df97c5ffd1"),
                                        SkRm:               DeHex_Testing("438d8bcef33b89e0e9ae5eb0957c353c25a94584b0dd59c991372a75b43cb661"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                        Enc:                DeHex_Testing("04305d35563527bce037773d79a13deabed0e8e7cde61eecee403496959e89e4d0ca701726696d1485137ccb5341b3c1c7aaee90a4a02449725e744b1193b53b5f"),
                                        SharedSecret:       DeHex_Testing("2e783ad86a1beae03b5749e0f3f5e9bb19cb7eb382f2fb2dd64c99f15ae0661b"),
                                        KeyScheduleContext: DeHex_Testing("01b873cdf2dff4c1434988053b7a775e980dd2039ea24f950b26b056ccedcb933198e486f9c9c09c9b5c753ac72d6005de254c607d1b534ed11d493ae1c1d9ac85"),
                                        Secret:             DeHex_Testing("f2f534e55931c62eeb2188c1f53450354a725183937e68c85e68d6b267504d26"),
                                        Key:                DeHex_Testing("55d9eb9d26911d4c514a990fa8d57048"),
                                        BaseNonce:          DeHex_Testing("b595dc6b2d7e2ed23af529b1"),
                                        ExporterSecret:     DeHex_Testing("895a723a1eab809804973a53c0ee18ece29b25a7555a4808277ad2651d66d705"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("b595dc6b2d7e2ed23af529b1"),
                                                Ct:    DeHex_Testing("90c4deb5b75318530194e4bb62f890b019b1397bbf9d0d6eb918890e1fb2be1ac2603193b60a49c2126b75d0eb"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("b595dc6b2d7e2ed23af529b0"),
                                                Ct:    DeHex_Testing("9e223384a3620f4a75b5a52f546b7262d8826dea18db5a365feb8b997180b22d72dc1287f7089a1073a7102c27"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("b595dc6b2d7e2ed23af529b3"),
                                                Ct:    DeHex_Testing("adf9f6000773035023be7d415e13f84c1cb32a24339a32eb81df02be9ddc6abc880dd81cceb7c1d0c7781465b2"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("b595dc6b2d7e2ed23af529b5"),
                                                Ct:    DeHex_Testing("1f4cc9b7013d65511b1f69c050b7bd8bbd5a5c16ece82b238fec4f30ba2400e7ca8ee482ac5253cffb5c3dc577"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("b595dc6b2d7e2ed23af5294e"),
                                                Ct:    DeHex_Testing("cdc541253111ed7a424eea5134dc14fc5e8293ab3b537668b8656789628e45894e5bb873c968e3b7cdcbb654a4"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("b595dc6b2d7e2ed23af528b1"),
                                                Ct:    DeHex_Testing("faf985208858b1253b97b60aecd28bc18737b58d1242370e7703ec33b73a4c31a1afee300e349adef9015bbbfd"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("a115a59bf4dd8dc49332d6a0093af8efca1bcbfd3627d850173f5c4a55d0c185"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("4517eaede0669b16aac7c92d5762dd459c301fa10e02237cd5aeb9be969430c4"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("164e02144d44b607a7722e58b0f4156e67c0c2874d74cf71da6ca48a4cbdc5e0"),
                                        },
                                },
                        },

                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.3.3
                        {
                                Mode: Auth,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode: Auth,

                                        KDFID:  KDF_HKDF_SHA256,
                                        KEMID:  DHKEM_P256_HKDF_SHA256,
                                        AEADID: AEAD_AES_128_GCM,

                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("798d82a8d9ea19dbc7f2c6dfa54e8a6706f7cdc119db0813dacf8440ab37c857"),
                                        PkEm:               DeHex_Testing("042224f3ea800f7ec55c03f29fc9865f6ee27004f818fcbdc6dc68932c1e52e15b79e264a98f2c535ef06745f3d308624414153b22c7332bc1e691cb4af4d53454"),
                                        SkEm:               DeHex_Testing("6b8de0873aed0c1b2d09b8c7ed54cbf24fdf1dfc7a47fa501f918810642d7b91"),
                                        IkmR:               DeHex_Testing("7bc93bde8890d1fb55220e7f3b0c107ae7e6eda35ca4040bb6651284bf0747ee"),
                                        PkRm:               DeHex_Testing("04423e363e1cd54ce7b7573110ac121399acbc9ed815fae03b72ffbd4c18b01836835c5a09513f28fc971b7266cfde2e96afe84bb0f266920e82c4f53b36e1a78d"),
                                        SkRm:               DeHex_Testing("d929ab4be2e59f6954d6bedd93e638f02d4046cef21115b00cdda2acb2a4440e"),
                                        IkmS:               DeHex_Testing("874baa0dcf93595a24a45a7f042e0d22d368747daaa7e19f80a802af19204ba8"),
                                        PkSm:               DeHex_Testing("04a817a0902bf28e036d66add5d544cc3a0457eab150f104285df1e293b5c10eef8651213e43d9cd9086c80b309df22cf37609f58c1127f7607e85f210b2804f73"),
                                        SkSm:               DeHex_Testing("1120ac99fb1fccc1e8230502d245719d1b217fe20505c7648795139d177f0de9"),
                                        Enc:                DeHex_Testing("042224f3ea800f7ec55c03f29fc9865f6ee27004f818fcbdc6dc68932c1e52e15b79e264a98f2c535ef06745f3d308624414153b22c7332bc1e691cb4af4d53454"),
                                        SharedSecret:       DeHex_Testing("d4aea336439aadf68f9348880aa358086f1480e7c167b6ef15453ba69b94b44f"),
                                        KeyScheduleContext: DeHex_Testing("02b88d4e6d91759e65e87c470e8b9141113e9ad5f0c8ceefc1e088c82e6980500798e486f9c9c09c9b5c753ac72d6005de254c607d1b534ed11d493ae1c1d9ac85"),
                                        Secret:             DeHex_Testing("fd0a93c7c6f6b1b0dd6a822d7b16f6c61c83d98ad88426df4613c3581a2319f1"),
                                        Key:                DeHex_Testing("19aa8472b3fdc530392b0e54ca17c0f5"),
                                        BaseNonce:          DeHex_Testing("b390052d26b67a5b8a8fcaa4"),
                                        ExporterSecret:     DeHex_Testing("f152759972660eb0e1db880835abd5de1c39c8e9cd269f6f082ed80e28acb164"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("b390052d26b67a5b8a8fcaa4"),
                                                Ct:    DeHex_Testing("82ffc8c44760db691a07c5627e5fc2c08e7a86979ee79b494a17cc3405446ac2bdb8f265db4a099ed3289ffe19"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("b390052d26b67a5b8a8fcaa5"),
                                                Ct:    DeHex_Testing("b0a705a54532c7b4f5907de51c13dffe1e08d55ee9ba59686114b05945494d96725b239468f1229e3966aa1250"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("b390052d26b67a5b8a8fcaa6"),
                                                Ct:    DeHex_Testing("8dc805680e3271a801790833ed74473710157645584f06d1b53ad439078d880b23e25256663178271c80ee8b7c"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("b390052d26b67a5b8a8fcaa0"),
                                                Ct:    DeHex_Testing("04c8f7aae1584b61aa5816382cb0b834a5d744f420e6dffb5ddcec633a21b8b3472820930c1ea9258b035937a2"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("b390052d26b67a5b8a8fca5b"),
                                                Ct:    DeHex_Testing("4a319462eaedee37248b4d985f64f4f863d31913fe9e30b6e13136053b69fe5d70853c84c60a84bb5495d5a678"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("b390052d26b67a5b8a8fcba4"),
                                                Ct:    DeHex_Testing("28e874512f8940fafc7d06135e7589f6b4198bc0f3a1c64702e72c9e6abaf9f05cb0d2f11b03a517898815c934"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("837e49c3ff629250c8d80d3c3fb957725ed481e59e2feb57afd9fe9a8c7c4497"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("594213f9018d614b82007a7021c3135bda7b380da4acd9ab27165c508640dbda"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("14fe634f95ca0d86e15247cca7de7ba9b73c9b9deb6437e1c832daf7291b79d5"),
                                        },
                                },
                        },

                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.3.4
                        {
                                Mode: AuthPSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode: AuthPSk,

                                        KDFID:  KDF_HKDF_SHA256,
                                        KEMID:  DHKEM_P256_HKDF_SHA256,
                                        AEADID: AEAD_AES_128_GCM,

                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("3c1fceb477ec954c8d58ef3249e4bb4c38241b5925b95f7486e4d9f1d0d35fbb"),
                                        PkEm:               DeHex_Testing("046a1de3fc26a3d43f4e4ba97dbe24f7e99181136129c48fbe872d4743e2b131357ed4f29a7b317dc22509c7b00991ae990bf65f8b236700c82ab7c11a84511401"),
                                        SkEm:               DeHex_Testing("36f771e411cf9cf72f0701ef2b991ce9743645b472e835fe234fb4d6eb2ff5a0"),
                                        IkmR:               DeHex_Testing("abcc2da5b3fa81d8aabd91f7f800a8ccf60ec37b1b585a5d1d1ac77f258b6cca"),
                                        PkRm:               DeHex_Testing("04d824d7e897897c172ac8a9e862e4bd820133b8d090a9b188b8233a64dfbc5f725aa0aa52c8462ab7c9188f1c4872f0c99087a867e8a773a13df48a627058e1b3"),
                                        SkRm:               DeHex_Testing("bdf4e2e587afdf0930644a0c45053889ebcadeca662d7c755a353d5b4e2a8394"),
                                        IkmS:               DeHex_Testing("6262031f040a9db853edd6f91d2272596eabbc78a2ed2bd643f770ecd0f19b82"),
                                        PkSm:               DeHex_Testing("049f158c750e55d8d5ad13ede66cf6e79801634b7acadcad72044eac2ae1d0480069133d6488bf73863fa988c4ba8bde1c2e948b761274802b4d8012af4f13af9e"),
                                        SkSm:               DeHex_Testing("b0ed8721db6185435898650f7a677affce925aba7975a582653c4cb13c72d240"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                        Enc:                DeHex_Testing("046a1de3fc26a3d43f4e4ba97dbe24f7e99181136129c48fbe872d4743e2b131357ed4f29a7b317dc22509c7b00991ae990bf65f8b236700c82ab7c11a84511401"),
                                        SharedSecret:       DeHex_Testing("d4c27698391db126f1612d9e91a767f10b9b19aa17e1695549203f0df7d9aebe"),
                                        KeyScheduleContext: DeHex_Testing("03b873cdf2dff4c1434988053b7a775e980dd2039ea24f950b26b056ccedcb933198e486f9c9c09c9b5c753ac72d6005de254c607d1b534ed11d493ae1c1d9ac85"),
                                        Secret:             DeHex_Testing("3bf9d4c7955da2740414e73081fa74d6f6f2b4b9645d0685219813ce99a2f270"),
                                        Key:                DeHex_Testing("4d567121d67fae1227d90e11585988fb"),
                                        BaseNonce:          DeHex_Testing("67c9d05330ca21e5116ecda6"),
                                        ExporterSecret:     DeHex_Testing("3f479020ae186788e4dfd4a42a21d24f3faabb224dd4f91c2b2e5e9524ca27b2"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("67c9d05330ca21e5116ecda6"),
                                                Ct:    DeHex_Testing("b9f36d58d9eb101629a3e5a7b63d2ee4af42b3644209ab37e0a272d44365407db8e655c72e4fa46f4ff81b9246"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("67c9d05330ca21e5116ecda7"),
                                                Ct:    DeHex_Testing("51788c4e5d56276771032749d015d3eea651af0c7bb8e3da669effffed299ea1f641df621af65579c10fc09736"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("67c9d05330ca21e5116ecda4"),
                                                Ct:    DeHex_Testing("3b5a2be002e7b29927f06442947e1cf709b9f8508b03823127387223d712703471c266efc355f1bc2036f3027c"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("67c9d05330ca21e5116ecda2"),
                                                Ct:    DeHex_Testing("8ddbf1242fe5c7d61e1675496f3bfdb4d90205b3dfbc1b12aab41395d71a82118e095c484103107cf4face5123"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("67c9d05330ca21e5116ecd59"),
                                                Ct:    DeHex_Testing("6de25ceadeaec572fbaa25eda2558b73c383fe55106abaec24d518ef6724a7ce698f83ecdc53e640fe214d2f42"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("67c9d05330ca21e5116ecca6"),
                                                Ct:    DeHex_Testing("f380e19d291e12c5e378b51feb5cd50f6d00df6cb2af8393794c4df342126c2e29633fe7e8ce49587531affd4d"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("595ce0eff405d4b3bb1d08308d70a4e77226ce11766e0a94c4fdb5d90025c978"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("110472ee0ae328f57ef7332a9886a1992d2c45b9b8d5abc9424ff68630f7d38d"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("18ee4d001a9d83a4c67e76f88dd747766576cac438723bad0700a910a4d717e6"),
                                        },
                                },
                        },
                },
        },
        {
                Name: "DHKEM(P-256, HKDF-SHA256), HKDF-SHA512, AES-128-GCM",
                Info: []*SuiteInfo_Testing{
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.4.1
                        {
                                Mode: Base,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Base,
                                        KEMID:              DHKEM_P256_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA512,
                                        AEADID:             AEAD_AES_128_GCM,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("4ab11a9dd78c39668f7038f921ffc0993b368171d3ddde8031501ee1e08c4c9a"),
                                        PkEm:               DeHex_Testing("0493ed86735bdfb978cc055c98b45695ad7ce61ce748f4dd63c525a3b8d53a15565c6897888070070c1579db1f86aaa56deb8297e64db7e8924e72866f9a472580"),
                                        SkEm:               DeHex_Testing("2292bf14bb6e15b8c81a0f45b7a6e93e32d830e48cca702e0affcfb4d07e1b5c"),
                                        IkmR:               DeHex_Testing("ea9ff7cc5b2705b188841c7ace169290ff312a9cb31467784ca92d7a2e6e1be8"),
                                        PkRm:               DeHex_Testing("04085aa5b665dc3826f9650ccbcc471be268c8ada866422f739e2d531d4a8818a9466bc6b449357096232919ec4fe9070ccbac4aac30f4a1a53efcf7af90610edd"),
                                        SkRm:               DeHex_Testing("3ac8530ad1b01885960fab38cf3cdc4f7aef121eaa239f222623614b4079fb38"),
                                        Enc:                DeHex_Testing("0493ed86735bdfb978cc055c98b45695ad7ce61ce748f4dd63c525a3b8d53a15565c6897888070070c1579db1f86aaa56deb8297e64db7e8924e72866f9a472580"),
                                        SharedSecret:       DeHex_Testing("02f584736390fc93f5b4ad039826a3fa08e9911bd1215a3db8e8791ba533cafd"),
                                        KeyScheduleContext: DeHex_Testing("005b8a3617af7789ee716e7911c7e77f84cdc4cc46e60fb7e19e4059f9aeadc00585e26874d1ddde76e551a7679cd47168c466f6e1f705cc9374c192778a34fcd5ca221d77e229a9d11b654de7942d685069c633b2362ce3b3d8ea4891c9a2a87a4eb7cdb289ba5e2ecbf8cd2c8498bb4a383dc021454d70d46fcbbad1252ef4f9"),
                                        Secret:             DeHex_Testing("0c7acdab61693f936c4c1256c78e7be30eebfe466812f9cc49f0b58dc970328dfc03ea359be0250a471b1635a193d2dfa8cb23c90aa2e25025b892a725353eeb"),
                                        Key:                DeHex_Testing("090ca96e5f8aa02b69fac360da50ddf9"),
                                        BaseNonce:          DeHex_Testing("9c995e621bf9a20c5ca45546"),
                                        ExporterSecret:     DeHex_Testing("4a7abb2ac43e6553f129b2c5750a7e82d149a76ed56dc342d7bca61e26d494f4855dff0d0165f27ce57756f7f16baca006539bb8e4518987ba610480ac03efa8"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("9c995e621bf9a20c5ca45546"),
                                                Ct:    DeHex_Testing("d3cf4984931484a080f74c1bb2a6782700dc1fef9abe8442e44a6f09044c88907200b332003543754eb51917ba"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("9c995e621bf9a20c5ca45547"),
                                                Ct:    DeHex_Testing("d14414555a47269dfead9fbf26abb303365e40709a4ed16eaefe1f2070f1ddeb1bdd94d9e41186f124e0acc62d"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("9c995e621bf9a20c5ca45544"),
                                                Ct:    DeHex_Testing("9bba136cade5c4069707ba91a61932e2cbedda2d9c7bdc33515aa01dd0e0f7e9d3579bf4016dec37da4aafa800"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("9c995e621bf9a20c5ca45542"),
                                                Ct:    DeHex_Testing("a531c0655342be013bf32112951f8df1da643602f1866749519f5dcb09cc68432579de305a77e6864e862a7600"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("9c995e621bf9a20c5ca455b9"),
                                                Ct:    DeHex_Testing("be5da649469efbad0fb950366a82a73fefeda5f652ec7d3731fac6c4ffa21a7004d2ab8a04e13621bd3629547d"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("9c995e621bf9a20c5ca45446"),
                                                Ct:    DeHex_Testing("62092672f5328a0dde095e57435edf7457ace60b26ee44c9291110ec135cb0e14b85594e4fea11247d937deb62"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("a32186b8946f61aeead1c093fe614945f85833b165b28c46bf271abf16b57208"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("84998b304a0ea2f11809398755f0abd5f9d2c141d1822def79dd15c194803c2a"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("93fb9411430b2cfa2cf0bed448c46922a5be9beff20e2e621df7e4655852edbc"),
                                        },
                                },
                        },
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.4.2
                        {
                                Mode: PSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               PSk,
                                        KEMID:              DHKEM_P256_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA512,
                                        AEADID:             AEAD_AES_128_GCM,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("c11d883d6587f911d2ddbc2a0859d5b42fb13bf2c8e89ef408a25564893856f5"),
                                        PkEm:               DeHex_Testing("04a307934180ad5287f95525fe5bc6244285d7273c15e061f0f2efb211c35057f3079f6e0abae200992610b25f48b63aacfcb669106ddee8aa023feed301901371"),
                                        SkEm:               DeHex_Testing("a5901ff7d6931959c2755382ea40a4869b1dec3694ed3b009dda2d77dd488f18"),
                                        IkmR:               DeHex_Testing("75bfc2a3a3541170a54c0b06444e358d0ee2b4fb78a401fd399a47a33723b700"),
                                        PkRm:               DeHex_Testing("043f5266fba0742db649e1043102b8a5afd114465156719cea90373229aabdd84d7f45dabfc1f55664b888a7e86d594853a6cccdc9b189b57839cbbe3b90b55873"),
                                        SkRm:               DeHex_Testing("bc6f0b5e22429e5ff47d5969003f3cae0f4fec50e23602e880038364f33b8522"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                        Enc:                DeHex_Testing("04a307934180ad5287f95525fe5bc6244285d7273c15e061f0f2efb211c35057f3079f6e0abae200992610b25f48b63aacfcb669106ddee8aa023feed301901371"),
                                        SharedSecret:       DeHex_Testing("2912aacc6eaebd71ff715ea50f6ef3a6637856b2a4c58ea61e0c3fc159e3bc16"),
                                        KeyScheduleContext: DeHex_Testing("01713f73042575cebfd132f0cc4338523f8eae95c80a749f7cf3eb9436ff1c612ca62c37df27ca46d2cc162445a92c5f5fdc57bcde129ca7b1f284b0c12297c037ca221d77e229a9d11b654de7942d685069c633b2362ce3b3d8ea4891c9a2a87a4eb7cdb289ba5e2ecbf8cd2c8498bb4a383dc021454d70d46fcbbad1252ef4f9"),
                                        Secret:             DeHex_Testing("ff2051d2128d5f3078de867143e076262ce1d0aecafc3fff3d607f1eaff05345c7d5ffcb3202cdecb3d1a2f7da20592a237747b6e855390cbe2109d3e6ac70c2"),
                                        Key:                DeHex_Testing("0b910ba8d9cfa17e5f50c211cb32839a"),
                                        BaseNonce:          DeHex_Testing("0c29e714eb52de5b7415a1b7"),
                                        ExporterSecret:     DeHex_Testing("50c0a182b6f94b4c0bd955c4aa20df01f282cc12c43065a0812fe4d4352790171ed2b2c4756ad7f5a730ba336c8f1edd0089d8331192058c385bae39c7cc8b57"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("0c29e714eb52de5b7415a1b7"),
                                                Ct:    DeHex_Testing("57624b6e320d4aba0afd11f548780772932f502e2ba2a8068676b2a0d3b5129a45b9faa88de39e8306da41d4cc"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("0c29e714eb52de5b7415a1b6"),
                                                Ct:    DeHex_Testing("159d6b4c24bacaf2f5049b7863536d8f3ffede76302dace42080820fa51925d4e1c72a64f87b14291a3057e00a"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("0c29e714eb52de5b7415a1b5"),
                                                Ct:    DeHex_Testing("bd24140859c99bf0055075e9c460032581dd1726d52cf980d308e9b20083ca62e700b17892bcf7fa82bac751d0"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("0c29e714eb52de5b7415a1b3"),
                                                Ct:    DeHex_Testing("93ddd55f82e9aaaa3cfc06840575f09d80160b20538125c2549932977d1238dde8126a4a91118faf8632f62cb8"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("0c29e714eb52de5b7415a148"),
                                                Ct:    DeHex_Testing("377a98a3c34bf716581b05a6b3fdc257f245856384d5f2241c8840571c52f5c85c21138a4a81655edab8fe227d"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("0c29e714eb52de5b7415a0b7"),
                                                Ct:    DeHex_Testing("cc161f5a179831d456d119d2f2c19a6817289c75d1c61cd37ac8a450acd9efba02e0ac00d128c17855931ff69a"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("8158bea21a6700d37022bb7802866edca30ebf2078273757b656ef7fc2e428cf"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("6a348ba6e0e72bb3ef22479214a139ef8dac57be34509a61087a12565473da8d"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("2f6d4f7a18ec48de1ef4469f596aada4afdf6d79b037ed3c07e0118f8723bffc"),
                                        },
                                },
                        },
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.4.3
                        {
                                Mode: Auth,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Auth,
                                        KEMID:              DHKEM_P256_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA512,
                                        AEADID:             AEAD_AES_128_GCM,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("6bb031aa9197562da0b44e737db2b9e61f6c3ea1138c37de28fc37ac29bc7350"),
                                        PkEm:               DeHex_Testing("04fec59fa9f76f5d0f6c1660bb179cb314ed97953c53a60ab38f8e6ace60fd59178084d0dd66e0f79172992d4ddb2e91172ce24949bcebfff158dcc417f2c6e9c6"),
                                        SkEm:               DeHex_Testing("93cddd5288e7ef4884c8fe321d075df01501b993ff49ffab8184116f39b3c655"),
                                        IkmR:               DeHex_Testing("649a3f92edbb7a2516a0ade0b7dccc58a37240c4ba06f9726a952227b4adf6ff"),
                                        PkRm:               DeHex_Testing("04378bad519aab406e04d0e5608bcca809c02d6afd2272d4dd03e9357bd0eee8adf84c8deba3155c9cf9506d1d4c8bfefe3cf033a75716cc3cc07295100ec96276"),
                                        SkRm:               DeHex_Testing("1ea4484be482bf25fdb2ed39e6a02ed9156b3e57dfb18dff82e4a048de990236"),
                                        IkmS:               DeHex_Testing("4d79b8691aab55a7265e8490a04bb3860ed64dece90953ad0dc43a6ea59b4bf2"),
                                        PkSm:               DeHex_Testing("0404d3c1f9fca22eb4a6d326125f0814c35593b1da8ea0d11a640730b215a259b9b98a34ad17e21617d19fe1d4fa39a4828bfdb306b729ec51c543caca3b2d9529"),
                                        SkSm:               DeHex_Testing("02b266d66919f7b08f42ae0e7d97af4ca98b2dae3043bb7e0740ccadc1957579"),
                                        Enc:                DeHex_Testing("04fec59fa9f76f5d0f6c1660bb179cb314ed97953c53a60ab38f8e6ace60fd59178084d0dd66e0f79172992d4ddb2e91172ce24949bcebfff158dcc417f2c6e9c6"),
                                        SharedSecret:       DeHex_Testing("1ed49f6d7ada333d171cd63861a1cb700a1ec4236755a9cd5f9f8f67a2f8e7b3"),
                                        KeyScheduleContext: DeHex_Testing("025b8a3617af7789ee716e7911c7e77f84cdc4cc46e60fb7e19e4059f9aeadc00585e26874d1ddde76e551a7679cd47168c466f6e1f705cc9374c192778a34fcd5ca221d77e229a9d11b654de7942d685069c633b2362ce3b3d8ea4891c9a2a87a4eb7cdb289ba5e2ecbf8cd2c8498bb4a383dc021454d70d46fcbbad1252ef4f9"),
                                        Secret:             DeHex_Testing("9c846ba81ddbbd57bc26d99da6cf7ab956bb735ecd47fe21ed14241c70791b7484c1d06663d21a5d97bf1be70d56ab727f650c4f859c5ed3f71f8928b3c082dd"),
                                        Key:                DeHex_Testing("9d4b1c83129f3de6db95faf3d539dcf1"),
                                        BaseNonce:          DeHex_Testing("ea4fd7a485ee5f1f4b62c1b7"),
                                        ExporterSecret:     DeHex_Testing("ca2410672369aae1afd6c2639f4fe34ca36d35410c090608d2924f60def17f910d7928575434d7f991b1f19d3e8358b8278ff59ced0d5eed4774cec72e12766e"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("ea4fd7a485ee5f1f4b62c1b7"),
                                                Ct:    DeHex_Testing("2480179d880b5f458154b8bfe3c7e8732332de84aabf06fc440f6b31f169e154157fa9eb44f2fa4d7b38a9236e"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("ea4fd7a485ee5f1f4b62c1b6"),
                                                Ct:    DeHex_Testing("10cd81e3a816d29942b602a92884348171a31cbd0f042c3057c65cd93c540943a5b05115bd520c09281061935b"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("ea4fd7a485ee5f1f4b62c1b5"),
                                                Ct:    DeHex_Testing("920743a88d8cf6a09e1a3098e8be8edd09db136e9d543f215924043af8c7410f68ce6aa64fd2b1a176e7f6b3fd"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("ea4fd7a485ee5f1f4b62c1b3"),
                                                Ct:    DeHex_Testing("6b11380fcc708fc8589effb5b5e0394cbd441fa5e240b5500522150ca8265d65ff55479405af936e2349119dcd"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("ea4fd7a485ee5f1f4b62c148"),
                                                Ct:    DeHex_Testing("d084eca50e7554bb97ba34c4482dfe32c9a2b7f3ab009c2d1b68ecbf97bee2d28cd94b6c829b96361f2701772d"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("ea4fd7a485ee5f1f4b62c0b7"),
                                                Ct:    DeHex_Testing("247da592cc4ce834a94de2c79f5730ee49342470a021e4a4bc2bb77c53b17413e94d94f57b4fdaedcf97cfe7b1"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("f03fbc82f321a0ab4840e487cb75d07aafd8e6f68485e4f7ff72b2f55ff24ad6"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("1ce0cadec0a8f060f4b5070c8f8888dcdfefc2e35819df0cd559928a11ff0891"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("70c405c707102fd0041ea716090753be47d68d238b111d542846bd0d84ba907c"),
                                        },
                                },
                        },
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.4.4
                        {
                                Mode: AuthPSk,

                                Setup: &amp;SetupInfo_Testing{
                                        Mode:   AuthPSk,
                                        KEMID:  DHKEM_P256_HKDF_SHA256,
                                        KDFID:  KDF_HKDF_SHA512,
                                        AEADID: AEAD_AES_128_GCM,

                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("37ae06a521cd555648c928d7af58ad2aa4a85e34b8cabd069e94ad55ab872cc8"),
                                        PkEm:               DeHex_Testing("04801740f4b1b35823f7fb2930eac2efc8c4893f34ba111c0bb976e3c7d5dc0aef5a7ef0bf4057949a140285f774f1efc53b3860936b92279a11b68395d898d138"),
                                        SkEm:               DeHex_Testing("778f2254ae5d661d5c7fca8c4a7495a25bd13f26258e459159f3899df0de76c1"),
                                        IkmR:               DeHex_Testing("7466024b7e2d2366c3914d7833718f13afb9e3e45bcfbb510594d614ddd9b4e7"),
                                        PkRm:               DeHex_Testing("04a4ca7af2fc2cce48edbf2f1700983e927743a4e85bb5035ad562043e25d9a111cbf6f7385fac55edc5c9d2ca6ed351a5643de95c36748e11dbec98730f4d43e9"),
                                        SkRm:               DeHex_Testing("00510a70fde67af487c093234fc4215c1cdec09579c4b30cc8e48cb530414d0e"),
                                        IkmS:               DeHex_Testing("ee27aaf99bf5cd8398e9de88ac09a82ac22cdb8d0905ab05c0f5fa12ba1709f3"),
                                        PkSm:               DeHex_Testing("04b59a4157a9720eb749c95f842a5e3e8acdccbe834426d405509ac3191e23f2165b5bb1f07a6240dd567703ae75e13182ee0f69fc102145cdb5abf681ff126d60"),
                                        SkSm:               DeHex_Testing("d743b20821e6326f7a26684a4beed7088b35e392114480ca9f6c325079dcf10b"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                        Enc:                DeHex_Testing("04801740f4b1b35823f7fb2930eac2efc8c4893f34ba111c0bb976e3c7d5dc0aef5a7ef0bf4057949a140285f774f1efc53b3860936b92279a11b68395d898d138"),
                                        SharedSecret:       DeHex_Testing("02bee8be0dda755846115db45071c0cf59c25722e015bde1c124de849c0fea52"),
                                        KeyScheduleContext: DeHex_Testing("03713f73042575cebfd132f0cc4338523f8eae95c80a749f7cf3eb9436ff1c612ca62c37df27ca46d2cc162445a92c5f5fdc57bcde129ca7b1f284b0c12297c037ca221d77e229a9d11b654de7942d685069c633b2362ce3b3d8ea4891c9a2a87a4eb7cdb289ba5e2ecbf8cd2c8498bb4a383dc021454d70d46fcbbad1252ef4f9"),
                                        Secret:             DeHex_Testing("0f9df08908a6a3d06c8e934cd3f5313f9ebccd0986e316c0198bb48bed30dc3db2f3baab94fd40c2c285c7288c77e2255401ee2d5884306addf4296b93c238b3"),
                                        Key:                DeHex_Testing("b68bb0e2fbf7431cedb46cc3b6f1fe9e"),
                                        BaseNonce:          DeHex_Testing("76af62719d33d39a1cb6be9f"),
                                        ExporterSecret:     DeHex_Testing("7f72308ae68c9a2b3862e686cb547b16d33d00fe482c770c4717d8b54e9b1e547244c3602bdd86d5a788a8443befea0a7658002b23f1c96a62a64986fffc511a"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("76af62719d33d39a1cb6be9f"),
                                                Ct:    DeHex_Testing("840669634db51e28df54f189329c1b727fd303ae413f003020aff5e26276aaa910fc4296828cb9d862c2fd7d16"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("76af62719d33d39a1cb6be9e"),
                                                Ct:    DeHex_Testing("d4680a48158d9a75fd09355878d6e33997a36ee01d4a8f22032b22373b795a941b7b9c5205ff99e0ff284beef4"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("76af62719d33d39a1cb6be9d"),
                                                Ct:    DeHex_Testing("c45eb6597de2bac929a0f5d404ba9d2dc1ea031880930f1fd7a283f0a0cbebb35eac1a9ee0d1225f5e0f181571"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("76af62719d33d39a1cb6be9b"),
                                                Ct:    DeHex_Testing("4ee2482ad8d7d1e9b7e651c78b6ca26d3c5314d0711710ca62c2fd8bb8996d7d8727c157538d5493da696b61f8"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("76af62719d33d39a1cb6be60"),
                                                Ct:    DeHex_Testing("65596b731df010c76a915c6271a438056ce65696459432eeafdae7b4cadb6290dd61e68edd4e40b659d2a8cbcc"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("76af62719d33d39a1cb6bf9f"),
                                                Ct:    DeHex_Testing("9f659482ebc52f8303f9eac75656d807ec38ce2e50c72e3078cd13d86b30e3f890690a873277620f8a6a42d836"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("c8c917e137a616d3d4e4c9fcd9c50202f366cb0d37862376bc79f9b72e8a8db9"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("33a5d4df232777008a06d0684f23bb891cfaef702f653c8601b6ad4d08dddddf"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("bed80f2e54f1285895c4a3f3b3625e6206f78f1ed329a0cfb5864f7c139b3c6a"),
                                        },
                                },
                        },
                },
        },
        {
                Name: "DHKEM(P-256, HKDF-SHA256), HKDF-SHA256, ChaCha20Poly1305",
                Info: []*SuiteInfo_Testing{
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.5.1
                        {
                                Mode: Base,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Base,
                                        KEMID:              DHKEM_P256_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_CHACHA_20_POLY_1305,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("f1f1a3bc95416871539ecb51c3a8f0cf608afb40fbbe305c0a72819d35c33f1f"),
                                        PkEm:               DeHex_Testing("04c07836a0206e04e31d8ae99bfd549380b072a1b1b82e563c935c095827824fc1559eac6fb9e3c70cd3193968994e7fe9781aa103f5b50e934b5b2f387e381291"),
                                        SkEm:               DeHex_Testing("7550253e1147aae48839c1f8af80d2770fb7a4c763afe7d0afa7e0f42a5b3689"),
                                        IkmR:               DeHex_Testing("61092f3f56994dd424405899154a9918353e3e008171517ad576b900ddb275e7"),
                                        PkRm:               DeHex_Testing("04a697bffde9405c992883c5c439d6cc358170b51af72812333b015621dc0f40bad9bb726f68a5c013806a790ec716ab8669f84f6b694596c2987cf35baba2a006"),
                                        SkRm:               DeHex_Testing("a4d1c55836aa30f9b3fbb6ac98d338c877c2867dd3a77396d13f68d3ab150d3b"),
                                        Enc:                DeHex_Testing("04c07836a0206e04e31d8ae99bfd549380b072a1b1b82e563c935c095827824fc1559eac6fb9e3c70cd3193968994e7fe9781aa103f5b50e934b5b2f387e381291"),
                                        SharedSecret:       DeHex_Testing("806520f82ef0b03c823b7fc524b6b55a088f566b9751b89551c170f4113bd850"),
                                        KeyScheduleContext: DeHex_Testing("00b738cd703db7b4106e93b4621e9a19c89c838e55964240e5d3f331aaf8b0d58b2e986ea1c671b61cf45eec134dac0bae58ec6f63e790b1400b47c33038b0269c"),
                                        Secret:             DeHex_Testing("fe891101629aa355aad68eff3cc5170d057eca0c7573f6575e91f9783e1d4506"),
                                        Key:                DeHex_Testing("a8f45490a92a3b04d1dbf6cf2c3939ad8bfc9bfcb97c04bffe116730c9dfe3fc"),
                                        BaseNonce:          DeHex_Testing("726b4390ed2209809f58c693"),
                                        ExporterSecret:     DeHex_Testing("4f9bd9b3a8db7d7c3a5b9d44fdc1f6e37d5d77689ade5ec44a7242016e6aa205"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("726b4390ed2209809f58c693"),
                                                Ct:    DeHex_Testing("6469c41c5c81d3aa85432531ecf6460ec945bde1eb428cb2fedf7a29f5a685b4ccb0d057f03ea2952a27bb458b"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("726b4390ed2209809f58c692"),
                                                Ct:    DeHex_Testing("f1564199f7e0e110ec9c1bcdde332177fc35c1adf6e57f8d1df24022227ffa8716862dbda2b1dc546c9d114374"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("726b4390ed2209809f58c691"),
                                                Ct:    DeHex_Testing("39de89728bcb774269f882af8dc5369e4f3d6322d986e872b3a8d074c7c18e8549ff3f85b6d6592ff87c3f310c"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("726b4390ed2209809f58c697"),
                                                Ct:    DeHex_Testing("bc104a14fbede0cc79eeb826ea0476ce87b9c928c36e5e34dc9b6905d91473ec369a08b1a25d305dd45c6c5f80"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("726b4390ed2209809f58c66c"),
                                                Ct:    DeHex_Testing("8f2814a2c548b3be50259713c6724009e092d37789f6856553d61df23ebc079235f710e6af3c3ca6eaba7c7c6c"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("726b4390ed2209809f58c793"),
                                                Ct:    DeHex_Testing("b45b69d419a9be7219d8c94365b89ad6951caf4576ea4774ea40e9b7047a09d6537d1aa2f7c12d6ae4b729b4d0"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("9b13c510416ac977b553bf1741018809c246a695f45eff6d3b0356dbefe1e660"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("6c8b7be3a20a5684edecb4253619d9051ce8583baf850e0cb53c402bdcaf8ebb"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("477a50d804c7c51941f69b8e32fe8288386ee1a84905fe4938d58972f24ac938"),
                                        },
                                },
                        },
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.5.2
                        {
                                Mode: PSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               PSk,
                                        KEMID:              DHKEM_P256_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_CHACHA_20_POLY_1305,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("e1a4e1d50c4bfcf890f2b4c7d6b2d2aca61368eddc3c84162df2856843e1057a"),
                                        PkEm:               DeHex_Testing("04f336578b72ad7932fe867cc4d2d44a718a318037a0ec271163699cee653fa805c1fec955e562663e0c2061bb96a87d78892bff0cc0bad7906c2d998ebe1a7246"),
                                        SkEm:               DeHex_Testing("7d6e4e006cee68af9b3fdd583a0ee8962df9d59fab029997ee3f456cbc857904"),
                                        IkmR:               DeHex_Testing("ee51dec304abf993ef8fd52aacdd3b539108bbf6e491943266c1de89ec596a17"),
                                        PkRm:               DeHex_Testing("041eb8f4f20ab72661af369ff3231a733672fa26f385ffb959fd1bae46bfda43ad55e2d573b880831381d9367417f554ce5b2134fbba5235b44db465feffc6189e"),
                                        SkRm:               DeHex_Testing("12ecde2c8bc2d5d7ed2219c71f27e3943d92b344174436af833337c557c300b3"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                        Enc:                DeHex_Testing("04f336578b72ad7932fe867cc4d2d44a718a318037a0ec271163699cee653fa805c1fec955e562663e0c2061bb96a87d78892bff0cc0bad7906c2d998ebe1a7246"),
                                        SharedSecret:       DeHex_Testing("ac4f260dce4db6bf45435d9c92c0e11cfdd93743bd3075949975974cc2b3d79e"),
                                        KeyScheduleContext: DeHex_Testing("01622b72afcc3795841596c67ea74400ca3b029374d7d5640bda367c5d67b3fbeb2e986ea1c671b61cf45eec134dac0bae58ec6f63e790b1400b47c33038b0269c"),
                                        Secret:             DeHex_Testing("858c8087a1c056db5811e85802f375bb0c19b9983204a1575de4803575d23239"),
                                        Key:                DeHex_Testing("6d61cb330b7771168c8619498e753f16198aad9566d1f1c6c70e2bc1a1a8b142"),
                                        BaseNonce:          DeHex_Testing("0de7655fb65e1cd51a38864e"),
                                        ExporterSecret:     DeHex_Testing("754ca00235b245e72d1f722a7718e7145bd113050a2aa3d89586d4cb7514bfdb"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("0de7655fb65e1cd51a38864e"),
                                                Ct:    DeHex_Testing("21433eaff24d7706f3ed5b9b2e709b07230e2b11df1f2b1fe07b3c70d5948a53d6fa5c8bed194020bd9df0877b"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("0de7655fb65e1cd51a38864f"),
                                                Ct:    DeHex_Testing("c74a764b4892072ea8c2c56b9bcd46c7f1e9ca8cb0a263f8b40c2ba59ac9c857033f176019562218769d3e0452"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("0de7655fb65e1cd51a38864c"),
                                                Ct:    DeHex_Testing("dc8cd68863474d6e9cbb6a659335a86a54e036249d41acf909e738c847ff2bd36fe3fcacda4ededa7032c0a220"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("0de7655fb65e1cd51a38864a"),
                                                Ct:    DeHex_Testing("cd54a8576353b1b9df366cb0cc042e46eef6f4cf01e205fe7d47e306b2fdd90f7185f289a26c613ca094e3be10"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("0de7655fb65e1cd51a3886b1"),
                                                Ct:    DeHex_Testing("6324570c9d542c70c7e70570c1d8f4c52a89484746bf0625441890ededcc80c24ef2301c38bfd34d689d19f67d"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("0de7655fb65e1cd51a38874e"),
                                                Ct:    DeHex_Testing("1ea6326c8098ed0437a553c466550114fb2ca1412cca7de98709b9ccdf19206e52c3d39180e2cf62b3e9f4baf4"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("530bbc2f68f078dccc89cc371b4f4ade372c9472bafe4601a8432cbb934f528d"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("6e25075ddcc528c90ef9218f800ca3dfe1b8ff4042de5033133adb8bd54c401d"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("6f6fbd0d1c7733f796461b3235a856cc34f676fe61ed509dfc18fa16efe6be78"),
                                        },
                                },
                        },
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.5.3
                        {
                                Mode: Auth,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Auth,
                                        KEMID:              DHKEM_P256_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_CHACHA_20_POLY_1305,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("0ecd212019008138a31f9104d5dba76b9f8e34d5b996041fff9e3df221dd0d5d"),
                                        PkEm:               DeHex_Testing("040d5176aedba55bc41709261e9195c5146bb62d783031280775f32e507d79b5cbc5748b6be6359760c73cfe10ca19521af704ca6d91ff32fc0739527b9385d415"),
                                        SkEm:               DeHex_Testing("085fd5d5e6ce6497c79df960cac93710006b76217d8bcfafbd2bb2c20ea03c42"),
                                        IkmR:               DeHex_Testing("d32236d8378b9563840653789eb7bc33c3c720e537391727bf1c812d0eac110f"),
                                        PkRm:               DeHex_Testing("0444f6ee41818d9fe0f8265bffd016b7e2dd3964d610d0f7514244a60dbb7a11ece876bb110a97a2ac6a9542d7344bf7d2bd59345e3e75e497f7416cf38d296233"),
                                        SkRm:               DeHex_Testing("3cb2c125b8c5a81d165a333048f5dcae29a2ab2072625adad66dbb0f48689af9"),
                                        IkmS:               DeHex_Testing("0e6be0851283f9327295fd49858a8c8908ea9783212945eef6c598ee0a3cedbb"),
                                        PkSm:               DeHex_Testing("04265529a04d4f46ab6fa3af4943774a9f1127821656a75a35fade898a9a1b014f64d874e88cddb24c1c3d79004d3a587db67670ca357ff4fba7e8b56ec013b98b"),
                                        SkSm:               DeHex_Testing("39b19402e742d48d319d24d68e494daa4492817342e593285944830320912519"),
                                        Enc:                DeHex_Testing("040d5176aedba55bc41709261e9195c5146bb62d783031280775f32e507d79b5cbc5748b6be6359760c73cfe10ca19521af704ca6d91ff32fc0739527b9385d415"),
                                        SharedSecret:       DeHex_Testing("1a45aa4792f4b166bfee7eeab0096c1a6e497480e2261b2a59aad12f2768d469"),
                                        KeyScheduleContext: DeHex_Testing("02b738cd703db7b4106e93b4621e9a19c89c838e55964240e5d3f331aaf8b0d58b2e986ea1c671b61cf45eec134dac0bae58ec6f63e790b1400b47c33038b0269c"),
                                        Secret:             DeHex_Testing("9193210815b87a4c5496c9d73e609a6c92665b5ea0d760866294906d089ebb57"),
                                        Key:                DeHex_Testing("cf292f8a4313280a462ce55cde05b5aa5744fe4ca89a5d81b0146a5eaca8092d"),
                                        BaseNonce:          DeHex_Testing("7e45c21e20e869ae00492123"),
                                        ExporterSecret:     DeHex_Testing("dba6e307f71769ba11e2c687cc19592f9d436da0c81e772d7a8a9fd28e54355f"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("7e45c21e20e869ae00492123"),
                                                Ct:    DeHex_Testing("25881f219935eec5ba70d7b421f13c35005734f3e4d959680270f55d71e2f5cb3bd2daced2770bf3d9d4916872,"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("7e45c21e20e869ae00492122"),
                                                Ct:    DeHex_Testing("653f0036e52a376f5d2dd85b3204b55455b7835c231255ae098d09ed138719b97185129786338ab6543f753193"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("7e45c21e20e869ae00492121"),
                                                Ct:    DeHex_Testing("60878706117f22180c788e62df6a595bc41906096a11a9513e84f0141e43239e81a98d7a235abc64112fcb8ddd"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("7e45c21e20e869ae00492127"),
                                                Ct:    DeHex_Testing("0f9094dd08240b5fa7a388b824d19d5b4b1e126cebfd67a062c32f9ba9f1f3866cc38de7df2702626e2ab65c0f"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("7e45c21e20e869ae004921dc"),
                                                Ct:    DeHex_Testing("dd29319e08135c5f8401d6537a364e92172c0e3f095f3fd18923881d11c0a6839345dd0b54acd0edd8f8344792"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("7e45c21e20e869ae00492023"),
                                                Ct:    DeHex_Testing("e2276ec5047bc4b6ed57d6da7da2fb47a77502f0a30f17d040247c73da336d722bc6c89adf68396a0912c6d152"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("56c4d6c1d3a46c70fd8f4ecda5d27c70886e348efb51bd5edeaa39ff6ce34389"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("d2d3e48ed76832b6b3f28fa84be5f11f09533c0e3c71825a34fb0f1320891b51"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("eb0d312b6263995b4c7761e64b688c215ffd6043ff3bad2368c862784cbe6eff"),
                                        },
                                },
                        },
                        // https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.5.4
                        {
                                Mode: AuthPSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               AuthPSk,
                                        KEMID:              DHKEM_P256_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_CHACHA_20_POLY_1305,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("f3a07f194703e321ef1f753a1b9fe27a498dfdfa309151d70bedd896c239c499"),
                                        PkEm:               DeHex_Testing("043539917ee26f8ae0aa5f784a387981b13de33124a3cde88b94672030183110f331400115855808244ff0c5b6ca6104483ac95724481d41bdcd9f15b430ad16f6"),
                                        SkEm:               DeHex_Testing("11b7e4de2d919240616a31ab14944cced79bc2372108bb98f6792e3b645fe546"),
                                        IkmR:               DeHex_Testing("1240e55a0a03548d7f963ef783b6a7362cb505e6b31dfd04c81d9b294543bfbd"),
                                        PkRm:               DeHex_Testing("04d383fd920c42d018b9d57fd73a01f1eee480008923f67d35169478e55d2e8817068daf62a06b10e0aad4a9e429fa7f904481be96b79a9c231a33e956c20b81b6"),
                                        SkRm:               DeHex_Testing("c29fc577b7e74d525c0043f1c27540a1248e4f2c8d297298e99010a92e94865c"),
                                        IkmS:               DeHex_Testing("ce2a0387a2eb8870a3a92c34a2975f0f3f271af4384d446c7dc1524a6c6c515a"),
                                        PkSm:               DeHex_Testing("0492cf8c9b144b742fe5a63d9a181a19d416f3ec8705f24308ad316564823c344e018bd7c03a33c926bb271b28ef5bf28c0ca00abff249fee5ef7f33315ff34fdb"),
                                        SkSm:               DeHex_Testing("53541bd995f874a67f8bfd8038afa67fd68876801f42ff47d0dc2a4deea067ae"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                        Enc:                DeHex_Testing("043539917ee26f8ae0aa5f784a387981b13de33124a3cde88b94672030183110f331400115855808244ff0c5b6ca6104483ac95724481d41bdcd9f15b430ad16f6"),
                                        SharedSecret:       DeHex_Testing("87584311791036a3019bc36803cdd42e9a8931a98b13c88835f2f8a9036a4fd6"),
                                        KeyScheduleContext: DeHex_Testing("03622b72afcc3795841596c67ea74400ca3b029374d7d5640bda367c5d67b3fbeb2e986ea1c671b61cf45eec134dac0bae58ec6f63e790b1400b47c33038b0269c"),
                                        Secret:             DeHex_Testing("fe52b4412590e825ea2603fa88e145b2ee014b942a774b55fab4f081301f16f4"),
                                        Key:                DeHex_Testing("31e140c8856941315d4067239fdc4ebe077fbf45a6fc78a61e7a6c8b3bacb10a"),
                                        BaseNonce:          DeHex_Testing("75838a8010d2e4760254dd56"),
                                        ExporterSecret:     DeHex_Testing("600895965755db9c5027f25f039a6e3e506c35b3b7084ce33c4a48d59ee1f0e3,"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("75838a8010d2e4760254dd56"),
                                                Ct:    DeHex_Testing("9eadfa0f954835e7e920ffe56dec6b31a046271cf71fdda55db72926e1d8fae94cc6280fcfabd8db71eaa65c05"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("75838a8010d2e4760254dd57"),
                                                Ct:    DeHex_Testing("e357ad10d75240224d4095c9f6150a2ed2179c0f878e4f2db8ca95d365d174d059ff8c3eb38ea9a65cfc8eaeb8"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("75838a8010d2e4760254dd54"),
                                                Ct:    DeHex_Testing("2fa56d00f8dd479d67a2ec3308325cf3bbccaf102a64ffccdb006bd7dcb932685b9a7b49cdc094a85fec1da5ef"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("75838a8010d2e4760254dd52"),
                                                Ct:    DeHex_Testing("1fe9d6db14965003ed81a39abf240f9cd7c5a454bca0d69ef9a2de16d537364fbbf110b9ef11fa4a7a0172f0ce"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("75838a8010d2e4760254dda9"),
                                                Ct:    DeHex_Testing("eaf4041a5c9122b22d1f8d698eeffe45d64b4ae33d0ddca3a4cdf4a5f595acc95a1a9334d06cc4d000df6aaad6"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("75838a8010d2e4760254dc56"),
                                                Ct:    DeHex_Testing("fb857f4185ce5286c1a52431867537204963ea66a3eee8d2a74419fd8751faee066d08277ac7880473aa4143ba"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                ExporterContext: nil,
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("c52b4592cd33dd38b2a3613108ddda28dcf7f03d30f2a09703f758bfa8029c9a"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("2f03bebc577e5729e148554991787222b5c2a02b77e9b1ac380541f710e5a318"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("e01dd49e8bfc3d9216abc1be832f0418adf8b47a7b5a330a7436c31e33d765d7"),
                                        },
                                },
                        },
                },
        },
        {
                Name: "DHKEM(X25519, HKDF-SHA256), HKDF-SHA256, AES-128-GCM",
                Info: []*SuiteInfo_Testing{
                        {
                                Mode: Base,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Base,
                                        KEMID:              DHKEM_X25519_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_AES_128_GCM,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("7268600d403fce431561aef583ee1613527cff655c1343f29812e66706df3234"),
                                        PkEm:               DeHex_Testing("37fda3567bdbd628e88668c3c8d7e97d1d1253b6d4ea6d44c150f741f1bf4431"),
                                        SkEm:               DeHex_Testing("52c4a758a802cd8b936eceea314432798d5baf2d7e9235dc084ab1b9cfa2f736"),
                                        IkmR:               DeHex_Testing("6db9df30aa07dd42ee5e8181afdb977e538f5e1fec8a06223f33f7013e525037"),
                                        PkRm:               DeHex_Testing("3948cfe0ad1ddb695d780e59077195da6c56506b027329794ab02bca80815c4d"),
                                        SkRm:               DeHex_Testing("4612c550263fc8ad58375df3f557aac531d26850903e55a9f23f21d8534e8ac8"),
                                        Enc:                DeHex_Testing("37fda3567bdbd628e88668c3c8d7e97d1d1253b6d4ea6d44c150f741f1bf4431"),
                                        SharedSecret:       DeHex_Testing("fe0e18c9f024ce43799ae393c7e8fe8fce9d218875e8227b0187c04e7d2ea1fc"),
                                        KeyScheduleContext: DeHex_Testing("00725611c9d98c07c03f60095cd32d400d8347d45ed67097bbad50fc56da742d07cb6cffde367bb0565ba28bb02c90744a20f5ef37f30523526106f637abb05449"),
                                        Secret:             DeHex_Testing("12fff91991e93b48de37e7daddb52981084bd8aa64289c3788471d9a9712f397"),
                                        Key:                DeHex_Testing("4531685d41d65f03dc48f6b8302c05b0"),
                                        BaseNonce:          DeHex_Testing("56d890e5accaaf011cff4b7d"),
                                        ExporterSecret:     DeHex_Testing("45ff1c2e220db587171952c0592d5f5ebe103f1561a2614e38f2ffd47e99e3f8"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("56d890e5accaaf011cff4b7d"),
                                                Ct:    DeHex_Testing("f938558b5d72f1a23810b4be2ab4f84331acc02fc97babc53a52ae8218a355a96d8770ac83d07bea87e13c512a"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("56d890e5accaaf011cff4b7c"),
                                                Ct:    DeHex_Testing("af2d7e9ac9ae7e270f46ba1f975be53c09f8d875bdc8535458c2494e8a6eab251c03d0c22a56b8ca42c2063b84"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("56d890e5accaaf011cff4b7f"),
                                                Ct:    DeHex_Testing("498dfcabd92e8acedc281e85af1cb4e3e31c7dc394a1ca20e173cb72516491588d96a19ad4a683518973dcc180"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("56d890e5accaaf011cff4b79"),
                                                Ct:    DeHex_Testing("583bd32bc67a5994bb8ceaca813d369bca7b2a42408cddef5e22f880b631215a09fc0012bc69fccaa251c0246d"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("56d890e5accaaf011cff4b82"),
                                                Ct:    DeHex_Testing("7175db9717964058640a3a11fb9007941a5d1757fda1a6935c805c21af32505bf106deefec4a49ac38d71c9e0a"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("56d890e5accaaf011cff4a7d"),
                                                Ct:    DeHex_Testing("957f9800542b0b8891badb026d79cc54597cb2d225b54c00c5238c25d05c30e3fbeda97d2e0e1aba483a2df9f2"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("3853fe2b4035195a573ffc53856e77058e15d9ea064de3e59f4961d0095250ee"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("2e8f0b54673c7029649d4eb9d5e33bf1872cf76d623ff164ac185da9e88c21a5"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("e9e43065102c3836401bed8c3c3c75ae46be1639869391d62c61f1ec7af54931"),
                                        },
                                },
                        },
                        {
                                Mode: PSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               PSk,
                                        KEMID:              DHKEM_X25519_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_AES_128_GCM,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("78628c354e46f3e169bd231be7b2ff1c77aa302460a26dbfa15515684c00130b"),
                                        PkEm:               DeHex_Testing("0ad0950d9fb9588e59690b74f1237ecdf1d775cd60be2eca57af5a4b0471c91b"),
                                        SkEm:               DeHex_Testing("463426a9ffb42bb17dbe6044b9abd1d4e4d95f9041cef0e99d7824eef2b6f588"),
                                        IkmR:               DeHex_Testing("d4a09d09f575fef425905d2ab396c1449141463f698f8efdb7accfaff8995098"),
                                        PkRm:               DeHex_Testing("9fed7e8c17387560e92cc6462a68049657246a09bfa8ade7aefe589672016366"),
                                        SkRm:               DeHex_Testing("c5eb01eb457fe6c6f57577c5413b931550a162c71a03ac8d196babbd4e5ce0fd"),
                                        Enc:                DeHex_Testing("0ad0950d9fb9588e59690b74f1237ecdf1d775cd60be2eca57af5a4b0471c91b"),
                                        SharedSecret:       DeHex_Testing("727699f009ffe3c076315019c69648366b69171439bd7dd0807743bde76986cd"),
                                        KeyScheduleContext: DeHex_Testing("01e78d5cf6190d275863411ff5edd0dece5d39fa48e04eec1ed9b71be34729d18ccb6cffde367bb0565ba28bb02c90744a20f5ef37f30523526106f637abb05449"),
                                        Secret:             DeHex_Testing("3728ab0b024b383b0381e432b47cced1496d2516957a76e2a9f5c8cb947afca4"),
                                        Key:                DeHex_Testing("15026dba546e3ae05836fc7de5a7bb26"),
                                        BaseNonce:          DeHex_Testing("9518635eba129d5ce0914555"),
                                        ExporterSecret:     DeHex_Testing("3d76025dbbedc49448ec3f9080a1abab6b06e91c0b11ad23c912f043a0ee7655"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("9518635eba129d5ce0914555"),
                                                Ct:    DeHex_Testing("e52c6fed7f758d0cf7145689f21bc1be6ec9ea097fef4e959440012f4feb73fb611b946199e681f4cfc34db8ea"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("9518635eba129d5ce0914554"),
                                                Ct:    DeHex_Testing("49f3b19b28a9ea9f43e8c71204c00d4a490ee7f61387b6719db765e948123b45b61633ef059ba22cd62437c8ba"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("9518635eba129d5ce0914557"),
                                                Ct:    DeHex_Testing("257ca6a08473dc851fde45afd598cc83e326ddd0abe1ef23baa3baa4dd8cde99fce2c1e8ce687b0b47ead1adc9"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("9518635eba129d5ce0914551"),
                                                Ct:    DeHex_Testing("a71d73a2cd8128fcccbd328b9684d70096e073b59b40b55e6419c9c68ae21069c847e2a70f5d8fb821ce3dfb1c"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("9518635eba129d5ce09145aa"),
                                                Ct:    DeHex_Testing("55f84b030b7f7197f7d7d552365b6b932df5ec1abacd30241cb4bc4ccea27bd2b518766adfa0fb1b71170e9392"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("9518635eba129d5ce0914455"),
                                                Ct:    DeHex_Testing("c5bf246d4a790a12dcc9eed5eae525081e6fb541d5849e9ce8abd92a3bc1551776bea16b4a518f23e237c14b59"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("dff17af354c8b41673567db6259fd6029967b4e1aad13023c2ae5df8f4f43bf6"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("6a847261d8207fe596befb52928463881ab493da345b10e1dcc645e3b94e2d95"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("8aff52b45a1be3a734bc7a41e20b4e055ad4c4d22104b0c20285a7c4302401cd"),
                                        },
                                },
                        },
                        {
                                Mode: Auth,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Auth,
                                        KEMID:              DHKEM_X25519_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_AES_128_GCM,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("6e6d8f200ea2fb20c30b003a8b4f433d2f4ed4c2658d5bc8ce2fef718059c9f7"),
                                        PkEm:               DeHex_Testing("23fb952571a14a25e3d678140cd0e5eb47a0961bb18afcf85896e5453c312e76"),
                                        SkEm:               DeHex_Testing("ff4442ef24fbc3c1ff86375b0be1e77e88a0de1e79b30896d73411c5ff4c3518"),
                                        IkmR:               DeHex_Testing("f1d4a30a4cef8d6d4e3b016e6fd3799ea057db4f345472ed302a67ce1c20cdec"),
                                        PkRm:               DeHex_Testing("1632d5c2f71c2b38d0a8fcc359355200caa8b1ffdf28618080466c909cb69b2e"),
                                        SkRm:               DeHex_Testing("fdea67cf831f1ca98d8e27b1f6abeb5b7745e9d35348b80fa407ff6958f9137e"),
                                        Enc:                DeHex_Testing("23fb952571a14a25e3d678140cd0e5eb47a0961bb18afcf85896e5453c312e76"),
                                        SharedSecret:       DeHex_Testing("2d6db4cf719dc7293fcbf3fa64690708e44e2bebc81f84608677958c0d4448a7"),
                                        KeyScheduleContext: DeHex_Testing("02725611c9d98c07c03f60095cd32d400d8347d45ed67097bbad50fc56da742d07cb6cffde367bb0565ba28bb02c90744a20f5ef37f30523526106f637abb05449"),
                                        Secret:             DeHex_Testing("56c62333d9d9f7767f5b083fdfce0aa7e57e301b74029bb0cffa7331385f1dda"),
                                        Key:                DeHex_Testing("b062cb2c4dd4bca0ad7c7a12bbc341e6"),
                                        BaseNonce:          DeHex_Testing("a1bc314c1942ade7051ffed0"),
                                        ExporterSecret:     DeHex_Testing("ee1a093e6e1c393c162ea98fdf20560c75909653550540a2700511b65c88c6f1"),
                                        IkmS:               DeHex_Testing("94b020ce91d73fca4649006c7e7329a67b40c55e9e93cc907d282bbbff386f58"),
                                        PkSm:               DeHex_Testing("8b0c70873dc5aecb7f9ee4e62406a397b350e57012be45cf53b7105ae731790b"),
                                        SkSm:               DeHex_Testing("dc4a146313cce60a278a5323d321f051c5707e9c45ba21a3479fecdf76fc69dd"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("a1bc314c1942ade7051ffed0"),
                                                Ct:    DeHex_Testing("5fd92cc9d46dbf8943e72a07e42f363ed5f721212cd90bcfd072bfd9f44e06b80fd17824947496e21b680c141b"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("a1bc314c1942ade7051ffed1"),
                                                Ct:    DeHex_Testing("d3736bb256c19bfa93d79e8f80b7971262cb7c887e35c26370cfed62254369a1b52e3d505b79dd699f002bc8ed"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("a1bc314c1942ade7051ffed2"),
                                                Ct:    DeHex_Testing("122175cfd5678e04894e4ff8789e85dd381df48dcaf970d52057df2c9acc3b121313a2bfeaa986050f82d93645"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("a1bc314c1942ade7051ffed4"),
                                                Ct:    DeHex_Testing("dae12318660cf963c7bcbef0f39d64de3bf178cf9e585e756654043cc5059873bc8af190b72afc43d1e0135ada"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("a1bc314c1942ade7051ffe2f"),
                                                Ct:    DeHex_Testing("55d53d85fe4d9e1e97903101eab0b4865ef20cef28765a47f840ff99625b7d69dee927df1defa66a036fc58ff2"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("a1bc314c1942ade7051fffd0"),
                                                Ct:    DeHex_Testing("42fa248a0e67ccca688f2b1d13ba4ba84755acf764bd797c8f7ba3b9b1dc3330326f8d172fef6003c79ec72319"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("28c70088017d70c896a8420f04702c5a321d9cbf0279fba899b59e51bac72c85"),
                                        },
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("28c70088017d70c896a8420f04702c5a321d9cbf0279fba899b59e51bac72c85"),
                                        },
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("28c70088017d70c896a8420f04702c5a321d9cbf0279fba899b59e51bac72c85"),
                                        },
                                },
                        },
                        {
                                Mode: AuthPSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               AuthPSk,
                                        KEMID:              DHKEM_X25519_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_AES_128_GCM,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("4303619085a20ebcf18edd22782952b8a7161e1dbae6e46e143a52a96127cf84"),
                                        PkEm:               DeHex_Testing("820818d3c23993492cc5623ab437a48a0a7ca3e9639c140fe1e33811eb844b7c"),
                                        SkEm:               DeHex_Testing("14de82a5897b613616a00c39b87429df35bc2b426bcfd73febcb45e903490768"),
                                        IkmR:               DeHex_Testing("4b16221f3b269a88e207270b5e1de28cb01f847841b344b8314d6a622fe5ee90"),
                                        PkRm:               DeHex_Testing("1d11a3cd247ae48e901939659bd4d79b6b959e1f3e7d66663fbc9412dd4e0976"),
                                        SkRm:               DeHex_Testing("cb29a95649dc5656c2d054c1aa0d3df0493155e9d5da6d7e344ed8b6a64a9423"),
                                        Enc:                DeHex_Testing("820818d3c23993492cc5623ab437a48a0a7ca3e9639c140fe1e33811eb844b7c"),
                                        SharedSecret:       DeHex_Testing("f9d0e870aba28d04709b2680cb8185466c6a6ff1d6e9d1091d5bf5e10ce3a577"),
                                        KeyScheduleContext: DeHex_Testing("03e78d5cf6190d275863411ff5edd0dece5d39fa48e04eec1ed9b71be34729d18ccb6cffde367bb0565ba28bb02c90744a20f5ef37f30523526106f637abb05449"),
                                        Secret:             DeHex_Testing("5f96c55e4108c6691829aaabaa7d539c0b41d7c72aae94ae289752f056b6cec4"),
                                        Key:                DeHex_Testing("1364ead92c47aa7becfa95203037b19a"),
                                        BaseNonce:          DeHex_Testing("99d8b5c54669807e9fc70df1"),
                                        ExporterSecret:     DeHex_Testing("f048d55eacbf60f9c6154bd4021774d1075ebf963c6adc71fa846f183ab2dde6"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                        IkmS:               DeHex_Testing("62f77dcf5df0dd7eac54eac9f654f426d4161ec850cc65c54f8b65d2e0b4e345"),
                                        PkSm:               DeHex_Testing("2bfb2eb18fcad1af0e4f99142a1c474ae74e21b9425fc5c589382c69b50cc57e"),
                                        SkSm:               DeHex_Testing("fc1c87d2f3832adb178b431fce2ac77c7ca2fd680f3406c77b5ecdf818b119f4"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("99d8b5c54669807e9fc70df1"),
                                                Ct:    DeHex_Testing("a84c64df1e11d8fd11450039d4fe64ff0c8a99fca0bd72c2d4c3e0400bc14a40f27e45e141a24001697737533e"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("99d8b5c54669807e9fc70df0"),
                                                Ct:    DeHex_Testing("4d19303b848f424fc3c3beca249b2c6de0a34083b8e909b6aa4c3688505c05ffe0c8f57a0a4c5ab9da127435d9"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("99d8b5c54669807e9fc70df3"),
                                                Ct:    DeHex_Testing("0c085a365fbfa63409943b00a3127abce6e45991bc653f182a80120868fc507e9e4d5e37bcc384fc8f14153b24"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("99d8b5c54669807e9fc70df5"),
                                                Ct:    DeHex_Testing("000a3cd3a3523bf7d9796830b1cd987e841a8bae6561ebb6791a3f0e34e89a4fb539faeee3428b8bbc082d2c1a"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("99d8b5c54669807e9fc70d0e"),
                                                Ct:    DeHex_Testing("576d39dd2d4cc77d1a14a51d5c5f9d5e77586c3d8d2ab33bdec6379e28ce5c502f0b1cbd09047cf9eb9269bb52"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("99d8b5c54669807e9fc70cf1"),
                                                Ct:    DeHex_Testing("13239bab72e25e9fd5bb09695d23c90a24595158b99127505c8a9ff9f127e0d657f71af59d67d4f4971da028f9"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("08f7e20644bb9b8af54ad66d2067457c5f9fcb2a23d9f6cb4445c0797b330067"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("52e51ff7d436557ced5265ff8b94ce69cf7583f49cdb374e6aad801fc063b010"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("a30c20370c026bbea4dca51cb63761695132d342bae33a6a11527d3e7679436d"),
                                        },
                                },
                        },
                },
        },
        {
                Name: "DHKEM(X25519, HKDF-SHA256), HKDF-SHA256, ChaCha20Poly1305",
                Info: []*SuiteInfo_Testing{
                        {
                                Mode: Base,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Base,
                                        KEMID:              DHKEM_X25519_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_CHACHA_20_POLY_1305,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("909a9b35d3dc4713a5e72a4da274b55d3d3821a37e5d099e74a647db583a904b"),
                                        PkEm:               DeHex_Testing("1afa08d3dec047a643885163f1180476fa7ddb54c6a8029ea33f95796bf2ac4a"),
                                        SkEm:               DeHex_Testing("f4ec9b33b792c372c1d2c2063507b684ef925b8c75a42dbcbf57d63ccd381600"),
                                        IkmR:               DeHex_Testing("1ac01f181fdf9f352797655161c58b75c656a6cc2716dcb66372da835542e1df"),
                                        PkRm:               DeHex_Testing("4310ee97d88cc1f088a5576c77ab0cf5c3ac797f3d95139c6c84b5429c59662a"),
                                        SkRm:               DeHex_Testing("8057991eef8f1f1af18f4a9491d16a1ce333f695d4db8e38da75975c4478e0fb"),
                                        Enc:                DeHex_Testing("1afa08d3dec047a643885163f1180476fa7ddb54c6a8029ea33f95796bf2ac4a"),
                                        SharedSecret:       DeHex_Testing("0bbe78490412b4bbea4812666f7916932b828bba79942424abb65244930d69a7"),
                                        KeyScheduleContext: DeHex_Testing("00431df6cd95e11ff49d7013563baf7f11588c75a6611ee2a4404a49306ae4cfc5b69c5718a60cc5876c358d3f7fc31ddb598503f67be58ea1e798c0bb19eb9796"),
                                        Secret:             DeHex_Testing("5b9cd775e64b437a2335cf499361b2e0d5e444d5cb41a8a53336d8fe402282c6"),
                                        Key:                DeHex_Testing("ad2744de8e17f4ebba575b3f5f5a8fa1f69c2a07f6e7500bc60ca6e3e3ec1c91"),
                                        BaseNonce:          DeHex_Testing("5c4d98150661b848853b547f"),
                                        ExporterSecret:     DeHex_Testing("a3b010d4994890e2c6968a36f64470d3c824c8f5029942feb11e7a74b2921922"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("5c4d98150661b848853b547f"),
                                                Ct:    DeHex_Testing("1c5250d8034ec2b784ba2cfd69dbdb8af406cfe3ff938e131f0def8c8b60b4db21993c62ce81883d2dd1b51a28"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("5c4d98150661b848853b547e"),
                                                Ct:    DeHex_Testing("6b53c051e4199c518de79594e1c4ab18b96f081549d45ce015be002090bb119e85285337cc95ba5f59992dc98c"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("5c4d98150661b848853b547d"),
                                                Ct:    DeHex_Testing("71146bd6795ccc9c49ce25dda112a48f202ad220559502cef1f34271e0cb4b02b4f10ecac6f48c32f878fae86b"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("5c4d98150661b848853b547b"),
                                                Ct:    DeHex_Testing("63357a2aa291f5a4e5f27db6baa2af8cf77427c7c1a909e0b37214dd47db122bb153495ff0b02e9e54a50dbe16"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("5c4d98150661b848853b5480"),
                                                Ct:    DeHex_Testing("18ab939d63ddec9f6ac2b60d61d36a7375d2070c9b683861110757062c52b8880a5f6b3936da9cd6c23ef2a95c"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("5c4d98150661b848853b557f"),
                                                Ct:    DeHex_Testing("7a4a13e9ef23978e2c520fd4d2e757514ae160cd0cd05e556ef692370ca53076214c0c40d4c728d6ed9e727a5b"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("4bbd6243b8bb54cec311fac9df81841b6fd61f56538a775e7c80a9f40160606e"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("8c1df14732580e5501b00f82b10a1647b40713191b7c1240ac80e2b68808ba69"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("5acb09211139c43b3090489a9da433e8a30ee7188ba8b0a9a1ccf0c229283e53"),
                                        },
                                },
                        },
                        {
                                Mode: PSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               PSk,
                                        KEMID:              DHKEM_X25519_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_CHACHA_20_POLY_1305,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("35706a0b09fb26fb45c39c2f5079c709c7cf98e43afa973f14d88ece7e29c2e3"),
                                        PkEm:               DeHex_Testing("2261299c3f40a9afc133b969a97f05e95be2c514e54f3de26cbe5644ac735b04"),
                                        SkEm:               DeHex_Testing("0c35fdf49df7aa01cd330049332c40411ebba36e0c718ebc3edf5845795f6321"),
                                        IkmR:               DeHex_Testing("26b923eade72941c8a85b09986cdfa3f1296852261adedc52d58d2930269812b"),
                                        PkRm:               DeHex_Testing("13640af826b722fc04feaa4de2f28fbd5ecc03623b317834e7ff4120dbe73062"),
                                        SkRm:               DeHex_Testing("77d114e0212be51cb1d76fa99dd41cfd4d0166b08caa09074430a6c59ef17879"),
                                        Enc:                DeHex_Testing("2261299c3f40a9afc133b969a97f05e95be2c514e54f3de26cbe5644ac735b04"),
                                        SharedSecret:       DeHex_Testing("4be079c5e77779d0215b3f689595d59e3e9b0455d55662d1f3666ec606e50ea7"),
                                        KeyScheduleContext: DeHex_Testing("016870c4c76ca38ae43efbec0f2377d109499d7ce73f4a9e1ec37f21d3d063b97cb69c5718a60cc5876c358d3f7fc31ddb598503f67be58ea1e798c0bb19eb9796"),
                                        Secret:             DeHex_Testing("16974354c497c9bd24c000ceed693779b604f1944975b18c442d373663f4a8cc"),
                                        Key:                DeHex_Testing("600d2fdb0313a7e5c86a9ce9221cd95bed069862421744cfb4ab9d7203a9c019"),
                                        BaseNonce:          DeHex_Testing("112e0465562045b7368653e7"),
                                        ExporterSecret:     DeHex_Testing("73b506dc8b6b4269027f80b0362def5cbb57ee50eed0c2873dac9181f453c5ac"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("112e0465562045b7368653e7"),
                                                Ct:    DeHex_Testing("4a177f9c0d6f15cfdf533fb65bf84aecdc6ab16b8b85b4cf65a370e07fc1d78d28fb073214525276f4a89608ff"),
                                        }, {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("112e0465562045b7368653e6"),
                                                Ct:    DeHex_Testing("5c3cabae2f0b3e124d8d864c116fd8f20f3f56fda988c3573b40b09997fd6c769e77c8eda6cda4f947f5b704a8"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("112e0465562045b7368653e5"),
                                                Ct:    DeHex_Testing("14958900b44bdae9cbe5a528bf933c5c990dbb8e282e6e495adf8205d19da9eb270e3a6f1e0613ab7e757962a4"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("112e0465562045b7368653e3"),
                                                Ct:    DeHex_Testing("c2a7bc09ddb853cf2effb6e8d058e346f7fe0fb3476528c80db6b698415c5f8c50b68a9a355609e96d2117f8d3"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("112e0465562045b736865318"),
                                                Ct:    DeHex_Testing("2414d0788e4bc39a59a26d7bd5d78e111c317d44c37bd5a4c2a1235f2ddc2085c487d406490e75210c958724a7"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("112e0465562045b7368652e7"),
                                                Ct:    DeHex_Testing("c567ae1c3f0f75abe1dd9e4532b422600ed4a6e5b9484dafb1e43ab9f5fd662b28c00e2e81d3cde955dae7e218"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("813c1bfc516c99076ae0f466671f0ba5ff244a41699f7b2417e4c59d46d39f40"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("2745cf3d5bb65c333658732954ee7af49eb895ce77f8022873a62a13c94cb4e1"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("ad40e3ae14f21c99bfdebc20ae14ab86f4ca2dc9a4799d200f43a25f99fa78ae"),
                                        },
                                },
                        },
                        {
                                Mode: Auth,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               Auth,
                                        KEMID:              DHKEM_X25519_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_CHACHA_20_POLY_1305,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("938d3daa5a8904540bc24f48ae90eed3f4f7f11839560597b55e7c9598c996c0"),
                                        PkEm:               DeHex_Testing("f7674cc8cd7baa5872d1f33dbaffe3314239f6197ddf5ded1746760bfc847e0e"),
                                        SkEm:               DeHex_Testing("c94619e1af28971c8fa7957192b7e62a71ca2dcdde0a7cc4a8a9e741d600ab13"),
                                        IkmR:               DeHex_Testing("64835d5ee64aa7aad57c6f2e4f758f7696617f8829e70bc9ac7a5ef95d1c756c"),
                                        PkRm:               DeHex_Testing("1a478716d63cb2e16786ee93004486dc151e988b34b475043d3e0175bdb01c44"),
                                        SkRm:               DeHex_Testing("3ca22a6d1cda1bb9480949ec5329d3bf0b080ca4c45879c95eddb55c70b80b82"),
                                        Enc:                DeHex_Testing("f7674cc8cd7baa5872d1f33dbaffe3314239f6197ddf5ded1746760bfc847e0e"),
                                        SharedSecret:       DeHex_Testing("d2d67828c8bc9fa661cf15a31b3ebf1febe0cafef7abfaaca580aaf6d471e3eb"),
                                        KeyScheduleContext: DeHex_Testing("02431df6cd95e11ff49d7013563baf7f11588c75a6611ee2a4404a49306ae4cfc5b69c5718a60cc5876c358d3f7fc31ddb598503f67be58ea1e798c0bb19eb9796"),
                                        Secret:             DeHex_Testing("3022dfc0a81d6e09a2e6daeeb605bb1ebb9ac49535540d9a4c6560064a6c6da8"),
                                        Key:                DeHex_Testing("b071fd1136680600eb447a845a967d35e9db20749cdf9ce098bcc4deef4b1356"),
                                        BaseNonce:          DeHex_Testing("d20577dff16d7cea2c4bf780"),
                                        ExporterSecret:     DeHex_Testing("be2d93b82071318cdb88510037cf504344151f2f9b9da8ab48974d40a2251dd7"),
                                        IkmS:               DeHex_Testing("9d8f94537d5a3ddef71234c0baedfad4ca6861634d0b94c3007fed557ad17df6"),
                                        PkSm:               DeHex_Testing("f0f4f9e96c54aeed3f323de8534fffd7e0577e4ce269896716bcb95643c8712b"),
                                        SkSm:               DeHex_Testing("2def0cb58ffcf83d1062dd085c8aceca7f4c0c3fd05912d847b61f3e54121f05"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("d20577dff16d7cea2c4bf780"),
                                                Ct:    DeHex_Testing("ab1a13c9d4f01a87ec3440dbd756e2677bd2ecf9df0ce7ed73869b98e00c09be111cb9fdf077347aeb88e61bdf"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("d20577dff16d7cea2c4bf781"),
                                                Ct:    DeHex_Testing("3265c7807ffff7fdace21659a2c6ccffee52a26d270c76468ed74202a65478bfaedfff9c2b7634e24f10b71016"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("d20577dff16d7cea2c4bf782"),
                                                Ct:    DeHex_Testing("3aadee86ad2a05081ea860033a9d09dbccb4acac2ded0891da40f51d4df19925f7a767b076a5cbc9355c8fd35e"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("d20577dff16d7cea2c4bf784"),
                                                Ct:    DeHex_Testing("502ecccd5c2be3506a081809cc58b43b94f77cbe37b8b31712d9e21c9e61aa6946a8e922f54eae630f88eb8033"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("d20577dff16d7cea2c4bf77f"),
                                                Ct:    DeHex_Testing("652e597ba20f3d9241cda61f33937298b1169e6adf72974bbe454297502eb4be132e1c5064702fc165c2ddbde8"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("d20577dff16d7cea2c4bf680"),
                                                Ct:    DeHex_Testing("3be14e8b3bbd1028cf2b7d0a691dbbeff71321e7dec92d3c2cfb30a0994ab246af76168480285a60037b4ba13a"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("070cffafd89b67b7f0eeb800235303a223e6ff9d1e774dce8eac585c8688c872"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("2852e728568d40ddb0edde284d36a4359c56558bb2fb8837cd3d92e46a3a14a8"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("1df39dc5dd60edcbf5f9ae804e15ada66e885b28ed7929116f768369a3f950ee"),
                                        },
                                },
                        },
                        {
                                Mode: AuthPSk,
                                Setup: &amp;SetupInfo_Testing{
                                        Mode:               AuthPSk,
                                        KEMID:              DHKEM_X25519_HKDF_SHA256,
                                        KDFID:              KDF_HKDF_SHA256,
                                        AEADID:             AEAD_CHACHA_20_POLY_1305,
                                        Info:               DeHex_Testing("4f6465206f6e2061204772656369616e2055726e"),
                                        IkmE:               DeHex_Testing("49d6eac8c6c558c953a0a252929a818745bb08cd3d29e15f9f5db5eb2e7d4b84"),
                                        PkEm:               DeHex_Testing("656a2e00dc9990fd189e6e473459392df556e9a2758754a09db3f51179a3fc02"),
                                        SkEm:               DeHex_Testing("5e6dd73e82b856339572b7245d3cbb073a7561c0bee52873490e305cbb710410"),
                                        IkmR:               DeHex_Testing("f3304ddcf15848488271f12b75ecaf72301faabf6ad283654a14c398832eb184"),
                                        PkRm:               DeHex_Testing("a5099431c35c491ec62ca91df1525d6349cb8aa170c51f9581f8627be6334851"),
                                        SkRm:               DeHex_Testing("7b36a42822e75bf3362dfabbe474b3016236408becb83b859a6909e22803cb0c"),
                                        Enc:                DeHex_Testing("656a2e00dc9990fd189e6e473459392df556e9a2758754a09db3f51179a3fc02"),
                                        SharedSecret:       DeHex_Testing("86a6c0ed17714f11d2951747e660857a5fd7616c933ef03207808b7a7123fe67"),
                                        KeyScheduleContext: DeHex_Testing("036870c4c76ca38ae43efbec0f2377d109499d7ce73f4a9e1ec37f21d3d063b97cb69c5718a60cc5876c358d3f7fc31ddb598503f67be58ea1e798c0bb19eb9796"),
                                        Secret:             DeHex_Testing("22670daee17530c9564001d0a7e740e80d0bcc7ae15349f472fcc9e057cbc259"),
                                        Key:                DeHex_Testing("49c7e6d7d2d257aded2a746fe6a9bf12d4de8007c4862b1fdffe8c35fb65054c"),
                                        BaseNonce:          DeHex_Testing("abac79931e8c1bcb8a23960a"),
                                        ExporterSecret:     DeHex_Testing("7c6cc1bb98993cd93e2599322247a58fd41fdecd3db895fb4c5fd8d6bbe606b5"),
                                        PSk:                DeHex_Testing("0247fd33b913760fa1fa51e1892d9f307fbe65eb171e8132c2af18555a738b82"),
                                        PSkID:              DeHex_Testing("456e6e796e20447572696e206172616e204d6f726961"),
                                        IkmS:               DeHex_Testing("20ade1d5203de1aadfb261c4700b6432e260d0d317be6ebbb8d7fffb1f86ad9d"),
                                        PkSm:               DeHex_Testing("3ac5bd4dd66ff9f2740bef0d6ccb66daa77bff7849d7895182b07fb74d087c45"),
                                        SkSm:               DeHex_Testing("90761c5b0a7ef0985ed66687ad708b921d9803d51637c8d1cb72d03ed0f64418"),
                                },
                                Encryptions: []*EncryptionInfo_Testing{
                                        {
                                                Seq:   0,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d30"),
                                                Nonce: DeHex_Testing("abac79931e8c1bcb8a23960a"),
                                                Ct:    DeHex_Testing("9aa52e29274fc6172e38a4461361d2342585d3aeec67fb3b721ecd63f059577c7fe886be0ede01456ebc67d597"),
                                        },
                                        {
                                                Seq:   1,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d31"),
                                                Nonce: DeHex_Testing("abac79931e8c1bcb8a23960b"),
                                                Ct:    DeHex_Testing("59460bacdbe7a920ef2806a74937d5a691d6d5062d7daafcad7db7e4d8c649adffe575c1889c5c2e3a49af8e3e"),
                                        },
                                        {
                                                Seq:   2,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d32"),
                                                Nonce: DeHex_Testing("abac79931e8c1bcb8a239608"),
                                                Ct:    DeHex_Testing("5688ff6a03ba26ae936044a5c800f286fb5d1eccdd2a0f268f6ff9773b51169318d1a1466bb36263415071db00"),
                                        },
                                        {
                                                Seq:   4,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d34"),
                                                Nonce: DeHex_Testing("abac79931e8c1bcb8a23960e"),
                                                Ct:    DeHex_Testing("d936b7a01f5c7dc4c3dc04e322cc694684ee18dd71719196874e5235aed3cfb06cadcd3bc7da0877488d7c551d"),
                                        },
                                        {
                                                Seq:   255,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323535"),
                                                Nonce: DeHex_Testing("abac79931e8c1bcb8a2396f5"),
                                                Ct:    DeHex_Testing("4d4c462f7b9b637eaf1f4e15e325b7bc629c0af6e3073422c86064cc3c98cff87300f054fd56dd57dc34358beb"),
                                        },
                                        {
                                                Seq:   256,
                                                Pt:    DeHex_Testing("4265617574792069732074727574682c20747275746820626561757479"),
                                                Aad:   DeHex_Testing("436f756e742d323536"),
                                                Nonce: DeHex_Testing("abac79931e8c1bcb8a23970a"),
                                                Ct:    DeHex_Testing("9b7f84224922d2a9edd7b2c2057f3bcf3a547f17570575e626202e593bfdd99e9878a1af9e41ded58c7fb77d2f"),
                                        },
                                },
                                Exports: []*ExportInfo_Testing{
                                        {
                                                L:             32,
                                                ExportedValue: DeHex_Testing("c23ebd4e7a0ad06a5dddf779f65004ce9481069ce0f0e6dd51a04539ddcbd5cd"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("00"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("ed7ff5ca40a3d84561067ebc8e01702bc36cf1eb99d42a92004642b9dfaadd37"),
                                        },
                                        {
                                                ExporterContext: DeHex_Testing("54657374436f6e74657874"),
                                                L:               32,
                                                ExportedValue:   DeHex_Testing("d3bae066aa8da27d527d85c040f7dd6ccb60221c902ee36a82f70bcd62a60ee4"),
                                        },
                                },
                        },
                },
        },
}
</pre>
		
		<pre class="file" id="file207" style="display: none">package hpke

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/encryption"
        "github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal"
)

// WithSenderPrivateKey returns an option that enables authenticated encapsulation
// by providing the sender's private key. When set, the KEM uses AuthEncap instead
// of Encap, allowing the receiver to verify the sender's identity.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1
func WithSenderPrivateKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](sk *PrivateKey[S]) encryption.KEMOption[*KEM[P, B, S], *PublicKey[P, B, S], *Capsule[P, B, S]] <span class="cov0" title="0">{
        return func(kem *KEM[P, B, S]) error </span><span class="cov0" title="0">{
                kem.senderPrivateKey = sk
                return nil
        }</span>
}

// KEM provides key encapsulation mechanism operations for HPKE.
// It wraps the underlying DHKEM (Diffie-Hellman based KEM) and supports both
// standard and authenticated encapsulation.
//
// The KEM generates an ephemeral key pair and combines it with the receiver's
// public key to produce a shared secret and a capsule (the ephemeral public key).
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4
type KEM[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        v                *internal.DHKEMScheme[P, B, S]
        senderPrivateKey *PrivateKey[S]
}

// Encapsulate generates a shared secret and encapsulates it for the given receiver.
// Returns:
//   - A symmetric key derived from the shared secret
//   - A capsule (ephemeral public key) to send to the receiver
//
// If WithSenderPrivateKey was configured, this performs authenticated encapsulation
// (AuthEncap), otherwise standard encapsulation (Encap).
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1
func (k *KEM[P, B, S]) Encapsulate(receiver *PublicKey[P, B, S], prng io.Reader) (*encryption.SymmetricKey, *Capsule[P, B, S], error) <span class="cov0" title="0">{
        var kv []byte
        var ephemeralPublicKey *PublicKey[P, B, S]
        var err error
        if k.IsAuthenticated() </span><span class="cov0" title="0">{
                kv, ephemeralPublicKey, err = k.v.AuthEncap(receiver, k.senderPrivateKey, prng)
        }</span> else<span class="cov0" title="0"> {
                kv, ephemeralPublicKey, err = k.v.Encap(receiver, prng)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">out, err := encryption.NewSymmetricKey(kv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return out, ephemeralPublicKey, nil</span>
}

// IsAuthenticated returns true if the sender's private key has been configured,
// indicating that authenticated encapsulation will be used.
func (k *KEM[P, B, S]) IsAuthenticated() bool <span class="cov0" title="0">{
        return k.senderPrivateKey != nil
}</span>

// WithSenderPublicKey returns an option that enables authenticated decapsulation
// by providing the sender's public key. When set, the DEM uses AuthDecap instead
// of Decap, verifying that the capsule was created by the sender.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1
func WithSenderPublicKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](pk *PublicKey[P, B, S]) encryption.DEMOption[*DEM[P, B, S], *Capsule[P, B, S]] <span class="cov0" title="0">{
        return func(dem *DEM[P, B, S]) error </span><span class="cov0" title="0">{
                dem.senderPublicKey = pk
                return nil
        }</span>
}

// DEM provides data encapsulation mechanism (decapsulation) operations for HPKE.
// It uses the receiver's private key to recover the shared secret from a capsule.
//
// The DEM supports both standard and authenticated decapsulation. Authenticated
// decapsulation verifies that the shared secret was produced using the sender's
// private key.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4
type DEM[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        v                  *internal.DHKEMScheme[P, B, S]
        receiverPrivateKey *PrivateKey[S]
        senderPublicKey    *PublicKey[P, B, S]
}

// Decapsulate recovers the shared secret from a capsule using the receiver's private key.
// Returns a symmetric key derived from the shared secret.
//
// If WithSenderPublicKey was configured, this performs authenticated decapsulation
// (AuthDecap), otherwise standard decapsulation (Decap).
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1
func (d *DEM[P, B, S]) Decapsulate(capsule *Capsule[P, B, S]) (*encryption.SymmetricKey, error) <span class="cov0" title="0">{
        var kv []byte
        var err error
        if d.IsAuthenticated() </span><span class="cov0" title="0">{
                kv, err = d.v.AuthDecap(d.receiverPrivateKey, d.senderPublicKey, capsule)
        }</span> else<span class="cov0" title="0"> {
                kv, err = d.v.Decap(d.receiverPrivateKey, capsule)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">out, err := encryption.NewSymmetricKey(kv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// IsAuthenticated returns true if the sender's public key has been configured,
// indicating that authenticated decapsulation will be used.
func (d *DEM[P, B, S]) IsAuthenticated() bool <span class="cov0" title="0">{
        return d.senderPublicKey != nil
}</span>
</pre>
		
		<pre class="file" id="file208" style="display: none">package hpke

import (
        "io"
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/encryption"
        "github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal"
)

// KeyGeneratorOption is a functional option for configuring the HPKE key generator.
// Currently no options are defined as HPKE key generation is fully determined by the
// cipher suite's KEM algorithm.
type KeyGeneratorOption[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] = encryption.KeyGeneratorOption[*KeyGenerator[P, B, S], *PrivateKey[S], *PublicKey[P, B, S]]

// KeyGenerator generates HPKE key pairs for the configured cipher suite.
// Key generation follows the DeriveKeyPair algorithm defined in RFC 9180 Section 4,
// which uses the KEM's KDF to derive keys from random input keying material (IKM).
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4
type KeyGenerator[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        dhkem *internal.DHKEMScheme[P, B, S]
}

// Generate creates a new HPKE key pair using randomness from prng.
// The private key is derived using the KEM's DeriveKeyPair algorithm with random IKM.
// The public key is the corresponding curve point pk = sk * G.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4
func (kg *KeyGenerator[P, B, S]) Generate(prng io.Reader) (sk *PrivateKey[S], pk *PublicKey[P, B, S], err error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithStackFrame().WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">sk, pk, err = kg.dhkem.GenerateKeyPair(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return sk, pk, nil</span>
}

// GenerateWithSeed creates a new HPKE key pair deterministically from seed material.
// The seed (IKM) SHOULD have at least Nsk bytes of entropy for the KEM algorithm.
// This implements the DeriveKeyPair algorithm from RFC 9180 Section 4.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#name-derivekeypair
func (kg *KeyGenerator[P, B, S]) GenerateWithSeed(ikm []byte) (sk *PrivateKey[S], pk *PublicKey[P, B, S], err error) <span class="cov8" title="1">{
        if ikm == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithStackFrame().WithMessage("ikm is nil")
        }</span>
        <span class="cov8" title="1">sk, pk, err = kg.dhkem.DeriveKeyPair(ikm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return sk, pk, nil</span>
}

// EncryptingWhileCachingRecentContextualInfo returns an option that enables caching
// of the sender context after encryption. This allows the Export method to be called
// to derive additional secrets from the encryption context.
//
// Note: When caching is enabled, the encrypter holds a mutex during Seal operations
// for thread safety.
func EncryptingWhileCachingRecentContextualInfo[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]]() encryption.EncrypterOption[*Encrypter[P, B, S], *PublicKey[P, B, S], Message, Ciphertext, *Capsule[P, B, S]] <span class="cov0" title="0">{
        return func(e *Encrypter[P, B, S]) error </span><span class="cov0" title="0">{
                e.shouldCacheCtx = true
                return nil
        }</span>
}

// EncryptingWithApplicationInfo returns an option that sets the application-specific
// info parameter for the HPKE key schedule. The info parameter is bound to the derived
// keys and must match between sender and receiver for successful decryption.
//
// Per RFC 9180 Section 5.1, info is application-supplied information that should be
// independently agreed upon by both parties.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1
func EncryptingWithApplicationInfo[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](info []byte) encryption.EncrypterOption[*Encrypter[P, B, S], *PublicKey[P, B, S], Message, Ciphertext, *Capsule[P, B, S]] <span class="cov0" title="0">{
        return func(e *Encrypter[P, B, S]) error </span><span class="cov0" title="0">{
                e.info = info
                return nil
        }</span>
}

// EncryptingWithAuthentication returns an option that enables Auth mode (mode_auth = 0x02).
// The sender's private key is used in the encapsulation to authenticate the sender's identity.
// The recipient can verify the sender possessed the corresponding private key.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.3
func EncryptingWithAuthentication[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](sk *PrivateKey[S]) encryption.EncrypterOption[*Encrypter[P, B, S], *PublicKey[P, B, S], Message, Ciphertext, *Capsule[P, B, S]] <span class="cov0" title="0">{
        return func(e *Encrypter[P, B, S]) error </span><span class="cov0" title="0">{
                e.senderPrivateKey = sk
                return nil
        }</span>
}

// EncryptingWithPreSharedKey returns an option that enables PSK mode (mode_psk = 0x01).
// Both sender and receiver must possess the same pre-shared key (psk) and PSK identifier
// (pskID). The PSK is incorporated into the key schedule, providing sender authentication.
//
// Per RFC 9180, the psk MUST have at least 32 bytes of entropy, and pskID is a sequence
// of bytes used to identify the PSK.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.2
func EncryptingWithPreSharedKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](pskID []byte, psk *encryption.SymmetricKey) encryption.EncrypterOption[*Encrypter[P, B, S], *PublicKey[P, B, S], Message, Ciphertext, *Capsule[P, B, S]] <span class="cov0" title="0">{
        return func(e *Encrypter[P, B, S]) error </span><span class="cov0" title="0">{
                e.pskID = pskID
                e.psk = psk
                return nil
        }</span>
}

// EncryptingWithAuthPSK returns an option that enables AuthPSK mode (mode_auth_psk = 0x03).
// This combines both asymmetric authentication (via the sender's private key) and PSK
// authentication, providing defence in depth.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.4
func EncryptingWithAuthPSK[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](sk *PrivateKey[S], pskID []byte, psk *encryption.SymmetricKey) encryption.EncrypterOption[*Encrypter[P, B, S], *PublicKey[P, B, S], Message, Ciphertext, *Capsule[P, B, S]] <span class="cov0" title="0">{
        return func(e *Encrypter[P, B, S]) error </span><span class="cov0" title="0">{
                e.senderPrivateKey = sk
                e.pskID = pskID
                e.psk = psk
                return nil
        }</span>
}

// Encrypter performs HPKE encryption operations. It establishes a sender context
// for each encryption and seals messages using the AEAD algorithm specified in
// the cipher suite.
//
// The encrypter supports all four HPKE modes, determined by which options were
// provided during construction. For each Encrypt/Seal call, a new ephemeral key
// pair is generated and a fresh sender context is established.
type Encrypter[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        suite            *CipherSuite
        senderPrivateKey *PrivateKey[S]
        info             []byte
        pskID            []byte
        psk              *encryption.SymmetricKey

        shouldCacheCtx bool
        cachedCtx      *SenderContext[P, B, S]
        mu             sync.Mutex
}

// Mode returns the HPKE mode that will be used for encryption, determined by
// which authentication parameters have been configured.
func (e *Encrypter[P, B, S]) Mode() ModeID <span class="cov8" title="1">{
        if e.psk != nil &amp;&amp; len(e.pskID) &gt; 0 </span><span class="cov0" title="0">{
                if e.senderPrivateKey != nil </span><span class="cov0" title="0">{
                        return AuthPSk
                }</span>
                <span class="cov0" title="0">return PSk</span>
        }
        <span class="cov8" title="1">if e.senderPrivateKey != nil </span><span class="cov0" title="0">{
                return Auth
        }</span>
        <span class="cov8" title="1">return Base</span>
}

// Encrypt encrypts a plaintext message to the receiver's public key.
// It returns the ciphertext and the capsule (ephemeral public key) that must be
// transmitted to the receiver for decryption. This is equivalent to Seal with nil aad.
//
// A fresh sender context is established for each call, generating a new ephemeral
// key pair and deriving fresh encryption keys.
func (e *Encrypter[P, B, S]) Encrypt(plaintext Message, receiver *PublicKey[P, B, S], prng io.Reader) (Ciphertext, *Capsule[P, B, S], error) <span class="cov8" title="1">{
        return e.Seal(plaintext, receiver, nil, prng)
}</span>

// Seal encrypts a plaintext message with associated data to the receiver's public key.
// The associated data (aad) is authenticated but not encrypted; it must be provided
// identically during decryption.
//
// Returns the ciphertext (containing encrypted plaintext and authentication tag) and
// the capsule (ephemeral public key) needed for decryption.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2
func (e *Encrypter[P, B, S]) Seal(plaintext Message, receiver *PublicKey[P, B, S], aad []byte, prng io.Reader) (Ciphertext, *Capsule[P, B, S], error) <span class="cov8" title="1">{
        if e.shouldCacheCtx </span><span class="cov0" title="0">{
                e.mu.Lock()
                defer e.mu.Unlock()
        }</span>
        <span class="cov8" title="1">if receiver == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithStackFrame().WithMessage("receiver public key is nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithStackFrame().WithMessage("prng is nil")
        }</span>

        <span class="cov8" title="1">var ctx *SenderContext[P, B, S]
        var err error
        switch e.Mode() </span>{
        case Base:<span class="cov8" title="1">
                ctx, err = SetupBaseS(e.suite, receiver, e.info, prng)</span>
        case Auth:<span class="cov0" title="0">
                ctx, err = SetupAuthS(e.suite, receiver, e.senderPrivateKey, e.info, prng)</span>
        case PSk:<span class="cov0" title="0">
                ctx, err = SetupPSKS(e.suite, receiver, e.psk.Bytes(), e.pskID, e.info, prng)</span>
        case AuthPSk:<span class="cov0" title="0">
                ctx, err = SetupAuthPSKS(e.suite, receiver, e.senderPrivateKey, e.psk.Bytes(), e.pskID, e.info, prng)</span>
        default:<span class="cov0" title="0">
                return nil, nil, ErrNotSupported.WithStackFrame().WithMessage("unsupported mode")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if e.shouldCacheCtx </span><span class="cov0" title="0">{
                e.cachedCtx = ctx
        }</span>

        <span class="cov8" title="1">ct, err := ctx.Seal(plaintext, aad)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return Ciphertext(ct), ctx.Capsule, nil</span>
}

// Export derives a secret from the encryption context using the HPKE secret export
// mechanism. This requires context caching to be enabled via EncryptingWhileCachingRecentContextualInfo.
//
// The exporter_context parameter and length are inputs to the secret derivation.
// The same inputs will produce the same output on both sender and receiver sides.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.3
func (e *Encrypter[P, B, S]) Export(context []byte, length uint) (*encryption.SymmetricKey, error) <span class="cov0" title="0">{
        if length == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithStackFrame()
        }</span>
        <span class="cov0" title="0">if !e.shouldCacheCtx || e.cachedCtx == nil </span><span class="cov0" title="0">{
                return nil, errs2.New("cannot export key without cached context")
        }</span>
        <span class="cov0" title="0">k, err := e.cachedCtx.Export(context, int(length))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">out, err := encryption.NewSymmetricKey(k)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// DecryptingWithApplicationInfo returns an option that sets the application-specific
// info parameter. This must match the info used by the sender for successful decryption.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1
func DecryptingWithApplicationInfo[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](info []byte) encryption.DecrypterOption[*Decrypter[P, B, S], Message, Ciphertext] <span class="cov0" title="0">{
        return func(d *Decrypter[P, B, S]) error </span><span class="cov0" title="0">{
                d.info = info
                return nil
        }</span>
}

// DecryptingWithCapsule returns an option that sets the capsule (enc) received from
// the sender. The capsule is the serialised ephemeral public key used in the key
// encapsulation mechanism. This option is required for decryption.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-4.1
func DecryptingWithCapsule[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](capsule *Capsule[P, B, S]) encryption.DecrypterOption[*Decrypter[P, B, S], Message, Ciphertext] <span class="cov8" title="1">{
        return func(d *Decrypter[P, B, S]) error </span><span class="cov8" title="1">{
                // For Base/PSK modes, the capsule is the ephemeral public key
                // For Auth modes, it will be overridden by DecryptingWithAuthentication
                d.ephemeralPublicKey = capsule
                return nil
        }</span>
}

// DecryptingWithAuthentication returns an option that enables Auth mode (mode_auth = 0x02)
// for decryption. The sender's public key is used to verify that the sender possessed
// the corresponding private key during encapsulation.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.3
func DecryptingWithAuthentication[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](pk *PublicKey[P, B, S]) encryption.DecrypterOption[*Decrypter[P, B, S], Message, Ciphertext] <span class="cov0" title="0">{
        return func(d *Decrypter[P, B, S]) error </span><span class="cov0" title="0">{
                d.senderPublicKey = pk
                return nil
        }</span>
}

// DecryptingWithPreSharedKey returns an option that enables PSK mode (mode_psk = 0x01)
// for decryption. The PSK and PSK ID must match those used by the sender.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.2
func DecryptingWithPreSharedKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](pskID []byte, psk *encryption.SymmetricKey) encryption.DecrypterOption[*Decrypter[P, B, S], Message, Ciphertext] <span class="cov0" title="0">{
        return func(d *Decrypter[P, B, S]) error </span><span class="cov0" title="0">{
                d.pskID = pskID
                d.psk = psk
                return nil
        }</span>
}

// DecryptingWithAuthPSK returns an option that enables AuthPSK mode (mode_auth_psk = 0x03)
// for decryption. Both the sender's public key and PSK must be provided and match those
// used by the sender.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.4
func DecryptingWithAuthPSK[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](pk *PublicKey[P, B, S], pskID []byte, psk *encryption.SymmetricKey) encryption.DecrypterOption[*Decrypter[P, B, S], Message, Ciphertext] <span class="cov0" title="0">{
        return func(d *Decrypter[P, B, S]) error </span><span class="cov0" title="0">{
                d.senderPublicKey = pk
                d.pskID = pskID
                d.psk = psk
                return nil
        }</span>
}

// Decrypter performs HPKE decryption operations. The receiver context is established
// during construction based on the receiver's private key and the capsule from the sender.
//
// The decrypter supports all four HPKE modes, determined by which options were provided
// during construction. The mode must match what the sender used, or decryption will fail.
type Decrypter[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        suite      *CipherSuite
        privateKey *PrivateKey[S]

        senderPublicKey    *PublicKey[P, B, S] // For Auth modes - sender's static public key
        ephemeralPublicKey *Capsule[P, B, S]   // Ephemeral public key
        info               []byte
        pskID              []byte
        psk                *encryption.SymmetricKey

        ctx *ReceiverContext[P, B, S]
}

// Mode returns the HPKE mode configured for decryption, determined by which
// authentication parameters have been set.
func (e *Decrypter[P, B, S]) Mode() ModeID <span class="cov8" title="1">{
        if e.psk != nil &amp;&amp; len(e.pskID) &gt; 0 </span><span class="cov0" title="0">{
                if e.senderPublicKey != nil </span><span class="cov0" title="0">{
                        return AuthPSk
                }</span>
                <span class="cov0" title="0">return PSk</span>
        }
        <span class="cov8" title="1">if e.senderPublicKey != nil </span><span class="cov0" title="0">{
                return Auth
        }</span>
        <span class="cov8" title="1">return Base</span>
}

// Decrypt decrypts a ciphertext encrypted to this receiver's public key.
// This is equivalent to Open with nil associated data.
func (e *Decrypter[P, B, S]) Decrypt(ciphertext Ciphertext) (Message, error) <span class="cov8" title="1">{
        return e.Open(ciphertext, nil)
}</span>

// Open decrypts a ciphertext with associated data. The associated data must match
// exactly what was provided during encryption, or the authentication will fail.
//
// The sequence number is incremented after each successful decryption, so ciphertexts
// must be opened in the same order they were sealed by the sender.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2
func (e *Decrypter[P, B, S]) Open(ciphertext Ciphertext, aad []byte) (Message, error) <span class="cov8" title="1">{
        if ciphertext == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithStackFrame().WithMessage("ciphertext is nil")
        }</span>
        <span class="cov8" title="1">pt, err := e.ctx.Open([]byte(ciphertext), aad)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return pt, nil</span>
}

// Export derives a secret from the decryption context using the HPKE secret export
// mechanism. The exporter_context parameter and length are inputs to the secret derivation.
//
// When called with the same inputs on both sender and receiver, Export produces the
// same output, enabling key agreement for additional symmetric keys.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.3
func (e *Decrypter[P, B, S]) Export(context []byte, length uint) (*encryption.SymmetricKey, error) <span class="cov0" title="0">{
        if length == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithStackFrame()
        }</span>
        <span class="cov0" title="0">k, err := e.ctx.Export(context, int(length))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">out, err := encryption.NewSymmetricKey(k)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file209" style="display: none">// This file contains the RFC 9180 API for HPKE (Hybrid Public Key Encryption).
// These functions correspond directly to the algorithms defined in the RFC:
//
//   - SetupBaseS/SetupBaseR: Base mode (mode_base = 0x00)
//   - SetupPSKS/SetupPSKR: PSK mode (mode_psk = 0x01)
//   - SetupAuthS/SetupAuthR: Auth mode (mode_auth = 0x02)
//   - SetupAuthPSKS/SetupAuthPSKR: AuthPSK mode (mode_auth_psk = 0x03)
//
// Each Setup function returns a context that can be used for encryption (sender)
// or decryption (receiver). The context provides Seal/Open methods for AEAD
// operations and Export for deriving additional secrets.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5

package hpke

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/encryption/hpke/internal"
)

// SetupBaseS establishes an encryption context for Base mode (mode_base = 0x00).
// This mode provides encryption to a public key without sender authentication.
//
// Parameters:
//   - suite: The cipher suite specifying KEM, KDF, and AEAD algorithms
//   - receiverPublicKey: The recipient's public key (pkR)
//   - info: Application-supplied information (optional; default "")
//   - prng: Source of randomness for ephemeral key generation
//
// Returns a SenderContext containing the capsule (enc) to send to the receiver.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.1
func SetupBaseS[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](suite *CipherSuite, receiverPublicKey *PublicKey[P, B, S], info []byte, prng io.Reader) (sender *SenderContext[P, B, S], err error) <span class="cov8" title="1">{
        out, err := internal.NewSenderContext(Base, suite, receiverPublicKey, nil, info, nil, nil, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SetupBaseR establishes a decryption context for Base mode (mode_base = 0x00).
// This is the receiver-side counterpart to SetupBaseS.
//
// Parameters:
//   - suite: The cipher suite (must match sender's)
//   - receiverPrivatekey: The recipient's private key (skR)
//   - ephemeralPublicKey: The capsule (enc) received from the sender
//   - info: Application-supplied information (must match sender's)
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.1
func SetupBaseR[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](suite *CipherSuite, receiverPrivatekey *PrivateKey[S], ephemeralPublicKey *PublicKey[P, B, S], info []byte) (*ReceiverContext[P, B, S], error) <span class="cov8" title="1">{
        out, err := internal.NewReceiverContext(Base, suite, receiverPrivatekey, ephemeralPublicKey, nil, info, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SetupPSKS establishes an encryption context for PSK mode (mode_psk = 0x01).
// This mode authenticates the sender via a pre-shared key known to both parties.
//
// The PSK provides authentication: the receiver can verify the sender possessed
// the PSK, but compromise of the PSK allows impersonation.
//
// Parameters:
//   - suite: The cipher suite specifying KEM, KDF, and AEAD algorithms
//   - receiverPublicKey: The recipient's public key (pkR)
//   - psk: The pre-shared key (MUST have at least 32 bytes of entropy)
//   - pskID: Identifier for the PSK (used to select among multiple PSKs)
//   - info: Application-supplied information (optional; default "")
//   - prng: Source of randomness for ephemeral key generation
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.2
func SetupPSKS[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](suite *CipherSuite, receiverPublicKey *PublicKey[P, B, S], psk, pskID, info []byte, prng io.Reader) (sender *SenderContext[P, B, S], err error) <span class="cov8" title="1">{
        out, err := internal.NewSenderContext(PSk, suite, receiverPublicKey, nil, info, psk, pskID, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SealPSK encrypts a plaintext using a PSK-mode sender context.
// This is a convenience wrapper around ctx.Seal for PSK mode.
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.2
func SealPSK[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](ctx *SenderContext[P, B, S], additionalData, plaintext []byte) (ciphertext []byte, err error) <span class="cov0" title="0">{
        out, err := ctx.Seal(plaintext, additionalData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// SetupPSKR establishes a decryption context for PSK mode (mode_psk = 0x01).
// This is the receiver-side counterpart to SetupPSKS.
//
// Parameters:
//   - suite: The cipher suite (must match sender's)
//   - receiverPrivatekey: The recipient's private key (skR)
//   - ephemeralPublicKey: The capsule (enc) received from the sender
//   - psk: The pre-shared key (must match sender's)
//   - pskID: Identifier for the PSK (must match sender's)
//   - info: Application-supplied information (must match sender's)
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.2
func SetupPSKR[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](suite *CipherSuite, receiverPrivatekey *PrivateKey[S], ephemeralPublicKey *PublicKey[P, B, S], psk, pskID, info []byte) (*ReceiverContext[P, B, S], error) <span class="cov8" title="1">{
        out, err := internal.NewReceiverContext(PSk, suite, receiverPrivatekey, ephemeralPublicKey, nil, info, psk, pskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SetupAuthS establishes an encryption context for Auth mode (mode_auth = 0x02).
// This mode authenticates the sender via an asymmetric key pair, allowing the
// recipient to verify the sender possessed the corresponding private key.
//
// Unlike PSK mode, Auth mode provides non-repudiation: only the holder of skS
// could have created the ciphertext. However, it requires the receiver to know
// the sender's public key in advance.
//
// Parameters:
//   - suite: The cipher suite specifying KEM, KDF, and AEAD algorithms
//   - receiverPublicKey: The recipient's public key (pkR)
//   - senderPrivateKey: The sender's private key (skS) for authentication
//   - info: Application-supplied information (optional; default "")
//   - prng: Source of randomness for ephemeral key generation
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.3
func SetupAuthS[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](suite *CipherSuite, receiverPublicKey *PublicKey[P, B, S], senderPrivateKey *PrivateKey[S], info []byte, prng io.Reader) (sender *SenderContext[P, B, S], err error) <span class="cov8" title="1">{
        out, err := internal.NewSenderContext(Auth, suite, receiverPublicKey, senderPrivateKey, info, nil, nil, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SetupAuthR establishes a decryption context for Auth mode (mode_auth = 0x02).
// This is the receiver-side counterpart to SetupAuthS.
//
// The receiver uses the sender's public key to verify the sender's identity.
// Decryption will fail if the ciphertext was not created using the corresponding
// sender private key.
//
// Parameters:
//   - suite: The cipher suite (must match sender's)
//   - receiverPrivatekey: The recipient's private key (skR)
//   - ephemeralPublicKey: The capsule (enc) received from the sender
//   - senderPublicKey: The sender's public key (pkS) for authentication
//   - info: Application-supplied information (must match sender's)
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.3
func SetupAuthR[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](suite *CipherSuite, receiverPrivatekey *PrivateKey[S], ephemeralPublicKey, senderPublicKey *PublicKey[P, B, S], info []byte) (*ReceiverContext[P, B, S], error) <span class="cov8" title="1">{
        out, err := internal.NewReceiverContext(Auth, suite, receiverPrivatekey, ephemeralPublicKey, senderPublicKey, info, nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SetupAuthPSKS establishes an encryption context for AuthPSK mode (mode_auth_psk = 0x03).
// This mode combines both PSK and asymmetric authentication, providing defence in depth.
//
// The sender is authenticated via both mechanisms: the PSK is incorporated into the
// key schedule, and the sender's private key is used in the encapsulation. Both must
// be valid for decryption to succeed.
//
// Parameters:
//   - suite: The cipher suite specifying KEM, KDF, and AEAD algorithms
//   - receiverPublicKey: The recipient's public key (pkR)
//   - senderPrivateKey: The sender's private key (skS) for authentication
//   - psk: The pre-shared key (MUST have at least 32 bytes of entropy)
//   - pskID: Identifier for the PSK
//   - info: Application-supplied information (optional; default "")
//   - prng: Source of randomness for ephemeral key generation
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.4
func SetupAuthPSKS[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](suite *CipherSuite, receiverPublicKey *PublicKey[P, B, S], senderPrivateKey *PrivateKey[S], psk, pskID, info []byte, prng io.Reader) (sender *SenderContext[P, B, S], err error) <span class="cov8" title="1">{
        out, err := internal.NewSenderContext(AuthPSk, suite, receiverPublicKey, senderPrivateKey, info, psk, pskID, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SetupAuthPSKR establishes a decryption context for AuthPSK mode (mode_auth_psk = 0x03).
// This is the receiver-side counterpart to SetupAuthPSKS.
//
// Both the sender's public key and the PSK are verified during decryption. The
// decryption will fail if either authentication mechanism fails.
//
// Parameters:
//   - suite: The cipher suite (must match sender's)
//   - receiverPrivatekey: The recipient's private key (skR)
//   - ephemeralPublicKey: The capsule (enc) received from the sender
//   - senderPublicKey: The sender's public key (pkS) for authentication
//   - psk: The pre-shared key (must match sender's)
//   - pskID: Identifier for the PSK (must match sender's)
//   - info: Application-supplied information (must match sender's)
//
// See: https://www.rfc-editor.org/rfc/rfc9180.html#section-5.1.4
func SetupAuthPSKR[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](suite *CipherSuite, receiverPrivatekey *PrivateKey[S], ephemeralPublicKey, senderPublicKey *PublicKey[P, B, S], psk, pskID, info []byte) (*ReceiverContext[P, B, S], error) <span class="cov8" title="1">{
        out, err := internal.NewReceiverContext(AuthPSk, suite, receiverPrivatekey, ephemeralPublicKey, senderPublicKey, info, psk, pskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file210" style="display: none">package encryption

import (
        "crypto/cipher"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

type Capsule any
type (
        KEM[PK PublicKey[PK], C Capsule] interface {
                Encapsulate(receiver PK, prng io.Reader) (*SymmetricKey, C, error)
                IsAuthenticated() bool
        }

        KEMOption[
                KM KEM[PK, C], PK PublicKey[PK], C Capsule,
        ] = func(KM) error
)

type (
        DEM[C Capsule] interface {
                Decapsulate(capsule C) (*SymmetricKey, error)
                IsAuthenticated() bool
        }

        DEMOption[
                DM DEM[C], C Capsule,
        ] = func(DM) error
)

type HybridEncrypter[
        PK PublicKey[PK],
        M Plaintext,
        C Ciphertext,
        U Capsule,
] interface {
        Encrypter[PK, M, C, U]
        Seal(plaintext M, receiver PK, aad []byte, prng io.Reader) (C, U, error)
}

type HybridDecrypter[
        M Plaintext,
        C Ciphertext,
] interface {
        Decrypter[M, C]
        Open(ciphertext C, aad []byte) (M, error)
}

type HybridScheme[
        SK PrivateKey[SK],
        PK PublicKey[PK],
        M Plaintext,
        C Ciphertext,
        U Capsule,
        KG KeyGenerator[SK, PK],
        KM KEM[PK, U],
        DM DEM[U],
        ENC HybridEncrypter[PK, M, C, U],
        DEC HybridDecrypter[M, C],
] interface {
        Scheme[SK, PK, M, C, U, KG, ENC, DEC]
        KEM(...KEMOption[KM, PK, U]) (KM, error)
        DEM(SK, ...DEMOption[DM, U]) (DM, error)
}

type AEADBasedHybridScheme[
        SK PrivateKey[SK],
        PK PublicKey[PK],
        M ~[]byte,
        C ~[]byte,
        U Capsule,
        KG KeyGenerator[SK, PK],
        KM KEM[PK, U],
        DM DEM[U],
        ENC HybridEncrypter[PK, M, C, U],
        DEC HybridDecrypter[M, C],
] interface {
        HybridScheme[SK, PK, M, C, U, KG, KM, DM, ENC, DEC]
        AEAD(*SymmetricKey) (cipher.AEAD, error)
}

func NewSymmetricKey(v []byte) (*SymmetricKey, error) <span class="cov0" title="0">{
        if len(v) == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidKey.WithMessage("symmetric key cannot be empty")
        }</span>
        <span class="cov0" title="0">if ct.SliceIsZero(v) == ct.True </span><span class="cov0" title="0">{
                return nil, ErrInvalidKey.WithMessage("symmetric key cannot be all zero")
        }</span>
        <span class="cov0" title="0">key := make([]byte, len(v))
        copy(key, v)
        return &amp;SymmetricKey{v: key}, nil</span>
}

type SymmetricKey struct {
        v []byte
}

func (k *SymmetricKey) Bytes() []byte <span class="cov0" title="0">{
        return k.v
}</span>

func (k *SymmetricKey) Equal(other *SymmetricKey) bool <span class="cov0" title="0">{
        if k == nil || other == nil </span><span class="cov0" title="0">{
                return k == other
        }</span>
        <span class="cov0" title="0">return ct.SliceEqual(k.v, other.v) == ct.True</span>
}

func (k *SymmetricKey) Clone() *SymmetricKey <span class="cov0" title="0">{
        v := make([]byte, len(k.v))
        copy(v, k.v)
        return &amp;SymmetricKey{v: v}
}</span>

var (
        ErrInvalidKey = errs2.New("invalid key")
)
</pre>
		
		<pre class="file" id="file211" style="display: none">package paillier

import (
        "github.com/fxamacker/cbor/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

var (
        _ cbor.Marshaler   = (*Plaintext)(nil)
        _ cbor.Unmarshaler = (*Plaintext)(nil)
        _ cbor.Marshaler   = (*Nonce)(nil)
        _ cbor.Unmarshaler = (*Nonce)(nil)
        _ cbor.Marshaler   = (*Ciphertext)(nil)
        _ cbor.Unmarshaler = (*Ciphertext)(nil)
        _ cbor.Marshaler   = (*PublicKey)(nil)
        _ cbor.Unmarshaler = (*PublicKey)(nil)
        _ cbor.Marshaler   = (*PrivateKey)(nil)
        _ cbor.Unmarshaler = (*PrivateKey)(nil)
)

// Plaintext serialisation - reuse num.Int and num.NatPlus CBOR.
type plaintextDTO struct {
        V *num.Int     `cbor:"v"`
        N *num.NatPlus `cbor:"n"`
}

// MarshalCBOR serialises the plaintext to CBOR format.
func (pt *Plaintext) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;plaintextDTO{
                V: pt.v,
                N: pt.n,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// UnmarshalCBOR deserializes the plaintext from CBOR format.
func (pt *Plaintext) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[plaintextDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">pt.v = dto.V
        pt.n = dto.N
        return nil</span>
}

// Nonce serialisation - reuse znstar.Unit CBOR.
type nonceDTO struct {
        U *znstar.RSAGroupElementUnknownOrder `cbor:"u"`
}

// MarshalCBOR serialises the nonce to CBOR format.
func (n *Nonce) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;nonceDTO{
                U: n.u,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// UnmarshalCBOR deserializes the nonce from CBOR format.
func (n *Nonce) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[nonceDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">n.u = dto.U
        return nil</span>
}

// Ciphertext serialisation - reuse znstar.Unit CBOR.
type ciphertextDTO struct {
        U *znstar.PaillierGroupElementUnknownOrder `cbor:"u"`
}

// MarshalCBOR serialises the ciphertext to CBOR format.
func (ct *Ciphertext) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;ciphertextDTO{
                U: ct.u,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// UnmarshalCBOR deserializes the ciphertext from CBOR format.
func (ct *Ciphertext) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[ciphertextDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">ct.u = dto.U
        return nil</span>
}

// PublicKey serialisation - reuse znstar.PaillierGroup CBOR.
type publicKeyDTO struct {
        Group *znstar.PaillierGroupUnknownOrder `cbor:"group"`
}

// MarshalCBOR serialises the public key to CBOR format.
func (pk *PublicKey) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;publicKeyDTO{
                Group: pk.group,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// UnmarshalCBOR deserializes the public key from CBOR format.
func (pk *PublicKey) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[publicKeyDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">pk.group = dto.Group
        // Spaces will be lazily initialised via cacheSpaces when accessed
        return nil</span>
}

// PrivateKey serialisation - reuse znstar.PaillierGroupKnownOrder and numct.Nat CBOR.
type privateKeyDTO struct {
        Group *znstar.PaillierGroupKnownOrder `cbor:"group"`
}

// MarshalCBOR serialises the private key to CBOR format.
func (sk *PrivateKey) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;privateKeyDTO{
                Group: sk.group,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// UnmarshalCBOR deserializes the private key from CBOR format.
func (sk *PrivateKey) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[privateKeyDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">sk.group = dto.Group
        // Initialise hp and hq before calling precompute
        sk.hp = numct.NewNat(0)
        sk.hq = numct.NewNat(0)
        sk.precompute()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file212" style="display: none">package paillier

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
)

// NewCiphertextSpace creates a new ciphertext space for Paillier encryption.
// The space is the multiplicative group (Z/nZ)* where n is the modulus.
func NewCiphertextSpace(n2, n *num.NatPlus) (*CiphertextSpace, error) <span class="cov8" title="1">{
        g, err := znstar.NewPaillierGroupOfUnknownOrder(n2, n)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;CiphertextSpace{g: g}, nil</span>
}

// CiphertextSpace represents the space of Paillier ciphertexts modulo n^2.
type CiphertextSpace struct {
        g *znstar.PaillierGroupUnknownOrder
}

// Group returns the underlying Paillier group of unknown order.
func (cts *CiphertextSpace) Group() *znstar.PaillierGroupUnknownOrder <span class="cov0" title="0">{
        return cts.g
}</span>

// N2 returns the modulus n^2 of the ciphertext space.
func (cts *CiphertextSpace) N2() *num.NatPlus <span class="cov8" title="1">{
        return cts.g.Modulus()
}</span>

// Sample samples a random ciphertext from the ciphertext space.
func (cts *CiphertextSpace) Sample(prng io.Reader) (*Ciphertext, error) <span class="cov8" title="1">{
        u, err := cts.g.Random(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Ciphertext{u: u}, nil</span>
}

// New creates a new ciphertext from a natural number.
func (cts *CiphertextSpace) New(x *numct.Nat) (*Ciphertext, error) <span class="cov8" title="1">{
        y, err := num.NewUintGivenModulus(x, cts.N2().ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">u, err := cts.g.FromUint(y)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Ciphertext{u: u}, nil</span>
}

// NewCiphertextFromUnit creates a new ciphertext from a Paillier group element.
func NewCiphertextFromUnit(u *znstar.PaillierGroupElementUnknownOrder) *Ciphertext <span class="cov0" title="0">{
        return &amp;Ciphertext{u: u}
}</span>

// Contains returns true if the ciphertext belongs to this ciphertext space.
func (cts *CiphertextSpace) Contains(ct *Ciphertext) bool <span class="cov8" title="1">{
        return ct != nil &amp;&amp; cts.N2().Equal(ct.N2())
}</span>

// Ciphertext represents an encrypted Paillier message in the group (Z/nZ)*.
type Ciphertext struct {
        u *znstar.PaillierGroupElementUnknownOrder
}

// Value returns the underlying group element.
func (ct *Ciphertext) Value() *znstar.PaillierGroupElementUnknownOrder <span class="cov8" title="1">{
        return ct.u
}</span>

// ValueCT returns the ciphertext value as a constant-time natural number.
func (ct *Ciphertext) ValueCT() *numct.Nat <span class="cov8" title="1">{
        return ct.Value().Value().Value()
}</span>

// N2 returns the modulus n of the ciphertext.
func (ct *Ciphertext) N2() *num.NatPlus <span class="cov8" title="1">{
        return ct.Value().Modulus()
}</span>

func (ct *Ciphertext) isValid(x *Ciphertext) <span class="cov8" title="1">{
        if x == nil </span><span class="cov0" title="0">{
                panic("cannot operate on nil ciphertexts")</span>
        }
        <span class="cov8" title="1">if !ct.N2().Equal(x.N2()) </span><span class="cov0" title="0">{
                panic("cannot operate on ciphertexts with different moduli")</span>
        }
}

// Op multiplies two ciphertexts in the group (Z/nZ)*, which corresponds
// to addition of the underlying plaintexts in the Paillier scheme.
func (ct *Ciphertext) Op(other *Ciphertext) *Ciphertext <span class="cov8" title="1">{
        ct.isValid(other)
        v := ct.Value().ForgetOrder().Mul(other.Value().ForgetOrder())
        return &amp;Ciphertext{u: v}
}</span>

// HomAdd performs homomorphic addition of two ciphertexts.
// The result decrypts to the sum of the two plaintexts: Dec(HomAdd(c1, c2)) = m1 + m2.
func (ct *Ciphertext) HomAdd(other *Ciphertext) *Ciphertext <span class="cov8" title="1">{
        return ct.Op(other)
}</span>

// HomSub performs homomorphic subtraction of two ciphertexts.
// The result decrypts to the difference of the two plaintexts: Dec(HomSub(c1, c2)) = m1 - m2.
func (ct *Ciphertext) HomSub(other *Ciphertext) *Ciphertext <span class="cov8" title="1">{
        ct.isValid(other)
        return &amp;Ciphertext{u: ct.Value().Div(other.Value())}
}</span>

// ScalarOp exponentiates a ciphertext by a scalar, which corresponds to
// multiplication of the underlying plaintext by the scalar in the Paillier scheme.
func (ct *Ciphertext) ScalarOp(scalar *num.Nat) *Ciphertext <span class="cov8" title="1">{
        return &amp;Ciphertext{u: ct.Value().Exp(scalar)}
}</span>

// ScalarOpBounded exponentiates a ciphertext by a scalar with a known bit bound.
// This is more efficient than ScalarOp when the scalar is known to be small.
func (ct *Ciphertext) ScalarOpBounded(scalar *num.Nat, bits uint) *Ciphertext <span class="cov8" title="1">{
        return &amp;Ciphertext{u: ct.Value().ExpBounded(scalar, bits)}
}</span>

// ScalarMul performs homomorphic scalar multiplication of a ciphertext.
// The result decrypts to the product of the plaintext and scalar: Dec(ScalarMul(c, k)) = m * k.
func (ct *Ciphertext) ScalarMul(scalar *num.Nat) *Ciphertext <span class="cov8" title="1">{
        return ct.ScalarOp(scalar)
}</span>

// ScalarMulBounded performs homomorphic scalar multiplication with a known bit bound.
// This is more efficient than ScalarMul when the scalar is known to be small.
func (ct *Ciphertext) ScalarMulBounded(scalar *num.Nat, bits uint) *Ciphertext <span class="cov8" title="1">{
        return ct.ScalarOpBounded(scalar, bits)
}</span>

// ReRandomise re-randomises a ciphertext by multiplying it with a fresh encryption of zero.
// This produces a new ciphertext that decrypts to the same plaintext but is unlinkable
// to the original. Returns the new ciphertext and the nonce used.
func (ct *Ciphertext) ReRandomise(pk *PublicKey, prng io.Reader) (*Ciphertext, *Nonce, error) <span class="cov8" title="1">{
        nonce, err := pk.NonceSpace().Sample(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">ciphertext, err := ct.ReRandomiseWithNonce(pk, nonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return ciphertext, nonce, nil</span>
}

// ReRandomiseWithNonce re-randomises a ciphertext using a provided nonce.
// The result is c' = c * r^n mod n, which decrypts to the same plaintext as c.
func (ct *Ciphertext) ReRandomiseWithNonce(pk *PublicKey, nonce *Nonce) (*Ciphertext, error) <span class="cov8" title="1">{
        g := pk.CiphertextSpace().g
        embeddedNonce, err := g.EmbedRSA(nonce.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">rn, err := g.NthResidue(embeddedNonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        // c' = c * r^n mod n^2
        <span class="cov8" title="1">return &amp;Ciphertext{u: ct.Value().Mul(rn)}, nil</span>
}

// Equal returns true if two ciphertexts are equal.
func (ct *Ciphertext) Equal(other *Ciphertext) bool <span class="cov8" title="1">{
        return ct.Value().Equal(other.Value())
}</span>

// Shift adds a plaintext value to an encrypted ciphertext without re-randomization.
// This is useful for adjusting ciphertexts by known values without changing randomness.
func (ct *Ciphertext) Shift(pk *PublicKey, message *Plaintext) (*Ciphertext, error) <span class="cov8" title="1">{
        gDeltaM, err := pk.group.Representative(message.ValueCT())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Ciphertext{u: ct.u.Mul(gDeltaM)}, nil</span>
}

// HashCode returns a hash code for the ciphertext.
func (ct *Ciphertext) HashCode() base.HashCode <span class="cov0" title="0">{
        return ct.Value().HashCode()
}</span>
</pre>
		
		<pre class="file" id="file213" style="display: none">package paillier

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
)

// NewPrivateKey creates a new Paillier private key from a Paillier group with known order.
// The group must contain the factorization n = p * q where p and q are distinct odd primes.
func NewPrivateKey(group *znstar.PaillierGroupKnownOrder) (*PrivateKey, error) <span class="cov8" title="1">{
        if group == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>

        <span class="cov8" title="1">sk := &amp;PrivateKey{ //nolint:exhaustruct // other fields initialised later
                group: group,
                hp:    numct.NewNat(0),
                hq:    numct.NewNat(0),
        }
        sk.precompute()
        return sk, nil</span>
}

// PrivateKey represents a Paillier private key containing the prime factorization
// of the modulus n = p * q. It enables efficient decryption using CRT.
type PrivateKey struct {
        group *znstar.PaillierGroupKnownOrder

        hp *numct.Nat
        hq *numct.Nat

        pk   *PublicKey
        once sync.Once
}

func (sk *PrivateKey) precompute() <span class="cov8" title="1">{
        sk.once.Do(func() </span><span class="cov8" title="1">{
                sk.Arithmetic().P.Factor.ModInv(sk.hp, sk.Arithmetic().Q.Factor.Nat())
                sk.Arithmetic().P.Factor.ModNeg(sk.hp, sk.hp)
                sk.Arithmetic().Q.Factor.ModInv(sk.hq, sk.Arithmetic().P.Factor.Nat())
                sk.Arithmetic().Q.Factor.ModNeg(sk.hq, sk.hq)
                sk.pk = &amp;PublicKey{group: sk.group.ForgetOrder()} //nolint:exhaustruct // other fields initialised later
        }</span>)
}

// Group returns the underlying Paillier group with known order.
func (sk *PrivateKey) Group() *znstar.PaillierGroupKnownOrder <span class="cov0" title="0">{
        return sk.group
}</span>

// Arithmetic returns the modular arithmetic instance for efficient computations mod n.
func (sk *PrivateKey) Arithmetic() *modular.OddPrimeSquareFactors <span class="cov8" title="1">{
        out, ok := sk.group.Arithmetic().(*modular.OddPrimeSquareFactors)
        if !ok </span><span class="cov0" title="0">{
                panic("expected modular.OddPrimeSquareFactors")</span>
        }
        <span class="cov8" title="1">return out</span>
}

// PublicKey derives and returns the corresponding public key.
func (sk *PrivateKey) PublicKey() *PublicKey <span class="cov8" title="1">{
        sk.precompute()
        return sk.pk
}</span>

// Equal returns true if both private keys are equal.
func (sk *PrivateKey) Equal(other *PrivateKey) bool <span class="cov8" title="1">{
        if sk == nil || other == nil </span><span class="cov0" title="0">{
                return sk == other
        }</span>
        <span class="cov8" title="1">return sk.group.Equal(other.group)</span>
}

// NewPublicKey creates a new Paillier public key from a Paillier group with unknown order.
// The public key contains only the modulus n, without knowledge of its factorization.
func NewPublicKey(group *znstar.PaillierGroupUnknownOrder) (*PublicKey, error) <span class="cov8" title="1">{
        if group == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>
        <span class="cov8" title="1">return &amp;PublicKey{ //nolint:exhaustruct // other fields initialised later
                group: group,
        }, nil</span>
}

// PublicKey represents a Paillier public key containing the modulus n.
// It can be used for encryption but not decryption.
type PublicKey struct {
        group *znstar.PaillierGroupUnknownOrder

        plaintextSpace  *PlaintextSpace
        nonceSpace      *NonceSpace
        ciphertextSpace *CiphertextSpace
        once            sync.Once
}

// Group returns the underlying Paillier group with unknown order.
func (pk *PublicKey) Group() *znstar.PaillierGroupUnknownOrder <span class="cov0" title="0">{
        return pk.group
}</span>

// Equal returns true if both public keys are equal.
func (pk *PublicKey) Equal(other *PublicKey) bool <span class="cov8" title="1">{
        if pk == nil || other == nil </span><span class="cov0" title="0">{
                return pk == other
        }</span>
        <span class="cov8" title="1">return pk.group.Equal(other.group)</span>
}

// Modulus returns the modulus n as a constant-time modulus.
func (pk *PublicKey) Modulus() *numct.Modulus <span class="cov0" title="0">{
        return pk.group.ModulusCT()
}</span>

// N returns the modulus n as a constant-time modulus.
func (pk *PublicKey) N() *numct.Modulus <span class="cov8" title="1">{
        return pk.group.N().ModulusCT()
}</span>

// N2 returns the modulus n as a constant-time modulus.
func (pk *PublicKey) N2() *numct.Modulus <span class="cov0" title="0">{
        return pk.group.ModulusCT()
}</span>

// Clone returns a shallow copy of the public key.
func (pk *PublicKey) Clone() *PublicKey <span class="cov0" title="0">{
        return &amp;PublicKey{ //nolint:exhaustruct // other fields initialised later
                group: pk.group,
        }
}</span>

// HashCode returns a hash code for the public key.
func (pk *PublicKey) HashCode() base.HashCode <span class="cov0" title="0">{
        return pk.N2().HashCode().Combine(pk.N().HashCode())
}</span>

func (pk *PublicKey) cacheSpaces() <span class="cov8" title="1">{
        pk.once.Do(func() </span><span class="cov8" title="1">{
                var errPlaintext, errNonce, errCiphertext error
                n := pk.group.N()
                nn := pk.group.Modulus()
                pk.plaintextSpace, errPlaintext = NewPlaintextSpace(n)
                pk.nonceSpace, errNonce = NewNonceSpace(n)
                pk.ciphertextSpace, errCiphertext = NewCiphertextSpace(nn, n)
                if errPlaintext != nil </span><span class="cov0" title="0">{
                        panic(errPlaintext)</span>
                }
                <span class="cov8" title="1">if errNonce != nil </span><span class="cov0" title="0">{
                        panic(errNonce)</span>
                }
                <span class="cov8" title="1">if errCiphertext != nil </span><span class="cov0" title="0">{
                        panic(errCiphertext)</span>
                }
        })
}

// PlaintextSpace returns the plaintext space Z_n for this public key.
func (pk *PublicKey) PlaintextSpace() *PlaintextSpace <span class="cov8" title="1">{
        pk.cacheSpaces()
        return pk.plaintextSpace
}</span>

// NonceSpace returns the nonce space (Z_n)* for this public key.
func (pk *PublicKey) NonceSpace() *NonceSpace <span class="cov8" title="1">{
        pk.cacheSpaces()
        return pk.nonceSpace
}</span>

// CiphertextSpace returns the ciphertext space (Z_n)* for this public key.
func (pk *PublicKey) CiphertextSpace() *CiphertextSpace <span class="cov8" title="1">{
        pk.cacheSpaces()
        return pk.ciphertextSpace
}</span>
</pre>
		
		<pre class="file" id="file214" style="display: none">package paillier

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
)

// NewNonceSpace creates a new nonce space (Z/nZ)* for Paillier encryption.
// The nonce space is the multiplicative group of units modulo n.
func NewNonceSpace(n *num.NatPlus) (*NonceSpace, error) <span class="cov8" title="1">{
        g, err := znstar.NewRSAGroupOfUnknownOrder(n)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;NonceSpace{g: g}, nil</span>
}

// NonceSpace represents the space of Paillier nonces (Z/nZ)*.
// Nonces are used to randomise ciphertexts for semantic security.
type NonceSpace struct {
        g *znstar.RSAGroupUnknownOrder
}

// N returns the modulus n of the nonce space.
func (ns *NonceSpace) N() *num.NatPlus <span class="cov0" title="0">{
        return ns.g.Modulus()
}</span>

// Sample samples a random nonce from the nonce space.
// The nonce is guaranteed to be a unit (coprime to n).
func (ns *NonceSpace) Sample(prng io.Reader) (*Nonce, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                u, err := ns.g.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
                <span class="cov8" title="1">if u.Value().IsUnit() </span><span class="cov8" title="1">{
                        return &amp;Nonce{u: u}, nil
                }</span>
        }
}

// New creates a nonce from a constant-time natural number.
// Returns an error if the value is not a unit modulo n.
func (ns *NonceSpace) New(x *numct.Nat) (*Nonce, error) <span class="cov0" title="0">{
        y, err := num.NewUintGivenModulus(x, ns.N().ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">u, err := ns.g.FromUint(y)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return &amp;Nonce{u: u}, nil</span>
}

// Contains returns true if the nonce belongs to this nonce space.
func (ns *NonceSpace) Contains(n *Nonce) bool <span class="cov0" title="0">{
        return n != nil &amp;&amp; ns.N().Equal(n.N())
}</span>

// Nonce represents a Paillier encryption nonce in the group (Z/nZ)*.
// Nonces provide the randomization needed for semantic security.
type Nonce struct {
        u *znstar.RSAGroupElementUnknownOrder
}

// Value returns the underlying RSA group element.
func (n *Nonce) Value() *znstar.RSAGroupElementUnknownOrder <span class="cov8" title="1">{
        return n.u
}</span>

// Equal returns true if two nonces are equal.
func (n *Nonce) Equal(other *Nonce) bool <span class="cov0" title="0">{
        if n == nil || other == nil </span><span class="cov0" title="0">{
                return n == other
        }</span>
        <span class="cov0" title="0">return n.Value().Equal(other.Value())</span>
}

// ValueCT returns the nonce value as a constant-time natural number.
func (n *Nonce) ValueCT() *numct.Nat <span class="cov0" title="0">{
        return n.Value().Value().Value()
}</span>

// N returns the modulus n of the nonce.
func (n *Nonce) N() *num.NatPlus <span class="cov0" title="0">{
        return n.Value().Modulus()
}</span>

func (n *Nonce) isValid(x *Nonce) <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                panic("cannot operate on nil nonces")</span>
        }
        <span class="cov0" title="0">if !n.N().Equal(x.N()) </span><span class="cov0" title="0">{
                panic("cannot operate on nonces with different moduli")</span>
        }
}

// Op performs the group operation on two nonces (multiplication modulo n).
func (n *Nonce) Op(other *Nonce) *Nonce <span class="cov0" title="0">{
        return n.Mul(other)
}</span>

// Mul multiplies two nonces and returns the result.
func (n *Nonce) Mul(other *Nonce) *Nonce <span class="cov0" title="0">{
        n.isValid(other)
        return &amp;Nonce{u: n.Value().Mul(other.Value())}
}</span>
</pre>
		
		<pre class="file" id="file215" style="display: none">// Package paillier implements the Paillier cryptosystem, an additive homomorphic
// public-key encryption scheme. It supports homomorphic addition of ciphertexts
// and scalar multiplication of ciphertexts by plaintexts.
package paillier

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
        "github.com/bronlabs/bron-crypto/pkg/encryption"
)

// Name is the identifier for the Paillier encryption scheme.
const (
        Name   encryption.Name = "paillier"
        KeyLen                 = znstar.PaillierKeyLen
)

// NewScheme returns a new Paillier encryption scheme instance.
func NewScheme() *Scheme <span class="cov8" title="1">{
        return &amp;Scheme{}
}</span>

// Scheme represents the Paillier encryption scheme and provides factory methods
// for creating key generators, encrypters, and decrypters.
type Scheme struct{}

// Name returns the identifier for the Paillier encryption scheme.
func (*Scheme) Name() encryption.Name <span class="cov0" title="0">{
        return Name
}</span>

// Keygen creates a new key generator with the given options.
func (*Scheme) Keygen(opts ...KeyGeneratorOption) (*KeyGenerator, error) <span class="cov8" title="1">{
        kg := &amp;KeyGenerator{
                bits: KeyLen,
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if err := opt(kg); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return kg, nil</span>
}

// Encrypter creates a new encrypter with the given options.
func (*Scheme) Encrypter(opts ...EncrypterOption) (*Encrypter, error) <span class="cov8" title="1">{
        e := &amp;Encrypter{}
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(e); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return e, nil</span>
}

// SelfEncrypter creates a new self-encrypter for the given private key.
// A self-encrypter encrypts messages to the owner of the private key,
// using CRT optimizations for faster encryption.
func (*Scheme) SelfEncrypter(sk *PrivateKey, opts ...SelfEncrypterOption) (*SelfEncrypter, error) <span class="cov8" title="1">{
        if sk == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>
        <span class="cov8" title="1">se := &amp;SelfEncrypter{sk: sk, pk: sk.PublicKey()}
        se.pk.cacheSpaces()
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(se); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return se, nil</span>
}

// Decrypter creates a new decrypter for the given private key.
func (*Scheme) Decrypter(sk *PrivateKey, opts ...DecrypterOption) (*Decrypter, error) <span class="cov8" title="1">{
        if sk == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithStackFrame()
        }</span>
        <span class="cov8" title="1">d := &amp;Decrypter{sk: sk}
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(d); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
        }
        <span class="cov8" title="1">return d, nil</span>
}

func lp(sk *PrivateKey, x *numct.Nat) <span class="cov8" title="1">{
        sk.Arithmetic().P.Squared.ModSub(x, x, numct.NatOne())
        sk.Arithmetic().P.Factor.Quo(x, x)
}</span>

func lq(sk *PrivateKey, x *numct.Nat) <span class="cov8" title="1">{
        sk.Arithmetic().Q.Squared.ModSub(x, x, numct.NatOne())
        sk.Arithmetic().Q.Factor.Quo(x, x)
}</span>

var (
        ErrInvalidArgument = errs2.New("invalid argument")
        ErrInvalidRange    = errs2.New("invalid range")
)
</pre>
		
		<pre class="file" id="file216" style="display: none">package paillier

import (
        "io"
        "sync"

        "golang.org/x/sync/errgroup"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
        "github.com/bronlabs/bron-crypto/pkg/encryption"
)

// KeyGeneratorOption is a functional option for configuring the key generator.
type KeyGeneratorOption = encryption.KeyGeneratorOption[*KeyGenerator, *PrivateKey, *PublicKey]

// WithKeyLen sets the bit length of the modulus n for the generated Paillier key pair.
func WithKeyLen(bits uint) KeyGeneratorOption <span class="cov8" title="1">{
        return func(kg *KeyGenerator) error </span><span class="cov8" title="1">{
                kg.bits = bits
                return nil
        }</span>
}

// KeyGenerator generates Paillier key pairs with configurable parameters.
type KeyGenerator struct {
        bits uint
}

// Generate creates a new Paillier key pair using the configured parameters.
// Returns the private key, public key, and any error encountered.
func (kg *KeyGenerator) Generate(prng io.Reader) (*PrivateKey, *PublicKey, error) <span class="cov8" title="1">{
        group, err := znstar.SamplePaillierGroup(kg.bits, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">sk, err := NewPrivateKey(group)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">pk, err := NewPublicKey(group.ForgetOrder())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return sk, pk, nil</span>
}

// EncrypterOption is a functional option for configuring the encrypter.
type EncrypterOption = encryption.EncrypterOption[*Encrypter, *PublicKey, *Plaintext, *Ciphertext, *Nonce]

// Encrypter performs Paillier encryption using a receiver's public key.
type Encrypter struct{}

// Encrypt encrypts a plaintext for the given receiver using a fresh random nonce.
// Returns the ciphertext, the nonce used, and any error encountered.
func (e *Encrypter) Encrypt(plaintext *Plaintext, receiver *PublicKey, prng io.Reader) (*Ciphertext, *Nonce, error) <span class="cov8" title="1">{
        nonce, err := receiver.NonceSpace().Sample(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">ciphertext, err := e.EncryptWithNonce(plaintext, receiver, nonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return ciphertext, nonce, nil</span>
}

// EncryptWithNonce encrypts a plaintext using a provided nonce.
// The ciphertext is computed as c = g^m * r^n mod n.
func (*Encrypter) EncryptWithNonce(plaintext *Plaintext, receiver *PublicKey, nonce *Nonce) (*Ciphertext, error) <span class="cov8" title="1">{
        embeddedNonce, err := receiver.group.EmbedRSA(nonce.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">rn, err := receiver.group.NthResidue(embeddedNonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">gm, err := receiver.group.Representative(plaintext.ValueCT())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Ciphertext{u: rn.Mul(gm)}, nil</span>
}

// EncryptMany encrypts multiple plaintexts in parallel using fresh random nonces.
// Returns the ciphertexts, the nonces used, and any error encountered.
func (e *Encrypter) EncryptMany(plaintexts []*Plaintext, receiver *PublicKey, prng io.Reader) ([]*Ciphertext, []*Nonce, error) <span class="cov8" title="1">{
        nonces := make([]*Nonce, len(plaintexts))
        var eg errgroup.Group
        for i := range plaintexts </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        nonces[i], err = receiver.NonceSpace().Sample(prng)
                        return err
                }</span>)
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">cts, err := e.EncryptManyWithNonces(plaintexts, receiver, nonces)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return cts, nonces, nil</span>
}

// EncryptManyWithNonces encrypts multiple plaintexts in parallel using provided nonces.
// The length of plaintexts and nonces must match.
func (e *Encrypter) EncryptManyWithNonces(plaintexts []*Plaintext, receiver *PublicKey, nonces []*Nonce) ([]*Ciphertext, error) <span class="cov8" title="1">{
        cts := make([]*Ciphertext, len(plaintexts))
        var eg errgroup.Group
        for i, p := range plaintexts </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        cts[i], err = e.EncryptWithNonce(p, receiver, nonces[i])
                        return err
                }</span>)
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return cts, nil</span>
}

// SelfEncrypterOption is a functional option for configuring the self-encrypter.
type SelfEncrypterOption = func(*SelfEncrypter) error

// SelfEncrypter performs Paillier encryption to oneself using CRT optimizations.
// This is more efficient than regular encryption when encrypting to one's own public key.
type SelfEncrypter struct {
        sk *PrivateKey
        pk *PublicKey
}

// PrivateKey returns the private key used by this self-encrypter.
func (se *SelfEncrypter) PrivateKey() *PrivateKey <span class="cov8" title="1">{
        return se.sk
}</span>

// SelfEncrypt encrypts a plaintext to oneself using a fresh random nonce.
// Uses CRT optimizations for faster encryption.
func (se *SelfEncrypter) SelfEncrypt(plaintext *Plaintext, prng io.Reader) (*Ciphertext, *Nonce, error) <span class="cov8" title="1">{
        nonce, err := se.pk.NonceSpace().Sample(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">ciphertext, err := se.SelfEncryptWithNonce(plaintext, nonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return ciphertext, nonce, nil</span>
}

// SelfEncryptWithNonce encrypts a plaintext to oneself using a provided nonce.
// Uses CRT optimizations for faster encryption.
func (se *SelfEncrypter) SelfEncryptWithNonce(plaintext *Plaintext, nonce *Nonce) (*Ciphertext, error) <span class="cov8" title="1">{
        embeddedNonce, err := se.pk.group.EmbedRSA(nonce.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">rn, err := se.sk.group.NthResidue(embeddedNonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">gm, err := se.sk.group.Representative(plaintext.ValueCT())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Ciphertext{u: rn.Mul(gm).ForgetOrder()}, nil</span>
}

// SelfEncryptMany encrypts multiple plaintexts to oneself in parallel.
// Uses CRT optimizations for faster encryption.
func (se *SelfEncrypter) SelfEncryptMany(plaintexts []*Plaintext, prng io.Reader) ([]*Ciphertext, []*Nonce, error) <span class="cov8" title="1">{
        nonces := make([]*Nonce, len(plaintexts))
        var eg errgroup.Group
        for i := range plaintexts </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        nonces[i], err = se.pk.NonceSpace().Sample(prng)
                        return err
                }</span>)
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">cts, err := se.SelfEncryptManyWithNonces(plaintexts, nonces)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return cts, nonces, nil</span>
}

// SelfEncryptManyWithNonces encrypts multiple plaintexts to oneself using provided nonces.
// The length of plaintexts and nonces must match.
func (se *SelfEncrypter) SelfEncryptManyWithNonces(plaintexts []*Plaintext, nonces []*Nonce) ([]*Ciphertext, error) <span class="cov8" title="1">{
        cts := make([]*Ciphertext, len(plaintexts))
        var eg errgroup.Group
        for i, p := range plaintexts </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        cts[i], err = se.SelfEncryptWithNonce(p, nonces[i])
                        return err
                }</span>)
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return cts, nil</span>
}

// DecrypterOption is a functional option for configuring the decrypter.
type DecrypterOption = encryption.DecrypterOption[*Decrypter, *Plaintext, *Ciphertext]

// Decrypter performs Paillier decryption using the private key.
// Uses CRT for efficient decryption.
type Decrypter struct {
        sk *PrivateKey
}

// Decrypt decrypts a ciphertext and returns the plaintext.
// Uses CRT-based decryption for efficiency.
func (d *Decrypter) Decrypt(ciphertext *Ciphertext) (*Plaintext, error) <span class="cov8" title="1">{
        var mp, mq numct.Nat
        var wg sync.WaitGroup
        wg.Add(2)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                d.sk.Arithmetic().P.Squared.ModExp(&amp;mp, ciphertext.ValueCT(), d.sk.Arithmetic().P.PhiFactor.Nat())
                lp(d.sk, &amp;mp)
                d.sk.Arithmetic().P.Factor.ModMul(&amp;mp, &amp;mp, d.sk.hp)
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                d.sk.Arithmetic().Q.Squared.ModExp(&amp;mq, ciphertext.ValueCT(), d.sk.Arithmetic().Q.PhiFactor.Nat())
                lq(d.sk, &amp;mq)
                d.sk.Arithmetic().Q.Factor.ModMul(&amp;mq, &amp;mq, d.sk.hq)
        }</span>()
        <span class="cov8" title="1">wg.Wait()
        out, err := d.sk.PublicKey().PlaintextSpace().FromNat(d.sk.Arithmetic().CrtModN.Params.Recombine(&amp;mp, &amp;mq))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file217" style="display: none">package paillier

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
)

// NewPlaintextSpace creates a new plaintext space Z_n for Paillier encryption.
// The space represents integers modulo n, where n is the RSA modulus.
func NewPlaintextSpace(n *num.NatPlus) (*PlaintextSpace, error) <span class="cov8" title="1">{
        out, err := num.NewZMod(n)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return (*PlaintextSpace)(out), nil</span>
}

// PlaintextSpace represents the space of Paillier plaintexts modulo n.
// Plaintexts are centred integers in the range [-n/2, n/2).
type PlaintextSpace num.ZMod

// N returns the modulus n of the plaintext space.
func (pts *PlaintextSpace) N() *num.NatPlus <span class="cov8" title="1">{
        return (*num.ZMod)(pts).Modulus()
}</span>

// Zero returns the zero plaintext (additive identity).
func (pts *PlaintextSpace) Zero() *Plaintext <span class="cov8" title="1">{
        return &amp;Plaintext{
                v: num.Z().Zero(),
                n: pts.N(),
        }
}</span>

// Sample samples a random plaintext from the plaintext space.
// If both bounds are nil, samples uniformly from the full range [-n/2, n/2).
// If both bounds are provided, samples uniformly from [lowInclusive, highExclusive).
func (pts *PlaintextSpace) Sample(lowInclusive, highExclusive *Plaintext, prng io.Reader) (*Plaintext, error) <span class="cov8" title="1">{
        if lowInclusive == nil &amp;&amp; highExclusive == nil </span><span class="cov8" title="1">{
                sampled, err := (*num.ZMod)(pts).Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
                <span class="cov8" title="1">v, err := num.Z().FromUintSymmetric(sampled)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
                <span class="cov8" title="1">return &amp;Plaintext{
                        v: v,
                        n: pts.N(),
                }, nil</span>
        }
        <span class="cov8" title="1">if lowInclusive != nil &amp;&amp; highExclusive != nil </span><span class="cov8" title="1">{
                v, err := num.Z().Random(lowInclusive.Value(), highExclusive.Value(), prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err)
                }</span>
                <span class="cov8" title="1">return &amp;Plaintext{
                        v: v,
                        n: pts.N(),
                }, nil</span>
        }
        <span class="cov0" title="0">return nil, ErrInvalidRange.WithMessage("must either be closed or open interval sampling")</span>
}

// Contains returns true if the plaintext belongs to this plaintext space.
func (pts *PlaintextSpace) Contains(m *Plaintext) bool <span class="cov8" title="1">{
        return m != nil &amp;&amp; pts.N().Equal(m.N())
}</span>

// FromNat creates a plaintext from a constant-time natural number.
// The value is reduced modulo n and centred to the symmetric range.
func (pts *PlaintextSpace) FromNat(x *numct.Nat) (*Plaintext, error) <span class="cov8" title="1">{
        y, err := num.NewUintGivenModulus(x, pts.N().ModulusCT())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">z, err := num.Z().FromUintSymmetric(y)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return &amp;Plaintext{
                v: z,
                n: pts.N(),
        }, nil</span>
}

// FromBytes creates a plaintext from a byte slice.
// The bytes are interpreted as a big-endian unsigned integer.
func (pts *PlaintextSpace) FromBytes(b []byte) (*Plaintext, error) <span class="cov8" title="1">{
        var x numct.Nat
        if ok := x.SetBytes(b); ok == ct.False </span><span class="cov0" title="0">{
                return nil, errs2.New("failed to create nat from bytes")
        }</span>
        <span class="cov8" title="1">return pts.FromNat(&amp;x)</span>
}

// FromInt creates a plaintext from a constant-time signed integer.
// Returns an error if the value is outside the valid range [-n/2, n/2).
func (pts *PlaintextSpace) FromInt(x *numct.Int) (*Plaintext, error) <span class="cov8" title="1">{
        y, err := num.Z().FromIntCT(x)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if !y.IsInRangeSymmetric(pts.N()) </span><span class="cov0" title="0">{
                return nil, ErrInvalidRange.WithMessage("int is out of range for plaintext space")
        }</span>
        <span class="cov8" title="1">return &amp;Plaintext{
                v: y,
                n: pts.N(),
        }, nil</span>
}

// Plaintext represents a Paillier plaintext as a centred integer in [-n/2, n/2).
// This centred representation allows for both positive and negative values.
type Plaintext struct {
        v *num.Int
        n *num.NatPlus
}

// Normalise returns the plaintext value reduced to the range [0, n).
func (pt *Plaintext) Normalise() *num.Uint <span class="cov8" title="1">{
        return pt.v.Mod(pt.n)
}</span>

// Value returns the centred integer value of the plaintext.
func (pt *Plaintext) Value() *num.Int <span class="cov8" title="1">{
        return pt.v
}</span>

// ValueCT returns the plaintext value as a constant-time signed integer.
func (pt *Plaintext) ValueCT() *numct.Int <span class="cov8" title="1">{
        return pt.Value().Value()
}</span>

// N returns the modulus n of the plaintext.
func (pt *Plaintext) N() *num.NatPlus <span class="cov8" title="1">{
        return pt.n
}</span>

func (pt *Plaintext) isValid(x *Plaintext) <span class="cov8" title="1">{
        if x == nil </span><span class="cov0" title="0">{
                panic("cannot operate on nil centred plaintexts")</span>
        }
        <span class="cov8" title="1">if !pt.n.Equal(x.n) </span><span class="cov0" title="0">{
                panic("cannot operate on centred plaintexts with different moduli")</span>
        }
        <span class="cov8" title="1">if !x.v.IsInRangeSymmetric(pt.n) </span><span class="cov0" title="0">{
                panic("cannot operate on centred plaintexts with values out of range")</span>
        }
}

// Op performs the group operation on two plaintexts (addition modulo n).
func (pt *Plaintext) Op(other *Plaintext) *Plaintext <span class="cov8" title="1">{
        return pt.Add(other)
}</span>

// Add adds two plaintexts and returns the result reduced to the centred range.
func (pt *Plaintext) Add(other *Plaintext) *Plaintext <span class="cov8" title="1">{
        pt.isValid(other)
        out, err := num.Z().FromUintSymmetric(pt.v.Mod(pt.n).Add(other.v.Mod(other.n)))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;Plaintext{v: out, n: pt.n}</span>
}

// Equal returns true if two plaintexts have the same value.
func (pt *Plaintext) Equal(other *Plaintext) bool <span class="cov8" title="1">{
        return pt.Value().Equal(other.Value())
}</span>

// OpInv returns the additive inverse of the plaintext.
func (pt *Plaintext) OpInv() *Plaintext <span class="cov8" title="1">{
        return pt.Neg()
}</span>

// Neg returns the negation of the plaintext.
func (pt *Plaintext) Neg() *Plaintext <span class="cov8" title="1">{
        out, err := num.Z().FromUintSymmetric(pt.v.Mod(pt.n).Neg())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;Plaintext{v: out, n: pt.n}</span>
}

// Sub subtracts another plaintext from this one and returns the result.
func (pt *Plaintext) Sub(other *Plaintext) *Plaintext <span class="cov8" title="1">{
        pt.isValid(other)
        out, err := num.Z().FromUintSymmetric(pt.v.Mod(pt.n).Sub(other.v.Mod(other.n)))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;Plaintext{v: out, n: pt.n}</span>
}

// IsLessThanOrEqual returns true if this plaintext is less than or equal to another.
func (pt *Plaintext) IsLessThanOrEqual(other *Plaintext) bool <span class="cov8" title="1">{
        return other != nil &amp;&amp; pt.n.Equal(other.n) &amp;&amp; pt.v.IsLessThanOrEqual(other.v)
}</span>

// PartialCompare compares two plaintexts and returns their ordering.
// Returns Incomparable if the plaintexts have different moduli.
func (pt *Plaintext) PartialCompare(other *Plaintext) base.PartialOrdering <span class="cov8" title="1">{
        if other == nil || !pt.n.Equal(other.n) </span><span class="cov8" title="1">{
                return base.Incomparable
        }</span>
        <span class="cov8" title="1">return base.PartialOrdering(pt.v.Compare(other.v))</span>
}

// Bytes returns the plaintext value as a big-endian byte slice.
func (pt *Plaintext) Bytes() []byte <span class="cov8" title="1">{
        return pt.Value().Bytes()
}</span>
</pre>
		
		<pre class="file" id="file218" style="display: none">package bip340

import (
        "crypto/sha256"
        "hash"
)

const (
        auxTag       = "BIP0340/aux"
        nonceTag     = "BIP0340/nonce"
        challengeTag = "BIP0340/challenge"
)

// Hasher implements the BIP-340 tagged hash scheme using SHA-256.
// It prefixes the hash with SHA256(tag) || SHA256(tag) as specified in BIP-340.
type Hasher struct {
        hash.Hash

        tag string
}

var _ hash.Hash = (*Hasher)(nil)

// NewBip340Hash creates a new BIP-340 tagged hash with the given tag string.
func NewBip340Hash(tag string) hash.Hash <span class="cov0" title="0">{
        bip340Hash := &amp;Hasher{sha256.New(), tag}
        bip340Hash.Reset()
        return bip340Hash
}</span>

// NewBip340HashAux creates a new BIP-340 tagged hash for auxiliary randomness.
func NewBip340HashAux() hash.Hash <span class="cov0" title="0">{
        return NewBip340Hash(auxTag)
}</span>

// NewBip340HashNonce creates a new BIP-340 tagged hash for nonce generation.
func NewBip340HashNonce() hash.Hash <span class="cov0" title="0">{
        return NewBip340Hash(nonceTag)
}</span>

// NewBip340HashChallenge creates a new BIP-340 tagged hash for challenge computation.
func NewBip340HashChallenge() hash.Hash <span class="cov0" title="0">{
        return NewBip340Hash(challengeTag)
}</span>

// Reset resets the hash to its initial state with the tag prefix applied.
func (h *Hasher) Reset() <span class="cov0" title="0">{
        tagDigest := sha256.Sum256([]byte(h.tag))
        h.Hash.Reset()
        _, _ = h.Write(tagDigest[:])
        _, _ = h.Write(tagDigest[:])
}</span>
</pre>
		
		<pre class="file" id="file219" style="display: none">package hashing

import (
        "crypto/hmac"
        "encoding/binary"
        "hash"
        "slices"

        "golang.org/x/crypto/sha3"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing/kmac"
)

type (
        // KMACCustomizationString is a byte slice used as a domain separation string for KMAC operations.
        KMACCustomizationString = []byte
)

// Hash iteratively writes all the inputs to the given hash function and returns the result.
func Hash[H hash.Hash](hashFunc func() H, xs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        h := hashFunc()
        for i, x := range xs </span><span class="cov0" title="0">{
                if _, err := h.Write(x); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not write to hash for input %d", i)
                }</span>
        }
        <span class="cov0" title="0">digest := h.Sum(nil)
        return digest, nil</span>
}

// HashPrefixedLength hashes the inputs after encoding each with its index and length prefix.
// This encoding ensures that different input sequences produce distinct hash inputs.
func HashPrefixedLength[H hash.Hash](hashFunc func() H, xs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        h := hashFunc()
        _, err := h.Write(encodePrefixedLength(xs...))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not hash input")
        }</span>

        <span class="cov0" title="0">digest := h.Sum(nil)
        return digest, nil</span>
}

// HashChain computes an iterated hash where each input is hashed together with the previous output.
// It starts with a zero-initialised buffer and iteratively computes H(previous || input) for each input.
func HashChain[H hash.Hash](hashFunc func() H, xs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        h := hashFunc()
        var err error
        out := make([]byte, h.Size())
        for i, x := range xs </span><span class="cov0" title="0">{
                out, err = Hash(hashFunc, out, x)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not compute hash for input %d", i)
                }</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

// Hmac iteratively writes all the inputs to an hmac (defined by the hash function and the key) and returns the result.
func Hmac[H hash.Hash](key []byte, hashFunc func() H, xs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        hmacFunc := func() hash.Hash </span><span class="cov0" title="0">{ return hmac.New(HashFuncTypeErase(hashFunc), key) }</span>
        <span class="cov0" title="0">out, err := Hash(hmacFunc, xs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("computing hmac")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// HmacPrefixedLength computes an HMAC over the inputs after encoding each with its index and length prefix.
func HmacPrefixedLength[H hash.Hash](key []byte, hashFunc func() H, xs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        hmacFunc := func() hash.Hash </span><span class="cov0" title="0">{ return hmac.New(HashFuncTypeErase(hashFunc), key) }</span>
        <span class="cov0" title="0">out, err := HashPrefixedLength(hmacFunc, xs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("computing hmac")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// Kmac computes a KMAC (Keccak Message Authentication Code) over the inputs using a cSHAKE function.
// Tag sizes are 32 and 64 bytes when instantiated with cSHAKE128 and cSHAKE256, respectively.
// The key must be at least half the output size to meet the security level requirements.
func Kmac(key, customizationString []byte, h func(n, s []byte) sha3.ShakeHash, xs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        cShake := h([]byte("KMAC"), customizationString)
        if len(key) &lt; cShake.Size()/2 </span><span class="cov0" title="0">{
                return nil, kmac.ErrInvalidKeyLength.WithMessage("key length does not meet %d-bit security level", cShake.Size()*4)
        }</span>
        <span class="cov0" title="0">k := kmac.AbsorbPaddedKey(key, cShake.Size(), cShake)
        for _, x := range xs </span><span class="cov0" title="0">{
                _, err := k.Write(x)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not write into internal state")
                }</span>
        }
        <span class="cov0" title="0">return k.Sum(nil), nil</span>
}

// KmacPrefixedLength computes a KMAC over the inputs after encoding each with its index and length prefix.
func KmacPrefixedLength(key, customizationString []byte, h func(n, s []byte) sha3.ShakeHash, xs ...[]byte) ([]byte, error) <span class="cov0" title="0">{
        cShake := h([]byte("KMAC"), customizationString)
        if len(key) &lt; cShake.Size()/2 </span><span class="cov0" title="0">{
                return nil, kmac.ErrInvalidKeyLength.WithMessage("key length does not meet %d-bit security level", cShake.Size()*4)
        }</span>
        <span class="cov0" title="0">k := kmac.AbsorbPaddedKey(key, cShake.Size(), cShake)
        _, err := k.Write(encodePrefixedLength(xs...))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not write into internal state")
        }</span>
        <span class="cov0" title="0">return k.Sum(nil), nil</span>
}

// HashFuncTypeErase converts a generic hash constructor to a non-generic one returning hash.Hash.
// This is useful when interfacing with APIs that require func() hash.Hash, such as crypto/hmac.
func HashFuncTypeErase[H hash.Hash](hashFunc func() H) func() hash.Hash <span class="cov0" title="0">{
        return func() hash.Hash </span><span class="cov0" title="0">{
                return hashFunc()
        }</span>
}

func encodePrefixedLength(messages ...[]byte) []byte <span class="cov0" title="0">{
        output := []byte{}
        for i, message := range messages </span><span class="cov0" title="0">{
                encodedMessage := slices.Concat(toBytes32LE(int32(i)), toBytes32LE(int32(len(message))), message)
                output = slices.Concat(output, encodedMessage)
        }</span>
        <span class="cov0" title="0">return output</span>
}

func toBytes32LE(i int32) []byte <span class="cov0" title="0">{
        b := make([]byte, 4)
        binary.LittleEndian.PutUint32(b, uint32(i))
        return b
}</span>
</pre>
		
		<pre class="file" id="file220" style="display: none">package kmac

import (
        "encoding/binary"
        "hash"
        "slices"

        "golang.org/x/crypto/sha3"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

const (
        // See [1] (Sec 8.4.2).
        minimumTagSize = 8
)

// ErrInvalidKeyLength is returned when the key length does not meet the security strength requirements.
var ErrInvalidKeyLength = errs2.New("invalid key length")

// ErrInvalidTagSize is returned when the tag size is smaller than the minimum allowed.
var ErrInvalidTagSize = errs2.New("invalid tag size")

var _ hash.Hash = (*kmac)(nil)

type kmac struct {
        sha3.ShakeHash // cSHAKE context and Read/Write operations

        tagSize int // tag size

        // initBlock is the KMAC specific initialization set of bytes. It is initialised
        // by newKMAC function and stores the key, encoded by the method specified in 3.3 of [1].
        // It is stored here in order for Reset() to be able to put context into
        // initial state.
        initBlock []byte
}

// Bytepad pads the input to a multiple of w bytes as specified in NIST SP 800-185.
func Bytepad(input []byte, w int) []byte <span class="cov8" title="1">{
        buf := LeftEncode(uint64(w))
        buf = slices.Concat(buf, input)
        padlen := w - (len(buf) % w)
        return slices.Concat(buf, make([]byte, padlen))
}</span>

// LeftEncode encodes a non-negative integer with the length prefix on the left as specified in NIST SP 800-185.
func LeftEncode(value uint64) []byte <span class="cov8" title="1">{
        var b [9]byte
        binary.BigEndian.PutUint64(b[1:], value)
        // Trim all but last leading zero bytes
        i := byte(1)
        for i &lt; 8 &amp;&amp; b[i] == 0 </span><span class="cov8" title="1">{
                i++
        }</span>
        // Prepend number of encoded bytes
        <span class="cov8" title="1">b[i-1] = 9 - i
        return b[i-1:]</span>
}

// RightEncode encodes a non-negative integer with the length suffix on the right as specified in NIST SP 800-185.
func RightEncode(value uint64) []byte <span class="cov8" title="1">{
        var b [9]byte
        binary.BigEndian.PutUint64(b[:8], value)
        // Trim all but last leading zero bytes
        i := byte(0)
        for i &lt; 7 &amp;&amp; b[i] == 0 </span><span class="cov8" title="1">{
                i++
        }</span>
        // Append number of encoded bytes
        <span class="cov8" title="1">b[8] = 8 - i
        return b[i:]</span>
}

// AbsorbPaddedKey creates a KMAC instance by absorbing the padded key into the cSHAKE state.
func AbsorbPaddedKey(key []byte, tagSize int, c sha3.ShakeHash) hash.Hash <span class="cov8" title="1">{
        // absorb bytepad(encode_string(K), rate) into the internal state
        initBlock := slices.Concat(LeftEncode(uint64(len(key)*8)), key)
        k := &amp;kmac{ShakeHash: c, tagSize: tagSize, initBlock: initBlock}
        k.Write(Bytepad(k.initBlock, k.BlockSize()))
        return k
}</span>

// NewKMAC128 creates a new KMAC providing 128 bits of security.
func NewKMAC128(key []byte, tagSize int, customizationString []byte) (hash.Hash, error) <span class="cov8" title="1">{
        if len(key) &lt; 16 </span><span class="cov0" title="0">{
                return nil, ErrInvalidKeyLength.WithMessage("key length must not be smaller than 128-bit security strength")
        }</span>
        <span class="cov8" title="1">if tagSize &lt; minimumTagSize </span><span class="cov0" title="0">{
                return nil, ErrInvalidTagSize.WithMessage("tag size must be at least %d bytes", minimumTagSize)
        }</span>

        <span class="cov8" title="1">c := sha3.NewCShake128([]byte("KMAC"), customizationString)
        return AbsorbPaddedKey(key, tagSize, c), nil</span>
}

// NewKMAC256 creates a new KMAC providing 256 bits of security.
func NewKMAC256(key []byte, tagSize int, customizationString []byte) (hash.Hash, error) <span class="cov8" title="1">{
        if len(key) &lt; 32 </span><span class="cov0" title="0">{
                return nil, ErrInvalidKeyLength.WithMessage("key length must not be smaller than 256-bit security strength")
        }</span>
        <span class="cov8" title="1">if tagSize &lt; minimumTagSize </span><span class="cov0" title="0">{
                return nil, ErrInvalidTagSize.WithMessage("tag size must be at least %d bytes", minimumTagSize)
        }</span>

        <span class="cov8" title="1">c := sha3.NewCShake256([]byte("KMAC"), customizationString)
        return AbsorbPaddedKey(key, tagSize, c), nil</span>
}

func (k *kmac) Reset() <span class="cov8" title="1">{
        k.ShakeHash.Reset()
        k.Write(Bytepad(k.initBlock, k.BlockSize()))
}</span>

func (k *kmac) Size() int <span class="cov0" title="0">{
        return k.tagSize
}</span>

func (k *kmac) Sum(b []byte) []byte <span class="cov8" title="1">{
        clone := k.Clone()
        // absorb right_encode(L)
        clone.Write(RightEncode(uint64(k.tagSize * 8)))

        // squeeze tagSize bytes
        tag := make([]byte, k.tagSize)
        if _, err := clone.Read(tag); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return slices.Concat(b, tag)</span>
}
</pre>
		
		<pre class="file" id="file221" style="display: none">package poseidon

import (
        "math/big"

        "github.com/cronokirby/saferith"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta"
)

// Parameters contains the configuration for a Poseidon hash instance including
// round constants, MDS matrix, and other permutation parameters.
type Parameters struct {
        fullRounds, partialRounds, stateSize, rate, power int
        hashInitialRoundConstant                          bool
        roundConstants                                    [][]*pasta.PallasBaseFieldElement
        mds                                               [][]*pasta.PallasBaseFieldElement
}

// https://github.com/o1-labs/o1js-bindings/blob/df8c87ed6804465f79196fdff84e5147ae71e92d/crypto/constants.ts#L282
var poseidonParamsKimchiFp = &amp;Parameters{
        fullRounds:               55,
        partialRounds:            0,
        stateSize:                3,
        rate:                     2,
        power:                    7,
        hashInitialRoundConstant: true,
        // TODO: import these
        roundConstants: [][]*pasta.PallasBaseFieldElement{
                {
                        dec("21155079691556475130150866428468322463125560312786319980770950159250751855431"),
                        dec("16883442198399350202652499677723930673110172289234921799701652810789093522349"),
                        dec("17030687036425314703519085065002231920937594822150793091243263847382891822670"),
                },
                {
                        dec("25216718237129482752721276445368692059997901880654047883630276346421457427360"),
                        dec("9054264347380455706540423067244764093107767235485930776517975315876127782582"),
                        dec("26439087121446593160953570192891907825526260324480347638727375735543609856888"),
                },
                {
                        dec("15251000790817261169639394496851831733819930596125214313084182526610855787494"),
                        dec("10861916012597714684433535077722887124099023163589869801449218212493070551767"),
                        dec("18597653523270601187312528478986388028263730767495975370566527202946430104139"),
                },
                {
                        dec("15831416454198644276563319006805490049460322229057756462580029181847589006611"),
                        dec("15171856919255965617705854914448645702014039524159471542852132430360867202292"),
                        dec("15488495958879593647482715143904752785889816789652405888927117106448507625751"),
                },
                {
                        dec("19039802679983063488134304670998725949842655199289961967801223969839823940152"),
                        dec("4720101937153217036737330058775388037616286510783561045464678919473230044408"),
                        dec("10226318327254973427513859412126640040910264416718766418164893837597674300190"),
                },
                {
                        dec("20878756131129218406920515859235137275859844638301967889441262030146031838819"),
                        dec("7178475685651744631172532830973371642652029385893667810726019303466125436953"),
                        dec("1996970955918516145107673266490486752153434673064635795711751450164177339618"),
                },
                {
                        dec("15205545916434157464929420145756897321482314798910153575340430817222504672630"),
                        dec("25660296961552699573824264215804279051322332899472350724416657386062327210698"),
                        dec("13842611741937412200312851417353455040950878279339067816479233688850376089318"),
                },
                {
                        dec("1383799642177300432144836486981606294838630135265094078921115713566691160459"),
                        dec("1135532281155277588005319334542025976079676424839948500020664227027300010929"),
                        dec("4384117336930380014868572224801371377488688194169758696438185377724744869360"),
                },
                {
                        dec("21725577575710270071808882335900370909424604447083353471892004026180492193649"),
                        dec("676128913284806802699862508051022306366147359505124346651466289788974059668"),
                        dec("25186611339598418732666781049829183886812651492845008333418424746493100589207"),
                },
                {
                        dec("10402240124664763733060094237696964473609580414190944671778761753887884341073"),
                        dec("11918307118590866200687906627767559273324023585642003803337447146531313172441"),
                        dec("16895677254395661024186292503536662354181715337630376909778003268311296637301"),
                },
                {
                        dec("23818602699032741669874498456696325705498383130221297580399035778119213224810"),
                        dec("4285193711150023248690088154344086684336247475445482883105661485741762600154"),
                        dec("19133204443389422404056150665863951250222934590192266371578950735825153238612"),
                },
                {
                        dec("5515589673266504033533906836494002702866463791762187140099560583198974233395"),
                        dec("11830435563729472715615302060564876527985621376031612798386367965451821182352"),
                        dec("7510711479224915247011074129666445216001563200717943545636462819681638560128"),
                },
                {
                        dec("24694843201907722940091503626731830056550128225297370217610328578733387733444"),
                        dec("27361655066973784653563425664091383058914302579694897188019422193564924110528"),
                        dec("21606788186194534241166833954371013788633495786419718955480491478044413102713"),
                },
                {
                        dec("19934060063390905409309407607814787335159021816537006003398035237707924006757"),
                        dec("8495813630060004961768092461554180468161254914257386012937942498774724649553"),
                        dec("27524960680529762202005330464726908693944660961000958842417927307941561848461"),
                },
                {
                        dec("15178481650950399259757805400615635703086255035073919114667254549690862896985"),
                        dec("16164780354695672259791105197274509251141405713012804937107314962551600380870"),
                        dec("10529167793600778056702353412758954281652843049850979705476598375597148191979"),
                },
                {
                        dec("721141070179074082553302896292167103755384741083338957818644728290501449040"),
                        dec("22044408985956234023934090378372374883099115753118261312473550998188148912041"),
                        dec("27068254103241989852888872162525066148367014691482601147536314217249046186315"),
                },
                {
                        dec("3880429241956357176819112098792744584376727450211873998699580893624868748961"),
                        dec("17387097125522937623262508065966749501583017524609697127088211568136333655623"),
                        dec("6256814421247770895467770393029354017922744712896100913895513234184920631289"),
                },
                {
                        dec("2942627347777337187690939671601251987500285937340386328746818861972711408579"),
                        dec("24031654937764287280548628128490074801809101323243546313826173430897408945397"),
                        dec("14401457902976567713827506689641442844921449636054278900045849050301331732143"),
                },
                {
                        dec("20170632877385406450742199836933900257692624353889848352407590794211839130727"),
                        dec("24056496193857444725324410428861722338174099794084586764867109123681727290181"),
                        dec("11257913009612703357266904349759250619633397075667824800196659858304604714965"),
                },
                {
                        dec("22228158921984425749199071461510152694025757871561406897041788037116931009246"),
                        dec("9152163378317846541430311327336774331416267016980485920222768197583559318682"),
                        dec("13906695403538884432896105059360907560653506400343268230130536740148070289175"),
                },
                {
                        dec("7220714562509721437034241786731185291972496952091254931195414855962344025067"),
                        dec("27608867305903811397208862801981345878179337369367554478205559689592889691927"),
                        dec("13288465747219756218882697408422850918209170830515545272152965967042670763153"),
                },
                {
                        dec("8251343892709140154567051772980662609566359215743613773155065627504813327653"),
                        dec("22035238365102171608166944627493632660244312563934708756134297161332908879090"),
                        dec("13560937766273321037807329177749403409731524715067067740487246745322577571823"),
                },
                {
                        dec("21652518608959234550262559135285358020552897349934571164032339186996805408040"),
                        dec("22479086963324173427634460342145551255011746993910136574926173581069603086891"),
                        dec("13676501958531751140966255121288182631772843001727158043704693838707387130095"),
                },
                {
                        dec("5680310394102577950568930199056707827608275306479994663197187031893244826674"),
                        dec("25125360450906166639190392763071557410047335755341060350879819485506243289998"),
                        dec("22659254028501616785029594492374243581602744364859762239504348429834224676676"),
                },
                {
                        dec("23101411405087512171421838856759448177512679869882987631073569441496722536782"),
                        dec("24149774013240355952057123660656464942409328637280437515964899830988178868108"),
                        dec("5782097512368226173095183217893826020351125522160843964147125728530147423065"),
                },
                {
                        dec("13540762114500083869920564649399977644344247485313990448129838910231204868111"),
                        dec("20421637734328811337527547703833013277831804985438407401987624070721139913982"),
                        dec("7742664118615900772129122541139124149525273579639574972380600206383923500701"),
                },
                {
                        dec("1109643801053963021778418773196543643970146666329661268825691230294798976318"),
                        dec("16580663920817053843121063692728699890952505074386761779275436996241901223840"),
                        dec("14638514680222429058240285918830106208025229459346033470787111294847121792366"),
                },
                {
                        dec("17080385857812672649489217965285727739557573467014392822992021264701563205891"),
                        dec("26176268111736737558502775993925696791974738793095023824029827577569530708665"),
                        dec("4382756253392449071896813428140986330161215829425086284611219278674857536001"),
                },
                {
                        dec("13934033814940585315406666445960471293638427404971553891617533231178815348902"),
                        dec("27054912732979753314774418228399230433963143177662848084045249524271046173121"),
                        dec("28916070403698593376490976676534962592542013020010643734621202484860041243391"),
                },
                {
                        dec("24820015636966360150164458094894587765384135259446295278101998130934963922381"),
                        dec("7969535238488580655870884015145760954416088335296905520306227531221721881868"),
                        dec("7690547696740080985104189563436871930607055124031711216224219523236060212249"),
                },
                {
                        dec("9712576468091272384496248353414290908377825697488757134833205246106605867289"),
                        dec("12148698031438398980683630141370402088785182722473169207262735228500190477924"),
                        dec("14359657643133476969781351728574842164124292705609900285041476162075031948227"),
                },
                {
                        dec("23563839965372067275137992801035780013422228997724286060975035719045352435470"),
                        dec("4184634822776323233231956802962638484057536837393405750680645555481330909086"),
                        dec("16249511905185772125762038789038193114431085603985079639889795722501216492487"),
                },
                {
                        dec("11001863048692031559800673473526311616702863826063550559568315794438941516621"),
                        dec("4702354107983530219070178410740869035350641284373933887080161024348425080464"),
                        dec("23751680507533064238793742311430343910720206725883441625894258483004979501613"),
                },
                {
                        dec("28670526516158451470169873496541739545860177757793329093045522432279094518766"),
                        dec("3568312993091537758218792253361873752799472566055209125947589819564395417072"),
                        dec("1819755756343439646550062754332039103654718693246396323207323333948654200950"),
                },
                {
                        dec("5372129954699791301953948907349887257752247843844511069896766784624930478273"),
                        dec("17512156688034945920605615850550150476471921176481039715733979181538491476080"),
                        dec("25777105342317622165159064911913148785971147228777677435200128966844208883059"),
                },
                {
                        dec("25350392006158741749134238306326265756085455157012701586003300872637887157982"),
                        dec("20096724945283767296886159120145376967480397366990493578897615204296873954844"),
                        dec("8063283381910110762785892100479219642751540456251198202214433355775540036851"),
                },
                {
                        dec("4393613870462297385565277757207010824900723217720226130342463666351557475823"),
                        dec("9874972555132910032057499689351411450892722671352476280351715757363137891038"),
                        dec("23590926474329902351439438151596866311245682682435235170001347511997242904868"),
                },
                {
                        dec("17723373371137275859467518615551278584842947963894791032296774955869958211070"),
                        dec("2350345015303336966039836492267992193191479606566494799781846958620636621159"),
                        dec("27755207882790211140683010581856487965587066971982625511152297537534623405016"),
                },
                {
                        dec("6584607987789185408123601849106260907671314994378225066806060862710814193906"),
                        dec("609759108847171587253578490536519506369136135254150754300671591987320319770"),
                        dec("28435187585965602110074342250910608316032945187476441868666714022529803033083"),
                },
                {
                        dec("16016664911651770663938916450245705908287192964254704641717751103464322455303"),
                        dec("17551273293154696089066968171579395800922204266630874071186322718903959339163"),
                        dec("20414195497994754529479032467015716938594722029047207834858832838081413050198"),
                },
                {
                        dec("19773307918850685463180290966774465805537520595602496529624568184993487593855"),
                        dec("24598603838812162820757838364185126333280131847747737533989799467867231166980"),
                        dec("11040972566103463398651864390163813377135738019556270484707889323659789290225"),
                },
                {
                        dec("5189242080957784038860188184443287562488963023922086723850863987437818393811"),
                        dec("1435203288979376557721239239445613396009633263160237764653161500252258220144"),
                        dec("13066591163578079667911016543985168493088721636164837520689376346534152547210"),
                },
                {
                        dec("17345901407013599418148210465150865782628422047458024807490502489711252831342"),
                        dec("22139633362249671900128029132387275539363684188353969065288495002671733200348"),
                        dec("1061056418502836172283188490483332922126033656372467737207927075184389487061"),
                },
                {
                        dec("10241738906190857416046229928455551829189196941239601756375665129874835232299"),
                        dec("27808033332417845112292408673209999320983657696373938259351951416571545364415"),
                        dec("18820154989873674261497645724903918046694142479240549687085662625471577737140"),
                },
                {
                        dec("7983688435214640842673294735439196010654951226956101271763849527529940619307"),
                        dec("17067928657801807648925755556866676899145460770352731818062909643149568271566"),
                        dec("24472070825156236829515738091791182856425635433388202153358580534810244942762"),
                },
                {
                        dec("25752201169361795911258625731016717414310986450004737514595241038036936283227"),
                        dec("26041505376284666160132119888949817249574689146924196064963008712979256107535"),
                        dec("23977050489096115210391718599021827780049209314283111721864956071820102846008"),
                },
                {
                        dec("26678257097278788410676026718736087312816016749016738933942134600725962413805"),
                        dec("10480026985951498884090911619636977502506079971893083605102044931823547311729"),
                        dec("21126631300593007055117122830961273871167754554670317425822083333557535463396"),
                },
                {
                        dec("1564862894215434177641156287699106659379648851457681469848362532131406827573"),
                        dec("13247162472821152334486419054854847522301612781818744556576865965657773174584"),
                        dec("8673615954922496961704442777870253767001276027366984739283715623634850885984"),
                },
                {
                        dec("2794525076937490807476666942602262298677291735723129868457629508555429470085"),
                        dec("4656175953888995612264371467596648522808911819700660048695373348629527757049"),
                        dec("23221574237857660318443567292601561932489621919104226163978909845174616477329"),
                },
                {
                        dec("1878392460078272317716114458784636517603142716091316893054365153068227117145"),
                        dec("2370412714505757731457251173604396662292063533194555369091306667486647634097"),
                        dec("17409784861870189930766639925394191888667317762328427589153989811980152373276"),
                },
                {
                        dec("25869136641898166514111941708608048269584233242773814014385564101168774293194"),
                        dec("11361209360311194794795494027949518465383235799633128250259863567683341091323"),
                        dec("14913258820718821235077379851098720071902170702113538811112331615559409988569"),
                },
                {
                        dec("12957012022018304419868287033513141736995211906682903915897515954290678373899"),
                        dec("17128889547450684566010972445328859295804027707361763477802050112063630550300"),
                        dec("23329219085372232771288306767242735245018143857623151155581182779769305489903"),
                },
                {
                        dec("1607741027962933685476527275858938699728586794398382348454736018784568853937"),
                        dec("2611953825405141009309433982109911976923326848135736099261873796908057448476"),
                        dec("7372230383134982628913227482618052530364724821976589156840317933676130378411"),
                },
                {
                        dec("20203606758501212620842735123770014952499754751430660463060696990317556818571"),
                        dec("4678361398979174017885631008335559529633853759463947250620930343087749944307"),
                        dec("27176462634198471376002287271754121925750749676999036165457559387195124025594"),
                },
                {
                        dec("6361981813552614697928697527332318530502852015189048838072565811230204474643"),
                        dec("13815234633287489023151647353581705241145927054858922281829444557905946323248"),
                        dec("10888828634279127981352133512429657747610298502219125571406085952954136470354"),
                },
        },
        mds: [][]*pasta.PallasBaseFieldElement{
                {
                        dec("12035446894107573964500871153637039653510326950134440362813193268448863222019"),
                        dec("25461374787957152039031444204194007219326765802730624564074257060397341542093"),
                        dec("27667907157110496066452777015908813333407980290333709698851344970789663080149"),
                },
                {
                        dec("4491931056866994439025447213644536587424785196363427220456343191847333476930"),
                        dec("14743631939509747387607291926699970421064627808101543132147270746750887019919"),
                        dec("9448400033389617131295304336481030167723486090288313334230651810071857784477"),
                },
                {
                        dec("10525578725509990281643336361904863911009900817790387635342941550657754064843"),
                        dec("27437632000253211280915908546961303399777448677029255413769125486614773776695"),
                        dec("27566319851776897085443681456689352477426926500749993803132851225169606086988"),
                },
        },
}

// https://github.com/o1-labs/o1js-bindings/blob/df8c87ed6804465f79196fdff84e5147ae71e92d/crypto/constants.ts#L584
var poseidonParamsLegacyFp = &amp;Parameters{
        fullRounds:               63,
        partialRounds:            0,
        hashInitialRoundConstant: true,
        stateSize:                3,
        rate:                     2,
        power:                    5,
        roundConstants: [][]*pasta.PallasBaseFieldElement{
                {
                        dec("1346081094044643970582493287085428191977688221215786919106342366360741041016"),
                        dec("10635969173348128974923358283368657934408577270968219574411363948927109531877"),
                        dec("18431955373344919956072236142080066866861234899777299873162413437379924987003"),
                },
                {

                        dec("5797044060651575840084283729791357462720161727701814038830889113712361837236"),
                        dec("931288489507796144596974766082847744938192694315568692730730202141894005205"),
                        dec("13659894470945121760517769979107966886673294523737498361566285362771110125394"),
                },
                {
                        dec("6076231707445968054305995680347976771585015308155855387339303513025362636128"),
                        dec("28822740034050339685362260108484262889265034407340240070058997651710236456303"),
                        dec("23420266473857869790486107029614186913447272961845992963194006142267563993493"),
                },
                {
                        dec("13753917374184785903125509246122783296344288469304898921025291716613575849357"),
                        dec("22396739346703340038555577564698139382745239004673153148674304627904081092826"),
                        dec("13064238335532551154986111986409392866270911640785653458047811526842088084911"),
                },
                {
                        dec("23165923875642452719095776619341762858050322341374771345641255745672274104746"),
                        dec("1876216571769482372914291210815859835162659440705283782713345335434924136736"),
                        dec("25448252060136178247213604035267580231762596830634036926922217427938159849142"),
                },
                {
                        dec("2161875315509206970842862195937323600322108268401381254431163181777726747153"),
                        dec("19159855698625842998331760283165907305622417625829203038229273729196960321630"),
                        dec("24828563875172432296791053766778475681869974948122169083176331088266823626561"),
                },
                {
                        dec("15959479662608710141128458274961057999257961784282074767105536637788386907463"),
                        dec("8006369581283017287449277389162056290714176164680299906116833200510117952858"),
                        dec("18794336794618132129607701188430371953320538976527988886453665523008714542779"),
                },
                {
                        dec("19408271715954593722501381885401160867835377473312521553027032015227895029571"),
                        dec("13654747284005184272412579731446984220568337794941823533879059135026064413631"),
                        dec("14094055032353750931629930778481002727722804310855727808905931659115939920989"),
                },
                {
                        dec("13241818625838429282823260827177433104574315653706102174619924764342778921524"),
                        dec("25709259239494174564705048436260891089407557689981668111890003079561388887725"),
                        dec("26866626910239634723971078462134580196819809568632305020800296809092442642381"),
                },
                {
                        dec("23886826350713085163238005260075062110062681905356997481925492650252417143049"),
                        dec("16853602711255261520713463306790360324679500458440235992292027384928526778856"),
                        dec("18444710386168488194610417945072711530390091945738595259171890487504771614189"),
                },
                {
                        dec("16896789009769903615328691751424474161656500693270070895928499575572871141439"),
                        dec("23842266984616972287898037872537536999393060934879414668030219493005225085992"),
                        dec("24369698563802298585444760814856330583118549706483939267059237951238240608187"),
                },
                {
                        dec("25360195173713628054110426524260405937218170863260484655473435413697869858790"),
                        dec("1486437708678506228822038923353468635394979165769861487132708983207562337116"),
                        dec("18653498960429911228442559598959970807723487073275324556015861725806677047150"),
                },
                {
                        dec("18878179044241268037057256060083772636369783391816038647949347814518015576522"),
                        dec("178715779905629247116805974152863592571182389085419970371289655361443016848"),
                        dec("8381006794425876451998903949255801618132578446062133243427381291481465852184"),
                },
                {
                        dec("4176946262813877719206528849579392120806054050640974718891398605746592169324"),
                        dec("16376345520728802444699629729684297833862527190772376028981704525651968727081"),
                        dec("8399065769082251057361366626601550736334213197703006866551331927128775757919"),
                },
                {
                        dec("15435308585611812393531506745122614542196708285088622615406141986333182280857"),
                        dec("4082259282787276939431186930090898350392871145699460879678141552997816391817"),
                        dec("26348742719959309014730178326877937464605873211235784184917342950648457078699"),
                },
                {
                        dec("9707631711734344681918469569872517425107158187591261754498805460753455298868"),
                        dec("27910768846011709391567916011595957279088224137468948238696800459136335473132"),
                        dec("20407239095656434708569263842372155762970847207558227886302782130015730063802"),
                },
                {
                        dec("22726225412881182965250630589245572283256255052470345984553083359461473893802"),
                        dec("12443967854426795490638709950679156338200426963050610832781263082981525248175"),
                        dec("27102543658848146076219989119639465430524061997280788166887046421706499775415"),
                },
                {
                        dec("14427224233985680214097547669945064793149553513421479297921556194475574770861"),
                        dec("22917454832925781549840198815703114840452733537799472739275668965081704937832"),
                        dec("3455076056123630366063931123762198941796412458154689469887583689725886013901"),
                },
                {
                        dec("4513100023937785913596662867311227004762025658663076805918211014066645403017"),
                        dec("18187619530784075723418065322038024507729605774832001333883311123910954334059"),
                        dec("9447065431426150382325592560406989926365684509675374414068135115024495130938"),
                },
                {
                        dec("3227816098015819796753427754968234889554095489076864339942014527747604603014"),
                        dec("14798316759185072116520458171957899889489461918408669809912344751222514418582"),
                        dec("23013904852315603905843158448056763116188801262838729536210355401378476650033"),
                },
                {
                        dec("20979191509934291452182967564058656088941447895799901211038858159903580333267"),
                        dec("20772973010251235271448378823573767262405703078344288856168565499702414379868"),
                        dec("10105446427739226002497411811738001382334316505480517822035303561899927603685"),
                },
                {
                        dec("11079074761356717003579108002319997196881121172538617046865136940931215263187"),
                        dec("4693927775411489288330326150094711670434597808961717172753867514688725690438"),
                        dec("18581720304902876944842830383273503265470859268712618325357902881821721540119"),
                },
                {
                        dec("3065369948183164725765083504606321683481629263177690053939474679689088169185"),
                        dec("18515622379147081456114962668688706121098539582467584736624699157043365677487"),
                        dec("17563088600719312877716085528177751048248154461245613291986010180187238198006"),
                },
                {
                        dec("26199746176994924146211004840756471702409132230831594954444947705902602287290"),
                        dec("7576136600627345523051497639367002272003104458453478964661395239732811642605"),
                        dec("20058687874612168338994287374025378897088936171250328231848098497610185784281"),
                },
                {
                        dec("16894722532414195606958290526999761110785277556463400588047573469106594850228"),
                        dec("13961730805696859614283621225672002906734926278118993580398533742874863598733"),
                        dec("25256842011135514243352951950573936602906198374305137963222382546140030647211"),
                },
                {
                        dec("18530360047537856737482157200091774590035773602620205695980247565433703032532"),
                        dec("23014819965938599260086897799541446473887833964178378497976832161473586995397"),
                        dec("27911426213258307990762460361663504655967992659180759140364181941291843542489"),
                },
                {
                        dec("1067338118323302017358103178057182291035336430305886255160210378977812067042"),
                        dec("17219092885519007424608854460610388434712113621163885775309496940189894433620"),
                        dec("16432921127615937542183846559291144733339643093361323334499888895135356545408"),
                },
                {
                        dec("28608851042959977114787048070153637607786033079364369200270218128830983558707"),
                        dec("10121629780013165888398831090128011045011860641816380162950736555305748332191"),
                        dec("2348036340843128746981122630521268144839343500596932561106759754644596320722"),
                },
                {
                        dec("16619881370356823200358060093334065394764987467483650323706184068451904156452"),
                        dec("2302436627861989749837563733434625231689351276818486757748445924305258835336"),
                        dec("27514536540953539473280001431110316405453388911725550380123851609652679788049"),
                },
                {
                        dec("9459277727420672604737117687200019308525004979918488827092207438664125039815"),
                        dec("23425670740358068509956137586663046763224562225383386726193078231034380596217"),
                        dec("7641885067011661443791509688937280323563328029517832788240965464798835873658"),
                },
                {
                        dec("9579420382351699601929202663836555665702024548386778299996961509578687980280"),
                        dec("18513671386572584282611234979588379470994484682444053600751415262497237017703"),
                        dec("24923151431234706142737221165378041700050312199585085101919834422744926421604"),
                },
                {
                        dec("21131320841803068139502705966375283830095161079635803028011171241658723560073"),
                        dec("19208476595309656066589572658712717685014329237892885950958199953675225096566"),
                        dec("24023185216737416080949689106968568821656545490748664446389634158498624398204"),
                },
                {
                        dec("7510552996848634969347937904645640209946785877619890235458182993413526028718"),
                        dec("3694415017252995094553868781762548289196990492336482360084813900937464847638"),
                        dec("9219021070107873028263141554048987416559034633883158827414043929220388719352"),
                },
                {
                        dec("5058327241234443421111591959922712922949620710493120384930391763032694640881"),
                        dec("13148252221647574076185511663661016015859769210867362839817254885265598775418"),
                        dec("15186790492457240277904880519227706403545816456632095870015828239411033220638"),
                },
                {
                        dec("2775942914650502409705888572245750999561427024488403026572311267798009048466"),
                        dec("6277965230841030155341171319927732572492215818164736949144854827643964384893"),
                        dec("24144742149845235561087977558785057713814731737434473021812189457617252043745"),
                },
                {
                        dec("25789129719327437503403457598813971826156253950521984610569937361506914183550"),
                        dec("21500534320778995945845999974779950304491968082325255355181901574840373597824"),
                        dec("17185359848218837018503091932245529880546896465437232425673134558221638601375"),
                },
                {
                        dec("12253896579078110143384981818031883112606762215016553811786428215758384195713"),
                        dec("12956658260778456372481429232709881794962204180363200699121804724437678625542"),
                        dec("3023603786717368708677300377055384474816569333060487675635618249403832078921"),
                },
                {
                        dec("4186492855716808019562789862833898284927736051002588766326482010810259565130"),
                        dec("4263939782228419774639068267872291539552889472311225829898746091327730032923"),
                        dec("24068843626280451423530509388397151179174104901782990365720205643492047328816"),
                },
                {
                        dec("14564937827374621319716285527475223392664010281568256859627186463065876537730"),
                        dec("28367596550218705971881480694115935470211319172596432472834880507822452927283"),
                        dec("28712267437482356021504544448225827500268648754270274754623969882031853409874"),
                },
                {
                        dec("4542596163006916397403529184431773692747461300288194722982487051249951403191"),
                        dec("2530461821259252672899452671728393208543894014761816288817584587718369998371"),
                        dec("12886393063011539390567049190923398676964700147222878509238966758839020897414"),
                },
                {
                        dec("21593897590707514492037699253654745501762191795293908682495110982956631870528"),
                        dec("13233005790593128135480716846773978578237145313006994631606474472023504621256"),
                        dec("21621863098292803642478350494794106282518362577273973885587684567452726939909"),
                },
                {
                        dec("26068620073001644720969640099644251616742620988609091568084348314770436291745"),
                        dec("18248589586787935500122854210401321966459127818593446990365211078521058875685"),
                        dec("21247134484403265289037859533347798468858819117600251067578809852124865474448"),
                },
                {
                        dec("7947383127165915366383984718363902897504221803836013123394785749404572432524"),
                        dec("22173041014621867335598230447618036223462011647696367239478182269973488867154"),
                        dec("16773227734018849308448505860847939069870370055633571816925675705713088305139"),
                },
                {
                        dec("10708707957340055662073314227607620808612686977606082605219160019699644826999"),
                        dec("21249897193797038261479589555720746994050836195265348846222835266344091683000"),
                        dec("12581195059139097540117398803363514148192715293133623516709277290477633379593"),
                },
                {
                        dec("19779599816866992123290302397082614570282926215253589712189610064229996603178"),
                        dec("21749216503901548676985371189807470207364320167486559936962401093285243029177"),
                        dec("17600045923623503357380202389718735904174992978547372448837488832457719009224"),
                },
                {
                        dec("2732872979548118117758016335601225525660858727422778256671975055129965858636"),
                        dec("13703031005128062046175331918702218558750713240446179585947851411173844703597"),
                        dec("28447710105386636841938034820015573492556750872924193415447818187228356409281"),
                },
                {
                        dec("28539960355005748517007309210788803416171161412204526246799800716567376494244"),
                        dec("21329318452221893900731030722137844458345358926323127858742388587761302609863"),
                        dec("28135302149599894709369178097439582767613940517471323224020113411362601191873"),
                },
                {
                        dec("24980774120400248734054527936006392540889095705961960837980443629260392758683"),
                        dec("20339911045808632098936066397942175169549806052128535543540543556255197716643"),
                        dec("7929293103930252545581851978492699598413941396422930641071359388697302362494"),
                },
                {
                        dec("8911092207145893152276662096451247820054843777071569723455408545101628926203"),
                        dec("19648860643145256523615441075182036100116634560394529500146405733687718224516"),
                        dec("14635387208623683806428528837466762532853903031263830054986064902455379735903"),
                },
                {
                        dec("11555212214346132926966321609673228184079851030522218543981385635403167028692"),
                        dec("20896918157639814425520058178561910811657326967880217845710779511927814874973"),
                        dec("4650158165912007049140499755153804318686705949436165235742106170124284287326"),
                },
                {
                        dec("13880660273492757167295696447853232191657893303250187467329180558670697369810"),
                        dec("8043529172463774320604378774840863923445982272478964686447801046272917236836"),
                        dec("2134399296482715903442913099374581981696436050603410080564843555725771329441"),
                },
                {
                        dec("27320952903412641133501507962185246982787769547770982814240701526492601978122"),
                        dec("23417491374379751329394424924400186404791519133465537872457405970098902747611"),
                        dec("17612427354278346772575179176139417348059847375297761006336024476146551185903"),
                },
                {
                        dec("10710998507064742997612080847223278109404482930427999113323732519626499166548"),
                        dec("14958094513415797513745395709487730603918953350067504982704138489305723550923"),
                        dec("24096319595904213497633343966229498735553590589105811393277073274927955202995"),
                },
                {
                        dec("17983724131200292654039765185049138356840415443160477259330748730019147254309"),
                        dec("17598096800487588874709548646068838880468456205252324677357706597166777506441"),
                        dec("27420647821110229619898200875848631488422182349567475956209153112306555222281"),
                },
                {
                        dec("448538544835457571662601142415301047108854812427100562339376187510452313026"),
                        dec("23494184556634922103535803143214434479598067155171780264810485708203176455201"),
                        dec("22626342941879801989161990529511235538216563009907378573817996229389756621777"),
                },
                {
                        dec("26128268137723417163973860961686381960826033145738852158792607959175787222856"),
                        dec("20225791828042873305317281581105429726352058325970107209484198122707862156597"),
                        dec("7538871133759632802857159609785118198934349221046986784429069814655215585732"),
                },
                {
                        dec("26184554861259642274153262777073624024579929401668865520166966302070394487366"),
                        dec("28755259264665180745537307265993667261709206143628938749669440804401623257679"),
                        dec("11896066093033549470312328497237649508068258723531931099214795928200015717321"),
                },
                {
                        dec("21657721599978732693249012287058163532690942515202465984736373311077240614059"),
                        dec("9214914097169852704753116653702415951907628005986883140609006971322091003693"),
                        dec("18710111680849814325169297240208687402588261569152088592693815711857504371037"),
                },
                {
                        dec("6813635166770764528979084175325709935892248249948967889926276426090222296643"),
                        dec("20546585456429436268067726231902751119458200511988152296570567167520382569278"),
                        dec("20087466019194902429054761607398988292568594301671509779549344754172952693871"),
                },
                {
                        dec("28185105286740691904534067831357491310995891986363455251895371651360605333143"),
                        dec("10108348212894231193041286244259038275269464277821588425688314560368589986063"),
                        dec("11433633215392393209829215018579238412423821563056156785641278458497271271546"),
                },
                {
                        dec("27870881917195016999862550657996865268956893566432995492427618003637597051321"),
                        dec("102309803677783876701097881491240456320211833502658383473112057006867019389"),
                        dec("22844040227595875612525628393174357057929113317578127744718774517498324646590"),
                },
                {
                        dec("18364790233947478619325319418813215212267974311771564959136180502266118026133"),
                        dec("2480624341921718230432383518425561514824501138863702825916674641657321180841"),
                        dec("16778939567530361665956758171503829349658551798564323167725356065198936433124"),
                },
                {
                        dec("11947564511486966895926950599696532964589539443187518177489990556481125699966"),
                        dec("3133187646540385483015602955087323554103587039123577645562801570574691666057"),
                        dec("27704797101265438206569218421707753788081674727344603874614391656565567951541"),
                },
                {
                        dec("13001484695584753475562184349533365512515447041450030471627087395341039487710"),
                        dec("477322000667279478600757543806155989948171541982639893984064422067850617496"),
                        dec("13913755821658634147813329813115566967428755223601185963529801459396673113438"),
                },
                {
                        dec("16621869429023470107454028095846067937827722393398508604914831452950874033411"),
                        dec("21755744236927410239079501831014076529931327263341620300431356747367343619046"),
                        dec("26538666591151124505694487799121414506088199961481579132019627484065014831180"),
                },
                {
                        dec("3066480818457008068617042549071052338581291837882909165666223566402713429090"),
                        dec("16182268213934119294035309949459684472027705439038023775276926916166831108357"),
                        dec("28907604876608422892474268478706783033050951245339691569015166507728369585190"),
                },
                {
                        dec("27973960109508292680965426133498827831691369851701664449575719912259359998113"),
                        dec("1456924360278399121996742356757866616312146358469991014696110099534285524446"),
                        dec("8234248752911525485438611255163504976087091103090603316695312869292347668495"),
                },
                {
                        dec("8716078950082339630026654067608811496722305720644485560320987802533380421009"),
                        dec("19016744645809919602099479306503354923553336014593353020688463619133130053825"),
                        dec("24379650661051444982012238084495990858827340608012118841005379796362233056432"),
                },
                {
                        dec("2245379544097631382062919677963998259142792890502492881341386639439507471783"),
                        dec("28788137434161061988371619554419440748189388934884757179010092973102292086583"),
                        dec("7187000185648741287953633167647835668543536354944774631102766873251849991238"),
                },
                {
                        dec("18319349500538500800225762827448369057030532278398270164660609327776487168142"),
                        dec("2622932985948021877314529887962683530522545893985767148345336304947201715671"),
                        dec("13805188629797792210337544360632964855143280581052079479249966961215582531026"),
                },
                {
                        dec("27457600993464082637917106210690168172469473943609357897393615707457194410878"),
                        dec("15448646156961779103834447043970817898237835202826003934642165760908058355399"),
                        dec("9396792545729486882231669677795667529746274932273033601723318032992363022062"),
                },
                {
                        dec("9927877141952679457141759789181418464292082444806533413864151258248124544859"),
                        dec("23827901395971835838179844085051957393677906360196119690926757794561937573142"),
                        dec("3273544693673216914876067527455588276979859627093391584406340272737391174619"),
                },
                {
                        dec("19571510438350300564152393820251652609646082150148656806391655428002614034315"),
                        dec("4458840243585913642400750597703353770666314833058197517675446022682775625834"),
                        dec("6452218213610300363069953741424106105609715382419342511693148495219793324457"),
                },
                {
                        dec("14558167930891460678441266912176752652821641543245953113671886345167213541771"),
                        dec("10650967986920075561478528461783351160938460620955779955379459848889204404950"),
                        dec("19990009778942542934049216419052172134625404062770188357110708518621145688588"),
                },
                {
                        dec("26855242974447190235826233682457047761532515293146087151296725996543442567035"),
                        dec("22785340043356532865086769889360674409753343398766563441587096485751538658065"),
                        dec("28603049427449348335651629195385434188071937908693764500052489540779792538285"),
                },
                {
                        dec("20545812864989828913452616721240947168977365844984763819184465128164378967167"),
                        dec("23234068381345797209897730226956922073109641728569353961504167817770340037954"),
                        dec("26031714567641615877877111172701145299483019910006153132858512509897185854695"),
                },
                {
                        dec("9512221744061419790435674197238913998387834650389922233458121639503195504983"),
                        dec("12587458000103271975978240683793268604398305885278203470492658961734100340536"),
                        dec("9670291694005369437277651504604785512303147991710650505302465204429311229197"),
                },
                {
                        dec("26995526763045548800439747262386290359229145489609341602564040676717570935439"),
                        dec("23742712112104280264401317024221734961713400615669958343926511931219510484675"),
                        dec("27931469778579449247589315744656633392873808631802461175539563849884447358271"),
                },
                {
                        dec("20669006894143187877081688942720159738269397552445286314270368345994751825389"),
                        dec("26891772301075275370472640177651637211280740381619976926886106618375467277414"),
                        dec("28387986011980449959047232529988203397251084614417760995257355718700961696092"),
                },
                {
                        dec("6579105010484741592730389416372694666279917604793318157514380025250233913402"),
                        dec("11007035767869292700964744408562802781669930023548892567535397874932420229930"),
                        dec("981148366863906885900456473323410468923514528856216824044152942069412627408"),
                },
                {
                        dec("22213671088722307302576907504985884923571642958053627659840326928319445671280"),
                        dec("1318836216310789598614608105109389429335273432455224127576823891011367206122"),
                        dec("25586582796990779718352441955439394949194222626688223867952982491529809559257"),
                },
                {

                        dec("4923739488579452777913681531125585976446366144127161879759262506690369040090"),
                        dec("23505612338866210737103599484620591026802005128655081877133994175016351514827"),
                        dec("323887003859465324514901860965142186539600668250760639664361851354147799637"),
                },
                {
                        dec("10198923064967306784017949469108033682156920551672348936591491217255268794658"),
                        dec("9593680688139131432883442351722730169325112619984238956948153423155998917175"),
                        dec("27027988263960602112273050725720071355535922812577299127302015348825197871870"),
                },
                {
                        dec("14419883951157390867695097127684346981136020111885301573583640959136319507752"),
                        dec("5104414988075833278683649298543440897371415916271358703850262680431809374355"),
                        dec("24739655595299332818980677669648719986462429574612913501586844601377825836782"),
                },
                {
                        dec("28522818684103966731129743408029731246564480741348128436668680764518115102581"),
                        dec("21520350704208288978690888796633940487888044365108767319141211249242880355961"),
                        dec("17391005598311948834360476853940353239444383292422171321575043660157438608537"),
                },
                {
                        dec("15367833944125677011173327826570204350687925236257190051755087781855930646142"),
                        dec("21715073802090413714601069529558707101797361591183718695054701329871284436172"),
                        dec("8994093285353831008525761670339342200997965950202092028313103110478252647618"),
                },
                {
                        dec("8370824693889782161629525898408725452177580012023459750897244954935682978671"),
                        dec("16123253540853556024347150096993154278773652905830608614979368087152152043083"),
                        dec("3535380953353495025888433493640531836449699255364366295870140701379497967423"),
                },
                {
                        dec("6954518484798178646508803478426114267143074508396663899281411171704702743829"),
                        dec("28903134801897070276701950388422104654018369750191967384271618837091859516942"),
                        dec("20872505363530172448468374920196608937030884647150175861507911076568784054834"),
                },
                {
                        dec("6902861581703501105786795670676641959401710346423594578401934671029571262513"),
                        dec("10124161387604183369443890585742198433184078889862870469507328332805848271064"),
                        dec("10488004060799269337071647841224034919633445750252076195310163972966405029030"),
                },
                {
                        dec("507704911991278613147490289466075160618843900088471236546244459176211783848"),
                        dec("7252739745607302667257774481690407709040936359589867974787811552896597703097"),
                        dec("23278073497974004442836030100920157527910770509761505828038443336325476654930"),
                },
                {
                        dec("22766285055433137793164317120096790621982728188995759745859222009100808389090"),
                        dec("23129058299483468195787339200845749049960038336751758017949899311636830205152"),
                        dec("16665333681978951552434356320651834889869437822496200946959897681307959400425"),
                },
                {
                        dec("12145699202182574939376505075528461451757079041659894988784442097333218352048"),
                        dec("26340666275844437932755852805027863696219004039301187587209926587657008948704"),
                        dec("19208771804191839410002226941825269105677187954811130189835856228258013753206"),
                },
                {

                        dec("21957102494792377508237608216278079874536155315851198461024084071231867104453"),
                        dec("6933367436450995525851693784691226222726503560893470094614235356287049091852"),
                        dec("15707767379191450768747057313641112321773921923533732633534831270357733757271"),
                },
                {

                        dec("27661963645951389261638591385668507557739541354225916772550248746235106571003"),
                        dec("19699458096897937575096494582288688995241392471402204995195057374756282223421"),
                        dec("902873385171181344315871113842580653512118892800584003934454469411716098791"),
                },
                {
                        dec("17184835876565576154014372215369798779520343573944211203710896053325717110660"),
                        dec("664657295519303589036289440053175741110032988007278988577620229144220576240"),
                        dec("10803972669668998371638869508774217165881281885838503958226056357738500321396"),
                },
                {
                        dec("2329846733754251453632375727999372856194157027336139087170310553870624325301"),
                        dec("14139944357035048486675740400655356660678187875721949218090128899571575479791"),
                        dec("18368148273419807418427674359327442879484531833435081951870369910704734685351"),
                },
                {
                        dec("10480273665080572189328459165704340191901489646067580012574464138528963201459"),
                        dec("21773636700078124500346009061678153597323236568110076029811348966753228682835"),
                        dec("18184268307211429260956076021417309535471438696101133218049142374847151474905"),
                },
                {
                        dec("25957533025669311312382992376854735734491934602484112256289764602447226406852"),
                        dec("22223261506176684934865714490719116745135417403915426392159449667435294570739"),
                        dec("22937309162832499167063076416585504361695925730111272512450449042837586253575"),
                },
                {
                        dec("16956181785481598286719868503945127919581091625126206673934113115358441284347"),
                        dec("8497782777197814773596870810881707148695901557289856910220737358078100998191"),
                        dec("21135503731586600979470064722475007625236017670426339278983640892218291297054"),
                },
                {
                        dec("17809297343844488723046665739910571149089769215421130894378638450427880983923"),
                        dec("72435395972188389387093550708873189001876361107443937983754878061522372356"),
                        dec("7511239878692099209014947248389283109997289411550315391143819429585903287870"),
                },
        },
        mds: [][]*pasta.PallasBaseFieldElement{
                {
                        dec("5328350144166205084223774245058198666309664348635459768305312917086056785354"),
                        dec("15214731724107930304595906373487084110291887262136882623959435918484004667388"),
                        dec("22399519358931858664262538157042328690232277435337286643350379269028878354609"),
                },
                {
                        dec("10086628405675314879458652402278736459294354590428582803795166650930540770072"),
                        dec("17127968360683744052278857147989507037142007029142438136689352416106177192235"),
                        dec("14207324749280135281015658576564097509614634975132487654324863824516044294735"),
                },
                {
                        dec("3059104278162906687184746935153057867173086006783171716838577369156969739687"),
                        dec("16755849208683706534025643823697988418063305979108082130624352443958404325985"),
                        dec("16889774624482628108075965871448623911656600744832339664842346756371603433407"),
                },
        },
}

func dec(dec string) *pasta.PallasBaseFieldElement <span class="cov8" title="1">{
        bi, ok := new(big.Int).SetString(dec, 10)
        if !ok </span><span class="cov0" title="0">{
                panic("invalid number")</span>
        }
        <span class="cov8" title="1">bn := new(saferith.Nat).SetBig(bi, 256)
        fe, err := pasta.NewPallasBaseField().FromBytes(bn.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return fe</span>
}
</pre>
		
		<pre class="file" id="file222" style="display: none">package poseidon

import (
        "hash"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// ErrInvalidDataLength is returned when the input data length is not a multiple of 32 bytes.
var ErrInvalidDataLength = errs2.New("invalid data length")

var (
        _ hash.Hash = (*Poseidon)(nil)
)

// Poseidon implements the Poseidon hash function over the Pallas base field.
// It provides a sponge-based construction suitable for zero-knowledge proof systems.
type Poseidon struct {
        state  *state
        offset int
}

// NewKimchi creates a new Poseidon hasher with Kimchi parameters used by Mina Protocol.
func NewKimchi() *Poseidon <span class="cov0" title="0">{
        return &amp;Poseidon{
                state:  newInitialState(poseidonParamsKimchiFp),
                offset: 0,
        }
}</span>

// NewLegacy creates a new Poseidon hasher with legacy parameters.
func NewLegacy() *Poseidon <span class="cov8" title="1">{
        return &amp;Poseidon{
                state:  newInitialState(poseidonParamsLegacyFp),
                offset: 0,
        }
}</span>

// NewLegacyHash creates a new Poseidon hasher with legacy parameters that implements hash.Hash.
func NewLegacyHash() hash.Hash <span class="cov0" title="0">{
        return NewLegacy()
}</span>

// Rate returns the rate of the sponge construction (number of field elements absorbed per permutation).
func (p *Poseidon) Rate() int <span class="cov8" title="1">{
        return p.state.parameters.rate
}</span>

// Update absorbs field elements into the sponge state and applies the permutation.
func (p *Poseidon) Update(xs ...*pasta.PallasBaseFieldElement) <span class="cov8" title="1">{
        if len(xs) == 0 </span><span class="cov8" title="1">{
                p.state.Permute()
                return
        }</span>

        <span class="cov8" title="1">for range len(xs) % p.Rate() </span><span class="cov8" title="1">{
                xs = append(xs, pasta.NewPallasBaseField().Zero())
        }</span>

        <span class="cov8" title="1">for blockIndex := 0; blockIndex &lt; len(xs); blockIndex += p.Rate() </span><span class="cov8" title="1">{
                for i := range p.Rate() </span><span class="cov8" title="1">{
                        p.state.v[i] = p.state.v[i].Add(xs[blockIndex+i])
                }</span>
                <span class="cov8" title="1">p.state.Permute()</span>
        }
}

// Hash resets the state, absorbs the input field elements, and returns the digest.
func (p *Poseidon) Hash(xs ...*pasta.PallasBaseFieldElement) *pasta.PallasBaseFieldElement <span class="cov8" title="1">{
        p.state = newInitialState(p.state.parameters)
        p.Update(xs...)
        return p.Digest()
}</span>

// Digest returns the current hash output as the first element of the state.
func (p *Poseidon) Digest() *pasta.PallasBaseFieldElement <span class="cov8" title="1">{
        return p.state.v[0]
}</span>

// Write implements io.Writer by converting bytes to field elements and hashing them.
// The data length must be a multiple of 32 bytes.
func (p *Poseidon) Write(data []byte) (n int, err error) <span class="cov8" title="1">{
        if (len(data) % 32) != 0 </span><span class="cov8" title="1">{
                return 0, ErrInvalidDataLength.WithMessage("data length must be multiple of 32")
        }</span>

        <span class="cov8" title="1">elems := []*pasta.PallasBaseFieldElement{}
        for i := range (len(data) + 31) / 32 </span><span class="cov8" title="1">{
                bytes := data[32*i : 32*(i+1)]
                fe, err := pasta.NewPallasBaseField().FromBytes(bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, errs2.Wrap(err).WithMessage("cannot create Pallas base field element")
                }</span>
                <span class="cov8" title="1">elems = append(elems, fe)</span>
        }
        <span class="cov8" title="1">p.Hash(elems...)
        return len(data), nil</span>
}

// Sum appends the current hash to b and returns the resulting slice.
// It implements hash.Hash.
func (p *Poseidon) Sum(data []byte) []byte <span class="cov8" title="1">{
        _, err := p.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return p.Digest().Bytes()</span>
}

// Reset resets the hasher to its initial state.
func (p *Poseidon) Reset() <span class="cov8" title="1">{
        p.state = newInitialState(p.state.parameters)
}</span>

// Size returns the number of bytes in the hash output (32 bytes for a field element).
func (*Poseidon) Size() int <span class="cov8" title="1">{
        return 32
}</span>

// BlockSize returns the hash's underlying block size in bytes.
func (*Poseidon) BlockSize() int <span class="cov8" title="1">{
        return 32
}</span>

// exp mutates f by computing x^3, x^5, x^7 or x^-1 as described in
// https://eprint.iacr.org/2019/458.pdf page 8
func exp(f *pasta.PallasBaseFieldElement, power int) *pasta.PallasBaseFieldElement <span class="cov8" title="1">{
        if power == 3 </span><span class="cov0" title="0">{
                f2 := f.Square()
                f3 := f.Mul(f2)
                return f3
        }</span>
        <span class="cov8" title="1">if power == 5 </span><span class="cov8" title="1">{
                f2 := f.Square()
                f4 := f2.Square()
                f5 := f.Mul(f4)
                return f5
        }</span>
        <span class="cov0" title="0">if power == 7 </span><span class="cov0" title="0">{
                f2 := f.Square()
                f4 := f2.Square()
                f6 := f2.Mul(f4)
                f7 := f.Mul(f6)
                return f7
        }</span>
        <span class="cov0" title="0">if power == -1 </span><span class="cov0" title="0">{
                fInv, err := f.TryInv()
                if err != nil </span><span class="cov0" title="0">{
                        return pasta.NewPallasBaseField().Zero()
                }</span>
                <span class="cov0" title="0">return fInv</span>
        }
        <span class="cov0" title="0">return pasta.NewPallasBaseField().Zero()</span>
}

type state struct {
        v          []*pasta.PallasBaseFieldElement
        parameters *Parameters
}

func newInitialState(parameters *Parameters) *state <span class="cov8" title="1">{
        s := &amp;state{
                v:          make([]*pasta.PallasBaseFieldElement, parameters.stateSize),
                parameters: parameters,
        }
        for i := range s.v </span><span class="cov8" title="1">{
                s.v[i] = pasta.NewPallasBaseField().Zero()
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Permute from: https://github.com/o1-labs/o1js-bindings/blob/df8c87ed6804465f79196fdff84e5147ae71e92d/crypto/poseidon.ts#L125
// Standard Poseidon (without "partial rounds") goes like this:
//
//        ARK_0 -&gt; SBOX -&gt; MDS
//
// -&gt; ARK_1 -&gt; SBOX -&gt; MDS
// -&gt; ...
// -&gt; ARK_{rounds - 1} -&gt; SBOX -&gt; MDS
//
// where all computation operates on a vector of field elements, the "state", and
// - ARK  ... add vector of round constants to the state, element-wise (different vector in each round)
// - SBOX ... raise state to a power, element-wise
// - MDS  ... multiply the state by a constant matrix (same matrix every round)
// (these operations are done modulo p of course)
//
// For constraint efficiency reasons, in Mina's implementation the first round constant addition is left out
// and is done at the end instead, so that effectively the order of operations in each iteration is rotated:
//
//        SBOX -&gt; MDS -&gt; ARK_0
//
// -&gt; SBOX -&gt; MDS -&gt; ARK_1
// -&gt; ...
// -&gt; SBOX -&gt; MDS -&gt; ARK_{rounds - 1}
//
// If `hasInitialRoundConstant` is true, another ARK step is added at the beginning.
//
// See also Snarky.Sponge.Poseidon.block_cipher.
func (s *state) Permute() <span class="cov8" title="1">{
        roundKeysOffset := 0
        if s.parameters.hashInitialRoundConstant </span><span class="cov8" title="1">{
                for i := range s.parameters.stateSize </span><span class="cov8" title="1">{
                        s.v[i] = s.v[i].Add(s.parameters.roundConstants[0][i])
                }</span>
                <span class="cov8" title="1">roundKeysOffset = 1</span>
        }
        <span class="cov8" title="1">for round := range s.parameters.fullRounds </span><span class="cov8" title="1">{
                s.sbox()
                s.mds()
                s.ark(round, roundKeysOffset)
        }</span>
}

func (s *state) sbox() <span class="cov8" title="1">{
        for i := range s.parameters.stateSize </span><span class="cov8" title="1">{
                s.v[i] = exp(s.v[i], s.parameters.power)
        }</span>
}

func (s *state) mds() <span class="cov8" title="1">{
        state2 := newInitialState(s.parameters)
        for row := range s.parameters.stateSize </span><span class="cov8" title="1">{
                for col := range s.parameters.stateSize </span><span class="cov8" title="1">{
                        state2.v[row] = state2.v[row].Add(s.v[col].Mul(s.parameters.mds[row][col]))
                }</span>
        }
        <span class="cov8" title="1">copy(s.v, state2.v)</span>
}

func (s *state) ark(round, offset int) <span class="cov8" title="1">{
        for i := range s.parameters.stateSize </span><span class="cov8" title="1">{
                s.v[i] = s.v[i].Add(s.parameters.roundConstants[round+offset][i])
        }</span>
}
</pre>
		
		<pre class="file" id="file223" style="display: none">package key_agreement

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

type privateKeyDTO[V algebra.UintLike[V]] struct {
        V V    `cbor:"v"`
        T Type `cbor:"t"`
}

func (sk *PrivateKey[V]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;privateKeyDTO[V]{
                V: sk.v,
                T: sk.t,
        }
        return serde.MarshalCBOR(dto)
}</span>

func (sk *PrivateKey[V]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[privateKeyDTO[V]](data)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("couldn't serialise private key")
        }</span>
        <span class="cov8" title="1">if _, err := NewPrivateKey(dto.V, dto.T); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid private key")
        }</span>
        <span class="cov8" title="1">sk.v = dto.V
        sk.t = dto.T
        return nil</span>
}

type publicKeyDTO[V algebra.AbelianGroupElement[V, S], S algebra.UintLike[S]] struct {
        V V    `cbor:"v"`
        T Type `cbor:"t"`
}

func (pk *PublicKey[V, S]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;publicKeyDTO[V, S]{
                V: pk.v,
                T: pk.t,
        }
        return serde.MarshalCBOR(dto)
}</span>

func (pk *PublicKey[V, S]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[publicKeyDTO[V, S]](data)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("couldn't serialise public key")
        }</span>
        <span class="cov8" title="1">if _, err := NewPublicKey(dto.V, dto.T); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid public key")
        }</span>
        <span class="cov8" title="1">pk.v = dto.V
        pk.t = dto.T
        return nil</span>
}

type sharedKeyDTO struct {
        V []byte `cbor:"v"`
        T Type   `cbor:"t"`
}

func (k *SharedKey) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;sharedKeyDTO{
                V: k.v,
                T: k.t,
        }
        return serde.MarshalCBOR(dto)
}</span>

func (k *SharedKey) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[sharedKeyDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("couldn't serialise shared key")
        }</span>
        <span class="cov8" title="1">if _, err := NewSharedKey(dto.V, dto.T); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid shared key")
        }</span>
        <span class="cov8" title="1">k.v = dto.V
        k.t = dto.T
        return nil</span>
}
</pre>
		
		<pre class="file" id="file224" style="display: none">package dhc

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

type privateKeyDTO struct {
        V []byte `cbor:"seed"`
}

func (sk *PrivateKey) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;privateKeyDTO{
                V: sk.v,
        }
        return serde.MarshalCBOR(dto)
}</span>

func (sk *PrivateKey) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[privateKeyDTO](data)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("could not serialise private key")
        }</span>
        <span class="cov8" title="1">if _, err := NewPrivateKey(dto.V); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid private key")
        }</span>
        <span class="cov8" title="1">sk.v = slices.Clone(dto.V)
        return nil</span>
}

type extendedPrivateKeyDTO[S algebra.PrimeFieldElement[S]] struct {
        V []byte `cbor:"seed"`
        S S      `cbor:"s"`
}

func (esk *ExtendedPrivateKey[S]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;extendedPrivateKeyDTO[S]{
                V: esk.v,
                S: esk.s,
        }
        return serde.MarshalCBOR(dto)
}</span>

func (esk *ExtendedPrivateKey[S]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[extendedPrivateKeyDTO[S]](data)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("could not serialise extended private key")
        }</span>
        <span class="cov8" title="1">dtoSk, err := NewPrivateKey(dto.V)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid private key")
        }</span>
        <span class="cov8" title="1">dtoSf := algebra.StructureMustBeAs[algebra.PrimeField[S]](dto.S.Structure())
        var ok bool
        if isFromCurve25519(dtoSf.Name()) </span><span class="cov8" title="1">{
                expected, err := ExtendPrivateKey(dtoSk, dtoSf)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("invalid extended private key")
                }</span>
                <span class="cov8" title="1">ok = expected.s.Equal(dto.S)</span>
        } else<span class="cov8" title="1"> {
                var s S
                s, err = dtoSf.FromBytes(dto.V)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("invalid extended private key")
                }</span>
                <span class="cov8" title="1">ok = s.Equal(dto.S)</span>
        }
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return ErrValidation.WithMessage("invalid extended private key scalar")
        }</span>
        <span class="cov8" title="1">esk.v = slices.Clone(dto.V)
        esk.s = dto.S
        return nil</span>
}
</pre>
		
		<pre class="file" id="file225" style="display: none">package dhc

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/curve25519"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/edwards25519"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/key_agreement"
)

// Type is the type identifier for the ECSVDP-DHC key agreement scheme.
const Type key_agreement.Type = "ECSVDP-DHC"

type (
        // PrivateKey represents a private key in the DHC key agreement scheme.
        PrivateKey struct {
                v []byte
        }
        // ExtendedPrivateKey represents an extended private key with scalar value.
        ExtendedPrivateKey[S algebra.PrimeFieldElement[S]] struct {
                PrivateKey

                s S
        }
        // PublicKey represents a public key in the DHC key agreement scheme.
        PublicKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] = key_agreement.PublicKey[P, S]
        // SharedKey represents a shared key in the DHC key agreement scheme.
        SharedKey[B algebra.FiniteFieldElement[B]] = key_agreement.SharedKey
)

// DeriveSharedSecret derives a shared secret using the DHC key agreement scheme.
func DeriveSharedSecret[
        P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S],
](myPrivateKey *ExtendedPrivateKey[S], otherPartyPublicKey *PublicKey[P, B, S]) (*SharedKey[B], error) <span class="cov8" title="1">{
        curve := algebra.StructureMustBeAs[curves.Curve[P, B, S]](otherPartyPublicKey.Value().Structure())
        if myPrivateKey == nil || otherPartyPublicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil key provided")
        }</span>
        <span class="cov8" title="1">if myPrivateKey.Type() != Type || otherPartyPublicKey.Type() != Type </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("incompatible key types")
        }</span>
        // assumption 1
        <span class="cov8" title="1">if myPrivateKey.Value().IsZero() </span><span class="cov0" title="0">{
                return nil, ErrInvalidSubGroup.WithMessage("invalid private key")
        }</span>
        <span class="cov8" title="1">if !otherPartyPublicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidSubGroup.WithMessage("Public Key not in the prime subgroup")
        }</span>
        // step 1
        <span class="cov8" title="1">k, err := curve.ScalarField().FromCardinal(curve.Cofactor())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get cofactor")
        }</span>
        <span class="cov8" title="1">kInv, err := k.TryInv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get inverse")
        }</span>
        <span class="cov8" title="1">t := kInv.Mul(myPrivateKey.Value())
        // step 2
        bigP := otherPartyPublicKey.Value().ScalarMul(k.Mul(t))
        // step 3
        if bigP.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrInvalidSubGroup.WithMessage("invalid public key")
        }</span>
        // step 4
        <span class="cov8" title="1">x, err := bigP.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get affine x coordinate")
        }</span>
        // step 5
        <span class="cov8" title="1">return NewSharedKey(x)</span>
}

// SerialiseExtendedPrivateKey serialises an extended private key to bytes.
func SerialiseExtendedPrivateKey[S algebra.PrimeFieldElement[S]](sk *ExtendedPrivateKey[S]) ([]byte, error) <span class="cov8" title="1">{
        if sk == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil extended private key")
        }</span>
        <span class="cov8" title="1">return sk.v, nil</span>
}

// SerialisePublicKey serialises a public key to bytes.
func SerialisePublicKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](pk *PublicKey[P, B, S]) ([]byte, error) <span class="cov8" title="1">{
        if pk == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil public key")
        }</span>
        <span class="cov8" title="1">curve := algebra.StructureMustBeAs[curves.Curve[P, B, S]](pk.Value().Structure())
        var out []byte
        if isFromCurve25519(curve.Name()) || isFromEdwards25519(curve.Name()) </span><span class="cov8" title="1">{
                out = pk.Value().ToCompressed()
        }</span> else<span class="cov8" title="1"> {
                out = pk.Value().ToUncompressed()
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SerialiseSharedKey serialises a shared key to bytes.
func SerialiseSharedKey[B algebra.FiniteFieldElement[B]](k *SharedKey[B]) ([]byte, error) <span class="cov0" title="0">{
        if k == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil shared key")
        }</span>
        <span class="cov0" title="0">return k.Bytes(), nil</span>
}

// NewPrivateKey creates a new PrivateKey instance.
func NewPrivateKey(v []byte) (*PrivateKey, error) <span class="cov8" title="1">{
        if ct.SliceIsZero(v) == ct.True </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("private key bytes are zero")
        }</span>
        <span class="cov8" title="1">return &amp;PrivateKey{v: slices.Clone(v)}, nil</span>
}

// Value returns the value of the private key.
func (sk *PrivateKey) Value() []byte <span class="cov8" title="1">{
        return sk.v
}</span>

// Type returns the type of the private key.
func (*PrivateKey) Type() key_agreement.Type <span class="cov8" title="1">{
        return Type
}</span>

// Equal checks if two private keys are equal.
func (sk *PrivateKey) Equal(other *PrivateKey) bool <span class="cov8" title="1">{
        if sk == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return sk == other
        }</span>
        <span class="cov8" title="1">return ct.SliceEqual(sk.v, other.v) == ct.True</span>
}

// ExtendPrivateKey extends a PrivateKey to an ExtendedPrivateKey with scalar value.
// If scalar field is from Curve25519, the private key bytes are clamped as per RFC 7748.
func ExtendPrivateKey[S algebra.PrimeFieldElement[S]](sk *PrivateKey, sf algebra.PrimeField[S]) (*ExtendedPrivateKey[S], error) <span class="cov8" title="1">{
        if sk == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil private key")
        }</span>
        <span class="cov8" title="1">if sf == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil sf")
        }</span>
        <span class="cov8" title="1">var s S
        var err error
        if isFromCurve25519(sf.Name()) </span><span class="cov8" title="1">{
                sf := algebra.StructureMustBeAs[interface {
                        algebra.PrimeField[S]
                        FromClampedBytes([]byte) (S, error)
                }](sf)
                s, err = sf.FromClampedBytes(sk.Value()) // Note that the input to FromClampedBytes is little-endian
        }</span> else<span class="cov8" title="1"> {
                s, err = sf.FromBytes(sk.Value())
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not derive extended private key")
        }</span>
        <span class="cov8" title="1">if s.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrInvalidSubGroup.WithMessage("invalid private key scalar")
        }</span>
        <span class="cov8" title="1">return &amp;ExtendedPrivateKey[S]{PrivateKey: *sk, s: s}, nil</span>
}

// Value returns the scalar value of the extended private key.
func (esk *ExtendedPrivateKey[S]) Value() S <span class="cov8" title="1">{
        return esk.s
}</span>

// Bytes returns the byte representation of the extended private key.
func (esk *ExtendedPrivateKey[S]) Bytes() []byte <span class="cov8" title="1">{
        return esk.v // this may be little-endian if from X25519
}</span>

// Equal checks if two extended private keys are equal.
func (esk *ExtendedPrivateKey[S]) Equal(other *ExtendedPrivateKey[S]) bool <span class="cov8" title="1">{
        if esk == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return esk == other
        }</span>
        <span class="cov8" title="1">return ct.SliceEqual(esk.v, other.v) == ct.True &amp;&amp; esk.s.Equal(other.s)</span>
}

// NewPublicKey creates a new PublicKey instance.
func NewPublicKey[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](v P) (*PublicKey[P, B, S], error) <span class="cov8" title="1">{
        out, err := key_agreement.NewPublicKey(v, Type)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not create public key")
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// NewSharedKey creates a new SharedKey instance.
func NewSharedKey[B algebra.FiniteFieldElement[B]](v B) (*SharedKey[B], error) <span class="cov8" title="1">{
        var b []byte
        if isFromCurve25519(v.Structure().Name()) </span><span class="cov8" title="1">{
                b = sliceutils.Reversed(v.Bytes()) // X25519 expects little-endian
        }</span> else<span class="cov8" title="1"> {
                b = v.Bytes()
        }</span>
        <span class="cov8" title="1">out, err := key_agreement.NewSharedKey(b, Type)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create shared key")
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func isFromCurve25519(name string) bool <span class="cov8" title="1">{
        switch name </span>{
        case curve25519.PrimeCurveName, curve25519.ScalarFieldName, curve25519.BaseFieldName:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isFromEdwards25519(name string) bool <span class="cov8" title="1">{
        switch name </span>{
        case edwards25519.PrimeCurveName, edwards25519.ScalarFieldName, edwards25519.BaseFieldName:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

var (
        ErrInvalidArgument = errs2.New("invalid argument")
        ErrInvalidSubGroup = errs2.New("element not in correct subgroup")
        ErrValidation      = errs2.New("validation error")
)
</pre>
		
		<pre class="file" id="file226" style="display: none">package key_agreement

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// Type represents the type of key agreement algorithm.
type Type string

// NewPrivateKey creates a new PrivateKey instance.
func NewPrivateKey[V algebra.UintLike[V]](v V, t Type) (*PrivateKey[V], error) <span class="cov8" title="1">{
        if v.IsZero() </span><span class="cov8" title="1">{
                return nil, ErrInvalidKey.WithMessage("private key is zero")
        }</span>

        <span class="cov8" title="1">return &amp;PrivateKey[V]{v: v, t: t}, nil</span>
}

// PrivateKey represents a private key in a key agreement scheme.
type PrivateKey[V algebra.UintLike[V]] struct {
        v V
        t Type
}

// Type returns the type of the private key.
func (sk *PrivateKey[V]) Type() Type <span class="cov8" title="1">{
        return sk.t
}</span>

// Value returns the value of the private key.
func (sk *PrivateKey[V]) Value() V <span class="cov8" title="1">{
        return sk.v
}</span>

// Equal checks if two private keys are equal.
func (sk *PrivateKey[V]) Equal(other *PrivateKey[V]) bool <span class="cov8" title="1">{
        if sk == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return sk == other
        }</span>
        <span class="cov8" title="1">return sk.v.Equal(other.v) &amp;&amp; sk.t == other.t</span>
}

// NewPublicKey creates a new PublicKey instance.
func NewPublicKey[V algebra.AbelianGroupElement[V, S], S algebra.UintLike[S]](v V, t Type) (*PublicKey[V, S], error) <span class="cov8" title="1">{
        if v.IsOpIdentity() || !v.IsTorsionFree() </span><span class="cov8" title="1">{
                return nil, ErrInvalidKey.WithMessage("public key is invalid: zero or not torsion free")
        }</span>

        <span class="cov8" title="1">return &amp;PublicKey[V, S]{v: v, t: t}, nil</span>
}

// PublicKey represents a public key in a key agreement scheme.
type PublicKey[V algebra.AbelianGroupElement[V, S], S algebra.UintLike[S]] struct {
        v V
        t Type
}

// Type returns the type of the public key.
func (pk *PublicKey[V, S]) Type() Type <span class="cov8" title="1">{
        return pk.t
}</span>

// Value returns the value of the public key.
func (pk *PublicKey[V, S]) Value() V <span class="cov8" title="1">{
        return pk.v
}</span>

// Equal checks if two public keys are equal.
func (pk *PublicKey[V, S]) Equal(other *PublicKey[V, S]) bool <span class="cov8" title="1">{
        if pk == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return pk == other
        }</span>
        <span class="cov8" title="1">return pk.v.Equal(other.v) &amp;&amp; pk.t == other.t</span>
}

// HashCode returns the hash code of the public key.
func (pk *PublicKey[V, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return pk.v.HashCode()
}</span>

// Clone creates a deep copy of the public key.
func (pk *PublicKey[V, S]) Clone() *PublicKey[V, S] <span class="cov0" title="0">{
        return &amp;PublicKey[V, S]{v: pk.v.Clone(), t: pk.t}
}</span>

// NewSharedKey creates a new SharedKey instance.
func NewSharedKey(v []byte, t Type) (*SharedKey, error) <span class="cov8" title="1">{
        if ct.SliceIsZero(v) == ct.True </span><span class="cov8" title="1">{
                return nil, ErrInvalidKey.WithMessage("shared key is zero")
        }</span>
        <span class="cov8" title="1">return &amp;SharedKey{v: v, t: t}, nil</span>
}

// SharedKey represents a shared key derived from a key agreement scheme.
type SharedKey struct {
        v []byte
        t Type
}

// Bytes returns the byte representation of the shared key.
func (k *SharedKey) Bytes() []byte <span class="cov8" title="1">{
        return k.v
}</span>

// Type returns the type of the shared key.
func (k *SharedKey) Type() Type <span class="cov8" title="1">{
        return k.t
}</span>

// Equal checks if two shared keys are equal.
func (k *SharedKey) Equal(other *SharedKey) bool <span class="cov8" title="1">{
        if k == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return k == other
        }</span>
        <span class="cov8" title="1">return ct.SliceEqual(k.v, other.v) == ct.True &amp;&amp; k.t == other.t</span>
}

var (
        ErrInvalidKey = errs2.New("invalid key")
)
</pre>
		
		<pre class="file" id="file227" style="display: none">package echo

import (
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// ExchangeEchoBroadcastSimple runs an echo broadcast: send, echo, and verify consistent payloads for all parties.
func ExchangeEchoBroadcastSimple[B any](rt *network.Router, correlationID string, message B) (network.RoundMessages[B], error) <span class="cov0" title="0">{
        r, err := NewEchoBroadcastRunner(rt.PartyID(), hashset.NewComparable(rt.Quorum()...).Freeze(), correlationID, message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create echo broadcast runner")
        }</span>
        <span class="cov0" title="0">result, err := r.Run(rt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to run echo broadcast")
        }</span>

        <span class="cov0" title="0">output := make(map[sharing.ID]B)
        for id, m := range result.Iter() </span><span class="cov0" title="0">{
                output[id] = m
        }</span>
        <span class="cov0" title="0">return hashmap.NewImmutableComparableFromNativeLike(output), nil</span>
}
</pre>
		
		<pre class="file" id="file228" style="display: none">package echo

import (
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// Participant drives the echo broadcast protocol for a single party.
type Participant[B any] struct {
        sharingID sharing.ID
        quorum    network.Quorum
        state     state
}

type state struct {
        messages map[sharing.ID][]byte
}

func NewParticipant[B any](id sharing.ID, quorum network.Quorum) (*Participant[B], error) <span class="cov8" title="1">{
        if quorum == nil || !quorum.Contains(id) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("sharingID not in quorum")
        }</span>

        <span class="cov8" title="1">p := &amp;Participant[B]{
                sharingID: id,
                quorum:    quorum,
                state: state{
                        messages: make(map[sharing.ID][]byte),
                },
        }
        return p, nil</span>
}

// SharingID returns the participant's identifier.
func (p *Participant[B]) SharingID() sharing.ID <span class="cov8" title="1">{
        return p.sharingID
}</span>

// Quorum returns the participant quorum.
func (p *Participant[B]) Quorum() network.Quorum <span class="cov0" title="0">{
        return p.quorum
}</span>
</pre>
		
		<pre class="file" id="file229" style="display: none">package echo

import (
        "bytes"

        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// Round1 broadcasts the sender's message to all other parties.
func (p *Participant[B]) Round1(message B) (network.OutgoingUnicasts[*Round1P2P], error) <span class="cov8" title="1">{
        serializedMessage, err := serde.MarshalCBOR(message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal message")
        }</span>

        <span class="cov8" title="1">r1 := hashmap.NewComparable[sharing.ID, *Round1P2P]()
        for id := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if id == p.sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">r1.Put(id, &amp;Round1P2P{
                        Payload: serializedMessage,
                })</span>
        }

        <span class="cov8" title="1">p.state.messages[p.sharingID] = serializedMessage
        return r1.Freeze(), nil</span>
}

// Round2 echoes every received payload back to all parties.
func (p *Participant[B]) Round2(r1 network.RoundMessages[*Round1P2P]) (network.OutgoingUnicasts[*Round2P2P], error) <span class="cov8" title="1">{
        receivedMessages := make(map[sharing.ID][]byte)
        for id := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if id == p.sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">m, ok := r1.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing message")
                }</span>
                <span class="cov8" title="1">receivedMessages[id] = m.Payload
                p.state.messages[id] = m.Payload</span>
        }

        <span class="cov8" title="1">r2 := hashmap.NewComparable[sharing.ID, *Round2P2P]()
        for id := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if id == p.sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">r2.Put(id, &amp;Round2P2P{
                        Echo: receivedMessages,
                })</span>
        }

        <span class="cov8" title="1">return r2.Freeze(), nil</span>
}

// Round3 validates echo consistency and outputs the agreed messages.
func (p *Participant[B]) Round3(r2 network.RoundMessages[*Round2P2P]) (network.RoundMessages[B], error) <span class="cov8" title="1">{
        received := make(map[sharing.ID][]byte)
        for id := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if id == p.sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">message := p.state.messages[id]
                for echoID := range p.quorum.Iter() </span><span class="cov8" title="1">{
                        if echoID == p.sharingID || echoID == id </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">echo, ok := r2.Get(echoID)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, ErrFailed.WithMessage("missing message")
                        }</span>
                        <span class="cov8" title="1">echoMessage := echo.Echo[id]
                        if !bytes.Equal(message, echoMessage) </span><span class="cov0" title="0">{
                                return nil, ErrFailed.WithMessage("mismatched echo")
                        }</span>
                }
                <span class="cov8" title="1">received[id] = message</span>
        }

        <span class="cov8" title="1">r3 := hashmap.NewComparable[sharing.ID, B]()
        for id := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if id == p.sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">message, err := serde.UnmarshalCBOR[B](received[id])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to unmarshal message")
                }</span>
                <span class="cov8" title="1">r3.Put(id, message)</span>
        }

        <span class="cov8" title="1">return r3.Freeze(), nil</span>
}
</pre>
		
		<pre class="file" id="file230" style="display: none">package echo

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

type echoBroadcastRunner[B any] struct {
        party         *Participant[B]
        correlationID string
        message       B
}

// NewEchoBroadcastRunner constructs an echo broadcast runner for the given party and quorum.
func NewEchoBroadcastRunner[B any](sharingID sharing.ID, quorum network.Quorum, correlationID string, message B) (network.Runner[network.RoundMessages[B]], error) <span class="cov0" title="0">{
        party, err := NewParticipant[B](sharingID, quorum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create participant")
        }</span>

        <span class="cov0" title="0">r := &amp;echoBroadcastRunner[B]{
                party,
                correlationID,
                message,
        }
        return r, nil</span>
}

// Run executes the three-round echo broadcast protocol over the provided router.
func (r *echoBroadcastRunner[B]) Run(rt *network.Router) (network.RoundMessages[B], error) <span class="cov0" title="0">{
        // r1
        r1Out, err := r.party.Round1(r.message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to run round 1")
        }</span>
        <span class="cov0" title="0">r2In, err := network.ExchangeUnicastSimple(rt, r.correlationID+":EchoRound1P2P", r1Out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to exchange unicast")
        }</span>

        // r2
        <span class="cov0" title="0">r2Out, err := r.party.Round2(r2In)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to run round 2")
        }</span>
        <span class="cov0" title="0">r3In, err := network.ExchangeUnicastSimple(rt, r.correlationID+":EchoRound2P2P", r2Out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to exchange broadcast")
        }</span>

        // r3
        <span class="cov0" title="0">output, err := r.party.Round3(r3In)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to run round 3")
        }</span>

        <span class="cov0" title="0">return output, nil</span>
}
</pre>
		
		<pre class="file" id="file231" style="display: none">package network

import (
        "maps"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// ExchangeUnicastSimple sends messages to all participants and receives the same messages back from them.
func ExchangeUnicastSimple[U any](rt *Router, correlationID string, messages RoundMessages[U]) (RoundMessages[U], error) <span class="cov0" title="0">{
        messagesSerialized := make(map[sharing.ID][]byte)
        for _, id := range rt.Quorum() </span><span class="cov0" title="0">{
                if id == rt.PartyID() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">message, ok := messages.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing message")
                }</span>
                <span class="cov0" title="0">messageSerialized, err := serde.MarshalCBOR(message)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to marshal message")
                }</span>
                <span class="cov0" title="0">messagesSerialized[id] = messageSerialized</span>
        }
        <span class="cov0" title="0">err := rt.SendTo(correlationID, messagesSerialized)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to send messages")
        }</span>

        <span class="cov0" title="0">coparties := slices.Collect(maps.Keys(messagesSerialized))
        receivedMessagesSerialized, err := rt.ReceiveFrom(correlationID, coparties...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to exchange messages")
        }</span>
        <span class="cov0" title="0">receivedMessages := make(map[sharing.ID]U)
        for id, m := range receivedMessagesSerialized </span><span class="cov0" title="0">{
                msg, err := serde.UnmarshalCBOR[U](m)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to unmarshal message")
                }</span>
                <span class="cov0" title="0">receivedMessages[id] = msg</span>
        }
        <span class="cov0" title="0">return hashmap.NewImmutableComparableFromNativeLike(receivedMessages), nil</span>
}
</pre>
		
		<pre class="file" id="file232" style="display: none">package exchange

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/network/echo"
)

// Exchange performs a combined broadcast and unicast exchange under a shared correlation ID.
func Exchange[B any, U any](rt *network.Router, correlationID string, broadcastMessageOut B, unicastMessagesOut network.RoundMessages[U]) (broadcastMessagesIn network.RoundMessages[B], unicastMessagesIn network.RoundMessages[U], err error) <span class="cov0" title="0">{
        broadcastMessagesIn, err = echo.ExchangeEchoBroadcastSimple(rt, correlationID+":BROADCAST", broadcastMessageOut)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot exchange broadcast")
        }</span>
        <span class="cov0" title="0">unicastMessagesIn, err = network.ExchangeUnicastSimple(rt, correlationID+":UNICAST", unicastMessagesOut)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot exchange unicast")
        }</span>
        <span class="cov0" title="0">return broadcastMessagesIn, unicastMessagesIn, nil</span>
}

// Broadcast performs an echo-broadcast round with the given message.
func Broadcast[B any](rt *network.Router, correlationID string, broadcastMessageOut B) (broadcastMessagesIn network.RoundMessages[B], err error) <span class="cov0" title="0">{
        broadcastMessagesIn, err = echo.ExchangeEchoBroadcastSimple(rt, correlationID+":BROADCAST", broadcastMessageOut)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot exchange broadcast")
        }</span>
        <span class="cov0" title="0">return broadcastMessagesIn, nil</span>
}

// Unicast performs a unicast-only exchange where each party sends distinct messages.
func Unicast[U any](rt *network.Router, correlationID string, unicastMessagesOut network.RoundMessages[U]) (unicastMessagesIn network.RoundMessages[U], err error) <span class="cov0" title="0">{
        unicastMessagesIn, err = network.ExchangeUnicastSimple(rt, correlationID+":UNICAST", unicastMessagesOut)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot exchange unicast")
        }</span>
        <span class="cov0" title="0">return unicastMessagesIn, nil</span>
}
</pre>
		
		<pre class="file" id="file233" style="display: none">package network

import (
        "crypto/sha3"
        "hash"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

var sidHasher = func() hash.Hash <span class="cov0" title="0">{ return sha3.New256() }</span>

// SID is a 32-byte session identifier derived from hashed inputs.
type SID [32]byte

// NewSID hashes the provided byte slices to produce a 32-byte session identifier.
func NewSID(xs ...[]byte) (SID, error) <span class="cov0" title="0">{
        digest, err := hashing.Hash(sidHasher, xs...)
        if len(digest) != 32 </span><span class="cov0" title="0">{
                return SID{}, ErrInvalidArgument.WithMessage("digest length is not 32 bytes")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return SID{}, errs2.Wrap(err).WithMessage("failed to create session ID")
        }</span>
        <span class="cov0" title="0">var sid SID
        copy(sid[:], digest)
        return sid, nil</span>
}

// Message represents any network payload.
type Message any
</pre>
		
		<pre class="file" id="file234" style="display: none">package network

import (
        "maps"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// Delivery abstracts a transport layer used by the router.
type Delivery interface {
        PartyID() sharing.ID
        Quorum() []sharing.ID
        Send(to sharing.ID, message []byte) error
        Receive() (from sharing.ID, message []byte, err error)
}

// Router orchestrates correlation-aware sending and receiving over a Delivery.
type Router struct {
        receiveBuffer []routerMessage
        delivery      Delivery
}

// NewRouter wraps a Delivery with buffering and correlation-aware routing.
func NewRouter(delivery Delivery) *Router <span class="cov0" title="0">{
        return &amp;Router{
                receiveBuffer: nil,
                delivery:      delivery,
        }
}</span>

// SendTo serialises and sends messages to the given recipients under a correlation identifier.
func (r *Router) SendTo(correlationID string, messages map[sharing.ID][]byte) error <span class="cov0" title="0">{
        for id, payload := range messages </span><span class="cov0" title="0">{
                //nolint:exhaustruct // From is optional
                message := routerMessage{
                        CorrelationID: correlationID,
                        Payload:       payload,
                }
                serializedMessage, err := serde.MarshalCBOR(&amp;message)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("failed to marshal message")
                }</span>
                <span class="cov0" title="0">if err := r.delivery.Send(id, serializedMessage); err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("failed to send message")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ReceiveFrom collects messages matching the correlation identifier from the specified senders,
// buffering unrelated messages for later retrieval.
func (r *Router) ReceiveFrom(correlationID string, froms ...sharing.ID) (map[sharing.ID][]byte, error) <span class="cov0" title="0">{
        received := make(map[sharing.ID][]byte)
        var kept []routerMessage
        for _, bufferedMsg := range r.receiveBuffer </span><span class="cov0" title="0">{
                if bufferedMsg.CorrelationID == correlationID </span><span class="cov0" title="0">{
                        received[bufferedMsg.From] = bufferedMsg.Payload
                }</span> else<span class="cov0" title="0"> {
                        kept = append(kept, bufferedMsg)
                }</span>
        }
        <span class="cov0" title="0">r.receiveBuffer = kept

        for !sliceutils.IsSuperSet(slices.Collect(maps.Keys(received)), froms) </span><span class="cov0" title="0">{
                from, serializedMessage, err := r.delivery.Receive()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to receive message")
                }</span>
                <span class="cov0" title="0">message, err := serde.UnmarshalCBOR[routerMessage](serializedMessage)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to decode message")
                }</span>

                <span class="cov0" title="0">if message.CorrelationID == correlationID </span><span class="cov0" title="0">{
                        received[from] = message.Payload
                }</span> else<span class="cov0" title="0"> {
                        message.From = from
                        r.receiveBuffer = append(r.receiveBuffer, message)
                }</span>
        }
        <span class="cov0" title="0">return received, nil</span>
}

// PartyID returns the router's local party identifier.
func (r *Router) PartyID() sharing.ID <span class="cov0" title="0">{
        return r.delivery.PartyID()
}</span>

// Quorum returns the identifiers of all parties in the session.
func (r *Router) Quorum() []sharing.ID <span class="cov0" title="0">{
        return r.delivery.Quorum()
}</span>

type routerMessage struct {
        From          sharing.ID `cbor:"from"`
        CorrelationID string     `cbor:"correlationID"`
        Payload       []byte     `cbor:"payload"`
}
</pre>
		
		<pre class="file" id="file235" style="display: none">package ntu

import (
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/stretchr/testify/require"
)

// CBORRoundTrip serialises and deserialises a value, asserting round-trip fidelity.
func CBORRoundTrip[T any](tb testing.TB, v T) T <span class="cov0" title="0">{
        tb.Helper()

        data, err := serde.MarshalCBOR(v)
        require.NoError(tb, err)

        out, err := serde.UnmarshalCBOR[T](data)
        require.NoError(tb, err)
        return out
        // return v
}</span>
</pre>
		
		<pre class="file" id="file236" style="display: none">package ntu

import (
        "maps"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

const messageBufferSize = 128

// MockCoordinator simulates a reliable message hub using buffered channels.
type MockCoordinator struct {
        channels map[sharing.ID]chan deliveryMessage
}

// NewMockCoordinator allocates buffered in-memory channels for each party in the quorum.
func NewMockCoordinator(quorum ...sharing.ID) *MockCoordinator <span class="cov0" title="0">{
        channels := make(map[sharing.ID]chan deliveryMessage)
        for _, p := range quorum </span><span class="cov0" title="0">{
                channels[p] = make(chan deliveryMessage, messageBufferSize)
        }</span>
        <span class="cov0" title="0">return &amp;MockCoordinator{channels: channels}</span>
}

// DeliveryFor returns a Delivery implementation bound to the given party.
func (c *MockCoordinator) DeliveryFor(sharingID sharing.ID) network.Delivery <span class="cov0" title="0">{
        recv := c.channels[sharingID]
        send := make(map[sharing.ID]chan&lt;- deliveryMessage)
        for id, ch := range c.channels </span><span class="cov0" title="0">{
                if id == sharingID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">send[id] = ch</span>
        }

        <span class="cov0" title="0">return &amp;mockDelivery{
                sharingID:      sharingID,
                quorum:         slices.Collect(maps.Keys(c.channels)),
                receiveChannel: recv,
                sendChannels:   send,
        }</span>
}

type deliveryMessage struct {
        From    sharing.ID `cbor:"from"`
        Payload []byte     `cbor:"payload"`
}

type mockDelivery struct {
        sharingID      sharing.ID
        quorum         []sharing.ID
        receiveChannel &lt;-chan deliveryMessage
        sendChannels   map[sharing.ID]chan&lt;- deliveryMessage
}

// PartyID returns the local party identifier.
func (d *mockDelivery) PartyID() sharing.ID <span class="cov0" title="0">{
        return d.sharingID
}</span>

// Quorum returns the identifiers of the simulated quorum.
func (d *mockDelivery) Quorum() []sharing.ID <span class="cov0" title="0">{
        return d.quorum
}</span>

// Send enqueues a message to the destination's channel.
func (d *mockDelivery) Send(sharingID sharing.ID, payload []byte) error <span class="cov0" title="0">{
        payloadClone := make([]byte, len(payload))
        copy(payloadClone, payload)
        sendChan, ok := d.sendChannels[sharingID]
        if !ok </span><span class="cov0" title="0">{
                return errs2.Wrap(network.ErrFailed).WithMessage("no channel for recipient")
        }</span>

        <span class="cov0" title="0">sendChan &lt;- deliveryMessage{
                From:    d.sharingID,
                Payload: payloadClone,
        }
        return nil</span>
}

// Receive blocks until a message is available for the party.
func (d *mockDelivery) Receive() (from sharing.ID, payload []byte, err error) <span class="cov0" title="0">{
        msg := &lt;-d.receiveChannel
        return msg.From, msg.Payload, nil
}</span>
</pre>
		
		<pre class="file" id="file237" style="display: none">package ntu

import (
        "maps"
        "slices"
        "sync"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/stretchr/testify/require"
        "golang.org/x/sync/errgroup"
)

// TestExecuteRunners concurrently executes the given runners with mock deliveries and collects their outputs.
func TestExecuteRunners[O any](tb testing.TB, runners map[sharing.ID]network.Runner[O]) map[sharing.ID]O <span class="cov0" title="0">{
        tb.Helper()

        results := make(map[sharing.ID]O)
        var resultsMutex sync.Mutex
        testCoordinator := NewMockCoordinator(slices.Collect(maps.Keys(runners))...)

        var errGroup errgroup.Group
        for id, runner := range runners </span><span class="cov0" title="0">{
                errGroup.Go(func() error </span><span class="cov0" title="0">{
                        rt := network.NewRouter(testCoordinator.DeliveryFor(id))
                        result, err := runner.Run(rt)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">resultsMutex.Lock()
                        defer resultsMutex.Unlock()
                        results[id] = result
                        return nil</span>
                })
        }

        <span class="cov0" title="0">err := errGroup.Wait()
        require.NoError(tb, err)
        return results</span>
}
</pre>
		
		<pre class="file" id="file238" style="display: none">package ntu

import (
        "encoding/binary"
        "io"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/stretchr/testify/require"
)

// TestParticipant is the minimal interface needed to route messages in helpers.
type TestParticipant interface {
        SharingID() sharing.ID
}

// MakeRandomQuorum samples a random quorum of distinct non-zero sharing IDs.
func MakeRandomQuorum(tb testing.TB, prng io.Reader, n int) network.Quorum <span class="cov0" title="0">{
        tb.Helper()

        quorum := hashset.NewComparable[sharing.ID]()
        for quorum.Size() &lt; n </span><span class="cov0" title="0">{
                var id [2]byte
                _, err := io.ReadFull(prng, id[:])
                require.NoError(tb, err)
                sharingID := binary.LittleEndian.Uint16(id[:])
                if sharingID != 0 </span><span class="cov0" title="0">{
                        quorum.Add(sharing.ID(sharingID))
                }</span>
        }

        <span class="cov0" title="0">return quorum.Freeze()</span>
}

// MakeRandomSessionID reads 32 random bytes into an SID.
func MakeRandomSessionID(tb testing.TB, prng io.Reader) network.SID <span class="cov0" title="0">{
        tb.Helper()

        var sid network.SID
        _, err := io.ReadFull(prng, sid[:])
        require.NoError(tb, err)

        return sid
}</span>

// MapO2I maps the outputs of all participants in a round of a protocol to the inputs of the next round
// with serialising and deserializing them throughout the process.
func MapO2I[
        P TestParticipant, BcastT, UnicastT network.Message,
](
        tb testing.TB,
        participants []P,
        broadcastOutputs map[sharing.ID]BcastT,
        UnicastOutputs map[sharing.ID]network.RoundMessages[UnicastT],
) (
        broadcastInputs map[sharing.ID]network.RoundMessages[BcastT],
        UnicastInputs map[sharing.ID]network.RoundMessages[UnicastT],
) <span class="cov0" title="0">{
        tb.Helper()
        if len(broadcastOutputs) != 0 </span><span class="cov0" title="0">{
                broadcastInputs = MapBroadcastO2I(tb, participants, broadcastOutputs)
        }</span>
        <span class="cov0" title="0">if len(UnicastOutputs) != 0 </span><span class="cov0" title="0">{
                UnicastInputs = MapUnicastO2I(tb, participants, UnicastOutputs)
        }</span>
        <span class="cov0" title="0">return broadcastInputs, UnicastInputs</span>
}

// MapBroadcastO2I maps the broadcasts of all participants in a round of a protocol to the inputs of the next round
// with serialising and deserializing them throughout the process.
func MapBroadcastO2I[
        P interface {
                SharingID() sharing.ID
        }, BcastT network.Message,
](
        tb testing.TB,
        participants []P,
        broadcastOutputs map[sharing.ID]BcastT,
) (
        broadcastInputs map[sharing.ID]network.RoundMessages[BcastT],
) <span class="cov0" title="0">{
        tb.Helper()
        broadcastInputs = make(map[sharing.ID]network.RoundMessages[BcastT], len(participants))
        for _, receiver := range participants </span><span class="cov0" title="0">{
                inputs := hashmap.NewComparable[sharing.ID, BcastT]()
                for _, sender := range participants </span><span class="cov0" title="0">{
                        if sender.SharingID() == receiver.SharingID() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">msg, ok := broadcastOutputs[sender.SharingID()]
                        if ok </span><span class="cov0" title="0">{
                                inputs.Put(sender.SharingID(), CBORRoundTrip(tb, msg))
                        }</span>
                }
                <span class="cov0" title="0">broadcastInputs[receiver.SharingID()] = inputs.Freeze()</span>
        }
        <span class="cov0" title="0">return broadcastInputs</span>
}

// MapUnicastO2I maps the P2P messages of all participants in a round of a protocol to the inputs of the next round
// with serialising and deserializing them throughout the process.
func MapUnicastO2I[
        P interface {
                SharingID() sharing.ID
        }, UnicastT network.Message,
](
        tb testing.TB,
        participants []P,
        p2pOutputs map[sharing.ID]network.RoundMessages[UnicastT],
) (
        p2pInputs map[sharing.ID]network.RoundMessages[UnicastT],
) <span class="cov0" title="0">{
        tb.Helper()
        p2pInputs = make(map[sharing.ID]network.RoundMessages[UnicastT], len(participants))
        for _, receiver := range participants </span><span class="cov0" title="0">{
                inputs := hashmap.NewComparable[sharing.ID, UnicastT]()
                for _, sender := range participants </span><span class="cov0" title="0">{
                        if sender.SharingID() == receiver.SharingID() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">p2pOutput, ok := p2pOutputs[sender.SharingID()]
                        if ok </span><span class="cov0" title="0">{
                                msg, exists := p2pOutput.Get(receiver.SharingID())
                                if exists </span><span class="cov0" title="0">{
                                        inputs.Put(sender.SharingID(), CBORRoundTrip(tb, msg))
                                }</span>
                        }
                }
                <span class="cov0" title="0">p2pInputs[receiver.SharingID()] = inputs.Freeze()</span>

        }
        <span class="cov0" title="0">return p2pInputs</span>
}
</pre>
		
		<pre class="file" id="file239" style="display: none">package ecbbot

import (
        "encoding/binary"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
)

// Suite configures EC batching base OTs over a prime-order group.
type Suite[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        ot.DefaultSuite

        group       algebra.PrimeGroup[G, S]
        scalarField algebra.PrimeField[S]
}

// NewSuite creates an EC BBOT suite for batch size xi and block length l.
func NewSuite[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](xi, l int, group algebra.PrimeGroup[G, S]) (*Suite[G, S], error) <span class="cov8" title="1">{
        if group == nil </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid group")
        }</span>
        <span class="cov8" title="1">field, ok := group.ScalarStructure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ot.ErrFailed.WithMessage("invalid group scalar structure")
        }</span>
        <span class="cov8" title="1">if (xi % 8) != 0 </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid xi")
        }</span>
        <span class="cov8" title="1">defaultSuite, err := ot.NewDefaultSuite(xi, l)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create default suite")
        }</span>

        <span class="cov8" title="1">s := &amp;Suite[G, S]{
                *defaultSuite,
                group,
                field,
        }
        return s, nil</span>
}

// Group returns the underlying prime-order group.
func (s *Suite[G, S]) Group() algebra.PrimeGroup[G, S] <span class="cov8" title="1">{
        return s.group
}</span>

// Field returns the scalar field used with the group.
func (s *Suite[G, S]) Field() algebra.PrimeField[S] <span class="cov0" title="0">{
        return s.scalarField
}</span>

// ReceiverOutput holds scalar outputs for the receiver side.
type ReceiverOutput[S algebra.PrimeFieldElement[S]] struct {
        ot.ReceiverOutput[S]
}

// NewReceiverOutput allocates an empty receiver output structure for xi and l.
func NewReceiverOutput[S algebra.PrimeFieldElement[S]](xi, l int) *ReceiverOutput[S] <span class="cov8" title="1">{
        r := make([][]S, xi)
        for i := range r </span><span class="cov8" title="1">{
                r[i] = make([]S, l)
        }</span>
        <span class="cov8" title="1">return &amp;ReceiverOutput[S]{
                ot.ReceiverOutput[S]{
                        Choices:  nil,
                        Messages: r,
                },
        }</span>
}

// ToBitsOutput hashes scalar outputs into byte strings usable by VSOT/extension.
func (r *ReceiverOutput[S]) ToBitsOutput(byteLen int, key []byte) (*vsot.ReceiverOutput, error) <span class="cov0" title="0">{
        if byteLen &lt; 16 || len(key) &lt; 16 </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid hash or key size")
        }</span>
        <span class="cov0" title="0">h, err := blake2b.New(byteLen, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ot.ErrFailed.WithMessage("failed to create hasher")
        }</span>

        <span class="cov0" title="0">out := &amp;vsot.ReceiverOutput{
                ReceiverOutput: ot.ReceiverOutput[[]byte]{
                        Choices:  r.Choices,
                        Messages: make([][][]byte, len(r.Messages)),
                },
        }
        for xi := range r.Messages </span><span class="cov0" title="0">{
                out.Messages[xi] = make([][]byte, len(r.Messages[xi]))
                for l, m := range r.Messages[xi] </span><span class="cov0" title="0">{
                        h.Reset()
                        h.Write(binary.LittleEndian.AppendUint64(nil, uint64(xi)))
                        h.Write(binary.LittleEndian.AppendUint64(nil, uint64(l)))
                        h.Write(m.Bytes())
                        out.Messages[xi][l] = h.Sum(nil)
                }</span>
        }

        <span class="cov0" title="0">return out, nil</span>
}

// SenderOutput holds scalar branch outputs for the sender side.
type SenderOutput[S algebra.PrimeFieldElement[S]] struct {
        ot.SenderOutput[S]
}

// NewSenderOutput allocates an empty sender output structure for xi and l.
func NewSenderOutput[S algebra.PrimeFieldElement[S]](xi, l int) *SenderOutput[S] <span class="cov8" title="1">{
        s := make([][2][]S, xi)
        for i := range s </span><span class="cov8" title="1">{
                s[i][0] = make([]S, l)
                s[i][1] = make([]S, l)
        }</span>
        <span class="cov8" title="1">return &amp;SenderOutput[S]{
                ot.SenderOutput[S]{
                        Messages: s,
                },
        }</span>
}

// ToBitsOutput hashes scalar outputs into byte strings usable by VSOT/extension.
func (s *SenderOutput[S]) ToBitsOutput(byteLen int, key []byte) (*vsot.SenderOutput, error) <span class="cov0" title="0">{
        if byteLen &lt; 16 || len(key) &lt; 16 </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid hash or key size")
        }</span>
        <span class="cov0" title="0">h, err := blake2b.New(byteLen, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ot.ErrFailed.WithMessage("failed to create hasher")
        }</span>

        <span class="cov0" title="0">out := &amp;vsot.SenderOutput{
                SenderOutput: ot.SenderOutput[[]byte]{
                        Messages: make([][2][][]byte, len(s.Messages)),
                },
        }
        for xi := range s.Messages </span><span class="cov0" title="0">{
                out.Messages[xi][0] = make([][]byte, len(s.Messages[xi][0]))
                out.Messages[xi][1] = make([][]byte, len(s.Messages[xi][1]))
                for l := range s.Messages[xi][0] </span><span class="cov0" title="0">{
                        h.Reset()
                        h.Write(binary.LittleEndian.AppendUint64(nil, uint64(xi)))
                        h.Write(binary.LittleEndian.AppendUint64(nil, uint64(l)))
                        h.Write(s.Messages[xi][0][l].Bytes())
                        out.Messages[xi][0][l] = h.Sum(nil)
                        h.Reset()
                        h.Write(binary.LittleEndian.AppendUint64(nil, uint64(xi)))
                        h.Write(binary.LittleEndian.AppendUint64(nil, uint64(l)))
                        h.Write(s.Messages[xi][1][l].Bytes())
                        out.Messages[xi][1][l] = h.Sum(nil)
                }</span>
        }

        <span class="cov0" title="0">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file240" style="display: none">package ecbbot

import (
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
)

// TaggedKeyAgreement performs simple DH-style key agreement with domain-separated hashing.
type TaggedKeyAgreement[GE algebra.PrimeGroupElement[GE, SE], SE algebra.PrimeFieldElement[SE]] struct {
        group       algebra.PrimeGroup[GE, SE]
        scalarField algebra.PrimeField[SE]
}

// NewTaggedKeyAgreement constructs a keyed agreement helper over the given group.
func NewTaggedKeyAgreement[GE algebra.PrimeGroupElement[GE, SE], SE algebra.PrimeFieldElement[SE]](group algebra.PrimeGroup[GE, SE]) (*TaggedKeyAgreement[GE, SE], error) <span class="cov8" title="1">{
        scalarField, ok := group.ScalarStructure().(algebra.PrimeField[SE])
        if !ok </span><span class="cov0" title="0">{
                return nil, ot.ErrFailed.WithMessage("invalid group scalar structure")
        }</span>
        <span class="cov8" title="1">ka := &amp;TaggedKeyAgreement[GE, SE]{
                group:       group,
                scalarField: scalarField,
        }
        return ka, nil</span>
}

func (ka *TaggedKeyAgreement[GE, SE]) R(prng io.Reader) (SE, error) <span class="cov8" title="1">{
        var nilSE SE
        if prng == nil </span><span class="cov0" title="0">{
                return nilSE, ot.ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">a, err := ka.scalarField.Random(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nilSE, errs2.Wrap(err).WithMessage("random scalar")
        }</span>

        <span class="cov8" title="1">return a, nil</span>
}

func (ka *TaggedKeyAgreement[GE, SE]) Msg1(a SE) (GE, error) <span class="cov8" title="1">{
        ms := ka.group.ScalarBaseOp(a)
        return ms, nil
}</span>

func (ka *TaggedKeyAgreement[GE, SE]) Msg2(b SE, _ GE) (GE, error) <span class="cov8" title="1">{
        return ka.Msg1(b)
}</span>

// Key1 derives the sender-side key using scalar a and peer message mr with a tag.
func (ka *TaggedKeyAgreement[GE, SE]) Key1(a SE, mr GE, tag []byte) (SE, error) <span class="cov8" title="1">{
        var nilSE SE

        if a.IsZero() || !mr.IsTorsionFree() </span><span class="cov0" title="0">{
                return nilSE, ot.ErrInvalidArgument.WithMessage("invalid arguments")
        }</span>
        <span class="cov8" title="1">raw := mr.ScalarOp(a)
        k, err := ka.scalarField.Hash(slices.Concat(tag, raw.Bytes()))
        if err != nil </span><span class="cov0" title="0">{
                return nilSE, errs2.Wrap(err).WithMessage("hash to scalar")
        }</span>
        <span class="cov8" title="1">return k, nil</span>
}

func (ka *TaggedKeyAgreement[GE, SE]) Key2(b SE, ms GE, tag []byte) (SE, error) <span class="cov8" title="1">{
        return ka.Key1(b, ms, tag)
}</span>
</pre>
		
		<pre class="file" id="file241" style="display: none">package ecbbot

import (
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const transcriptLabel = "BRON_CRYPTO_BBOT-"

type participant[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        ka    *TaggedKeyAgreement[G, S]
        suite *Suite[G, S]
        round int
        tape  transcripts.Transcript
        prng  io.Reader
}

// Sender obtains the 2 random messages for the 1|2 ROT.
type Sender[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        participant[G, S]

        state SenderState[S]
}

type SenderState[S algebra.PrimeFieldElement[S]] struct {
        a S
}

// Receiver chooses one message (with its choice bit) out of the sender's 1|2 ROT messages.
type Receiver[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        participant[G, S]
}

// NewSender constructs a Random OT sender.
func NewSender[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[G, S], tape transcripts.Transcript, prng io.Reader) (*Sender[G, S], error) <span class="cov8" title="1">{
        if suite == nil || tape == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid args")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        ka, err := NewTaggedKeyAgreement(suite.Group())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create tagged key agreement")
        }</span>

        <span class="cov8" title="1">s := &amp;Sender[G, S]{
                participant: participant[G, S]{
                        ka:    ka,
                        round: 1,
                        suite: suite,
                        tape:  tape,
                        prng:  prng,
                },
                state: SenderState[S]{}, //nolint:exhaustruct // zero value, populated during protocol
        }

        return s, nil</span>
}

// NewReceiver constructs a Random OT receiver.
func NewReceiver[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[G, S], tape transcripts.Transcript, prng io.Reader) (*Receiver[G, S], error) <span class="cov8" title="1">{
        if suite == nil || tape == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid args")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        ka, err := NewTaggedKeyAgreement(suite.Group())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create tagged key agreement")
        }</span>

        <span class="cov8" title="1">r := &amp;Receiver[G, S]{
                participant: participant[G, S]{
                        ka:    ka,
                        suite: suite,
                        round: 2,
                        tape:  tape,
                        prng:  prng,
                },
        }
        return r, nil</span>
}
</pre>
		
		<pre class="file" id="file242" style="display: none">package ecbbot

import (
        "bytes"
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
)

type Popf[GE algebra.PrimeGroupElement[GE, SE], SE algebra.PrimeFieldElement[SE]] struct {
        group algebra.PrimeGroup[GE, SE]
        tag0  []byte
        tag1  []byte
}

func NewPopf[GE algebra.PrimeGroupElement[GE, SE], SE algebra.PrimeFieldElement[SE]](group algebra.PrimeGroup[GE, SE], tag0, tag1 []byte) (*Popf[GE, SE], error) <span class="cov8" title="1">{
        if len(tag0) == 0 || len(tag1) == 0 || bytes.Equal(tag0, tag1) </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid args")
        }</span>

        <span class="cov8" title="1">f := &amp;Popf[GE, SE]{
                group: group,
                tag0:  tag0,
                tag1:  tag1,
        }
        return f, nil</span>
}

func (f *Popf[GE, SE]) Program(x byte, y GE, prng io.Reader) (s0, s1 GE, err error) <span class="cov8" title="1">{
        var nilGE GE
        if x &gt; 1 || prng == nil </span><span class="cov0" title="0">{
                return nilGE, nilGE, ot.ErrInvalidArgument.WithMessage("invalid arguments")
        }</span>

        <span class="cov8" title="1">if x == 0 </span><span class="cov8" title="1">{
                s1, err = f.group.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilGE, nilGE, errs2.Wrap(err).WithMessage("cannot sample point")
                }</span>
                <span class="cov8" title="1">h0, err := f.h0(s1)
                if err != nil </span><span class="cov0" title="0">{
                        return nilGE, nilGE, errs2.Wrap(err).WithMessage("s1")
                }</span>
                <span class="cov8" title="1">s0 = y.Op(h0.OpInv())</span>
        } else<span class="cov8" title="1"> {
                s0, err = f.group.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilGE, nilGE, errs2.Wrap(err).WithMessage("cannot sample point")
                }</span>
                <span class="cov8" title="1">h1, err := f.h1(s0)
                if err != nil </span><span class="cov0" title="0">{
                        return nilGE, nilGE, errs2.Wrap(err).WithMessage("s1")
                }</span>
                <span class="cov8" title="1">s1 = y.Op(h1.OpInv())</span>
        }

        <span class="cov8" title="1">return s0, s1, nil</span>
}

func (f *Popf[GE, SE]) Eval(s0, s1 GE, x byte) (y GE, err error) <span class="cov8" title="1">{
        var nilGE GE
        if x &gt; 1 </span><span class="cov0" title="0">{
                return nilGE, ot.ErrInvalidArgument.WithMessage("invalid arguments")
        }</span>

        <span class="cov8" title="1">if x == 0 </span><span class="cov8" title="1">{
                h0, err := f.h0(s1)
                if err != nil </span><span class="cov0" title="0">{
                        return nilGE, errs2.Wrap(err).WithMessage("s1")
                }</span>
                <span class="cov8" title="1">y = s0.Op(h0)</span>
        } else<span class="cov8" title="1"> {
                h1, err := f.h1(s0)
                if err != nil </span><span class="cov0" title="0">{
                        return nilGE, errs2.Wrap(err).WithMessage("s1")
                }</span>
                <span class="cov8" title="1">y = s1.Op(h1)</span>
        }

        <span class="cov8" title="1">return y, nil</span>
}

func (f *Popf[GE, SE]) h0(p GE) (GE, error) <span class="cov8" title="1">{
        var nilGE GE
        p0, err := f.group.Hash(slices.Concat(f.tag0, p.Bytes()))
        if err != nil </span><span class="cov0" title="0">{
                return nilGE, errs2.Wrap(err).WithMessage("hash to curve failed")
        }</span>
        <span class="cov8" title="1">return p0, nil</span>
}

func (f *Popf[GE, SE]) h1(p GE) (GE, error) <span class="cov8" title="1">{
        var nilGE GE

        p1, err := f.group.Hash(slices.Concat(f.tag1, p.Bytes()))
        if err != nil </span><span class="cov0" title="0">{
                return nilGE, errs2.Wrap(err).WithMessage("hash to curve failed")
        }</span>
        <span class="cov8" title="1">return p1, nil</span>
}
</pre>
		
		<pre class="file" id="file243" style="display: none">package ecbbot

import (
        "encoding/binary"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
)

const (
        TaggedKeyAgreementMs = "BRON_CRYPTO-BBOT-KA-MA-"
        PopfKeyLabel         = "BRON_CRYPTO-BBOT-POPF-"
        Ro0Label             = "BRON_CRYPTO-BBOT-RO0-"
        Ro1Label             = "BRON_CRYPTO-BBOT-RO1-"
        TagLength            = 16
)

// Round1 runs the sender's first round: sample a, send key agreement message.
func (s *Sender[G, S]) Round1() (r1out *Round1P2P[G, S], err error) <span class="cov8" title="1">{
        // Validation
        if s.round != 1 </span><span class="cov0" title="0">{
                return nil, ot.ErrRound.WithMessage("running round %d but participant expected round %d", 1, s.round)
        }</span>

        // step 1.1 (KA.R)
        <span class="cov8" title="1">s.state.a, err = s.ka.R(s.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("generating a")
        }</span>

        // step 1.2 (KA.msg_1)
        <span class="cov8" title="1">ms, err := s.ka.Msg1(s.state.a)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("creating msg1")
        }</span>

        // step 1.3 (Setup RO)
        <span class="cov8" title="1">s.tape.AppendBytes(TaggedKeyAgreementMs, ms.Bytes())

        s.round = 3
        r1out = &amp;Round1P2P[G, S]{
                Ms: ms,
        }
        return r1out, nil</span>
}

// Round2 completes key agreement per choice bit, programs POPF, and returns receiver output.
func (r *Receiver[G, S]) Round2(r1out *Round1P2P[G, S], choices []byte) (r2out *Round2P2P[G, S], receiverOut *ReceiverOutput[S], err error) <span class="cov8" title="1">{
        // Validation
        if r.round != 2 </span><span class="cov0" title="0">{
                return nil, nil, ot.ErrRound.WithMessage("running round %d but participant expected round %d", 2, r.round)
        }</span>

        // Setup ROs
        <span class="cov8" title="1">r.tape.AppendBytes(TaggedKeyAgreementMs, r1out.Ms.Bytes())
        f, err := r.makeProgrammableOncePublicFunction()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("creating popf")
        }</span>

        // step 2.1
        <span class="cov8" title="1">phi := make([][2][]G, r.suite.Xi())
        receiverOut = NewReceiverOutput[S](r.suite.Xi(), r.suite.L())
        receiverOut.Choices = choices
        for i := range r.suite.Xi() </span><span class="cov8" title="1">{
                ci := (choices[i/8] &gt;&gt; (i % 8)) &amp; 0b1
                phi[i] = [2][]G{make([]G, r.suite.L()), make([]G, r.suite.L())}
                for l := range r.suite.L() </span><span class="cov8" title="1">{
                        // step 2.2 (KA.R)
                        bi, err := r.ka.R(r.prng)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("generating random scalar bi")
                        }</span>

                        // step 2.3 (KA.msg_2)
                        <span class="cov8" title="1">mRi, err := r.ka.Msg2(bi, r1out.Ms)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("creating msg2")
                        }</span>

                        // step 2.4 (KA.key_2)
                        <span class="cov8" title="1">tag := r.makeKeyAgreementTag(i, l, ci)
                        receiverOut.Messages[i][l], err = r.ka.Key2(bi, r1out.Ms, tag)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("computing shared bytes for KA.key_2")
                        }</span>

                        // step 2.5,2.6 (POPF.Program)
                        <span class="cov8" title="1">phi[i][0][l], phi[i][1][l], err = f.Program(ci, mRi, r.prng)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("generating random scalar sc")
                        }</span>
                }
        }

        <span class="cov8" title="1">r.round++
        r2out = &amp;Round2P2P[G, S]{Phi: phi}
        return r2out, receiverOut, nil</span>
}

// Round3 evaluates the programmed POPF and derives sender outputs for both branches.
func (s *Sender[G, S]) Round3(r2out *Round2P2P[G, S]) (senderOut *SenderOutput[S], err error) <span class="cov8" title="1">{
        // Validation
        if s.round != 3 </span><span class="cov0" title="0">{
                return nil, ot.ErrRound.WithMessage("running round %d but participant expected round %d", 3, s.round)
        }</span>

        <span class="cov8" title="1">f, err := s.makeProgrammableOncePublicFunction()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("creating popf")
        }</span>

        // step 3.1
        <span class="cov8" title="1">senderOut = NewSenderOutput[S](s.suite.Xi(), s.suite.L())
        for i := range s.suite.Xi() </span><span class="cov8" title="1">{
                for l := range s.suite.L() </span><span class="cov8" title="1">{
                        for j := range byte(2) </span><span class="cov8" title="1">{
                                // step 3.2 (POPF.Eval)
                                p, err := f.Eval(r2out.Phi[i][0][l], r2out.Phi[i][1][l], j)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, errs2.Wrap(err).WithMessage("popf eval")
                                }</span>

                                // step 3.3 (KA.key_1)
                                <span class="cov8" title="1">tag := s.makeKeyAgreementTag(i, l, j)
                                senderOut.Messages[i][j][l], err = s.ka.Key2(s.state.a, p, tag)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, errs2.Wrap(err).WithMessage("computing shared bytes for KA.key_2")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">s.round++
        return senderOut, nil</span>
}

func (p *participant[G, S]) makeProgrammableOncePublicFunction() (f *Popf[G, S], err error) <span class="cov8" title="1">{
        var tagsRandomOracle [2][]byte
        tagsRandomOracle[0], err = p.tape.ExtractBytes(Ro0Label, TagLength)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("extracting tag Ro0")
        }</span>
        <span class="cov8" title="1">tagsRandomOracle[1], err = p.tape.ExtractBytes(Ro1Label, TagLength)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("extracting tag Ro1")
        }</span>
        <span class="cov8" title="1">f, err = NewPopf(p.suite.Group(), tagsRandomOracle[0], tagsRandomOracle[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("creating popf")
        }</span>
        <span class="cov8" title="1">return f, nil</span>
}

func (p *participant[G, S]) makeKeyAgreementTag(xi, l int, j byte) []byte <span class="cov8" title="1">{
        return slices.Concat([]byte(PopfKeyLabel), binary.LittleEndian.AppendUint32(nil, uint32(xi*p.suite.L()+l)), []byte{j})
}</span>
</pre>
		
		<pre class="file" id="file244" style="display: none">package testutils

import (
        "io"
        "testing"

        "github.com/stretchr/testify/require"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// RunBBOT runs the full batched base OT protocol.
func RunBBOT[GE algebra.PrimeGroupElement[GE, SE], SE algebra.PrimeFieldElement[SE]](xi, l int, group algebra.PrimeGroup[GE, SE], sessionID network.SID, tape transcripts.Transcript, prng io.Reader) (*ecbbot.SenderOutput[SE], *ecbbot.ReceiverOutput[SE], error) <span class="cov0" title="0">{
        suite, err := ecbbot.NewSuite(xi, l, group)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("constructing OT suite in run BatchedBaseOT")
        }</span>

        <span class="cov0" title="0">sender, err := ecbbot.NewSender(sessionID, suite, tape.Clone(), prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("constructing OT sender in run BatchedBaseOT")
        }</span>
        <span class="cov0" title="0">receiver, err := ecbbot.NewReceiver(sessionID, suite, tape.Clone(), prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("constructing OT receiver in run BatchedBaseOT")
        }</span>

        // Run the protocol
        // R1
        <span class="cov0" title="0">r1Out, err := sender.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("sender round 1 in run BatchedBaseOT")
        }</span>

        // R2
        <span class="cov0" title="0">receiverInput := make([]byte, xi/8)
        if _, err := io.ReadFull(prng, receiverInput); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("reading receiver input")
        }</span>
        <span class="cov0" title="0">r2Out, receiverOutput, err := receiver.Round2(r1Out, receiverInput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("receiver round 2 in run BatchedBaseOT")
        }</span>

        // R3
        <span class="cov0" title="0">senderOutput, err := sender.Round3(r2Out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("sender round 3 in run BatchedBaseOT")
        }</span>
        <span class="cov0" title="0">return senderOutput, receiverOutput, nil</span>
}

func ValidateOT[S algebra.PrimeFieldElement[S]](
        tb testing.TB,
        xi int, // number of OTe messages in the batch
        l int, // number of OTe elements per message
        senderOutput *ecbbot.SenderOutput[S],
        receiverOutput *ecbbot.ReceiverOutput[S],
) <span class="cov0" title="0">{
        tb.Helper()

        // Check length matching
        if len(receiverOutput.Choices) != xi/8 || len(receiverOutput.Messages) != xi || len(senderOutput.Messages) != xi </span><span class="cov0" title="0">{
                require.FailNow(tb, "length mismatch")
        }</span>

        // Check baseOT results
        <span class="cov0" title="0">for xiI := range xi </span><span class="cov0" title="0">{
                if len(receiverOutput.Messages[xiI]) != l || len(senderOutput.Messages[xiI][0]) != l || len(senderOutput.Messages[xiI][1]) != l </span><span class="cov0" title="0">{
                        require.FailNow(tb, "length mismatch")
                }</span>
                <span class="cov0" title="0">choice := (receiverOutput.Choices[xiI/8] &gt;&gt; (xiI % 8)) &amp; 0b1
                for li := range l </span><span class="cov0" title="0">{
                        received := receiverOutput.Messages[xiI][li]
                        sentChosen := senderOutput.Messages[xiI][choice][li]
                        sentNotChosen := senderOutput.Messages[xiI][1-choice][li]
                        require.True(tb, sentChosen.Equal(received))
                        require.False(tb, sentNotChosen.Equal(received))
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file245" style="display: none">package vsot

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
)

// Round1P2P carries B=bG and its proof of knowledge from the sender.
type Round1P2P[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        BigB  P                     `cbor:"bigB"`
        Proof compiler.NIZKPoKProof `cbor:"proof"`
}

// Validate performs basic sanity checks on the message.
func (r1 *Round1P2P[P, B, S]) Validate() error <span class="cov8" title="1">{
        if r1 == nil || r1.BigB.IsOpIdentity() </span><span class="cov0" title="0">{
                return ot.ErrInvalidArgument.WithMessage("invalid message")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Round2P2P carries the receiver's A values derived from its choices.
type Round2P2P[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        BigA []P `cbor:"bigA"`
}

// Validate checks sizes and non-identity constraints.
func (r2 *Round2P2P[P, B, S]) Validate(xi, l int) error <span class="cov8" title="1">{
        if r2 == nil || len(r2.BigA) != (xi*l) </span><span class="cov0" title="0">{
                return ot.ErrInvalidArgument.WithMessage("invalid message")
        }</span>
        <span class="cov8" title="1">for _, a := range r2.BigA </span><span class="cov8" title="1">{
                if a.IsOpIdentity() </span><span class="cov0" title="0">{
                        return ot.ErrInvalidArgument.WithMessage("invalid message")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Round3P2P carries the sender's masked digest differences.
type Round3P2P struct {
        Xi [][]byte `cbor:"xi"`
}

// Validate checks sizes of Xi payloads.
func (r3 *Round3P2P) Validate(xi, l, h int) error <span class="cov8" title="1">{
        if r3 == nil || len(r3.Xi) != (xi*l) </span><span class="cov0" title="0">{
                return ot.ErrInvalidArgument.WithMessage("invalid message")
        }</span>
        <span class="cov8" title="1">for _, x := range r3.Xi </span><span class="cov8" title="1">{
                if len(x) != h </span><span class="cov0" title="0">{
                        return ot.ErrInvalidArgument.WithMessage("invalid message")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Round4P2P carries receiver-chosen digests.
type Round4P2P struct {
        RhoPrime [][]byte `cbor:"rhoPrime"`
}

// Validate checks sizes of rhoPrime payloads.
func (r4 *Round4P2P) Validate(xi, l, h int) error <span class="cov8" title="1">{
        if r4 == nil || len(r4.RhoPrime) != (xi*l) </span><span class="cov0" title="0">{
                return ot.ErrInvalidArgument.WithMessage("invalid message")
        }</span>
        <span class="cov8" title="1">for _, x := range r4.RhoPrime </span><span class="cov8" title="1">{
                if len(x) != h </span><span class="cov0" title="0">{
                        return ot.ErrInvalidArgument.WithMessage("invalid message")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Round5P2P carries sender openings of rho digests.
type Round5P2P struct {
        Rho0Digest [][]byte `cbor:"rho0Digest"`
        Rho1Digest [][]byte `cbor:"rho1Digest"`
}

// Validate checks payload sizes for both digest slices.
func (r5 *Round5P2P) Validate(xi, l, h int) error <span class="cov8" title="1">{
        if r5 == nil || len(r5.Rho0Digest) != (xi*l) || len(r5.Rho1Digest) != (xi*l) </span><span class="cov0" title="0">{
                return ot.ErrInvalidArgument.WithMessage("invalid message")
        }</span>
        <span class="cov8" title="1">for i := range xi * l </span><span class="cov8" title="1">{
                if len(r5.Rho0Digest[i]) != h || len(r5.Rho1Digest[i]) != h </span><span class="cov0" title="0">{
                        return ot.ErrInvalidArgument.WithMessage("invalid message")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file246" style="display: none">package vsot

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel = "BRON_CRYPTO_VSOT-"
        aLabel          = "BRON_CRYPTO_VSOT-A-"
)

type participant[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        sessionID network.SID
        suite     *Suite[P, B, S]
        tape      transcripts.Transcript
        round     int
        prng      io.Reader
}

func (p *participant[P, B, S]) hash(idx int, b, a P, data []byte) ([]byte, error) <span class="cov8" title="1">{
        digest, err := hashing.HashPrefixedLength(p.suite.HashFunc(), binary.LittleEndian.AppendUint64(nil, uint64(idx)), p.sessionID[:], b.ToCompressed(), a.ToCompressed(), data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute hash")
        }</span>
        <span class="cov8" title="1">return digest, nil</span>
}

// Sender drives the VSOT sender state machine.
type Sender[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        participant[P, B, S]

        state senderState[P, B, S]
}

type senderState[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        b                S
        bigB             P
        rho0Digest       [][]byte
        rho1Digest       [][]byte
        rho0DigestDigest [][]byte
}

// NewSender creates a VSOT sender bound to the session, suite, transcript, and randomness source.
func NewSender[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[P, B, S], tape transcripts.Transcript, prng io.Reader) (*Sender[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil || tape == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid args")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        s := &amp;Sender[P, B, S]{
                participant: participant[P, B, S]{
                        sessionID: sessionID,
                        suite:     suite,
                        tape:      tape,
                        round:     1,
                        prng:      prng,
                },
                state: senderState[P, B, S]{}, //nolint:exhaustruct // zero value, populated during protocol
        }

        return s, nil</span>
}

// Receiver drives the VSOT receiver state machine.
type Receiver[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        participant[P, B, S]

        state receiverState[P, B, S]
}

type receiverState[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        bigB           P
        bigA           []P
        rhoOmega       [][]byte
        rhoOmegaDigest [][]byte
        omegaRaw       []uint64
        omega          []S
        xi             [][]byte
}

// NewReceiver creates a VSOT receiver bound to the session, suite, transcript, and randomness source.
func NewReceiver[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[P, B, S], tape transcripts.Transcript, prng io.Reader) (*Receiver[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil || tape == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid args")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        r := &amp;Receiver[P, B, S]{
                participant: participant[P, B, S]{
                        sessionID: sessionID,
                        suite:     suite,
                        tape:      tape,
                        round:     2,
                        prng:      prng,
                },
                state: receiverState[P, B, S]{}, //nolint:exhaustruct // zero value, populated during protocol
        }

        return r, nil</span>
}
</pre>
		
		<pre class="file" id="file247" style="display: none">package vsot

import (
        "crypto/subtle"
        "fmt"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        dlogschnorr "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fiatshamir"
)

// Round1 samples sender secret b, computes B = bG, proves knowledge of b, and sends (B, proof).
func (s *Sender[P, B, S]) Round1() (*Round1P2P[P, B, S], error) <span class="cov8" title="1">{
        var err error
        if s.round != 1 </span><span class="cov0" title="0">{
                return nil, ot.ErrRound.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">s.state.b, err = s.suite.Field().Random(s.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("generating b")
        }</span>
        <span class="cov8" title="1">s.state.bigB = s.suite.Curve().ScalarBaseMul(s.state.b)

        dlogProtocol, err := dlogschnorr.NewProtocol(s.suite.Curve().Generator(), s.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog protocol")
        }</span>
        <span class="cov8" title="1">dlogProtocolCompiler, err := fiatshamir.NewCompiler(dlogProtocol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog protocol compiler")
        }</span>
        // TODO: would be nice to have dlogschnorr.NewStatement(G, P)
        <span class="cov8" title="1">dlogStatement := &amp;dlogschnorr.Statement[P, S]{
                X: s.state.bigB,
        }
        // TODO: would be nice to have dlogschnorr.NewWitness(s)
        dlogWitness := &amp;dlogschnorr.Witness[S]{
                W: s.state.b,
        }
        dlogProver, err := dlogProtocolCompiler.NewProver(s.sessionID, s.tape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog prover")
        }</span>
        <span class="cov8" title="1">dlogProof, err := dlogProver.Prove(dlogStatement, dlogWitness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog proof")
        }</span>
        // TODO: a lot of lines (~24) just to do PoK :(

        <span class="cov8" title="1">r1 := &amp;Round1P2P[P, B, S]{
                BigB:  s.state.bigB,
                Proof: dlogProof,
        }
        s.round += 2
        return r1, nil</span>
}

// Round2 verifies the sender's proof, encodes receiver choices, and computes A values and receiver seeds.
func (r *Receiver[P, B, S]) Round2(r1 *Round1P2P[P, B, S], choices []byte) (*Round2P2P[P, B, S], *ReceiverOutput, error) <span class="cov8" title="1">{
        if r.round != 2 </span><span class="cov0" title="0">{
                return nil, nil, ot.ErrRound.WithMessage("invalid round")
        }</span>
        <span class="cov8" title="1">if err := r1.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("invalid message")
        }</span>
        <span class="cov8" title="1">if len(choices)*8 != r.suite.Xi() </span><span class="cov0" title="0">{
                return nil, nil, ot.ErrInvalidArgument.WithMessage("invalid choices length")
        }</span>

        <span class="cov8" title="1">dlogProtocol, err := dlogschnorr.NewProtocol(r.suite.curve.Generator(), r.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create dlog protocol")
        }</span>
        <span class="cov8" title="1">dlogProtocolCompiler, err := fiatshamir.NewCompiler(dlogProtocol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create dlog protocol compiler")
        }</span>
        // TODO: would be nice to have dlogschnorr.NewStatement(G, P)
        <span class="cov8" title="1">dlogStatement := &amp;dlogschnorr.Statement[P, S]{
                X: r1.BigB,
        }
        dlogVerifier, err := dlogProtocolCompiler.NewVerifier(r.sessionID, r.tape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create dlog verifier")
        }</span>
        <span class="cov8" title="1">err = dlogVerifier.Verify(dlogStatement, r1.Proof)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("verification failed")
        }</span>

        <span class="cov8" title="1">r.state.omegaRaw = make([]uint64, r.suite.Xi()*r.suite.L())
        r.state.omega = make([]S, r.suite.Xi()*r.suite.L())
        r.state.rhoOmega = make([][]byte, r.suite.Xi()*r.suite.L())
        r.state.bigB = r1.BigB
        r.state.bigA = make([]P, r.suite.Xi()*r.suite.L())
        receiverOutput := &amp;ReceiverOutput{
                ot.ReceiverOutput[[]byte]{
                        Choices:  choices,
                        Messages: make([][][]byte, r.suite.Xi()),
                },
        }
        for i := range r.suite.Xi() </span><span class="cov8" title="1">{
                c := uint64((choices[i/8] &gt;&gt; (i % 8)) &amp; 0b1)
                receiverOutput.Messages[i] = make([][]byte, r.suite.L())
                for j := range r.suite.L() </span><span class="cov8" title="1">{
                        idx := i*r.suite.L() + j
                        a, err := r.suite.field.Random(r.prng)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("generating a")
                        }</span>
                        <span class="cov8" title="1">r.state.omegaRaw[idx] = c
                        r.state.omega[idx] = r.suite.field.FromUint64(r.state.omegaRaw[idx])
                        r.state.bigA[idx] = r.suite.curve.ScalarBaseMul(a).Add(r.state.bigB.ScalarMul(r.state.omega[idx]))
                        r.state.rhoOmega[idx], err = r.hash(idx, r.state.bigB, r.state.bigA[idx], r.state.bigB.ScalarMul(a).ToCompressed())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash B * a_i")
                        }</span>
                        <span class="cov8" title="1">receiverOutput.Messages[i][j] = r.state.rhoOmega[idx]

                        r.tape.AppendBytes(fmt.Sprintf("%s%d-%d-", aLabel, i, j), r.state.bigA[idx].ToCompressed())</span>
                }
        }

        <span class="cov8" title="1">r2 := &amp;Round2P2P[P, B, S]{
                BigA: r.state.bigA,
        }
        r.round += 2
        return r2, receiverOutput, nil</span>
}

// Round3 derives sender seeds rho0/rho1 and commits to them with digests and XOR masks.
func (s *Sender[P, B, S]) Round3(r2 *Round2P2P[P, B, S]) (*Round3P2P, *SenderOutput, error) <span class="cov8" title="1">{
        var err error
        if s.round != 3 </span><span class="cov0" title="0">{
                return nil, nil, ot.ErrRound.WithMessage("invalid round")
        }</span>
        <span class="cov8" title="1">if err := r2.Validate(s.suite.Xi(), s.suite.L()); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("invalid message")
        }</span>

        <span class="cov8" title="1">rho0 := make([][]byte, s.suite.Xi()*s.suite.L())
        rho1 := make([][]byte, s.suite.Xi()*s.suite.L())
        s.state.rho0Digest = make([][]byte, s.suite.Xi()*s.suite.L())
        s.state.rho1Digest = make([][]byte, s.suite.Xi()*s.suite.L())
        s.state.rho0DigestDigest = make([][]byte, s.suite.Xi()*s.suite.L())
        xi := make([][]byte, s.suite.Xi()*s.suite.L())
        senderOutput := &amp;SenderOutput{
                ot.SenderOutput[[]byte]{
                        Messages: make([][2][][]byte, s.suite.Xi()),
                },
        }
        for i := range s.suite.Xi() </span><span class="cov8" title="1">{
                senderOutput.Messages[i][0] = make([][]byte, s.suite.L())
                senderOutput.Messages[i][1] = make([][]byte, s.suite.L())
                for j := range s.suite.L() </span><span class="cov8" title="1">{
                        idx := i*s.suite.L() + j
                        bigA := r2.BigA[idx]

                        rho0[idx], err = s.hash(idx, s.state.bigB, bigA, bigA.ScalarMul(s.state.b).ToCompressed())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash A * b_i")
                        }</span>
                        <span class="cov8" title="1">rho1[idx], err = s.hash(idx, s.state.bigB, bigA, (bigA.Sub(s.state.bigB)).ScalarMul(s.state.b).ToCompressed())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash (A - B_i) * b_i")
                        }</span>
                        <span class="cov8" title="1">senderOutput.Messages[i][0][j] = rho0[idx]
                        senderOutput.Messages[i][1][j] = rho1[idx]

                        s.state.rho0Digest[idx], err = s.hash(idx, s.state.bigB, bigA, rho0[idx])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash rho_0")
                        }</span>
                        <span class="cov8" title="1">s.state.rho0DigestDigest[idx], err = s.hash(idx, s.state.bigB, bigA, s.state.rho0Digest[idx])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash rho_0 digest")
                        }</span>
                        <span class="cov8" title="1">s.state.rho1Digest[idx], err = s.hash(idx, s.state.bigB, bigA, rho1[idx])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash rho_1")
                        }</span>
                        <span class="cov8" title="1">rho1DigestDigest, err := s.hash(idx, s.state.bigB, bigA, s.state.rho1Digest[idx])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash rho_1 digest")
                        }</span>
                        <span class="cov8" title="1">xi[idx] = make([]byte, len(s.state.rho0DigestDigest[idx]))
                        subtle.XORBytes(xi[idx], s.state.rho0DigestDigest[idx], rho1DigestDigest)

                        s.tape.AppendBytes(fmt.Sprintf("%s%d-%d-", aLabel, i, j), bigA.ToCompressed())</span>
                }
        }

        <span class="cov8" title="1">r3 := &amp;Round3P2P{
                Xi: xi,
        }
        s.round += 2
        return r3, senderOutput, nil</span>
}

// Round4 unblinds the masked digest corresponding to each receiver choice and returns rhoPrime values.
func (r *Receiver[P, B, S]) Round4(r3 *Round3P2P) (*Round4P2P, error) <span class="cov8" title="1">{
        var err error
        if r.round != 4 </span><span class="cov0" title="0">{
                return nil, ot.ErrRound.WithMessage("invalid round")
        }</span>
        <span class="cov8" title="1">if err := r3.Validate(r.suite.Xi(), r.suite.L(), r.suite.hashFunc().Size()); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid message")
        }</span>

        <span class="cov8" title="1">r.state.xi = r3.Xi
        rhoPrime := make([][]byte, r.suite.Xi()*r.suite.L())
        r.state.rhoOmegaDigest = make([][]byte, r.suite.Xi()*r.suite.L())
        for i := range r.suite.Xi() </span><span class="cov8" title="1">{
                for j := range r.suite.L() </span><span class="cov8" title="1">{
                        idx := i*r.suite.L() + j
                        if len(r3.Xi[idx]) != r.suite.hashFunc().Size() </span><span class="cov0" title="0">{
                                return nil, ot.ErrInvalidArgument.WithMessage("invalid message")
                        }</span>

                        <span class="cov8" title="1">r.state.rhoOmegaDigest[idx], err = r.hash(idx, r.state.bigB, r.state.bigA[idx], r.state.rhoOmega[idx])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot hash rho_omega")
                        }</span>
                        <span class="cov8" title="1">rhoPrime[idx], err = r.hash(idx, r.state.bigB, r.state.bigA[idx], r.state.rhoOmegaDigest[idx])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot hash rho_omega digest")
                        }</span>
                        <span class="cov8" title="1">xi := ct.CSelectInts(ct.Choice(r.state.omegaRaw[idx]), make([]byte, len(r3.Xi[idx])), r3.Xi[idx])
                        subtle.XORBytes(rhoPrime[idx], rhoPrime[idx], xi)</span>
                }
        }

        <span class="cov8" title="1">r4 := &amp;Round4P2P{
                RhoPrime: rhoPrime,
        }
        r.round += 2
        return r4, nil</span>
}

// Round5 checks rhoPrime against sender commitments and returns digest openings.
func (s *Sender[P, B, S]) Round5(r4 *Round4P2P) (*Round5P2P, error) <span class="cov8" title="1">{
        if s.round != 5 </span><span class="cov0" title="0">{
                return nil, ot.ErrRound.WithMessage("invalid round")
        }</span>
        <span class="cov8" title="1">if err := r4.Validate(s.suite.Xi(), s.suite.L(), s.suite.hashFunc().Size()); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid message")
        }</span>

        <span class="cov8" title="1">for i := range s.suite.Xi() </span><span class="cov8" title="1">{
                for j := range s.suite.L() </span><span class="cov8" title="1">{
                        idx := i*s.suite.L() + j
                        if len(r4.RhoPrime[idx]) != s.suite.hashFunc().Size() </span><span class="cov0" title="0">{
                                return nil, ot.ErrInvalidArgument.WithMessage("invalid message")
                        }</span>

                        <span class="cov8" title="1">if subtle.ConstantTimeCompare(r4.RhoPrime[idx], s.state.rho0DigestDigest[idx]) != 1 </span><span class="cov0" title="0">{
                                return nil, base.ErrAbort.WithMessage("verification failed")
                        }</span>
                }
        }

        <span class="cov8" title="1">r5 := &amp;Round5P2P{
                Rho0Digest: s.state.rho0Digest,
                Rho1Digest: s.state.rho1Digest,
        }
        s.round += 2
        return r5, nil</span>
}

// Round6 verifies the sender's openings against the receiver's choice and internal hashes.
func (r *Receiver[P, B, S]) Round6(r5 *Round5P2P) error <span class="cov8" title="1">{
        if r.round != 6 </span><span class="cov0" title="0">{
                return ot.ErrRound.WithMessage("invalid round")
        }</span>
        <span class="cov8" title="1">if err := r5.Validate(r.suite.Xi(), r.suite.L(), r.suite.hashFunc().Size()); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid message")
        }</span>

        <span class="cov8" title="1">for i := range r.suite.Xi() </span><span class="cov8" title="1">{
                for j := range r.suite.L() </span><span class="cov8" title="1">{
                        idx := i*r.suite.L() + j
                        rho0Digest := r5.Rho0Digest[idx]
                        rho1Digest := r5.Rho1Digest[idx]
                        if len(rho0Digest) != r.suite.hashFunc().Size() || len(rho1Digest) != r.suite.hashFunc().Size() </span><span class="cov0" title="0">{
                                return ot.ErrInvalidArgument.WithMessage("invalid message")
                        }</span>

                        <span class="cov8" title="1">switch r.state.omegaRaw[idx] </span>{
                        case 0:<span class="cov8" title="1">
                                if subtle.ConstantTimeCompare(rho0Digest, r.state.rhoOmegaDigest[idx]) != 1 </span><span class="cov0" title="0">{
                                        return base.ErrAbort.WithMessage("verification failed")
                                }</span>
                        case 1:<span class="cov8" title="1">
                                if subtle.ConstantTimeCompare(rho1Digest, r.state.rhoOmegaDigest[idx]) != 1 </span><span class="cov0" title="0">{
                                        return base.ErrAbort.WithMessage("verification failed")
                                }</span>
                        default:<span class="cov0" title="0">
                                panic("invalid internal state - this should never happen")</span>
                        }

                        <span class="cov8" title="1">rho0DigestDigest, err := r.hash(idx, r.state.bigB, r.state.bigA[idx], rho0Digest)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot hash rho_0 digest")
                        }</span>
                        <span class="cov8" title="1">rho1DigestDigest, err := r.hash(idx, r.state.bigB, r.state.bigA[idx], rho1Digest)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot hash rho_1 digest")
                        }</span>
                        <span class="cov8" title="1">xi := make([]byte, len(rho0DigestDigest))
                        subtle.XORBytes(xi, rho0DigestDigest, rho1DigestDigest)
                        if subtle.ConstantTimeCompare(xi, r.state.xi[idx]) != 1 </span><span class="cov0" title="0">{
                                return base.ErrAbort.WithMessage("verification failed")
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file248" style="display: none">package vsot

import (
        "hash"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
)

// SenderOutput carries the sender's ROT outputs for VSOT.
type SenderOutput struct {
        ot.SenderOutput[[]byte] `cbor:"output"`
}

// InferredMessageBytesLen infers the byte length of messages, returning 0 on inconsistency.
func (so *SenderOutput) InferredMessageBytesLen() int <span class="cov8" title="1">{
        if len(so.Messages) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if len(so.Messages[0][0]) == 0 || len(so.Messages[0][1]) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">l := len(so.Messages[0][0][0])
        for _, messages := range so.Messages </span><span class="cov8" title="1">{
                for _, message := range messages[0] </span><span class="cov8" title="1">{
                        if len(message) != l </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                }
                <span class="cov8" title="1">for _, message := range messages[1] </span><span class="cov8" title="1">{
                        if len(message) != l </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                }
        }
        <span class="cov8" title="1">return l</span>
}

type ReceiverOutput struct {
        ot.ReceiverOutput[[]byte] `cbor:"output"`
}

// InferredMessageBytesLen infers the byte length of messages, returning 0 on inconsistency.
func (ro *ReceiverOutput) InferredMessageBytesLen() int <span class="cov8" title="1">{
        if len(ro.Messages) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if len(ro.Messages[0]) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">l := len(ro.Messages[0][0])
        for _, messages := range ro.Messages </span><span class="cov8" title="1">{
                for _, message := range messages </span><span class="cov8" title="1">{
                        if len(message) != l </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                }
        }
        <span class="cov8" title="1">return l</span>
}

type Suite[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        ot.DefaultSuite

        curve    curves.Curve[P, B, S]
        field    algebra.PrimeField[S]
        hashFunc func() hash.Hash
}

// NewSuite configures VSOT over the given curve with batch size xi and block length l.
func NewSuite[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]](xi, l int, curve curves.Curve[P, B, S], hashFunc func() hash.Hash) (*Suite[P, B, S], error) <span class="cov8" title="1">{
        if hashFunc == nil </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid hash func")
        }</span>
        <span class="cov8" title="1">if (xi % 8) != 0 </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid xi")
        }</span>
        <span class="cov8" title="1">field, ok := curve.ScalarStructure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ot.ErrFailed.WithMessage("invalid curve scalar structure")
        }</span>

        <span class="cov8" title="1">defaultSuite, err := ot.NewDefaultSuite(xi, l)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create default suite")
        }</span>
        <span class="cov8" title="1">s := &amp;Suite[P, B, S]{
                DefaultSuite: *defaultSuite,
                curve:        curve,
                field:        field,
                hashFunc:     hashFunc,
        }

        return s, nil</span>
}

// Curve returns the curve used by the suite.
func (s *Suite[P, B, S]) Curve() curves.Curve[P, B, S] <span class="cov8" title="1">{
        return s.curve
}</span>

// Field returns the prime field used for scalars.
func (s *Suite[P, B, S]) Field() algebra.PrimeField[S] <span class="cov8" title="1">{
        return s.field
}</span>

// HashFunc returns the hash function used in the protocol.
func (s *Suite[P, B, S]) HashFunc() func() hash.Hash <span class="cov8" title="1">{
        return s.hashFunc
}</span>
</pre>
		
		<pre class="file" id="file249" style="display: none">package ot

import (
        "fmt"
)

// PackedBits is a byte vector of little-endian packed bits.
type PackedBits []byte

// Pack compresses the bits in the input vector v, truncating each input byte to
// its least significant bit. E.g., [0x01,0x01,0x01,0x01, 0x00,0x00,0x01,0x00] ---&gt; [0xF0].
func Pack(unpackedBits []uint8) (PackedBits, error) <span class="cov0" title="0">{
        vOut := PackedBits(make([]byte, (len(unpackedBits)+7)/8))
        isNonBinary := uint8(0)

        for i, bit := range unpackedBits </span><span class="cov0" title="0">{
                isNonBinary |= bit
                vOut[i/8] |= (bit &amp; 0b1) &lt;&lt; (i % 8)
        }</span>
        <span class="cov0" title="0">if isNonBinary&amp;0xFE != 0x00 </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("input vector contains non-binary elements")
        }</span>

        <span class="cov0" title="0">return vOut, nil</span>
}

// Unpack expands the bits of the input vector into separate bytes.
// E.g., [0xF0,0x12] ---&gt; [1,1,1,1, 0,0,0,0, 0,0,0,1, 0,0,1,0].
func (pb PackedBits) Unpack() []uint8 <span class="cov0" title="0">{
        vOut := make([]byte, pb.BitLen())
        for i := range pb.BitLen() </span><span class="cov0" title="0">{
                vOut[i] = pb.Get(uint(i))
        }</span>
        <span class="cov0" title="0">return vOut</span>
}

// String returns a string representation of the packed bits.
func (pb PackedBits) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v", pb.Unpack())
}</span>

// Get gets the `i`th bit of a packed bits vector.
// E.g., [0x12, 0x34] --&gt; [0,1,0,0, 1,0,0,0, 1,1,0,0, 0,0,1,0].
func (pb PackedBits) Get(i uint) uint8 <span class="cov0" title="0">{
        return (pb[i/8] &gt;&gt; (i % 8)) &amp; 0b1
}</span>

// Swap swaps the `i`th and `j`th bits.
func (pb PackedBits) Swap(i, j uint) <span class="cov0" title="0">{
        iBit := (pb[i/8] &gt;&gt; (i % 8)) &amp; 0b1
        jBit := (pb[j/8] &gt;&gt; (j % 8)) &amp; 0b1

        pb[i/8] &amp;^= 1 &lt;&lt; (i % 8)
        pb[i/8] |= jBit &lt;&lt; (i % 8)

        pb[j/8] &amp;^= 1 &lt;&lt; (j % 8)
        pb[j/8] |= iBit &lt;&lt; (j % 8)
}</span>

// Set sets the `i`th bit of a packed bits vector. Input `bit` is truncated
// to its least significant bit (i.e., we only consider the last bit of `bit`).
func (pb PackedBits) Set(i uint) <span class="cov0" title="0">{
        pb[i/8] |= 1 &lt;&lt; (i % 8)
}</span>

// Clear sets the `i`th bit of a packed bits vector to 0.
func (pb PackedBits) Clear(i uint) <span class="cov0" title="0">{
        pb[i/8] &amp;^= 1 &lt;&lt; (i % 8)
}</span>

// Repeat repeats the bits in the input vector `nrepetitions` times. E.g.,
// if v = [0,1,0,1] and nrepetitions = 2, then the output is [0,0,1,1,0,0,1,1].
// To do so, bits must be unpacked, repeated, and packed in the output.
func (pb PackedBits) Repeat(nRepetitions int) PackedBits <span class="cov0" title="0">{
        vOut := PackedBits(make([]byte, len(pb)*nRepetitions))
        nextBit := 0
        for i := range pb.BitLen() </span><span class="cov0" title="0">{
                bit := pb.Get(uint(i))
                for range nRepetitions </span><span class="cov0" title="0">{
                        vOut[nextBit/8] |= bit &lt;&lt; (nextBit % 8)
                        nextBit++
                }</span>
        }
        <span class="cov0" title="0">return vOut</span>
}

// BitLen returns the number of bits represented by the packed slice.
func (pb PackedBits) BitLen() int <span class="cov0" title="0">{
        return len(pb) * 8
}</span>

// TransposePackedBits transposes a 2D matrix of "packed" bits (represented in
// groups of 8 bits per bytes), yielding a new 2D matrix of "packed" bits. If we
// were to unpack the bits, inputMatrixBits[i][j] == outputMatrixBits[j][i].
func TransposePackedBits(inputMatrix [][]byte) ([][]byte, error) <span class="cov0" title="0">{
        // Read input sizes and allocate output
        nRowsInput := len(inputMatrix)
        if nRowsInput%8 != 0 || nRowsInput == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("input matrix must have a number of rows divisible by 8")
        }</span>
        // check if array is a matrix
        <span class="cov0" title="0">for i := range nRowsInput </span><span class="cov0" title="0">{
                if len(inputMatrix[i]) != len(inputMatrix[0]) </span><span class="cov0" title="0">{
                        return nil, ErrInvalidArgument.WithMessage("input matrix must be a 2D matrix")
                }</span>
        }

        <span class="cov0" title="0">nColsInputBytes := len(inputMatrix[0])
        nRowsOutput := nColsInputBytes &lt;&lt; 3
        nColsOutputBytes := nRowsInput &gt;&gt; 3
        transposedMatrix := make([][]byte, nRowsOutput)
        for i := range nRowsOutput </span><span class="cov0" title="0">{
                transposedMatrix[i] = make([]byte, nColsOutputBytes)
        }</span>
        // transpose the matrix bits, one bit at a time
        <span class="cov0" title="0">for rowByte := range nColsOutputBytes </span><span class="cov0" title="0">{
                for rowBitWithinByte := range 8 </span><span class="cov0" title="0">{
                        for columnByte := range nColsInputBytes </span><span class="cov0" title="0">{
                                for columnBitWithinByte := range 8 </span><span class="cov0" title="0">{
                                        rowBit := rowByte&lt;&lt;3 + rowBitWithinByte
                                        columnBit := columnByte&lt;&lt;3 + columnBitWithinByte
                                        // Grab the corresponding  bit at input[rowBit][columnBit]
                                        bitAtInputRowBitColumnBit := inputMatrix[rowBit][columnByte] &gt;&gt; columnBitWithinByte &amp; 0x01
                                        // Place the bit at output[columnBit][rowBit]
                                        shiftedBit := bitAtInputRowBitColumnBit &lt;&lt; rowBitWithinByte
                                        transposedMatrix[columnBit][rowByte] |= shiftedBit
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return transposedMatrix, nil</span>
}

// Parse converts a binary string into PackedBits.
func Parse(v string) (PackedBits, error) <span class="cov0" title="0">{
        if v == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("input string cannot be empty")
        }</span>

        <span class="cov0" title="0">byteLen := (len(v) + 7) / 8
        packedBits := make(PackedBits, byteLen)

        for i, char := range v </span><span class="cov0" title="0">{
                if char != '0' &amp;&amp; char != '1' </span><span class="cov0" title="0">{
                        return nil, ErrInvalidArgument.WithMessage("invalid character in the input")
                }</span>
                <span class="cov0" title="0">byteIndex := i / 8
                bitPos := uint(i % 8)

                if char == '1' </span><span class="cov0" title="0">{
                        packedBits[byteIndex] |= 1 &lt;&lt; (byte(bitPos))
                }</span>
        }

        <span class="cov0" title="0">return packedBits, nil</span>
}
</pre>
		
		<pre class="file" id="file250" style="display: none">package softspoken

import (
        "bytes"
        "encoding/gob"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

type challengeResponseDTO struct {
        X [SigmaBytes]byte
        T [Kappa][SigmaBytes]byte
}

type round1P2PDTO struct {
        U                 [Kappa][]byte // [][']bits
        ChallengeResponse challengeResponseDTO
}

func (r1 *Round1P2P) GobEncode() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;round1P2PDTO{
                U: r1.U,
                ChallengeResponse: challengeResponseDTO{
                        X: r1.ChallengeResponse.X,
                        T: r1.ChallengeResponse.T,
                },
        }

        var buf bytes.Buffer
        enc := gob.NewEncoder(&amp;buf)
        err := enc.Encode(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot serialise Round1P2P message")
        }</span>
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func (r1 *Round1P2P) GobDecode(data []byte) error <span class="cov0" title="0">{
        var out round1P2PDTO
        dec := gob.NewDecoder(bytes.NewReader(data))
        err := dec.Decode(&amp;out)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot deserialize Round1P2P message")
        }</span>

        <span class="cov0" title="0">r1.U = out.U
        r1.ChallengeResponse.X = out.ChallengeResponse.X
        r1.ChallengeResponse.T = out.ChallengeResponse.T
        return nil</span>
}
</pre>
		
		<pre class="file" id="file251" style="display: none">package softspoken

import (
        "github.com/bronlabs/bron-crypto/pkg/ot"
)

// Challenge is the verifier's random challenge for the consistency check (_i  [M=/][] bits).
type Challenge = [][SigmaBytes]byte // _i  [M=/][]bits is the random challenge for the consistency check.

// ChallengeResponse (, ) is the OTe challenge response from the receiver, to be verified by the Sender.
type ChallengeResponse struct {
        X [SigmaBytes]byte        `cbor:"x"`
        T [Kappa][SigmaBytes]byte `cbor:"t"`
}

// Round1P2P carries masked payloads and the Fiat-Shamir challenge response.
type Round1P2P struct {
        U                 [Kappa][]byte     `cbor:"u"`                 // [][']bits
        ChallengeResponse ChallengeResponse `cbor:"challengeResponse"` // [] + [][]bits
}

// Validate checks lengths of U entries against suite parameters.
func (r1 *Round1P2P) Validate(xi, l int) error <span class="cov8" title="1">{
        eta := l * xi                       //  = L*
        etaPrimeBytes := eta/8 + SigmaBytes // '=  + 
        for i := range Kappa </span><span class="cov8" title="1">{
                if len(r1.U[i]) != etaPrimeBytes </span><span class="cov0" title="0">{
                        return ot.ErrInvalidArgument.WithMessage("U[%d] length is %d, should be '=%d", i, len(r1.U[i]), etaPrimeBytes)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file252" style="display: none">package softspoken

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "io"
        "slices"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel         = "BRON_CRYPTO_SOFTSPOKEN_OT-"
        expansionMaskLabel      = "BRON_CRYPTO_SOFTSPOKEN_OT_EXPANSION_MASK-"
        challengeResponseXLabel = "BRON_CRYPTO_SOFTSPOKEN_OT_CHALLENGE_RESPONSE_X-"
        challengeResponseTLabel = "BRON_CRYPTO_SOFTSPOKEN_OT_CHALLENGE_RESPONSE_T-"
)

type participant struct {
        sessionID network.SID
        suite     *Suite
        round     int
        tape      transcripts.Transcript
        prng      io.Reader
}

// Sender drives the SoftSpoken sender state machine.
type Sender struct {
        participant

        receiverSeeds *vsot.ReceiverOutput
}

// Receiver drives the SoftSpoken receiver state machine.
type Receiver struct {
        participant

        senderSeeds *vsot.SenderOutput
}

// NewSender constructs a SoftSpoken sender with VSOT seed outputs.
func NewSender(sessionID network.SID, receiverSeeds *vsot.ReceiverOutput, suite *Suite, tape transcripts.Transcript, prng io.Reader) (*Sender, error) <span class="cov8" title="1">{
        if receiverSeeds == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid args")
        }</span>
        <span class="cov8" title="1">if receiverSeeds.InferredXi() != Kappa || receiverSeeds.InferredL() != 1 </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid receiver seeds")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        s := &amp;Sender{
                participant: participant{
                        sessionID,
                        suite,
                        2,
                        tape,
                        prng,
                },
                receiverSeeds: receiverSeeds,
        }

        return s, nil</span>
}

// NewReceiver constructs a SoftSpoken receiver with VSOT seed outputs.
func NewReceiver(sessionID network.SID, senderSeeds *vsot.SenderOutput, suite *Suite, tape transcripts.Transcript, prng io.Reader) (*Receiver, error) <span class="cov8" title="1">{
        if senderSeeds == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid args")
        }</span>
        <span class="cov8" title="1">if senderSeeds.InferredXi() != Kappa || senderSeeds.InferredL() != 1 </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid sender seeds")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        r := &amp;Receiver{
                participant: participant{
                        sessionID,
                        suite,
                        1,
                        tape,
                        prng,
                },
                senderSeeds: senderSeeds,
        }

        return r, nil</span>
}

func (p *participant) hash(j, l int, data ...[]byte) ([]byte, error) <span class="cov8" title="1">{
        preimage := slices.Concat(p.sessionID[:], binary.LittleEndian.AppendUint64(nil, uint64(j)), binary.LittleEndian.AppendUint64(nil, uint64(l)))
        for _, d := range data </span><span class="cov8" title="1">{
                preimage = slices.Concat(preimage, d)
        }</span>
        <span class="cov8" title="1">out, err := hashing.Hash(p.suite.hashFunc, preimage)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash data")
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// expand derives pseudorandom output from a seed message and choice bit.
func (p *participant) expand(outputLen, idx int, message []byte, choice int) ([]byte, error) <span class="cov8" title="1">{
        xof, err := blake2b.NewXOF(blake2b.OutputLengthUnknown, p.sessionID[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create blake2b XOF")
        }</span>
        <span class="cov8" title="1">_, err = xof.Write(slices.Concat(binary.LittleEndian.AppendUint64(nil, uint64(idx)), binary.LittleEndian.AppendUint64(nil, uint64(choice)), message))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot write to blake2b XOF")
        }</span>
        <span class="cov8" title="1">digest := make([]byte, outputLen)
        if _, err = io.ReadFull(xof, digest); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot read digest")
        }</span>
        <span class="cov8" title="1">return digest, nil</span>
}
</pre>
		
		<pre class="file" id="file253" style="display: none">package softspoken

import (
        "crypto/subtle"
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/binaryfields/bf128"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// Round1 expands receiver seeds, applies choice mask x, and returns masked values and output.
func (r *Receiver) Round1(x []byte) (*Round1P2P, *ReceiverOutput, error) <span class="cov8" title="1">{
        if r.round != 1 </span><span class="cov0" title="0">{
                return nil, nil, ot.ErrRound.WithMessage("running round %d but participant expected round %d", 1, r.round)
        }</span>
        <span class="cov8" title="1">if len(x)*8 != r.suite.Xi() </span><span class="cov0" title="0">{
                return nil, nil, ot.ErrInvalidArgument.WithMessage("choice bits length must be =%d (is %d)", r.suite.Xi(), len(x)*8)
        }</span>

        <span class="cov8" title="1">receiverOutput := &amp;ReceiverOutput{
                ot.ReceiverOutput[[]byte]{
                        Choices:  x,
                        Messages: nil,
                },
        }

        eta := r.suite.L() * r.suite.Xi() //  = L*
        etaBytes := eta / 8
        etaPrimeBytes := etaBytes + SigmaBytes // '=  + 

        // EXTENSION
        // step 1.1 &amp; 1.2: Generate x' as a concatenation of L copies of x and  random bits
        sigmaBits := make([]byte, SigmaBytes)
        _, err := io.ReadFull(r.prng, sigmaBits)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("sampling random bits for Softspoken OTe")
        }</span>
        <span class="cov8" title="1">xPrime := slices.Concat(ot.PackedBits(x).Repeat(r.suite.L()), sigmaBits)

        // step 1.3: Extend the baseOT seeds
        var t [2][Kappa][]byte
        for i := range Kappa </span><span class="cov8" title="1">{
                t[0][i], err = r.expand(etaPrimeBytes, i, r.senderSeeds.Messages[i][0][0], 0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("bad PRG writing for SoftSpoken OTe")
                }</span>
                <span class="cov8" title="1">t[1][i], err = r.expand(etaPrimeBytes, i, r.senderSeeds.Messages[i][1][0], 1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("bad PRG writing for SoftSpoken OTe")
                }</span>
        }

        // step 1.4: Compute u_i = t_{0,i}  t_{1,i}  x'
        <span class="cov8" title="1">r1 := new(Round1P2P)
        for i := range Kappa </span><span class="cov8" title="1">{
                r1.U[i] = make([]byte, etaPrimeBytes)
                subtle.XORBytes(r1.U[i], t[0][i], t[1][i])
                subtle.XORBytes(r1.U[i], r1.U[i], xPrime)
        }</span>

        // CONSISTENCY CHECK (Fiat-Shamir)
        // step 1.5: Generate the challenge () using Fiat-Shamir heuristic
        <span class="cov8" title="1">for i := range Kappa </span><span class="cov8" title="1">{
                r.tape.AppendBytes(expansionMaskLabel, r1.U[i])
        }</span>
        <span class="cov8" title="1">m := eta / Sigma                                    // M = /
        challengeFiatShamir := generateChallenge(r.tape, m) // 
        // step 1.6: Compute the challenge response (, _i) using the challenge ()
        err = r.computeResponse(xPrime, &amp;t, challengeFiatShamir, &amp;r1.ChallengeResponse)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute challenge")
        }</span>

        <span class="cov8" title="1">r.tape.AppendBytes(challengeResponseXLabel, r1.ChallengeResponse.X[:])
        for i := range Kappa </span><span class="cov8" title="1">{
                r.tape.AppendBytes(challengeResponseTLabel, r1.ChallengeResponse.T[i][:])
        }</span>

        // RANDOMISE
        // step 1.7: Transpose t_{0,i,j} -&gt; t_{0,j,i}  i[], j[']
        <span class="cov8" title="1">tj, err := ot.TransposePackedBits(t[0][:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("bad transposing t_0 for SoftSpoken COTe")
        }</span>
        // step 1.9: Randomise by hashing t_{0,j,i}  j['], i[]

        <span class="cov8" title="1">receiverOutput.Messages = make([][][]byte, r.suite.Xi())
        for j := range r.suite.Xi() </span><span class="cov8" title="1">{
                receiverOutput.Messages[j] = make([][]byte, r.suite.L())
                for l := range r.suite.L() </span><span class="cov8" title="1">{
                        digest, err := r.hash(j, l, tj[j*r.suite.L()+l])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("bad hashing t_j for SoftSpoken COTe")
                        }</span>
                        <span class="cov8" title="1">receiverOutput.Messages[j][l] = digest</span>
                }
        }

        <span class="cov8" title="1">r.round += 2
        return r1, receiverOutput, nil</span>
}

// Round2 uses the PRG to extend the baseOT results and verifies their consistency.
// Round2 derives sender outputs from seeds and receiver challenge, then checks consistency.
func (s *Sender) Round2(r1 *Round1P2P) (senderOutput *SenderOutput, err error) <span class="cov8" title="1">{
        // Validation
        if s.round != 2 </span><span class="cov0" title="0">{
                return nil, ot.ErrRound.WithMessage("running round %d but participant expected round %d", 2, s.round)
        }</span>
        <span class="cov8" title="1">if err := r1.Validate(s.suite.Xi(), s.suite.L()); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid round %d input", s.round)
        }</span>

        <span class="cov8" title="1">eta := s.suite.L() * s.suite.Xi()   //  = L*
        etaPrimeBytes := eta/8 + SigmaBytes // '=  + 

        // EXTENSION
        // step 2.1: Extend the baseOT seeds
        var tb [Kappa][]byte
        for i := range Kappa </span><span class="cov8" title="1">{
                tb[i], err = s.expand(etaPrimeBytes, i, s.receiverSeeds.Messages[i][0], int(s.receiverSeeds.Choices[i/8]&gt;&gt;(i%8)&amp;0b1))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("bad PRG write for SoftSpoken OTe")
                }</span>
        }
        // step 2.2: Compute q_i = b_i  u_i + tb_i  i[]
        <span class="cov8" title="1">extCorrelations := make([][]byte, Kappa)
        qiTemp := make([]byte, etaPrimeBytes)
        for i := range Kappa </span><span class="cov8" title="1">{
                extCorrelations[i] = tb[i]
                subtle.XORBytes(qiTemp, r1.U[i], tb[i])
                c := s.receiverSeeds.Choices[i/8] &gt;&gt; (i % 8) &amp; 0b1
                subtle.ConstantTimeCopy(int(c), extCorrelations[i], qiTemp)
        }</span>

        // CONSISTENCY CHECK (Fiat-Shamir)
        // step 2.3: Generate the challenge () using Fiat-Shamir heuristic
        <span class="cov8" title="1">for i := range Kappa </span><span class="cov8" title="1">{
                s.tape.AppendBytes(expansionMaskLabel, r1.U[i])
        }</span>
        <span class="cov8" title="1">M := eta / Sigma
        challengeFiatShamir := generateChallenge(s.tape, M)
        // step 2.4: Verify the challenge response (, _i) using the challenge ()
        err = s.verifyChallenge(challengeFiatShamir, &amp;r1.ChallengeResponse, extCorrelations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, base.ErrAbort.WithMessage("bad consistency check for SoftSpoken COTe")
        }</span>

        <span class="cov8" title="1">s.tape.AppendBytes(challengeResponseXLabel, r1.ChallengeResponse.X[:])
        for i := range Kappa </span><span class="cov8" title="1">{
                s.tape.AppendBytes(challengeResponseTLabel, r1.ChallengeResponse.T[i][:])
        }</span>

        // RANDOMISE
        // step 2.5: Transpose q_{i,j} -&gt; q_{j,i}  i[], j[']
        <span class="cov8" title="1">qjTransposed, err := ot.TransposePackedBits(extCorrelations)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("bad transposing q_{i,j} for SoftSpoken COTe")
        }</span>
        // step 2.6: Randomise by hashing q_{j,i} and q_{j,i}+_i  j[], i[]
        <span class="cov8" title="1">qjTransposedPlusDelta := make([][]byte, eta)
        for j := range eta </span><span class="cov8" title="1">{
                qjTransposedPlusDelta[j] = make([]byte, Kappa/8)
                // drop last '- rows, they are used only for the consistency check
                subtle.XORBytes(qjTransposedPlusDelta[j], qjTransposed[j], s.receiverSeeds.Choices)
        }</span>
        <span class="cov8" title="1">senderOutput = &amp;SenderOutput{
                ot.SenderOutput[[]byte]{
                        Messages: make([][2][][]byte, s.suite.Xi()),
                },
        }
        for j := range s.suite.Xi() </span><span class="cov8" title="1">{
                senderOutput.Messages[j][0] = make([][]byte, s.suite.L())
                senderOutput.Messages[j][1] = make([][]byte, s.suite.L())
                for l := range s.suite.L() </span><span class="cov8" title="1">{
                        digest, err := s.hash(j, l, qjTransposed[j*s.suite.L()+l])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("bad hashing q_j for SoftSpoken COTe (T&amp;R.2)")
                        }</span>
                        <span class="cov8" title="1">senderOutput.Messages[j][0][l] = digest
                        digest, err = s.hash(j, l, qjTransposedPlusDelta[j*s.suite.L()+l])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("bad hashing q_j_pDelta for SoftSpoken COTe (T&amp;R.2)")
                        }</span>
                        <span class="cov8" title="1">senderOutput.Messages[j][1][l] = digest</span>
                }
        }

        <span class="cov8" title="1">s.round += 2
        return senderOutput, nil</span>
}

// -------------------------------------------------------------------------- //
// --------------------------  CONSISTENCY CHECK ---------------------------- //
// -------------------------------------------------------------------------- //
// This section contains the functions for the fiat-shamir consistency check:
// 1. generateChallenge: the verifier generates the challenge ().
// 2. computeResponse: the prover computes the challenge response (, ^i)
//    using the challenge ().
// 3. verifyChallenge: the verifier verifies the challenge response (, ^i)
//    using the challenge () and the commitment to the statement (u_i).
//

func generateChallenge(transcript transcripts.Transcript, challengeLength int) (challenge Challenge) <span class="cov8" title="1">{
        challengeFiatShamir := make(Challenge, challengeLength)
        for i := range challengeLength </span><span class="cov8" title="1">{
                bytes, _ := transcript.ExtractBytes("OTe_challenge_Chi", SigmaBytes)
                copy(challengeFiatShamir[i][:], bytes)
        }</span>
        <span class="cov8" title="1">return challengeFiatShamir</span>
}

// computeResponse Computes the challenge response , ^i i[].
func (*Receiver) computeResponse(xPrime []byte, extOptions *[2][Kappa][]byte, challenge Challenge, challengeResponse *ChallengeResponse) error <span class="cov8" title="1">{
        m := len(challenge)
        etaBytes := (m * Sigma) / 8 // M = / -&gt;  = M*
        //  = x_{m:(m+1)} + {k=1}^{m} _k  x_{(k-1):k}
        x, err := bf128.NewField().FromBytes(xPrime[etaBytes : etaBytes+SigmaBytes])
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create field element")
        }</span>
        <span class="cov8" title="1">chi := make([]*bf128.FieldElement, m)
        for k := range m </span><span class="cov8" title="1">{
                xHatK, err := bf128.NewField().FromBytes(xPrime[k*SigmaBytes : (k+1)*SigmaBytes])
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot create field element")
                }</span>
                <span class="cov8" title="1">chi[k], err = bf128.NewField().FromBytes(challenge[k][:])
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot create field element")
                }</span>
                <span class="cov8" title="1">x = x.Add(xHatK.Mul(chi[k]))</span>
        }
        <span class="cov8" title="1">copy(challengeResponse.X[:], x.Bytes())
        // ^i = t^i_{0,{m:(m+1)} + {k=1}^{m} _k  t^i_{0,{(k-1):k}}
        for i := range Kappa </span><span class="cov8" title="1">{
                t, err := bf128.NewField().FromBytes(extOptions[0][i][etaBytes : etaBytes+SigmaBytes])
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot create field element")
                }</span>
                <span class="cov8" title="1">copy(challengeResponse.T[i][:], extOptions[0][i][etaBytes:etaBytes+SigmaBytes])
                for k := range m </span><span class="cov8" title="1">{
                        tHatK, err := bf128.NewField().FromBytes(extOptions[0][i][k*SigmaBytes : (k+1)*SigmaBytes])
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot create field element")
                        }</span>
                        <span class="cov8" title="1">t = t.Add(tHatK.Mul(chi[k]))</span>
                }
                <span class="cov8" title="1">copy(challengeResponse.T[i][:], t.Bytes())</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// verifyChallenge checks the consistency of the extension.
func (s *Sender) verifyChallenge(
        challenge Challenge,
        challengeResponse *ChallengeResponse,
        extCorrelations [][]byte,
) error <span class="cov8" title="1">{
        // Compute sizes
        m := len(challenge)                                // M = /
        etaBytes := (len(extCorrelations[0])) - SigmaBytes //  =  ' - 
        isCorrect := true
        for i := range Kappa </span><span class="cov8" title="1">{
                // q^i = q^i_hat_{m+1} + {k=1}^{m} _k  q^i_hat_k
                qi, err := bf128.NewField().FromBytes(extCorrelations[i][etaBytes : etaBytes+SigmaBytes])
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot create field element")
                }</span>
                <span class="cov8" title="1">for k := range m </span><span class="cov8" title="1">{
                        qiHatK, err := bf128.NewField().FromBytes(extCorrelations[i][k*SigmaBytes : (k+1)*SigmaBytes])
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot create field element")
                        }</span>
                        <span class="cov8" title="1">chiK, err := bf128.NewField().FromBytes(challenge[k][:])
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot create field element")
                        }</span>
                        <span class="cov8" title="1">qi = qi.Add(qiHatK.Mul(chiK))</span>
                }
                // ABORT if q^i != ^i + _i     i []
                <span class="cov8" title="1">t, err := bf128.NewField().FromBytes(challengeResponse.T[i][:])
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot create field element")
                }</span>
                <span class="cov8" title="1">x, err := bf128.NewField().FromBytes(challengeResponse.X[:])
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot create field element")
                }</span>
                <span class="cov8" title="1">choice := uint64((s.receiverSeeds.Choices[i/8] &gt;&gt; (i % 8)) &amp; 0b1)
                qiExpected := bf128.NewField().Select(choice, t, t.Add(x))
                isCorrect = isCorrect &amp;&amp; qiExpected.Equal(qi)</span>
        }
        <span class="cov8" title="1">if !isCorrect </span><span class="cov0" title="0">{
                return base.ErrAbort.WithMessage("expected q != q in SoftspokenOT, consistency check failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file254" style="display: none">package softspoken

import (
        "hash"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
)

const (
        // Kappa is the computational security parameter and number of seed OTs.
        Kappa = base.ComputationalSecurityBits

        // Sigma is the statistical security parameter.
        // Note: We apply the Fiat-Shamir transform using RO, and the
        // protocol retains UC security. This reduces the protocol to a single round
        // from receiver to sender (after the initial setup). Because the adversary
        // can attempt to find a convenient challenge by brute force under this optimization,
        // each occurrence of the statistical parameter (s in the notation of Keller
        // et al.) in the original protocol must be replaced by the computational security parameter.
        Sigma      = base.ComputationalSecurityBits
        SigmaBytes = base.ComputationalSecurityBytesCeil
)

type Suite struct {
        ot.DefaultSuite

        hashFunc func() hash.Hash
}

// NewSuite configures SoftSpokenOT for batch size xi, block length l, and hash function.
func NewSuite(xi, l int, hashFunc func() hash.Hash) (*Suite, error) <span class="cov8" title="1">{
        defaultSuite, err := ot.NewDefaultSuite(xi, l)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create default OT suite")
        }</span>
        <span class="cov8" title="1">if (xi % 8) != 0 </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid xi")
        }</span>
        <span class="cov8" title="1">if ((xi * l) % Sigma) != 0 </span><span class="cov0" title="0">{
                return nil, ot.ErrInvalidArgument.WithMessage("invalid xi or l; (xi * l) must be multiple of %d for consistency check", Sigma)
        }</span>

        <span class="cov8" title="1">s := &amp;Suite{*defaultSuite, hashFunc}
        return s, nil</span>
}

// SenderOutput holds the sender's SoftSpoken outputs.
type SenderOutput struct {
        ot.SenderOutput[[]byte]
}

// InferredMessageBytesLen infers the message byte length, returning 0 on inconsistency.
func (so *SenderOutput) InferredMessageBytesLen() int <span class="cov0" title="0">{
        if len(so.Messages) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(so.Messages[0][0]) == 0 || len(so.Messages[0][1]) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">l := len(so.Messages[0][0][0])
        for _, messages := range so.Messages </span><span class="cov0" title="0">{
                for _, message := range messages[0] </span><span class="cov0" title="0">{
                        if len(message) != l </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                }
                <span class="cov0" title="0">for _, message := range messages[1] </span><span class="cov0" title="0">{
                        if len(message) != l </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                }
        }
        <span class="cov0" title="0">return l</span>
}

type ReceiverOutput struct {
        ot.ReceiverOutput[[]byte]
}

// InferredMessageBytesLen infers the message byte length, returning 0 on inconsistency.
func (ro *ReceiverOutput) InferredMessageBytesLen() int <span class="cov0" title="0">{
        if len(ro.Messages) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(ro.Messages[0]) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">l := len(ro.Messages[0][0])
        for _, messages := range ro.Messages </span><span class="cov0" title="0">{
                for _, message := range messages </span><span class="cov0" title="0">{
                        if len(message) != l </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                }
        }
        <span class="cov0" title="0">return l</span>
}
</pre>
		
		<pre class="file" id="file255" style="display: none">package ot

// Suite captures batch and block sizes for an OT instantiation.
type Suite interface {
        Xi() int
        L() int
}

// DefaultSuite implements Suite with fixed parameters.
type DefaultSuite struct {
        xi int
        l  int
}

// NewDefaultSuite constructs a suite with the given batch size xi and message block length l.
func NewDefaultSuite(xi, l int) (*DefaultSuite, error) <span class="cov0" title="0">{
        if xi &lt;= 0 || l &lt;= 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid args")
        }</span>
        <span class="cov0" title="0">return &amp;DefaultSuite{xi, l}, nil</span>
}

// Xi returns the batch size (number of parallel OTs).
func (s *DefaultSuite) Xi() int <span class="cov0" title="0">{
        return s.xi
}</span>

// L returns the message block length.
func (s *DefaultSuite) L() int <span class="cov0" title="0">{
        return s.l
}</span>

// SenderOutput holds the sender's pair of messages for each OT and block index.
type SenderOutput[D any] struct {
        Messages [][2][]D `cbor:"messages"`
}

// InferredXi infers xi from the message count, or returns 0 if inconsistent.
func (so *SenderOutput[D]) InferredXi() int <span class="cov0" title="0">{
        return len(so.Messages)
}</span>

// InferredL infers l from the first entry and validates consistency across all entries.
func (so *SenderOutput[D]) InferredL() int <span class="cov0" title="0">{
        if len(so.Messages) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">l := len(so.Messages[0][0])
        for _, messages := range so.Messages </span><span class="cov0" title="0">{
                l0 := len(messages[0])
                l1 := len(messages[1])
                if l0 != l </span><span class="cov0" title="0">{
                        return 0
                }</span>
                <span class="cov0" title="0">if l1 != l </span><span class="cov0" title="0">{
                        return 0
                }</span>
        }

        <span class="cov0" title="0">return l</span>
}

// ReceiverOutput holds the receiver's choice bits and selected messages.
type ReceiverOutput[D any] struct {
        Choices  []byte `cbor:"choices"`
        Messages [][]D  `cbor:"messages"`
}

// InferredXi infers xi from choice bits and message count, returning 0 on mismatch.
func (ro *ReceiverOutput[D]) InferredXi() int <span class="cov0" title="0">{
        xi := len(ro.Messages)
        if len(ro.Choices)*8 != len(ro.Messages) </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return xi</span>
}

// InferredL infers l from the first row and validates consistency across all entries.
func (ro *ReceiverOutput[D]) InferredL() int <span class="cov0" title="0">{
        if len(ro.Messages) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">l := len(ro.Messages[0])
        for _, messages := range ro.Messages </span><span class="cov0" title="0">{
                if len(messages) != l </span><span class="cov0" title="0">{
                        return 0
                }</span>
        }
        <span class="cov0" title="0">return l</span>
}
</pre>
		
		<pre class="file" id="file256" style="display: none">package batch_schnorr

import (
        "encoding/binary"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils"
        "github.com/bronlabs/bron-crypto/pkg/proofs/dlog"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// Name is the protocol identifier for batch Schnorr discrete log proof.
const (
        Name sigma.Name = "BATCH_SCHNORR" + dlog.Type
)

var (
        // ErrInvalidArgument is returned when a function receives an invalid argument.
        ErrInvalidArgument = errs2.New("invalid argument")
        // ErrValidationFailed is returned when statement-witness validation fails.
        ErrValidationFailed = errs2.New("validation failed")
        // ErrVerificationFailed is returned when proof verification fails.
        ErrVerificationFailed = errs2.New("verification failed")
)

// Statement contains the generator and public group elements X_i being proven.
type Statement[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        Gen G   `cbor:"gen"`
        Xs  []G `cbor:"xs"`
}

// NewStatement creates a new statement from a generator and public group elements.
func NewStatement[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](g G, xs ...G) *Statement[G, S] <span class="cov8" title="1">{
        return &amp;Statement[G, S]{
                Gen: g,
                Xs:  xs,
        }
}</span>

// Bytes serialises the statement to a byte slice.
func (x *Statement[G, S]) Bytes() []byte <span class="cov0" title="0">{
        var d []byte

        gBytes := x.Gen.Bytes()
        d = binary.LittleEndian.AppendUint64(d, uint64(len(gBytes)))
        d = append(d, gBytes...)

        t := len(x.Xs)
        d = binary.LittleEndian.AppendUint64(d, uint64(t))
        for _, xi := range x.Xs </span><span class="cov0" title="0">{
                xBytes := xi.Bytes()
                d = binary.LittleEndian.AppendUint64(d, uint64(len(xBytes)))
                d = append(d, xi.Bytes()...)
        }</span>

        <span class="cov0" title="0">return d</span>
}

// Witness contains the secret scalars w_i such that X_i = g^w_i.
type Witness[S algebra.PrimeFieldElement[S]] struct {
        Ws []S `cbor:"ws"`
}

// NewWitness creates a new witness from secret scalars.
func NewWitness[S algebra.PrimeFieldElement[S]](ws ...S) *Witness[S] <span class="cov8" title="1">{
        return &amp;Witness[S]{
                Ws: ws,
        }
}</span>

// Bytes serialises the witness to a byte slice.
func (w *Witness[S]) Bytes() []byte <span class="cov0" title="0">{
        var d []byte

        t := len(w.Ws)
        d = binary.LittleEndian.AppendUint64(d, uint64(t))
        for _, wi := range w.Ws </span><span class="cov0" title="0">{
                wBytes := wi.Bytes()
                d = binary.LittleEndian.AppendUint64(d, uint64(len(wBytes)))
                d = append(d, wi.Bytes()...)
        }</span>

        <span class="cov0" title="0">return d</span>
}

// Commitment is the first message sent by the prover.
type Commitment[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        A G `cbor:"a"`
}

// Bytes serialises the commitment to a byte slice.
func (a *Commitment[G, S]) Bytes() []byte <span class="cov0" title="0">{
        var d []byte

        aBytes := a.A.Bytes()
        d = binary.LittleEndian.AppendUint64(d, uint64(len(aBytes)))
        d = append(d, aBytes...)

        return d
}</span>

// State holds the prover's randomness during the protocol execution.
type State[S algebra.PrimeFieldElement[S]] struct {
        S S `cbor:"s"`
}

// Response is the prover's answer to the verifier's challenge.
type Response[S algebra.PrimeFieldElement[S]] struct {
        Z S `cbor:"z"`
}

// Bytes serialises the response to a byte slice.
func (z *Response[S]) Bytes() []byte <span class="cov0" title="0">{
        var d []byte

        zBytes := z.Z.Bytes()
        d = binary.LittleEndian.AppendUint64(d, uint64(len(zBytes)))
        d = append(d, zBytes...)

        return d
}</span>

// Protocol implements a batch Schnorr sigma protocol for proving knowledge of k discrete logarithms.
// Given a generator g and public elements X_1,...,X_k, it proves knowledge of w_1,...,w_k such that X_i = g^w_i.
type Protocol[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        k               int
        challengeLength int
        soundnessError  int
        group           algebra.PrimeGroup[G, S]
        scalarField     algebra.PrimeField[S]
        prng            io.Reader
}

// NewProtocol creates a new batch Schnorr protocol for k discrete logarithms.
func NewProtocol[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](k int, group algebra.PrimeGroup[G, S], prng io.Reader) (*Protocol[G, S], error) <span class="cov8" title="1">{
        if k &lt; 2 </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("k must be &gt;= 2")
        }</span>
        <span class="cov8" title="1">if group == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("group is nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>

        <span class="cov8" title="1">challengeLengthBits := base.ComputationalSecurityBits + mathutils.CeilLog2(k)
        challengeLengthBytes := mathutils.CeilDiv(challengeLengthBits, 8)
        soundnessError := challengeLengthBytes*8 - mathutils.CeilLog2(k)
        scalarField := algebra.StructureMustBeAs[algebra.PrimeField[S]](group.ScalarStructure())
        p := &amp;Protocol[G, S]{
                k:               k,
                challengeLength: challengeLengthBytes,
                soundnessError:  soundnessError,
                group:           group,
                scalarField:     scalarField,
                prng:            prng,
        }
        return p, nil</span>
}

// Name returns the protocol identifier.
func (*Protocol[G, S]) Name() sigma.Name <span class="cov0" title="0">{
        return Name
}</span>

// ComputeProverCommitment generates the prover's first message and internal state.
func (p *Protocol[G, S]) ComputeProverCommitment(statement *Statement[G, S], _ *Witness[S]) (*Commitment[G, S], *State[S], error) <span class="cov8" title="1">{
        if statement == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("statement is nil")
        }</span>

        <span class="cov8" title="1">s, err := p.scalarField.Random(p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot generate random scalar")
        }</span>
        <span class="cov8" title="1">a := statement.Gen.ScalarOp(s)

        commitment := &amp;Commitment[G, S]{
                A: a,
        }
        state := &amp;State[S]{
                S: s,
        }
        return commitment, state, nil</span>
}

// ComputeProverResponse computes the prover's response to the verifier's challenge.
func (p *Protocol[G, S]) ComputeProverResponse(_ *Statement[G, S], witness *Witness[S], _ *Commitment[G, S], state *State[S], challenge sigma.ChallengeBytes) (*Response[S], error) <span class="cov8" title="1">{
        if state == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("state is nil")
        }</span>
        <span class="cov8" title="1">if witness == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("witness is nil")
        }</span>
        <span class="cov8" title="1">if len(witness.Ws) != p.k </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid number of witnesses")
        }</span>
        <span class="cov8" title="1">if len(challenge) != p.challengeLength </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid challenge length")
        }</span>

        <span class="cov8" title="1">polyRing, err := polynomials.NewPolynomialRing(p.scalarField)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create polynomial ring")
        }</span>
        <span class="cov8" title="1">coefficients := append([]S{state.S}, witness.Ws...)
        poly, err := polyRing.New(coefficients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create polynomial")
        }</span>

        <span class="cov8" title="1">e, err := p.scalarField.FromWideBytes(challenge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert challenge to scalar")
        }</span>

        <span class="cov8" title="1">z := poly.Eval(e)
        response := &amp;Response[S]{
                Z: z,
        }
        return response, nil</span>
}

// Verify checks if a proof transcript is valid for the given statement.
func (p *Protocol[G, S]) Verify(statement *Statement[G, S], commitment *Commitment[G, S], challenge sigma.ChallengeBytes, response *Response[S]) error <span class="cov8" title="1">{
        if commitment == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("commitment is nil")
        }</span>
        <span class="cov8" title="1">if statement == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("statement is nil")
        }</span>
        <span class="cov8" title="1">if response == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("response is nil")
        }</span>
        <span class="cov8" title="1">if len(statement.Xs) != p.k </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("invalid number of statements")
        }</span>
        <span class="cov8" title="1">if len(challenge) != p.challengeLength </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("invalid challenge length")
        }</span>

        <span class="cov8" title="1">polyModule, err := polynomials.NewPolynomialModule(p.group)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create polynomial module")
        }</span>
        <span class="cov8" title="1">coefficients := append([]G{commitment.A}, statement.Xs...)
        poly, err := polyModule.New(coefficients...)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create polynomial")
        }</span>

        <span class="cov8" title="1">e, err := p.scalarField.FromWideBytes(challenge)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot convert challenge to scalar")
        }</span>

        <span class="cov8" title="1">rCheck := poly.Eval(e)
        if !rCheck.Equal(statement.Gen.ScalarOp(response.Z)) </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("invalid proof")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RunSimulator generates a simulated proof transcript for the given statement and challenge.
func (p *Protocol[G, S]) RunSimulator(statement *Statement[G, S], challenge sigma.ChallengeBytes) (*Commitment[G, S], *Response[S], error) <span class="cov8" title="1">{
        z, err := p.scalarField.Random(p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample random scalar")
        }</span>

        <span class="cov8" title="1">e, err := p.scalarField.FromWideBytes(challenge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot convert challenge to scalar")
        }</span>

        <span class="cov8" title="1">polyModule, err := polynomials.NewPolynomialModule(p.group)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create polynomial module")
        }</span>
        <span class="cov8" title="1">coefficients := append([]G{p.group.OpIdentity()}, statement.Xs...)
        poly, err := polyModule.New(coefficients...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create polynomial")
        }</span>
        <span class="cov8" title="1">a := statement.Gen.ScalarOp(z).Op(poly.Eval(e).OpInv())

        commitment := &amp;Commitment[G, S]{
                A: a,
        }
        response := &amp;Response[S]{
                Z: z,
        }
        return commitment, response, nil</span>
}

// SpecialSoundness returns the number of transcripts needed for knowledge extraction (k+1).
func (p *Protocol[G, S]) SpecialSoundness() uint <span class="cov0" title="0">{
        return uint(p.k + 1)
}</span>

// SoundnessError returns the soundness error in bits.
func (p *Protocol[G, S]) SoundnessError() uint <span class="cov0" title="0">{
        return uint(p.soundnessError)
}</span>

// GetChallengeBytesLength returns the required challenge length in bytes.
func (p *Protocol[G, S]) GetChallengeBytesLength() int <span class="cov8" title="1">{
        return p.challengeLength
}</span>

// ValidateStatement checks that the statement and witness are consistent.
func (p *Protocol[G, S]) ValidateStatement(statement *Statement[G, S], witness *Witness[S]) error <span class="cov0" title="0">{
        if statement == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("statement is nil")
        }</span>
        <span class="cov0" title="0">if witness == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("witness is nil")
        }</span>
        <span class="cov0" title="0">if len(statement.Xs) != p.k </span><span class="cov0" title="0">{
                return ErrValidationFailed.WithMessage("invalid number of statements")
        }</span>
        <span class="cov0" title="0">if len(witness.Ws) != p.k </span><span class="cov0" title="0">{
                return ErrValidationFailed.WithMessage("invalid number of witnesses")
        }</span>

        <span class="cov0" title="0">for i := range p.k </span><span class="cov0" title="0">{
                if !statement.Gen.ScalarOp(witness.Ws[i]).Equal(statement.Xs[i]) </span><span class="cov0" title="0">{
                        return ErrValidationFailed.WithMessage("invalid statement")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func _[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](proto *Protocol[G, S]) {
        var _ sigma.Protocol[*Statement[G, S], *Witness[S], *Commitment[G, S], *State[S], *Response[S]] = proto
}
</pre>
		
		<pre class="file" id="file257" style="display: none">package dlog

import (
        "strings"

        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// Type is the identifier for proofs of knowledge of discrete logarithm.
const Type = "-dlog_pok-"

// IsProvingKnowledgeOfDiscreteLog checks whether the given sigma proof indicates
// that it is a proof of knowledge of discrete logarithm.
func IsProvingKnowledgeOfDiscreteLog(name sigma.Name) bool <span class="cov0" title="0">{
        return name != "" &amp;&amp; strings.Contains(string(name), Type)
}</span>
</pre>
		
		<pre class="file" id="file258" style="display: none">package schnorr

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/proofs/dlog"
        "github.com/bronlabs/bron-crypto/pkg/proofs/internal/meta/maurer09"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// Name is the protocol identifier for Schnorr's discrete log proof.
const Name sigma.Name = "SCHNORR" + dlog.Type

type (
        // Witness contains the secret scalar w such that X = g^w.
        Witness[S algebra.PrimeFieldElement[S]] = maurer09.Witness[S]
        // Statement contains the public group element X being proven.
        Statement[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] = maurer09.Statement[G]
        // State holds the prover's randomness during the protocol execution.
        State[S algebra.PrimeFieldElement[S]] = maurer09.State[S]
        // Commitment is the first message sent by the prover.
        Commitment[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] = maurer09.Commitment[G]
        // Response is the prover's answer to the verifier's challenge.
        Response[S algebra.PrimeFieldElement[S]] = maurer09.Response[S]
)

// NewWitness creates a new witness from a secret scalar.
func NewWitness[S algebra.PrimeFieldElement[S]](w S) *Witness[S] <span class="cov8" title="1">{
        return &amp;Witness[S]{W: w}
}</span>

// NewStatement creates a new statement from a public group element.
func NewStatement[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](x G) *Statement[G, S] <span class="cov8" title="1">{
        return &amp;Statement[G, S]{X: x}
}</span>

// Protocol implements Schnorr's sigma protocol for proving knowledge of a discrete logarithm.
// Given a generator g and public element X, it proves knowledge of w such that X = g^w.
type Protocol[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        maurer09.Protocol[G, S]
}

// NewProtocol creates a new Schnorr protocol instance with the given generator and randomness source.
func NewProtocol[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](generator G, prng io.Reader) (*Protocol[G, S], error) <span class="cov8" title="1">{
        group := algebra.StructureMustBeAs[algebra.PrimeGroup[G, S]](generator.Structure())
        scalarField := algebra.StructureMustBeAs[algebra.PrimeField[S]](group.ScalarStructure())
        challengeByteLen := 16
        soundnessError := uint(challengeByteLen * 8)
        homomorphism := func(s S) G </span><span class="cov8" title="1">{ return generator.ScalarOp(s) }</span>
        <span class="cov8" title="1">l, err := num.N().FromBytes(group.Order().Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create anchor")
        }</span>
        <span class="cov8" title="1">anc := &amp;anchor[G, S]{l, scalarField.Zero()}

        maurerProto, err := maurer09.NewProtocol(
                challengeByteLen,
                soundnessError,
                Name,
                group,
                scalarField,
                homomorphism,
                anc,
                prng,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return &amp;Protocol[G, S]{*maurerProto}, nil</span>
}

type anchor[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        l  *num.Nat
        id S
}

func (a *anchor[G, S]) L() *num.Nat <span class="cov8" title="1">{
        return a.l
}</span>

func (a *anchor[G, S]) PreImage(_ G) (w S) <span class="cov8" title="1">{
        return a.id
}</span>

func _[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](proto *Protocol[G, S]) {
        var _ sigma.MaurerProtocol[G, S, *Statement[G, S], *Witness[S], *Commitment[G, S], *State[S], *Response[S]] = proto
}
</pre>
		
		<pre class="file" id="file259" style="display: none">package maurer09

import (
        "io"
        "math/big"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

const (
        specialSoundness = 2
)

// Witness holds the Maurer09 witness.
type Witness[P algebra.GroupElement[P]] struct {
        W P `cbor:"w"`
}

// Bytes encodes the witness.
func (w *Witness[P]) Bytes() []byte <span class="cov0" title="0">{
        return w.W.Bytes()
}</span>

// Value returns the witness group element.
func (w *Witness[P]) Value() P <span class="cov0" title="0">{
        return w.W
}</span>

// Statement holds the Maurer09 statement.
type Statement[I algebra.GroupElement[I]] struct {
        X I `cbor:"x"`
}

// Bytes encodes the statement.
func (x *Statement[I]) Bytes() []byte <span class="cov0" title="0">{
        return x.X.Bytes()
}</span>

// Value returns the statement group element.
func (x *Statement[I]) Value() I <span class="cov0" title="0">{
        return x.X
}</span>

// State stores the prover's internal state.
type State[P algebra.GroupElement[P]] struct {
        S P `cbor:"s"`
}

// Bytes encodes the state.
func (s *State[P]) Bytes() []byte <span class="cov0" title="0">{
        return s.S.Bytes()
}</span>

// Value returns the state group element.
func (s *State[P]) Value() P <span class="cov0" title="0">{
        return s.S
}</span>

// Commitment holds the prover commitment.
type Commitment[I algebra.GroupElement[I]] struct {
        A I `cbor:"a"`
}

// Bytes encodes the commitment.
func (c *Commitment[I]) Bytes() []byte <span class="cov0" title="0">{
        return c.A.Bytes()
}</span>

// Value returns the commitment group element.
func (c *Commitment[I]) Value() I <span class="cov0" title="0">{
        return c.A
}</span>

// Response holds the prover response.
type Response[P algebra.GroupElement[P]] struct {
        Z P `cbor:"z"`
}

// Bytes encodes the response.
func (c *Response[P]) Bytes() []byte <span class="cov0" title="0">{
        return c.Z.Bytes()
}</span>

// Value returns the response group element.
func (c *Response[P]) Value() P <span class="cov0" title="0">{
        return c.Z
}</span>

// MaurerOption configures the Maurer09 protocol.
type MaurerOption[I algebra.GroupElement[I], P algebra.GroupElement[P]] func(protocol *Protocol[I, P])

// WithImageScalarMul overrides the scalar multiplication in the image group.
func WithImageScalarMul[I algebra.GroupElement[I], P algebra.GroupElement[P]](scalarMul func(I, []byte) I) MaurerOption[I, P] <span class="cov0" title="0">{
        return func(protocol *Protocol[I, P]) </span><span class="cov0" title="0">{
                protocol.imageScalarMul = scalarMul
        }</span>
}

// WithPreImageScalarMul overrides the scalar multiplication in the pre-image group.
func WithPreImageScalarMul[I algebra.GroupElement[I], P algebra.GroupElement[P]](scalarMul func(P, []byte) P) MaurerOption[I, P] <span class="cov0" title="0">{
        return func(protocol *Protocol[I, P]) </span><span class="cov0" title="0">{
                protocol.preImageScalarMul = scalarMul
        }</span>
}

// Protocol implements the Maurer09 sigma protocol.
type Protocol[I algebra.GroupElement[I], P algebra.GroupElement[P]] struct {
        imageGroup         algebra.FiniteGroup[I]
        preImageGroup      algebra.FiniteGroup[P]
        challengeByteLen   int
        soundnessError     uint
        name               sigma.Name
        oneWayHomomorphism sigma.OneWayHomomorphism[I, P]
        anchor             sigma.Anchor[I, P]
        imageScalarMul     func(I, []byte) I
        preImageScalarMul  func(P, []byte) P
        prng               io.Reader
}

// NewProtocol constructs a Maurer09 protocol instance.
func NewProtocol[I algebra.GroupElement[I], P algebra.GroupElement[P]](
        challengeByteLen int,
        soundnessError uint,
        name sigma.Name,
        imageGroup algebra.FiniteGroup[I],
        preImageGroup algebra.FiniteGroup[P],
        oneWayHomomorphism sigma.OneWayHomomorphism[I, P],
        anchor sigma.Anchor[I, P],
        prng io.Reader,
        options ...MaurerOption[I, P],
) (*Protocol[I, P], error) <span class="cov0" title="0">{
        if challengeByteLen &lt;= 0 || soundnessError &lt; 1 || imageGroup == nil || preImageGroup == nil || oneWayHomomorphism == nil || anchor == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid arguments")
        }</span>

        <span class="cov0" title="0">p := &amp;Protocol[I, P]{
                imageGroup:         imageGroup,
                preImageGroup:      preImageGroup,
                challengeByteLen:   challengeByteLen,
                soundnessError:     soundnessError,
                name:               name,
                oneWayHomomorphism: oneWayHomomorphism,
                anchor:             anchor,
                imageScalarMul:     defaultScalarMul[I],
                preImageScalarMul:  defaultScalarMul[P],
                prng:               prng,
        }
        for _, option := range options </span><span class="cov0" title="0">{
                option(p)
        }</span>
        <span class="cov0" title="0">return p, nil</span>
}

// ComputeProverCommitment creates the Maurer09 commitment and state.
func (p *Protocol[I, P]) ComputeProverCommitment(_ *Statement[I], _ *Witness[P]) (*Commitment[I], *State[P], error) <span class="cov0" title="0">{
        s, err := p.preImageGroup.Random(p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample element group")
        }</span>
        <span class="cov0" title="0">a := p.oneWayHomomorphism(s)

        return &amp;Commitment[I]{A: a}, &amp;State[P]{S: s}, nil</span>
}

// ComputeProverResponse computes the Maurer09 response.
func (p *Protocol[I, P]) ComputeProverResponse(_ *Statement[I], witness *Witness[P], _ *Commitment[I], state *State[P], challengeBytes sigma.ChallengeBytes) (*Response[P], error) <span class="cov0" title="0">{
        z := state.S.Op(p.preImageScalarMul(witness.W, challengeBytes))
        return &amp;Response[P]{Z: z}, nil
}</span>

// Verify checks a Maurer09 proof response.
func (p *Protocol[I, P]) Verify(statement *Statement[I], commitment *Commitment[I], challengeBytes sigma.ChallengeBytes, response *Response[P]) error <span class="cov0" title="0">{
        if !p.oneWayHomomorphism(response.Z).Equal(commitment.A.Op(p.imageScalarMul(statement.X, challengeBytes))) </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("invalid response")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RunSimulator simulates a Maurer09 transcript for a given challenge.
func (p *Protocol[I, P]) RunSimulator(statement *Statement[I], challengeBytes sigma.ChallengeBytes) (*Commitment[I], *Response[P], error) <span class="cov0" title="0">{
        z, err := p.preImageGroup.Random(p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample element group")
        }</span>
        <span class="cov0" title="0">a := p.oneWayHomomorphism(z).Op(p.imageScalarMul(statement.X.OpInv(), challengeBytes))

        return &amp;Commitment[I]{A: a}, &amp;Response[P]{Z: z}, nil</span>
}

// Extract derives the witness from two valid transcripts.
func (p *Protocol[I, P]) Extract(x *Statement[I], a *Commitment[I], ei []sigma.ChallengeBytes, zi []*Response[P]) (*Witness[P], error) <span class="cov0" title="0">{
        if uint(len(ei)) != specialSoundness || uint(len(zi)) != specialSoundness </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid number of challenge bytes")
        }</span>
        <span class="cov0" title="0">if err := p.Verify(x, a, ei[0], zi[0]); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("verification failed")
        }</span>
        <span class="cov0" title="0">if err := p.Verify(x, a, ei[1], zi[1]); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("verification failed")
        }</span>

        <span class="cov0" title="0">u := p.anchor.PreImage(x.X)

        // we have to fall back to big.Int here because it's the only way to compute ext GCD
        e1 := new(big.Int).SetBytes(ei[0])
        e2 := new(big.Int).SetBytes(ei[1])
        eDiff := new(big.Int).Sub(e1, e2)
        var g, alpha, beta big.Int
        g.GCD(&amp;alpha, &amp;beta, p.anchor.L().Big(), eDiff)
        if g.Cmp(big.NewInt(1)) != 0 </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("BUG: this should never happen")
        }</span>

        <span class="cov0" title="0">w := p.preImageScalarMulI(u, &amp;alpha).Op(p.preImageScalarMulI(zi[1].Z.OpInv().Op(zi[0].Z), &amp;beta))
        return &amp;Witness[P]{W: w}, nil</span>
}

// SpecialSoundness returns the protocol special soundness parameter.
func (*Protocol[I, P]) SpecialSoundness() uint <span class="cov0" title="0">{
        return specialSoundness
}</span>

// ValidateStatement checks statement/witness consistency.
func (p *Protocol[I, P]) ValidateStatement(statement *Statement[I], witness *Witness[P]) error <span class="cov0" title="0">{
        if !p.oneWayHomomorphism(witness.W).Equal(statement.X) </span><span class="cov0" title="0">{
                return ErrValidationFails.WithMessage("invalid statement")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetChallengeBytesLength returns the challenge size in bytes.
func (p *Protocol[I, P]) GetChallengeBytesLength() int <span class="cov0" title="0">{
        return p.challengeByteLen
}</span>

// Name returns the protocol name.
func (p *Protocol[I, P]) Name() sigma.Name <span class="cov0" title="0">{
        return p.name
}</span>

// SoundnessError returns the protocol soundness error.
func (p *Protocol[G, S]) SoundnessError() uint <span class="cov0" title="0">{
        return p.soundnessError
}</span>

// ImageGroup returns the protocol image group.
func (p *Protocol[I, P]) ImageGroup() algebra.FiniteGroup[I] <span class="cov0" title="0">{
        return p.imageGroup
}</span>

// PreImageGroup returns the protocol pre-image group.
func (p *Protocol[I, P]) PreImageGroup() algebra.FiniteGroup[P] <span class="cov0" title="0">{
        return p.preImageGroup
}</span>

// Phi returns the protocol one-way homomorphism.
func (p *Protocol[I, P]) Phi() sigma.OneWayHomomorphism[I, P] <span class="cov0" title="0">{
        return p.oneWayHomomorphism
}</span>

// Anchor returns the protocol anchor.
func (p *Protocol[I, P]) Anchor() sigma.Anchor[I, P] <span class="cov0" title="0">{
        return p.anchor
}</span>

func (p *Protocol[I, P]) preImageScalarMulI(base P, e *big.Int) P <span class="cov0" title="0">{
        absE := e.Bytes()
        if e.Sign() &lt; 0 </span><span class="cov0" title="0">{
                return p.preImageScalarMul(base.OpInv(), absE)
        }</span> else<span class="cov0" title="0"> {
                return p.preImageScalarMul(base, absE)
        }</span>
}

func defaultScalarMul[G algebra.GroupElement[G]](base G, eBytes []byte) G <span class="cov0" title="0">{
        e, _ := num.N().FromBytes(eBytes)
        return algebrautils.ScalarMul(base, e)
}</span>
</pre>
		
		<pre class="file" id="file260" style="display: none">package lp

import (
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/nthroot"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compose/sigand"
)

// Round1Output carries the verifier's first-round data.
type Round1Output struct {
        NthRootsProverOutput sigand.Commitment[*nthroot.Commitment[*modular.SimpleModulus]]
        X                    sigand.Statement[*nthroot.Statement[*modular.SimpleModulus]]
}

// Validate checks the Round1Output shape.
func (r1out *Round1Output) Validate(k int) error <span class="cov8" title="1">{
        if r1out == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("round 1 output is nil")
        }</span>
        <span class="cov8" title="1">if len(r1out.X) != k </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("X length (%d) != %d", len(r1out.X), k)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Round2Output carries the verifier's challenge bytes.
type Round2Output struct {
        NthRootsVerifierOutput sigma.ChallengeBytes
}

// Round3Output carries the prover's Nth-root responses.
type Round3Output struct {
        NthRootsProverOutput sigand.Response[*nthroot.Response[*modular.SimpleModulus]]
}

// Round4Output carries the final Paillier public-key verification data.
type Round4Output struct {
        YPrime []*numct.Nat
}

// Validate checks the Round4Output shape.
func (r4out *Round4Output) Validate(k int) error <span class="cov8" title="1">{
        if r4out == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("round 4 output is nil")
        }</span>
        <span class="cov8" title="1">if len(r4out.YPrime) != k </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("YPrime length (%d) != %d", len(r4out.YPrime), k)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file261" style="display: none">package lp

import (
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/nthroot"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compose/sigand"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid"
)

const (
        appTranscriptLabel       = "BRON_CRYPTO_PAILLIER_LP-"
        sessionIDTranscriptLabel = "BRON_CRYPTO_PAILLIER_LP_SESSION_ID"
)

// Participant holds a common state for the LP protocol participants.
type Participant[A znstar.ArithmeticPaillier] struct {
        // Base participant
        multiNthRootsProtocol sigma.Protocol[sigand.Statement[*nthroot.Statement[A]], sigand.Witness[*nthroot.Witness[A]], sigand.Commitment[*nthroot.Commitment[A]], sigand.State[*nthroot.State[A]], sigand.Response[*nthroot.Response[A]]]
        Prng                  io.Reader
        Round                 int
        SessionID             network.SID
        Transcript            transcripts.Transcript

        k int // security parameter - cheating prover can succeed with probability &lt; 2^(-k)
}

// SoundnessError returns the protocol soundness parameter.
func (p *Participant[A]) SoundnessError() int <span class="cov0" title="0">{
        return p.k
}</span>

// VerifierState tracks the verifier's internal state across rounds.
type VerifierState struct {
        rootsProver *sigma.Prover[
                sigand.Statement[*nthroot.Statement[*modular.SimpleModulus]],
                sigand.Witness[*nthroot.Witness[*modular.SimpleModulus]],
                sigand.Commitment[*nthroot.Commitment[*modular.SimpleModulus]],
                sigand.State[*nthroot.State[*modular.SimpleModulus]],
                sigand.Response[*nthroot.Response[*modular.SimpleModulus]],
        ]
        x sigand.Statement[*nthroot.Statement[*modular.SimpleModulus]]
        y sigand.Witness[*nthroot.Witness[*modular.SimpleModulus]]
}

// Verifier runs the LP verifier role.
type Verifier struct {
        Participant[*modular.SimpleModulus]

        paillierPublicKey *paillier.PublicKey
        enc               *paillier.Encrypter
        state             *VerifierState
}

// ProverState tracks the prover's internal state across rounds.
type ProverState struct {
        rootsVerifier *sigma.Verifier[
                sigand.Statement[*nthroot.Statement[*modular.OddPrimeSquareFactors]],
                sigand.Witness[*nthroot.Witness[*modular.OddPrimeSquareFactors]],
                sigand.Commitment[*nthroot.Commitment[*modular.OddPrimeSquareFactors]],
                sigand.State[*nthroot.State[*modular.OddPrimeSquareFactors]],
                sigand.Response[*nthroot.Response[*modular.OddPrimeSquareFactors]],
        ]
        x sigand.Statement[*nthroot.Statement[*modular.OddPrimeSquareFactors]]
}

// Prover runs the LP prover role.
type Prover struct {
        Participant[*modular.OddPrimeSquareFactors]

        paillierSecretKey *paillier.PrivateKey
        state             *ProverState
}

// NewVerifier constructs a verifier instance for the LP protocol.
func NewVerifier(sessionID network.SID, k int, pk *paillier.PublicKey, tape transcripts.Transcript, prng io.Reader) (verifier *Verifier, err error) <span class="cov8" title="1">{
        if err := validateVerifierInputs(k, pk, prng); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid input arguments")
        }</span>

        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                tape = hagrid.NewTranscript(appTranscriptLabel)
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d", sessionIDTranscriptLabel, sessionID)
        tape.AppendDomainSeparator(dst)

        nthRootsSigmaProtocol, err := nthroot.NewProtocol(pk.Group(), prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create Nth root protocol")
        }</span>
        <span class="cov8" title="1">multiNthRootsProtocol, err := sigand.Compose(nthRootsSigmaProtocol, uint(k))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create multi Nth root protocol")
        }</span>
        <span class="cov8" title="1">enc, err := paillier.NewScheme().Encrypter()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create paillier encrypter")
        }</span>

        <span class="cov8" title="1">return &amp;Verifier{
                Participant: Participant[*modular.SimpleModulus]{
                        k:                     k,
                        Round:                 1,
                        SessionID:             sessionID,
                        Transcript:            tape,
                        multiNthRootsProtocol: multiNthRootsProtocol,
                        Prng:                  prng,
                },
                paillierPublicKey: pk,
                enc:               enc,
                state: &amp;VerifierState{
                        rootsProver: nil,
                        x:           nil,
                        y:           nil,
                },
        }, nil</span>
}

func validateVerifierInputs(k int, pk *paillier.PublicKey, prng io.Reader) error <span class="cov8" title="1">{
        if pk == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("paillier public key is nil")
        }</span>
        <span class="cov8" title="1">if k &lt; 1 </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("invalid k: %d (must be positive)", k)
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewProver constructs a prover instance for the LP protocol.
func NewProver(sessionID network.SID, k int, sk *paillier.PrivateKey, tape transcripts.Transcript, prng io.Reader) (prover *Prover, err error) <span class="cov8" title="1">{
        if err := validateProverInputs(k, sk, prng); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid input arguments")
        }</span>

        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                tape = hagrid.NewTranscript(appTranscriptLabel)
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d", sessionIDTranscriptLabel, sessionID)
        tape.AppendDomainSeparator(dst)

        nthRootsSigmaProtocol, err := nthroot.NewProtocol(sk.Group(), prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create Nth root protocol")
        }</span>
        <span class="cov8" title="1">multiNthRootsProtocol, err := sigand.Compose(nthRootsSigmaProtocol, uint(k))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create multi Nth root protocol")
        }</span>

        <span class="cov8" title="1">return &amp;Prover{
                Participant: Participant[*modular.OddPrimeSquareFactors]{
                        k:                     k,
                        Round:                 2,
                        SessionID:             sessionID,
                        Transcript:            tape,
                        multiNthRootsProtocol: multiNthRootsProtocol,
                        Prng:                  prng,
                },
                paillierSecretKey: sk,
                state: &amp;ProverState{
                        rootsVerifier: nil,
                        x:             nil,
                },
        }, nil</span>
}

func validateProverInputs(k int, sk *paillier.PrivateKey, prng io.Reader) error <span class="cov8" title="1">{
        if sk == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("paillier secret key is nil")
        }</span>
        <span class="cov8" title="1">if k &lt; 1 </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("invalid k: %d (must be positive)", k)
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file262" style="display: none">package lp

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/nthroot"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compose/sigand"
)

// Round1 executes the verifier's first round.
func (verifier *Verifier) Round1() (output *Round1Output, err error) <span class="cov8" title="1">{
        if verifier.Round != 1 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("%d != 1", verifier.Round)
        }</span>

        <span class="cov8" title="1">rootTranscript := verifier.Transcript.Clone()

        zero, err := verifier.paillierPublicKey.PlaintextSpace().FromNat(numct.NatZero())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create plaintext zero")
        }</span>
        // V picks x = y^N mod N^2 which is the Paillier encryption of zero (N being the Paillier public-key)
        <span class="cov8" title="1">zeros := sliceutils.Repeat[[]*paillier.Plaintext](zero, verifier.k)
        ciphertexts, nonces, err := verifier.enc.EncryptMany(zeros, verifier.paillierPublicKey, verifier.Prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("encryption failed")
        }</span>

        <span class="cov8" title="1">verifier.state.x = sigand.ComposeStatements(slices.Collect(iterutils.Map(slices.Values(ciphertexts), func(x *paillier.Ciphertext) *nthroot.Statement[*modular.SimpleModulus] </span><span class="cov8" title="1">{
                return nthroot.NewStatement(x.Value())
        }</span>))...)
        <span class="cov8" title="1">verifier.state.y = sigand.ComposeWitnesses(slices.Collect(iterutils.Map(slices.Values(nonces), func(y *paillier.Nonce) *nthroot.Witness[*modular.SimpleModulus] </span><span class="cov8" title="1">{
                embeddedNonce, err := verifier.paillierPublicKey.Group().EmbedRSA(y.Value())
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">return nthroot.NewWitness(embeddedNonce)</span>
        }))...)
        <span class="cov8" title="1">verifier.state.rootsProver, err = sigma.NewProver(verifier.SessionID, rootTranscript.Clone(), verifier.multiNthRootsProtocol, verifier.state.x, verifier.state.y)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create sigma protocol prover")
        }</span>

        <span class="cov8" title="1">nthRootProverRound1Output, err := verifier.state.rootsProver.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 1 of Nth root prover")
        }</span>

        <span class="cov8" title="1">verifier.Round += 2
        return &amp;Round1Output{
                NthRootsProverOutput: nthRootProverRound1Output,
                X:                    verifier.state.x,
        }, nil</span>
}

// Round2 executes the prover's second round.
func (prover *Prover) Round2(input *Round1Output) (output *Round2Output, err error) <span class="cov8" title="1">{
        if prover.Round != 2 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("%d != 2", prover.Round)
        }</span>
        <span class="cov8" title="1">if err := input.Validate(prover.k); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid round 2 input")
        }</span>

        // prover.state.x = input.X
        <span class="cov8" title="1">prover.state.x = make([]*nthroot.Statement[*modular.OddPrimeSquareFactors], prover.k)
        for i, x := range input.X </span><span class="cov8" title="1">{
                prover.state.x[i], err = nthRootStatementLearnOrder(x, prover.paillierSecretKey.Group())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create statement with known order")
                }</span>
        }
        <span class="cov8" title="1">rootTranscript := prover.Transcript.Clone()
        prover.state.rootsVerifier, err = sigma.NewVerifier(prover.SessionID, rootTranscript.Clone(), prover.multiNthRootsProtocol, prover.state.x, prover.Prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create Nth root verifier")
        }</span>

        <span class="cov8" title="1">commitments := make([]*nthroot.Commitment[*modular.OddPrimeSquareFactors], prover.k)
        for i, a := range input.NthRootsProverOutput </span><span class="cov8" title="1">{
                commitments[i], err = nthRootCommitmentLearnOrder(a, prover.paillierSecretKey.Group())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create commitment with known order")
                }</span>
        }
        <span class="cov8" title="1">nthRootVerifierRound2Output, err := prover.state.rootsVerifier.Round2(commitments)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 2 of Nth root verifier")
        }</span>

        <span class="cov8" title="1">prover.Round += 2
        return &amp;Round2Output{
                NthRootsVerifierOutput: nthRootVerifierRound2Output,
        }, nil</span>
}

// Round3 executes the verifier's third round.
func (verifier *Verifier) Round3(input *Round2Output) (output *Round3Output, err error) <span class="cov8" title="1">{
        if verifier.Round != 3 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("%d != 3", verifier.Round)
        }</span>
        <span class="cov8" title="1">nthRootProverRound3Output, err := verifier.state.rootsProver.Round3(input.NthRootsVerifierOutput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 3 of Nth root prover")
        }</span>

        <span class="cov8" title="1">verifier.Round += 2
        return &amp;Round3Output{
                NthRootsProverOutput: nthRootProverRound3Output,
        }, nil</span>
}

// Round4 executes the prover's fourth round.
func (prover *Prover) Round4(input *Round3Output) (output *Round4Output, err error) <span class="cov8" title="1">{
        if prover.Round != 4 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("%d != 4", prover.Round)
        }</span>
        // round 4 of proving the knowledge of y
        <span class="cov8" title="1">responses := make([]*nthroot.Response[*modular.OddPrimeSquareFactors], prover.k)
        for i, z := range input.NthRootsProverOutput </span><span class="cov8" title="1">{
                responses[i], err = nthRootResponseLearnOrder(z, prover.paillierSecretKey.Group())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create response with known order")
                }</span>
        }
        <span class="cov8" title="1">if err := prover.state.rootsVerifier.Verify(responses); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot verify knowledge of Nth root from Verifier")
        }</span>

        // P calculates a y', the Nth root of x
        // Computing in (Z/NZ)* using CrtModN, with exponent = N^(-1) mod (N)
        // see: Yehuda Lindell's answer (https://crypto.stackexchange.com/a/46745) for reference
        <span class="cov8" title="1">var m numct.Nat
        prover.paillierSecretKey.Arithmetic().CrtModN.Phi.ModInv(&amp;m, prover.paillierSecretKey.Group().N().Value())

        // TODO: clean up and put in a helper
        yPrime := make([]*numct.Nat, prover.k)
        for i := range yPrime </span><span class="cov8" title="1">{
                yPrime[i] = numct.NewNat(0)
        }</span>
        <span class="cov8" title="1">prover.paillierSecretKey.Arithmetic().CrtModN.MultiBaseExp(
                yPrime,
                sliceutils.MapCast[[]*numct.Nat](prover.state.x, func(s *nthroot.Statement[*modular.OddPrimeSquareFactors]) *numct.Nat </span><span class="cov8" title="1">{ return s.X.Value().Value() }</span>),
                &amp;m,
        )

        // P returns a y'
        <span class="cov8" title="1">prover.Round += 2
        return &amp;Round4Output{
                YPrime: yPrime,
        }, nil</span>
}

// Round5 executes the verifier's final round.
func (verifier *Verifier) Round5(input *Round4Output) (err error) <span class="cov8" title="1">{
        // Validation
        if verifier.Round != 5 </span><span class="cov0" title="0">{
                return ErrRound.WithMessage("%d != 5", verifier.Round)
        }</span>
        <span class="cov8" title="1">if err := input.Validate(verifier.k); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid round 5 input")
        }</span>

        <span class="cov8" title="1">ok := ct.True
        for i := range verifier.k </span><span class="cov8" title="1">{
                // Reduce y mod N for comparison (yPrime is computed mod N, but y is in (Z/NZ)*)
                var yModN numct.Nat
                verifier.paillierPublicKey.N().Mod(&amp;yModN, verifier.state.y[i].W.Value().Value())
                ok &amp;= input.YPrime[i].Equal(&amp;yModN)
        }</span>
        <span class="cov8" title="1">if ok == ct.False </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("failed to verify Paillier public key")
        }</span>

        // V accepts if every y_i == y'_i
        <span class="cov8" title="1">verifier.Round += 2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file263" style="display: none">package lp

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/modular"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/nthroot"
)

func nthRootStatementLearnOrder[A znstar.ArithmeticPaillier](x *nthroot.Statement[A], g *znstar.PaillierGroupKnownOrder) (*nthroot.Statement[*modular.OddPrimeSquareFactors], error) <span class="cov8" title="1">{
        if x == nil || g == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("x or g is nil")
        }</span>
        <span class="cov8" title="1">learnedX, err := x.Value().LearnOrder(g)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to learn order of x")
        }</span>
        <span class="cov8" title="1">return &amp;nthroot.Statement[*modular.OddPrimeSquareFactors]{
                X: learnedX,
        }, nil</span>
}

func nthRootCommitmentLearnOrder[A znstar.ArithmeticPaillier](a *nthroot.Commitment[A], g *znstar.PaillierGroupKnownOrder) (*nthroot.Commitment[*modular.OddPrimeSquareFactors], error) <span class="cov8" title="1">{
        if a == nil || g == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("a or g is nil")
        }</span>
        <span class="cov8" title="1">learnedA, err := a.Value().LearnOrder(g)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to learn order of c")
        }</span>
        <span class="cov8" title="1">return &amp;nthroot.Commitment[*modular.OddPrimeSquareFactors]{
                A: learnedA,
        }, nil</span>
}

func nthRootResponseLearnOrder[A znstar.ArithmeticPaillier](z *nthroot.Response[A], g *znstar.PaillierGroupKnownOrder) (*nthroot.Response[*modular.OddPrimeSquareFactors], error) <span class="cov8" title="1">{
        if z == nil || g == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("z or g is nil")
        }</span>
        <span class="cov8" title="1">learnedZ, err := z.Value().LearnOrder(g)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to learn order of r")
        }</span>
        <span class="cov8" title="1">return &amp;nthroot.Response[*modular.OddPrimeSquareFactors]{
                Z: learnedZ,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file264" style="display: none">package lpdl

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        paillierrange "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/range"
)

// Round1Output carries the verifier's first-round data.
type Round1Output struct {
        RangeVerifierOutput    hash_comm.Commitment
        CPrime                 *paillier.Ciphertext
        CDoublePrimeCommitment hash_comm.Commitment
}

// Validate checks the Round1Output shape.
func (r1out *Round1Output) Validate() error <span class="cov8" title="1">{
        if r1out == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("round 1 output is nil")
        }</span>
        <span class="cov8" title="1">if r1out.CPrime == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("CPrime is nil")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Round2Output carries the prover's second-round data.
type Round2Output struct {
        RangeProverOutput *paillierrange.Commitment
        CHat              hash_comm.Commitment
}

// Validate checks the Round2Output shape.
func (r2out *Round2Output) Validate() error <span class="cov8" title="1">{
        if r2out == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("round 2 output is nil")
        }</span>
        <span class="cov8" title="1">if r2out.RangeProverOutput == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("range prover output is nil")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Round3Output carries the verifier's third-round data.
type Round3Output struct {
        RangeVerifierMessage hash_comm.Message
        RangeVerifierWitness hash_comm.Witness
        A                    *num.Uint
        B                    *num.Uint
        CDoublePrimeWitness  hash_comm.Witness
}

// Validate checks the Round3Output shape.
func (r3out *Round3Output) Validate() error <span class="cov8" title="1">{
        if r3out == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("round 3 output is nil")
        }</span>
        <span class="cov8" title="1">if r3out.RangeVerifierMessage == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("range verifier message")
        }</span>
        <span class="cov8" title="1">if ct.SliceIsZero(r3out.RangeVerifierWitness[:]) == ct.True </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("range verifier witness is empty")
        }</span>
        <span class="cov8" title="1">if r3out.A == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("A is nil")
        }</span>
        <span class="cov8" title="1">if r3out.B == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("B is nil")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Round4Output carries the prover's final response.
type Round4Output[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        RangeProverOutput *paillierrange.Response
        BigQHat           P
        BigQHatWitness    hash_comm.Witness
}

// Validate checks the Round4Output shape.
func (r4out *Round4Output[P, B, S]) Validate() error <span class="cov8" title="1">{
        if r4out == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("round 4 output is nil")
        }</span>
        <span class="cov8" title="1">if r4out.RangeProverOutput == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("range prover output is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(r4out.BigQHat) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("BigQHat is nil")
        }</span>
        <span class="cov8" title="1">if r4out.BigQHat.IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("BigQHat is identity")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file265" style="display: none">package lpdl

import (
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/network"
        paillierrange "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/range"
        zkcompiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/zk"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid"
)

const (
        appTranscriptLabel       = "BRON_CRYPTO_PAILLIER_LPDL-"
        sessionIDTranscriptLabel = "BRON_CRYPTO_PAILLIER_LPDL_SESSION_ID"
)

// Participant holds common state for the LPDL protocol participants.
type Participant[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        pk         *paillier.PublicKey
        bigQ       P
        round      int
        sessionID  network.SID
        transcript transcripts.Transcript
        prng       io.Reader
}

// State holds shared state for LPDL rounds.
type State[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        curve  curves.Curve[P, B, S]
        zModQ  *num.ZMod
        zModQ2 *num.ZMod
        a      *num.Uint
        b      *num.Uint
}

// VerifierState tracks the verifier's internal state across rounds.
type VerifierState[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        State[P, B, S]

        cDoublePrimeWitness hash_comm.Witness
        bigQPrime           P
        cHat                hash_comm.Commitment
}

// Verifier runs the LPDL verifier role.
type Verifier[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        Participant[P, B, S]

        rangeVerifier     *zkcompiler.Verifier[*paillierrange.Statement, *paillierrange.Witness, *paillierrange.Commitment, *paillierrange.State, *paillierrange.Response]
        paillierEncrypter *paillier.Encrypter
        c                 *paillier.Ciphertext
        state             *VerifierState[P, B, S]
        commitmentScheme  *hash_comm.Scheme
}

// ProverState tracks the prover's internal state across rounds.
type ProverState[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        State[P, B, S]

        alpha                  *paillier.Plaintext
        bigQHat                P
        bigQHatWitness         hash_comm.Witness
        cDoublePrimeCommitment hash_comm.Commitment
}

// Prover runs the LPDL prover role.
type Prover[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        Participant[P, B, S]

        rangeProver       *zkcompiler.Prover[*paillierrange.Statement, *paillierrange.Witness, *paillierrange.Commitment, *paillierrange.State, *paillierrange.Response]
        paillierDecrypter *paillier.Decrypter
        sk                *paillier.PrivateKey
        x                 S
        state             *ProverState[P, B, S]
        commitmentScheme  *hash_comm.Scheme
}

// NewVerifier constructs a verifier instance for the LPDL protocol.
func NewVerifier[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, publicKey *paillier.PublicKey, bigQ P, xEncrypted *paillier.Ciphertext, tape transcripts.Transcript, prng io.Reader) (verifier *Verifier[P, B, S], err error) <span class="cov8" title="1">{
        err = validateVerifierInputs(publicKey, bigQ, xEncrypted, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid input arguments")
        }</span>

        <span class="cov8" title="1">curve := algebra.StructureMustBeAs[curves.Curve[P, B, S]](bigQ.Structure())

        if tape == nil </span><span class="cov0" title="0">{
                tape = hagrid.NewTranscript(appTranscriptLabel)
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d", sessionIDTranscriptLabel, sessionID)
        tape.AppendDomainSeparator(dst)

        rangeProofTranscript := tape.Clone()
        rangeProtocol, q, q2, qThirdNat, err := initRangeProtocol(curve, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't initialise range protocol")
        }</span>

        // Create Phi(q/3) for homomorphic division
        <span class="cov8" title="1">var qThirdInt numct.Int
        qThirdInt.SetNat(qThirdNat)
        qThirdUnit, err := publicKey.Group().Representative(&amp;qThirdInt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute Phi(q/3)")
        }</span>
        <span class="cov8" title="1">qThird := paillier.NewCiphertextFromUnit(qThirdUnit)

        // xEncrypted has known order, qThird has unknown order from Phi
        // Need to forget order on xEncrypted for the division
        xUnknown := paillier.NewCiphertextFromUnit(xEncrypted.Value().ForgetOrder())
        rangeCiphertext := xUnknown.HomSub(qThird)
        rangeStatement := paillierrange.NewStatement(publicKey, rangeCiphertext, qThirdNat)
        rangeVerifier, err := zkcompiler.NewVerifier(sessionID, rangeProofTranscript, rangeProtocol, rangeStatement, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create Paillier range verifier")
        }</span>

        <span class="cov8" title="1">ck, err := hash_comm.NewKeyFromCRSBytes(sessionID, appTranscriptLabel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot instantiate committer")
        }</span>
        <span class="cov8" title="1">commitmentScheme, err := hash_comm.NewScheme(ck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot instantiate commitment scheme")
        }</span>

        <span class="cov8" title="1">paillierEncrypter, err := paillier.NewScheme().Encrypter()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create paillier encrypter")
        }</span>

        <span class="cov8" title="1">return &amp;Verifier[P, B, S]{
                Participant: Participant[P, B, S]{
                        pk:         publicKey,
                        bigQ:       bigQ,
                        round:      1,
                        sessionID:  sessionID,
                        transcript: tape,
                        prng:       prng,
                },
                rangeVerifier:     rangeVerifier,
                c:                 xEncrypted,
                commitmentScheme:  commitmentScheme,
                paillierEncrypter: paillierEncrypter,
                state: &amp;VerifierState[P, B, S]{
                        State: State[P, B, S]{
                                curve:  curve,
                                zModQ:  q,
                                zModQ2: q2,
                                a:      nil,
                                b:      nil,
                        },
                        cDoublePrimeWitness: hash_comm.Witness{},
                        bigQPrime:           *new(P),
                        cHat:                hash_comm.Commitment{},
                },
        }, nil</span>
}

func validateVerifierInputs[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](publicKey *paillier.PublicKey, bigQ P, xEncrypted *paillier.Ciphertext, prng io.Reader) error <span class="cov8" title="1">{
        if publicKey == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("public key is nil")
        }</span>
        <span class="cov8" title="1">if publicKey.N().BitLen() &lt; paillier.KeyLen </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("invalid paillier public key: modulus is too small")
        }</span>
        <span class="cov8" title="1">if xEncrypted == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("xEncrypted is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(bigQ) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("bigQ is nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewProver constructs a prover instance for the LPDL protocol.
func NewProver[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, curve curves.Curve[P, B, S], secretKey *paillier.PrivateKey, x S, r *paillier.Nonce, tape transcripts.Transcript, prng io.Reader) (verifier *Prover[P, B, S], err error) <span class="cov8" title="1">{
        if err = validateProverInputs(sessionID, curve, secretKey, x, r, prng); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid input arguments")
        }</span>

        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                tape = hagrid.NewTranscript(appTranscriptLabel)
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d", sessionIDTranscriptLabel, sessionID)
        tape.AppendDomainSeparator(dst)

        rangeProofTranscript := tape.Clone()
        rangeProtocol, q, qSquared, qThirdNat, err := initRangeProtocol(curve, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't initialise range protocol")
        }</span>

        <span class="cov8" title="1">qThirdAsPlaintext, err := secretKey.PublicKey().PlaintextSpace().FromNat(qThirdNat)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't convert q/3 to plaintext")
        }</span>

        <span class="cov8" title="1">xNat := numct.NewNatFromBytes(x.Bytes())
        xAsPlaintext, err := secretKey.PublicKey().PlaintextSpace().FromNat(xNat)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't convert x to plaintext")
        }</span>
        <span class="cov8" title="1">rangePlainText := xAsPlaintext.Sub(qThirdAsPlaintext)

        ck, err := hash_comm.NewKeyFromCRSBytes(sessionID, appTranscriptLabel)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot instantiate committer")
        }</span>
        <span class="cov8" title="1">commitmentScheme, err := hash_comm.NewScheme(ck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot instantiate commitment scheme")
        }</span>

        <span class="cov8" title="1">senc, err := paillier.NewScheme().SelfEncrypter(secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't create self-encrypter")
        }</span>

        <span class="cov8" title="1">rangeCipherText, err := senc.SelfEncryptWithNonce(rangePlainText, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't create range statement")
        }</span>
        <span class="cov8" title="1">rangeWitness := paillierrange.NewWitness(secretKey, rangePlainText, r)
        rangeStatement := paillierrange.NewStatement(secretKey.PublicKey(), rangeCipherText, qThirdNat)
        rangeProver, err := zkcompiler.NewProver(sessionID, rangeProofTranscript, rangeProtocol, rangeStatement, rangeWitness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't initialise prover")
        }</span>

        <span class="cov8" title="1">dec, err := paillier.NewScheme().Decrypter(secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create paillier decrypter")
        }</span>

        <span class="cov8" title="1">return &amp;Prover[P, B, S]{
                Participant: Participant[P, B, S]{
                        pk:         secretKey.PublicKey(),
                        bigQ:       curve.ScalarBaseMul(x),
                        round:      2,
                        sessionID:  sessionID,
                        transcript: tape,
                        prng:       prng,
                },
                rangeProver:       rangeProver,
                paillierDecrypter: dec,
                commitmentScheme:  commitmentScheme,
                sk:                secretKey,
                x:                 x,
                state: &amp;ProverState[P, B, S]{
                        State: State[P, B, S]{
                                curve:  curve,
                                zModQ:  q,
                                zModQ2: qSquared,
                                a:      nil,
                                b:      nil,
                        },
                        alpha:                  nil,
                        bigQHat:                *new(P),
                        bigQHatWitness:         hash_comm.Witness{},
                        cDoublePrimeCommitment: hash_comm.Commitment{},
                },
        }, nil</span>
}

func validateProverInputs[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, curve curves.Curve[P, B, S], secretKey *paillier.PrivateKey, x S, r *paillier.Nonce, prng io.Reader) error <span class="cov8" title="1">{ //nolint:unparam // sessionID is used!
        if len(sessionID) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("sessionID is empty")
        }</span>
        <span class="cov8" title="1">if secretKey == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("secret key is nil")
        }</span>
        <span class="cov8" title="1">if secretKey.Group().N().AnnouncedLen() &lt; base.IFCKeyLength </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("invalid paillier public key: modulus is too small")
        }</span>
        <span class="cov8" title="1">if curve == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("curve is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(x) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("x is nil")
        }</span>
        <span class="cov8" title="1">sf := algebra.StructureMustBeAs[algebra.PrimeField[S]](x.Structure())
        if curve.ScalarField().Name() != sf.Name() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("x is not an element of the scalar field of the curve")
        }</span>
        <span class="cov8" title="1">if r == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("r is nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func initRangeProtocol[P curves.Point[P, B, S], B algebra.FiniteFieldElement[B], S algebra.PrimeFieldElement[S]](curve curves.Curve[P, B, S], prng io.Reader) (rangeProtocol *paillierrange.Protocol, zModQ, zModQ2 *num.ZMod, qThird *numct.Nat, err error) <span class="cov8" title="1">{
        q := curve.Order()
        q2 := q.Mul(q)

        zModQ, err = num.NewZModFromCardinal(q)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, errs2.Wrap(err).WithMessage("cannot create ZMod from q")
        }</span>
        <span class="cov8" title="1">zModQ2, err = num.NewZModFromCardinal(q2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, errs2.Wrap(err).WithMessage("cannot create ZMod from q^2")
        }</span>

        <span class="cov8" title="1">three := numct.NewNat(3)
        qNat := numct.NewNatFromBytes(q.Bytes())
        qThird = numct.NewNat(0)
        qThird.EuclideanDivVarTime(nil, qNat, three)

        rangeProtocol, err = paillierrange.NewPaillierRange(base.ComputationalSecurityBits, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, errs2.Wrap(err).WithMessage("couldn't create range protocol")
        }</span>
        <span class="cov8" title="1">return rangeProtocol, zModQ, zModQ2, qThird, nil</span>
}
</pre>
		
		<pre class="file" id="file266" style="display: none">package lpdl

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
)

// Round1 executes the verifier's first round.
func (verifier *Verifier[P, B, S]) Round1() (r1out *Round1Output, err error) <span class="cov8" title="1">{
        // Validation
        if verifier.round != 1 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("%d != 1", verifier.round)
        }</span>

        <span class="cov8" title="1">verifier.state.a, err = verifier.state.zModQ.Random(verifier.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate random integer")
        }</span>
        <span class="cov8" title="1">verifier.state.b, err = verifier.state.zModQ2.Random(verifier.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate random integer")
        }</span>

        <span class="cov8" title="1">bAsPlaintext, err := verifier.pk.PlaintextSpace().FromNat(verifier.state.b.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create plaintext from nat")
        }</span>

        // 1.i. compute a (*) c (+) Enc(b, r) for random r
        // acEnc, err := verifier.pk.CipherTextMul(verifier.c, new(saferith.Int).SetNat(verifier.state.a))
        <span class="cov8" title="1">acEnc := verifier.c.ScalarMul(verifier.state.a.Nat())
        bEnc, _, err := verifier.paillierEncrypter.Encrypt(bAsPlaintext, verifier.pk, verifier.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot encrypt value")
        }</span>
        <span class="cov8" title="1">cPrime := acEnc.HomAdd(bEnc)

        // 1.ii. compute c'' = commit(a, b)
        cDoublePrimeCommitment, cDoublePrimeWitness, err := verifier.commitmentScheme.Committer().Commit(slices.Concat(verifier.state.a.Bytes(), verifier.state.b.Bytes()), verifier.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot commit to a and b")
        }</span>
        <span class="cov8" title="1">verifier.state.cDoublePrimeWitness = cDoublePrimeWitness

        // 1.iii. compute Q' = aQ + bQ
        // TODO: add SetNatCT to ScalarField etc.
        aScalar, err := verifier.state.curve.ScalarField().FromBytesBEReduce(verifier.state.a.BytesBE())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert a to scalar")
        }</span>
        <span class="cov8" title="1">bScalar, err := verifier.state.curve.ScalarField().FromBytesBEReduce(verifier.state.b.BytesBE())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert b to scalar")
        }</span>
        <span class="cov8" title="1">verifier.state.bigQPrime = verifier.bigQ.ScalarMul(aScalar).Add(verifier.state.curve.ScalarBaseMul(bScalar))

        // 4.i. In parallel to the above, run L_P protocol
        rangeVerifierOutput, err := verifier.rangeVerifier.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("range verifier round 1")
        }</span>

        // 1.iv sends c' and c'' to P
        <span class="cov8" title="1">verifier.round += 2
        return &amp;Round1Output{
                RangeVerifierOutput:    rangeVerifierOutput,
                CPrime:                 cPrime,
                CDoublePrimeCommitment: cDoublePrimeCommitment,
        }, nil</span>
}

// Round2 executes the prover's second round.
func (prover *Prover[P, B, S]) Round2(r1out *Round1Output) (r2out *Round2Output, err error) <span class="cov8" title="1">{
        // Validation; RangeVerifierOutput deferred to `rangeProver.Round2`, CPrime deferred to `decryptor.Decrypt`
        if prover.round != 2 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("%d != 2", prover.round)
        }</span>
        <span class="cov8" title="1">if err := r1out.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid round 2 input")
        }</span>

        <span class="cov8" title="1">prover.state.cDoublePrimeCommitment = r1out.CDoublePrimeCommitment

        // 2.i. decrypt c' to obtain alpha, compute Q^ = alpha * G
        prover.state.alpha, err = prover.paillierDecrypter.Decrypt(r1out.CPrime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot decrypt cipher text")
        }</span>

        <span class="cov8" title="1">alphaScalar, err := prover.state.curve.ScalarField().FromBytesBEReduce(prover.state.alpha.Normalise().BytesBE())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert alpha to scalar")
        }</span>
        <span class="cov8" title="1">prover.state.bigQHat = prover.state.curve.ScalarBaseMul(alphaScalar)

        // 2.ii. compute c^ = commit(Q^) and send to V

        bigQHatCommitment, bigQHatWitness, err := prover.commitmentScheme.Committer().Commit(prover.state.bigQHat.ToCompressed(), prover.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot commit to Q hat")
        }</span>
        <span class="cov8" title="1">prover.state.bigQHatWitness = bigQHatWitness

        // 4.i. In parallel to the above, run L_P protocol
        rangeProverOutput, err := prover.rangeProver.Round2(r1out.RangeVerifierOutput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("range prover round 2")
        }</span>

        <span class="cov8" title="1">prover.round += 2
        return &amp;Round2Output{
                RangeProverOutput: rangeProverOutput,
                CHat:              bigQHatCommitment,
        }, nil</span>
}

// Round3 executes the verifier's third round.
func (verifier *Verifier[P, B, S]) Round3(r2out *Round2Output) (r3out *Round3Output, err error) <span class="cov8" title="1">{
        // Validation; RangeProverOutput deferred to `rangeVerifier.Round3`
        if verifier.round != 3 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("%d != 3", verifier.round)
        }</span>
        <span class="cov8" title="1">if err := r2out.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid round 3 input")
        }</span>

        <span class="cov8" title="1">verifier.state.cHat = r2out.CHat

        // 4.i. In parallel to the above, run L_P protocol
        rangeVerifierMessage, rangeVerifierWitness, err := verifier.rangeVerifier.Round3(r2out.RangeProverOutput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("range verifier round 3")
        }</span>

        // 3. decommit c'' revealing a, b
        <span class="cov8" title="1">verifier.round += 2
        return &amp;Round3Output{
                RangeVerifierMessage: rangeVerifierMessage,
                RangeVerifierWitness: rangeVerifierWitness,
                A:                    verifier.state.a,
                B:                    verifier.state.b,
                CDoublePrimeWitness:  verifier.state.cDoublePrimeWitness,
        }, nil</span>
}

// Round4 executes the prover's fourth round.
func (prover *Prover[P, B, S]) Round4(r4In *Round3Output) (r4out *Round4Output[P, B, S], err error) <span class="cov8" title="1">{
        // Validation; RangeVerifierOutput deferred to `rangeProver.Round4`
        if prover.round != 4 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("%d != 4", prover.round)
        }</span>
        <span class="cov8" title="1">if err := r4In.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid round 4 input")
        }</span>

        <span class="cov8" title="1">if err := prover.commitmentScheme.Verifier().Verify(prover.state.cDoublePrimeCommitment, slices.Concat(r4In.A.Bytes(), r4In.B.Bytes()), r4In.CDoublePrimeWitness); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot open R commitment")
        }</span>

        // 4. check that alpha == ax + b (over integers), if not aborts
        <span class="cov8" title="1">x, err := num.Z().FromCardinal(prover.x.Cardinal())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert x to nat")
        }</span>
        <span class="cov8" title="1">if !prover.state.alpha.Value().Equal(r4In.A.Lift().Mul(x).Add(r4In.B.Lift())) </span><span class="cov8" title="1">{
                return nil, base.ErrAbort.WithMessage("verifier is misbehaving")
        }</span>

        <span class="cov8" title="1">rangeProverOutput, err := prover.rangeProver.Round4(r4In.RangeVerifierMessage, r4In.RangeVerifierWitness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("range prover round 4")
        }</span>

        // 4. decommit c^ revealing Q^
        <span class="cov8" title="1">prover.round += 2
        return &amp;Round4Output[P, B, S]{
                RangeProverOutput: rangeProverOutput,
                BigQHat:           prover.state.bigQHat,
                BigQHatWitness:    prover.state.bigQHatWitness,
        }, nil</span>
}

// Round5 executes the verifier's final round.
func (verifier *Verifier[P, B, S]) Round5(input *Round4Output[P, B, S]) (err error) <span class="cov8" title="1">{
        // Validation; RangeProverOutput deferred to `rangeVerifier.Round5`
        if verifier.round != 5 </span><span class="cov0" title="0">{
                return ErrRound.WithMessage("%d != 5", verifier.round)
        }</span>
        <span class="cov8" title="1">if err := input.Validate(); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid round 5 input")
        }</span>

        <span class="cov8" title="1">if err := verifier.commitmentScheme.Verifier().Verify(verifier.state.cHat, input.BigQHat.ToCompressed(), input.BigQHatWitness); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot decommit Q hat")
        }</span>

        // 5. accepts if and only if it accepts the range proof and Q^ == Q'
        <span class="cov8" title="1">if !input.BigQHat.Equal(verifier.state.bigQPrime) </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("invalid proof")
        }</span>
        <span class="cov8" title="1">err = verifier.rangeVerifier.Verify(input.RangeProverOutput)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("range verifier round 5")
        }</span>

        <span class="cov8" title="1">verifier.round += 2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file267" style="display: none">package nthroot

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/znstar"
        "github.com/bronlabs/bron-crypto/pkg/proofs/internal/meta/maurer09"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// Name identifies the Paillier nth-root sigma protocol.
const Name sigma.Name = "PAILLIER_NTH_ROOTS"

type (
        // Witness is the nth-root protocol witness.
        Witness[A znstar.ArithmeticPaillier] = maurer09.Witness[*znstar.PaillierGroupElement[A]]
        // Statement is the nth-root protocol statement.
        Statement[A znstar.ArithmeticPaillier] = maurer09.Statement[*znstar.PaillierGroupElement[A]]
        // State is the nth-root protocol prover state.
        State[A znstar.ArithmeticPaillier] = maurer09.State[*znstar.PaillierGroupElement[A]]
        // Commitment is the nth-root protocol commitment.
        Commitment[A znstar.ArithmeticPaillier] = maurer09.Commitment[*znstar.PaillierGroupElement[A]]
        // Response is the nth-root protocol response.
        Response[A znstar.ArithmeticPaillier] = maurer09.Response[*znstar.PaillierGroupElement[A]]
)

// NewStatement builds a new nth-root statement.
func NewStatement[X znstar.ArithmeticPaillier](x *znstar.PaillierGroupElement[X]) *Statement[X] <span class="cov8" title="1">{
        return &amp;Statement[X]{
                X: x,
        }
}</span>

// NewWitness builds a new nth-root witness.
func NewWitness[X znstar.ArithmeticPaillier](w *znstar.PaillierGroupElement[X]) *Witness[X] <span class="cov8" title="1">{
        return &amp;Witness[X]{
                W: w,
        }
}</span>

// Protocol implements the Paillier nth-root sigma protocol.
type Protocol[A znstar.ArithmeticPaillier] struct {
        maurer09.Protocol[*znstar.PaillierGroupElement[A], *znstar.PaillierGroupElement[A]]
}

// NewProtocol constructs a Paillier nth-root protocol instance.
func NewProtocol[A znstar.ArithmeticPaillier](group *znstar.PaillierGroup[A], prng io.Reader) (*Protocol[A], error) <span class="cov8" title="1">{
        oneWayHomomorphism := func(x *znstar.PaillierGroupElement[A]) *znstar.PaillierGroupElement[A] </span><span class="cov8" title="1">{
                y, _ := group.NthResidue(x.ForgetOrder())
                return y
        }</span>
        <span class="cov8" title="1">anc := &amp;anchor[A]{
                n: group.N().Nat(),
        }
        challengeBitLen := 128
        challengeByteLen := (challengeBitLen + 7) / 8
        soundnessError := uint(challengeBitLen)
        scalarMul := func(unit *znstar.PaillierGroupElement[A], eBytes []byte) *znstar.PaillierGroupElement[A] </span><span class="cov8" title="1">{
                e, _ := num.N().FromBytes(eBytes)
                return unit.Exp(e)
        }</span>

        <span class="cov8" title="1">proto, err := maurer09.NewProtocol(
                challengeByteLen,
                soundnessError,
                Name,
                group,
                group,
                oneWayHomomorphism,
                anc,
                prng,
                maurer09.WithImageScalarMul[*znstar.PaillierGroupElement[A], *znstar.PaillierGroupElement[A]](scalarMul),
                maurer09.WithPreImageScalarMul[*znstar.PaillierGroupElement[A]](scalarMul),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create underlying Maurer09 protocol")
        }</span>
        <span class="cov8" title="1">return &amp;Protocol[A]{*proto}, nil</span>
}

type anchor[A znstar.ArithmeticPaillier] struct {
        n *num.Nat
}

func (a *anchor[A]) L() *num.Nat <span class="cov8" title="1">{
        return a.n
}</span>

func (*anchor[A]) PreImage(x *znstar.PaillierGroupElement[A]) (w *znstar.PaillierGroupElement[A]) <span class="cov8" title="1">{
        return x
}</span>
</pre>
		
		<pre class="file" id="file268" style="display: none">package nthroot

import "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"

// Verify wraps the embedded Maurer09 verification to surface errs2-style errors.
func (p *Protocol[A]) Verify(statement *Statement[A], commitment *Commitment[A], challengeBytes sigma.ChallengeBytes, response *Response[A]) error <span class="cov8" title="1">{
        if err := p.Protocol.Verify(statement, commitment, challengeBytes, response); err != nil </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("verification failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file269" style="display: none">package pailliern

import (
        "fmt"
        "math/big"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/encryption"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        appTranscriptLabel       = "BRON_CRYPTO_NIZK_PAILLIER_N"
        sessionIDTranscriptLabel = "BRON_CRYPTO_NIZK_PAILLIER_N_SESSION_ID"
        nTranscriptLabel         = "BRON_CRYPTO_NIZK_PAILLIER_N_N"

        // Alpha .
        Alpha = 6370

        // M is defined as m = /log(), where  = 128 and statistical soundness error is 2^(-).
        M = 11
)

var pBig, _ = new(big.Int).SetString("44871651744009136248115543081640547413785854417842050160655833875792914833852769205831424979368719986889519256934239452438251108738670217298542180982547421007901019408155961940142468907900676141149633188172029947498666222471142795699128314649438784106402197023949268047384343715946006767671319388463922366703585708460135453240679421061304864609915827908896062350138633849514905858373339528086006145373712431756746905467935232935398951226852071323775412278763371089401544920873813490290672436809231516731065356763193493525160238868779310055137922174496115680527519932793977258424479253973670103634070028863591207614649216492780891961054287421831028229266989697058385612003557825398202548657910983931484180193293615175594925895929359108723671212631368891689462486968022029482413912928883488902454913524492340322599922718890878760895105937402913873414377276608236656947832307175090505396675623505955607363683869194683635689701238311577953994900734498406703176954324494694474545570839360607926610248093452739817614097197031607820417729009847465138388398887861935127785385309564525648905444610640901769290645369888935446477559073843982605496992468605588284307311971153579731703863970674466666844817336319390617551354845025116350295041840093627836067370100384861820888752358520276041000456608056339377573485917445104757987800101659688183150320442308091835974182809184299472568260682774683272697993855730500061223160274918361373258473553412704497335663924406111413972911417644029226449602417135116011968946232623154008710271296183350215563946003547561056456285939676838623311370087238225630994506113422922846572616538637723054222166159389475617214681282874373185283568512603887750846072033376432252677883915884203823739988948315257311383912016966925295975180180438969999175030785077627458887411146486902613291202008193902979800279637509789564807502239686755727063367075758492823731724669702442450502667810890608807091448688985203084972035197770874223259420649055450382725355162738490355628688943706634905982449810389530661328557381850782677221561924983234877936783136471890539395124220965982831778882400224156689487137227198030461624542872774217771594215907203725682315714199249588874271661233929713660269883273404764648327455796699366900022345171030564747210542398285078804310752063852249740561571105640741618793118627170070315410588646442647771802031066589341358879304845579387079972404386434238273904239604603511925708377008467129590636257287965232576327580009018475271364237665836186806027331208426256451429549641988386585949300254487647395222785274120561299318070944530096970076560461229486504018773252771360855091191876004370694539453020462096690084476681253865429278552786361828508910022714749051734108364178374765700925133405508684883070", 10)

// P is a product of all primes &lt; Alpha, the value is exported, so we can verify it in the tests.
var P = numct.NewNatFromBig(pBig, pBig.BitLen())

// Proof holds the Paillier N proof data.
type Proof struct {
        Sigmas []*numct.Nat
}

// Prover generates a Paillier N proof.
type Prover struct {
        sid network.SID
        // TODO: replace with concrete type
        enc  encryption.SelfEncrypter[*paillier.PrivateKey, *paillier.Plaintext, *paillier.Ciphertext, *paillier.Nonce]
        tape transcripts.Transcript
}

// NewProver constructs a prover for the Paillier N proof.
func NewProver(sessionID network.SID, enc encryption.SelfEncrypter[*paillier.PrivateKey, *paillier.Plaintext, *paillier.Ciphertext, *paillier.Nonce], tape transcripts.Transcript) (prover *Prover, err error) <span class="cov8" title="1">{
        if enc == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("encrypter is nil")
        }</span>
        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("transcript is nil")
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d", sessionIDTranscriptLabel, sessionID)
        tape.AppendDomainSeparator(dst)
        tape.AppendBytes(nTranscriptLabel, enc.PrivateKey().PublicKey().Modulus().BytesBE())

        return &amp;Prover{
                sid:  sessionID,
                enc:  enc,
                tape: tape,
        }, nil</span>
}

// PrivateKey returns the prover's Paillier secret key.
func (p *Prover) PrivateKey() *paillier.PrivateKey <span class="cov8" title="1">{
        return p.enc.PrivateKey()
}</span>

// Prove generates a proof and returns the public statement.
func (p *Prover) Prove() (proof *Proof, statement *paillier.PublicKey, err error) <span class="cov8" title="1">{
        crtModN := p.PrivateKey().Arithmetic().CrtModN
        rhos, err := extractRhos(p.tape, crtModN.N)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create a proof")
        }</span>

        <span class="cov8" title="1">var nInv numct.Nat
        if ok := crtModN.Phi.ModInv(&amp;nInv, crtModN.N.Nat()); ok == ct.False </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("cannot invert N")
        }</span>
        <span class="cov8" title="1">sigmas := make([]*numct.Nat, M)
        for i := range sigmas </span><span class="cov8" title="1">{
                sigmas[i] = numct.NewNat(0)
        }</span>
        <span class="cov8" title="1">crtModN.MultiBaseExp(sigmas, rhos, &amp;nInv)
        proof = &amp;Proof{
                Sigmas: sigmas,
        }
        return proof, p.PrivateKey().PublicKey(), nil</span>
}

// Verify validates a Paillier N proof for the given statement.
func Verify(sessionID network.SID, tape transcripts.Transcript, statement *paillier.PublicKey, proof *Proof) error <span class="cov8" title="1">{
        if statement == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("statement is nil")
        }</span>
        <span class="cov8" title="1">if proof == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("proof is nil")
        }</span>
        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("transcript is nil")
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d", sessionIDTranscriptLabel, sessionID)
        tape.AppendDomainSeparator(dst)
        tape.AppendBytes(nTranscriptLabel, statement.Modulus().BytesBE())

        rhos, err := extractRhos(tape, statement.N())
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot verify a proof")
        }</span>

        // (a) check that N is a positive integer and is not divisible by all the primes less than .
        <span class="cov8" title="1">if statement.N().Nat().IsZero() != ct.False || statement.N().Nat().Coprime(P) != 1 </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("verification failed")
        }</span>

        // (b) check that _i is a positive integer for i = 1...m.
        <span class="cov8" title="1">if len(proof.Sigmas) != M </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("verification failed")
        }</span>
        <span class="cov8" title="1">for _, sigma := range proof.Sigmas </span><span class="cov8" title="1">{
                if sigma.IsZero() != ct.False </span><span class="cov0" title="0">{
                        return ErrVerificationFailed.WithMessage("verification failed")
                }</span>
        }

        // (c) verify that _i = (_i)^N mod N for i = 1...m.
        <span class="cov8" title="1">rhoChecks := make([]*numct.Nat, M)
        for i := range rhoChecks </span><span class="cov8" title="1">{
                rhoChecks[i] = numct.NewNat(0)
        }</span>
        <span class="cov8" title="1">statement.N().ModMultiBaseExp(rhoChecks, proof.Sigmas, statement.N().Nat())

        allEq := ct.True
        for i := range proof.Sigmas </span><span class="cov8" title="1">{
                allEq &amp;= rhoChecks[i].Equal(rhos[i])
        }</span>
        <span class="cov8" title="1">if allEq == ct.False </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("verification failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func extractRhos(transcript transcripts.Transcript, n *numct.Modulus) ([]*numct.Nat, error) <span class="cov8" title="1">{
        byteSize := uint((n.BitLen() + 7) / 8)
        excessBits := n.BitLen() % 8

        result := make([]*numct.Nat, M)
        for i := range M </span><span class="cov8" title="1">{
                for k := range 128 </span><span class="cov8" title="1">{
                        label := fmt.Sprintf("rho_%d_%d", i, k)
                        candidateBytes, err := transcript.ExtractBytes(label, byteSize)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot extract rho")
                        }</span>

                        <span class="cov8" title="1">candidateBytes[0] &amp;= (1 &lt;&lt; excessBits) - 1 // candidateBytes[0] is the highest byte (big endian)
                        var candidateNat numct.Nat
                        if ok := candidateNat.SetBytes(candidateBytes); ok == ct.False </span><span class="cov0" title="0">{
                                return nil, ErrFailed.WithMessage("cannot set bytes")
                        }</span>

                        // we are rejecting a candidate rho &gt;= N,
                        // instead of rejecting we could just do rho mod N, but this would introduce a slightly biased value.
                        <span class="cov8" title="1">l, _, _ := candidateNat.Compare(n.Nat())
                        if candidateNat.Coprime(n.Nat()) == 1 &amp;&amp; l == ct.True </span><span class="cov8" title="1">{
                                result[i] = candidateNat.Clone()
                                break</span>
                        }
                }

                // the probability of this happening is very low (&lt; 2^(-128))
                <span class="cov8" title="1">if result[i] == nil </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("cannot find suitable rho")
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file270" style="display: none">package paillierrange

import (
        "bytes"
        "encoding/binary"
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// Name identifies the Paillier range proof protocol.
const Name = "PaillierRange"

var (
        _ sigma.Witness                                                        = (*Witness)(nil)
        _ sigma.Statement                                                      = (*Statement)(nil)
        _ sigma.Commitment                                                     = (*Commitment)(nil)
        _ sigma.State                                                          = (*State)(nil)
        _ sigma.Response                                                       = (*Response)(nil)
        _ sigma.Protocol[*Statement, *Witness, *Commitment, *State, *Response] = (*Protocol)(nil)
)

// Witness contains the secret inputs for the range proof.
type Witness struct {
        Sk *paillier.PrivateKey
        X  *paillier.Plaintext
        R  *paillier.Nonce
}

// Bytes serialises the witness for transcript binding.
func (w *Witness) Bytes() []byte <span class="cov0" title="0">{
        var buf bytes.Buffer
        buf.Write(w.Sk.Group().Modulus().Bytes())
        buf.Write(w.X.Value().Bytes())
        buf.Write(w.R.Value().Bytes())
        return buf.Bytes()
}</span>

// NewWitness constructs a range-proof witness.
func NewWitness(sk *paillier.PrivateKey, x *paillier.Plaintext, r *paillier.Nonce) *Witness <span class="cov0" title="0">{
        return &amp;Witness{
                Sk: sk,
                X:  x,
                R:  r,
        }
}</span>

// Statement defines the public inputs for the range proof.
type Statement struct {
        Pk *paillier.PublicKey
        C  *paillier.Ciphertext
        L  *numct.Nat
}

// Bytes serialises the statement for transcript binding.
func (s *Statement) Bytes() []byte <span class="cov8" title="1">{
        pkBytes := s.Pk.Group().Modulus().Bytes()
        cBytes := s.C.Value().Bytes()
        lBytes := s.L.Bytes()
        return slices.Concat(
                binary.LittleEndian.AppendUint64(nil, uint64(len(pkBytes))), pkBytes,
                binary.LittleEndian.AppendUint64(nil, uint64(len(cBytes))), cBytes,
                binary.LittleEndian.AppendUint64(nil, uint64(len(lBytes))), lBytes,
        )
}</span>

// NewStatement constructs a range-proof statement.
func NewStatement(pk *paillier.PublicKey, c *paillier.Ciphertext, l *numct.Nat) *Statement <span class="cov0" title="0">{
        return &amp;Statement{
                Pk: pk,
                C:  c,
                L:  l,
        }
}</span>

// Commitment holds the prover commitment for the range proof.
type Commitment struct {
        C1 []*paillier.Ciphertext
        C2 []*paillier.Ciphertext
}

// Bytes serialises the commitment for transcript binding.
func (c *Commitment) Bytes() []byte <span class="cov8" title="1">{
        var a []byte

        a = binary.LittleEndian.AppendUint64(a, uint64(len(c.C1)))
        for _, c1 := range c.C1 </span><span class="cov8" title="1">{
                var c1Bytes []byte
                if c1 != nil &amp;&amp; c1.Value() != nil </span><span class="cov8" title="1">{
                        c1Bytes = c1.Value().Bytes()
                }</span>
                <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(c1Bytes)))
                a = append(a, c1Bytes...)</span>
        }

        <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(c.C2)))
        for _, c2 := range c.C2 </span><span class="cov8" title="1">{
                var c2Bytes []byte
                if c2 != nil &amp;&amp; c2.Value() != nil </span><span class="cov8" title="1">{
                        c2Bytes = c2.Value().Bytes()
                }</span>
                <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(nil, uint64(len(c2Bytes)))
                a = append(a, c2Bytes...)</span>
        }

        <span class="cov8" title="1">return a</span>
}

// State stores the prover's internal state between rounds.
type State struct {
        W1 []*paillier.Plaintext
        R1 []*paillier.Nonce
        W2 []*paillier.Plaintext
        R2 []*paillier.Nonce
}

// Response is the prover response for the range proof.
type Response struct {
        W1 []*paillier.Plaintext
        R1 []*paillier.Nonce
        W2 []*paillier.Plaintext
        R2 []*paillier.Nonce
        Wj []*paillier.Plaintext
        Rj []*paillier.Nonce
        J  []uint
}

// Bytes serialises the response for transcript binding.
func (r *Response) Bytes() []byte <span class="cov8" title="1">{
        var a []byte

        a = binary.LittleEndian.AppendUint64(a, uint64(len(r.W1)))
        for _, w1 := range r.W1 </span><span class="cov8" title="1">{
                var w1Bytes []byte
                if w1 != nil &amp;&amp; w1.Value() != nil </span><span class="cov8" title="1">{
                        w1Bytes = w1.Value().Bytes()
                }</span>
                <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(w1Bytes)))
                a = append(a, w1Bytes...)</span>
        }

        <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(r.R1)))
        for _, r1 := range r.R1 </span><span class="cov8" title="1">{
                var r1Bytes []byte
                if r1 != nil &amp;&amp; r1.Value() != nil </span><span class="cov8" title="1">{
                        r1Bytes = r1.Value().Bytes()
                }</span>
                <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(r1Bytes)))
                a = append(a, r1Bytes...)</span>
        }

        <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(r.W2)))
        for _, w2 := range r.W2 </span><span class="cov8" title="1">{
                var w2Bytes []byte
                if w2 != nil &amp;&amp; w2.Value() != nil </span><span class="cov8" title="1">{
                        w2Bytes = w2.Value().Bytes()
                }</span>
                <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(w2Bytes)))
                a = append(a, w2Bytes...)</span>
        }

        <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(r.R2)))
        for _, r2 := range r.R2 </span><span class="cov8" title="1">{
                var r2Bytes []byte
                if r2 != nil &amp;&amp; r2.Value() != nil </span><span class="cov8" title="1">{
                        r2Bytes = r2.Value().Bytes()
                }</span>
                <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(nil, uint64(len(r2Bytes)))
                a = append(a, r2Bytes...)</span>
        }

        <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(r.Wj)))
        for _, wj := range r.Wj </span><span class="cov8" title="1">{
                var wjBytes []byte
                if wj != nil &amp;&amp; wj.Value() != nil </span><span class="cov8" title="1">{
                        wjBytes = wj.Value().Bytes()
                }</span>
                <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(wjBytes)))
                a = append(a, wjBytes...)</span>
        }

        <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(r.Rj)))
        for _, rj := range r.Rj </span><span class="cov8" title="1">{
                var rjBytes []byte
                if rj != nil &amp;&amp; rj.Value() != nil </span><span class="cov8" title="1">{
                        rjBytes = rj.Value().Bytes()
                }</span>
                <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(rjBytes)))
                a = append(a, rjBytes...)</span>
        }

        <span class="cov8" title="1">a = binary.LittleEndian.AppendUint64(a, uint64(len(r.J)))
        for _, j := range r.J </span><span class="cov8" title="1">{
                a = binary.LittleEndian.AppendUint64(a, uint64(j))
        }</span>

        <span class="cov8" title="1">return a</span>
}

// Protocol implements the Paillier range proof.
type Protocol struct {
        t    uint
        prng io.Reader
}

// NewPaillierRange constructs a Paillier range-proof protocol instance.
func NewPaillierRange(t uint, prng io.Reader) (*Protocol, error) <span class="cov8" title="1">{
        if t &lt; base.StatisticalSecurityBits </span><span class="cov0" title="0">{
                return nil, ErrValidationFailed.WithMessage("insufficient statistical security")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil prng")
        }</span>

        <span class="cov8" title="1">return &amp;Protocol{
                t:    t,
                prng: prng,
        }, nil</span>
}

// Name returns the protocol identifier.
func (*Protocol) Name() sigma.Name <span class="cov8" title="1">{
        return Name
}</span>

// ComputeProverCommitment generates the initial commitment and state.
func (p *Protocol) ComputeProverCommitment(statement *Statement, witness *Witness) (*Commitment, *State, error) <span class="cov8" title="1">{
        ps := statement.Pk.PlaintextSpace()
        lowBound, err := ps.FromNat(statement.L)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create new plaintext")
        }</span>
        <span class="cov8" title="1">highBound := lowBound.Add(lowBound)
        swaps := make([]byte, (p.t+7)/8)
        _, err = io.ReadFull(p.prng, swaps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot generate randomness")
        }</span>

        <span class="cov8" title="1">w := make([]*paillier.Plaintext, 2*p.t)
        for i := range p.t </span><span class="cov8" title="1">{
                w1i, err := ps.Sample(lowBound, highBound, p.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot compute w1i")
                }</span>
                <span class="cov8" title="1">w2i := w1i.Sub(lowBound)
                swapBit := (swaps[i/8] &gt;&gt; (i % 8)) % 2
                if swapBit != 0 </span><span class="cov8" title="1">{
                        w1i, w2i = w2i, w1i
                }</span>

                <span class="cov8" title="1">w[i] = w1i
                w[p.t+i] = w2i</span>
        }
        <span class="cov8" title="1">senc, err := paillier.NewScheme().SelfEncrypter(witness.Sk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create self encrypter")
        }</span>
        <span class="cov8" title="1">c, r, err := senc.SelfEncryptMany(w, p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot encrypt state")
        }</span>

        <span class="cov8" title="1">a := &amp;Commitment{
                C1: c[:p.t],
                C2: c[p.t:],
        }
        s := &amp;State{
                W1: w[:p.t],
                R1: r[:p.t],
                W2: w[p.t:],
                R2: r[p.t:],
        }

        return a, s, nil</span>
}

// ComputeProverResponse generates the response for a given challenge.
func (p *Protocol) ComputeProverResponse(statement *Statement, witness *Witness, _ *Commitment, state *State, challenge sigma.ChallengeBytes) (*Response, error) <span class="cov8" title="1">{
        if len(state.W1) != int(p.t) || len(state.R1) != int(p.t) || len(state.W2) != int(p.t) || len(state.R2) != int(p.t) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("inconsistent input")
        }</span>

        <span class="cov8" title="1">ps := statement.Pk.PlaintextSpace()
        lowBound, err := ps.FromNat(statement.L)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create new plaintext")
        }</span>
        <span class="cov8" title="1">highBound := lowBound.Add(lowBound)

        z := &amp;Response{
                W1: make([]*paillier.Plaintext, p.t),
                R1: make([]*paillier.Nonce, p.t),
                W2: make([]*paillier.Plaintext, p.t),
                R2: make([]*paillier.Nonce, p.t),
                Wj: make([]*paillier.Plaintext, p.t),
                Rj: make([]*paillier.Nonce, p.t),
                J:  make([]uint, p.t),
        }

        for i := range p.t </span><span class="cov8" title="1">{
                ei := (challenge[i/8] &gt;&gt; (i % 8)) % 2
                switch ei </span>{
                case 0:<span class="cov8" title="1">
                        z.W1[i] = state.W1[i]
                        z.R1[i] = state.R1[i]
                        z.W2[i] = state.W2[i]
                        z.R2[i] = state.R2[i]

                        // put some dummy value to it can be serialised
                        z.Wj[i] = new(paillier.Plaintext)
                        z.Rj[i] = new(paillier.Nonce)
                        z.J[i] = 0</span>
                case 1:<span class="cov8" title="1">
                        xPlusW1 := witness.X.Add(state.W1[i])
                        if isInRange(lowBound, highBound, xPlusW1) </span><span class="cov8" title="1">{
                                z.Wj[i] = xPlusW1
                                z.Rj[i] = witness.R.Mul(state.R1[i])
                                z.J[i] = 1
                        }</span> else<span class="cov8" title="1"> {
                                xPlusW2 := witness.X.Add(state.W2[i])
                                z.Wj[i] = xPlusW2
                                z.Rj[i] = witness.R.Mul(state.R2[i])
                                z.J[i] = 2
                        }</span>

                        // put some dummy value to it can be serialised
                        <span class="cov8" title="1">z.W1[i] = new(paillier.Plaintext)
                        z.R1[i] = new(paillier.Nonce)
                        z.W2[i] = new(paillier.Plaintext)
                        z.R2[i] = new(paillier.Nonce)</span>
                default:<span class="cov0" title="0">
                        panic("this should never happen")</span>
                }
        }

        <span class="cov8" title="1">return z, nil</span>
}

// Verify checks a prover response against the statement and commitment.
func (p *Protocol) Verify(statement *Statement, commitment *Commitment, challenge sigma.ChallengeBytes, response *Response) error <span class="cov8" title="1">{
        if len(commitment.C1) != int(p.t) || len(commitment.C2) != int(p.t) </span><span class="cov0" title="0">{
                return ErrFailed.WithMessage("inconsistent input")
        }</span>
        <span class="cov8" title="1">if len(response.W1) != int(p.t) || len(response.R1) != int(p.t) || len(response.W2) != int(p.t) || len(response.R2) != int(p.t) || len(response.Wj) != int(p.t) || len(response.Rj) != int(p.t) || len(response.J) != int(p.t) </span><span class="cov0" title="0">{
                return ErrFailed.WithMessage("inconsistent input")
        }</span>

        <span class="cov8" title="1">ps := statement.Pk.PlaintextSpace()
        lowBound, err := ps.FromNat(statement.L)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create new plaintext")
        }</span>
        <span class="cov8" title="1">highBound := lowBound.Add(lowBound)

        var c []*paillier.Ciphertext
        var w []*paillier.Plaintext
        var r []*paillier.Nonce
        for i := range p.t </span><span class="cov8" title="1">{
                ei := (challenge[i/8] &gt;&gt; (i % 8)) % 2
                switch ei </span>{
                case 0:<span class="cov8" title="1">
                        w1i := response.W1[i]
                        w2i := response.W2[i]
                        if (!isInRange(lowBound, highBound, w1i) || !isInRange(ps.Zero(), lowBound, w2i)) &amp;&amp;
                                (!isInRange(lowBound, highBound, w2i) || !isInRange(ps.Zero(), lowBound, w1i)) </span><span class="cov0" title="0">{

                                return ErrVerificationFailed.WithMessage("verification failed")
                        }</span>

                        <span class="cov8" title="1">w = append(w, w1i)
                        r = append(r, response.R1[i])
                        c = append(c, commitment.C1[i])
                        w = append(w, w2i)
                        r = append(r, response.R2[i])
                        c = append(c, commitment.C2[i])</span>
                case 1:<span class="cov8" title="1">
                        wi := response.Wj[i]
                        if !isInRange(lowBound, highBound, wi) </span><span class="cov8" title="1">{
                                return ErrVerificationFailed.WithMessage("verification failed")
                        }</span>

                        <span class="cov8" title="1">w = append(w, wi)
                        r = append(r, response.Rj[i])

                        switch response.J[i] </span>{
                        case 1:<span class="cov8" title="1">
                                ci := statement.C.HomAdd(commitment.C1[i])
                                c = append(c, ci)</span>
                        case 2:<span class="cov8" title="1">
                                ci := statement.C.HomAdd(commitment.C2[i])
                                c = append(c, ci)</span>
                        default:<span class="cov0" title="0">
                                return ErrVerificationFailed.WithMessage("verification failed")</span>
                        }
                default:<span class="cov0" title="0">
                        panic("this should never happen")</span>
                }
        }

        <span class="cov8" title="1">enc, err := paillier.NewScheme().Encrypter()
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create encrypter")
        }</span>
        <span class="cov8" title="1">cCheck, err := enc.EncryptManyWithNonces(w, statement.Pk, r)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot compute encrypted ciphertext")
        }</span>
        <span class="cov8" title="1">for i, ci := range c </span><span class="cov8" title="1">{
                if !cCheck[i].Equal(ci) </span><span class="cov0" title="0">{
                        return ErrVerificationFailed.WithMessage("verification failed")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// RunSimulator creates a simulated transcript for a given challenge.
func (p *Protocol) RunSimulator(statement *Statement, challenge sigma.ChallengeBytes) (*Commitment, *Response, error) <span class="cov8" title="1">{
        ps := statement.Pk.PlaintextSpace()
        lowBound, err := ps.FromNat(statement.L)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create new plaintext")
        }</span>
        <span class="cov8" title="1">highBound := lowBound.Add(lowBound)

        w1 := make([]*paillier.Plaintext, p.t)
        r1 := make([]*paillier.Nonce, p.t)
        c1 := make([]*paillier.Ciphertext, p.t)
        w2 := make([]*paillier.Plaintext, p.t)
        r2 := make([]*paillier.Nonce, p.t)
        c2 := make([]*paillier.Ciphertext, p.t)
        wj := make([]*paillier.Plaintext, p.t)
        rj := make([]*paillier.Nonce, p.t)
        j := make([]uint, p.t)

        enc, err := paillier.NewScheme().Encrypter()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create encrypter")
        }</span>

        <span class="cov8" title="1">toBeEncrypted := make([]*paillier.Plaintext, p.t*2)
        for i := range p.t </span><span class="cov8" title="1">{
                ei := (challenge[i/8] &gt;&gt; (i % 8)) % 2
                switch ei </span>{
                case 0:<span class="cov8" title="1">
                        w1[i], err = ps.Sample(lowBound, highBound, p.prng)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute w1i")
                        }</span>
                        <span class="cov8" title="1">w2[i] = w1[i].Sub(lowBound)
                        toBeEncrypted[i] = w1[i]
                        toBeEncrypted[i+p.t] = w2[i]</span>
                case 1:<span class="cov8" title="1">
                        wj[i], err = ps.Sample(lowBound, highBound, p.prng)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute w1i")
                        }</span>
                        <span class="cov8" title="1">toBeEncrypted[i] = wj[i]
                        toBeEncrypted[i+p.t] = ps.Zero()</span>
                default:<span class="cov0" title="0">
                        panic("this should never happen")</span>
                }
        }

        <span class="cov8" title="1">ctxs, rs, err := enc.EncryptMany(toBeEncrypted, statement.Pk, p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot encrypt many")
        }</span>

        <span class="cov8" title="1">for i := range p.t </span><span class="cov8" title="1">{
                ei := (challenge[i/8] &gt;&gt; (i % 8)) % 2
                switch ei </span>{
                case 0:<span class="cov8" title="1">
                        // Extract encrypted values for w1 and w2
                        c1[i] = ctxs[i]
                        r1[i] = rs[i]
                        c2[i] = ctxs[i+p.t]
                        r2[i] = rs[i+p.t]</span>
                case 1:<span class="cov8" title="1">
                        cji := ctxs[i]
                        rji := rs[i]
                        cZero := ctxs[i+p.t]
                        var ji [1]byte
                        _, err = io.ReadFull(p.prng, ji[:])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample j")
                        }</span>
                        <span class="cov8" title="1">j[i] = uint(1 + (ji[0] % 2))
                        switch j[i] </span>{
                        case 1:<span class="cov8" title="1">
                                c1[i] = cji.HomSub(statement.C)
                                c2[i] = cZero
                                rj[i] = rji</span>
                        case 2:<span class="cov8" title="1">
                                c2[i] = cji.HomSub(statement.C)
                                c1[i] = cZero
                                rj[i] = rji</span>
                        default:<span class="cov0" title="0">
                                panic("this should never happen")</span>
                        }
                default:<span class="cov0" title="0">
                        panic("this should never happen")</span>
                }
        }

        <span class="cov8" title="1">a := &amp;Commitment{
                C1: c1,
                C2: c2,
        }
        z := &amp;Response{
                W1: w1,
                R1: r1,
                W2: w2,
                R2: r2,
                Wj: wj,
                Rj: rj,
                J:  j,
        }
        return a, z, nil</span>
}

// SpecialSoundness returns the protocol special soundness parameter.
func (*Protocol) SpecialSoundness() uint <span class="cov8" title="1">{
        return 2
}</span>

// ValidateStatement checks the witness against the statement.
func (*Protocol) ValidateStatement(statement *Statement, witness *Witness) error <span class="cov8" title="1">{
        if !statement.Pk.Equal(witness.Sk.PublicKey()) </span><span class="cov0" title="0">{
                return ErrValidationFailed.WithMessage("paillier keys mismatch")
        }</span>
        <span class="cov8" title="1">senc, err := paillier.NewScheme().SelfEncrypter(witness.Sk)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("failed to create self encrypter")
        }</span>
        <span class="cov8" title="1">cCheck, err := senc.SelfEncryptWithNonce(witness.X, witness.R)
        if err != nil || !statement.C.Equal(cCheck) </span><span class="cov0" title="0">{
                return ErrValidationFailed.WithMessage("plaintext/ciphertext mismatch")
        }</span>

        <span class="cov8" title="1">var negL, twoL, L numct.Int
        L.SetNat(statement.L)
        negL.Neg(&amp;L)
        twoL.Double(&amp;L)

        lowBound, err := statement.Pk.PlaintextSpace().FromInt(&amp;negL)
        if err != nil </span><span class="cov0" title="0">{
                return ErrValidationFailed.WithMessage("cannot compute low bound")
        }</span>
        <span class="cov8" title="1">highBound, err := statement.Pk.PlaintextSpace().FromInt(&amp;twoL)
        if err != nil </span><span class="cov0" title="0">{
                return ErrValidationFailed.WithMessage("cannot compute high bound")
        }</span>

        <span class="cov8" title="1">if !isInRange(lowBound, highBound, witness.X) </span><span class="cov8" title="1">{
                return ErrValidationFailed.WithMessage("witness out of range")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetChallengeBytesLength returns the challenge size in bytes.
func (p *Protocol) GetChallengeBytesLength() int <span class="cov8" title="1">{
        return int((p.t + 7) / 8)
}</span>

// SoundnessError returns the protocol soundness error.
func (p *Protocol) SoundnessError() uint <span class="cov8" title="1">{
        return p.t
}</span>

func isInRange(lowInclusive, highExclusive, v *paillier.Plaintext) bool <span class="cov8" title="1">{
        return lowInclusive.IsLessThanOrEqual(v) &amp;&amp; v.IsLessThanOrEqual(highExclusive) &amp;&amp; !highExclusive.Equal(v)
}</span>
</pre>
		
		<pre class="file" id="file271" style="display: none">// Package compiler provides compilers that transform interactive sigma protocols
// into non-interactive zero-knowledge proofs of knowledge (NIZKPoK).
//
// This package supports three compiler implementations:
//   - Fiat-Shamir: A simple, efficient compiler using hash-based challenge derivation
//   - Fischlin: A UC-secure compiler using repeated attempts with hash-based filtering
//   - Randomised Fischlin: A variant of Fischlin using randomised attempts with hash-based filtering, usable for OR composition.
//
// Each compiler takes an interactive sigma protocol and produces a non-interactive
// protocol that can generate and verify proofs without interaction between parties.
package compiler

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fiatshamir"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fischlin"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/randfischlin"
)

// Name is the identifier for a compiler implementation.
type Name = internal.Name

// NIZKPoKProof is a serialised non-interactive zero-knowledge proof of knowledge.
type NIZKPoKProof = internal.NIZKPoKProof

// NIProver is the interface for generating non-interactive proofs.
type NIProver[X sigma.Statement, W sigma.Witness] = internal.NIProver[X, W]

// NIVerifier is the interface for verifying non-interactive proofs.
type NIVerifier[X sigma.Statement] = internal.NIVerifier[X]

// NonInteractiveProtocol is the interface for a compiled non-interactive protocol
// that can create provers and verifiers for generating and verifying proofs.
type NonInteractiveProtocol[X sigma.Statement, W sigma.Witness] = internal.NonInteractiveProtocol[X, W]

// Compile transforms an interactive sigma protocol into a non-interactive protocol
// using the specified compiler. The compilerName must be one of fiatshamir.Name,
// fischlin.Name, or randfischlin.Name. The prng is used by Fischlin-based compilers
// for randomness during proof generation.
func Compile[X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response](compilerName Name, sigmaProtocol sigma.Protocol[X, W, A, S, Z], prng io.Reader) (NonInteractiveProtocol[X, W], error) <span class="cov8" title="1">{
        switch compilerName </span>{
        case fiatshamir.Name:<span class="cov8" title="1">
                return fiatshamir.NewCompiler(sigmaProtocol)</span> //nolint:wrapcheck // pass through
        case fischlin.Name:<span class="cov8" title="1">
                return fischlin.NewCompiler(sigmaProtocol, prng)</span> //nolint:wrapcheck // pass through
        case randfischlin.Name:<span class="cov8" title="1">
                return randfischlin.NewCompiler(sigmaProtocol, prng)</span> //nolint:wrapcheck // pass through
        default:<span class="cov8" title="1">
                return nil, ErrUnsupportedType.WithMessage("unknown compiler name: %s", compilerName)</span>
        }
}

// IsSupported returns true if the given compiler name is a valid, supported compiler.
func IsSupported(name Name) bool <span class="cov8" title="1">{
        switch name </span>{
        case fiatshamir.Name, fischlin.Name, randfischlin.Name:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

var (
        ErrUnsupportedType = errs2.New("unsupported type")
)
</pre>
		
		<pre class="file" id="file272" style="display: none">// Package fiatshamir implements the Fiat-Shamir transform for compiling interactive
// sigma protocols into non-interactive zero-knowledge proofs.
//
// The Fiat-Shamir transform replaces the verifier's random challenge with a hash
// of the transcript, making the protocol non-interactive. This is a simple and
// efficient approach that provides computational security.
//
// The transform requires that the underlying sigma protocol has soundness error
// at least 2^(-128) to ensure computational security of the resulting NIZK proof.
package fiatshamir

import (
        "fmt"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        // Name is the identifier for the Fiat-Shamir compiler.
        Name compiler.Name = "FiatShamir"

        transcriptLabel = "BRON_CRYPTO_NIZKP_FIATSHAMIR-"
        statementLabel  = "statementLabel-"
        commitmentLabel = "commitmentLabel-"
        challengeLabel  = "challengeLabel-"
)

// Proof represents a Fiat-Shamir non-interactive proof containing
// the prover's commitment (a) and response (z).
type Proof[A sigma.Commitment, Z sigma.Response] struct {
        a A
        z Z
}

type proofDTO[A sigma.Commitment, Z sigma.Response] struct {
        A A `cbor:"A"`
        Z Z `cbor:"Z"`
}

// MarshalCBOR serialises the proof to CBOR format.
func (p *Proof[A, Z]) MarshalCBOR() ([]byte, error) <span class="cov8" title="1">{
        dto := &amp;proofDTO[A, Z]{
                A: p.a,
                Z: p.z,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Fiat-Shamir proof")
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// UnmarshalCBOR deserializes the proof from CBOR format.
func (p *Proof[A, Z]) UnmarshalCBOR(data []byte) error <span class="cov8" title="1">{
        dto, err := serde.UnmarshalCBOR[*proofDTO[A, Z]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.a = dto.A
        p.z = dto.Z
        return nil</span>
}

type fs[X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response] struct {
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
}

// NewCompiler creates a new Fiat-Shamir compiler for the given sigma protocol.
// The sigma protocol must have soundness error at least 2^(-128) to ensure
// computational security of the resulting non-interactive proof.
func NewCompiler[
        X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response,
](sigmaProtocol sigma.Protocol[X, W, A, S, Z]) (compiler.NonInteractiveProtocol[X, W], error) <span class="cov8" title="1">{
        if sigmaProtocol == nil </span><span class="cov8" title="1">{
                return nil, ErrNil.WithMessage("sigmaProtocol")
        }</span>
        <span class="cov8" title="1">if s := sigmaProtocol.SoundnessError(); s &lt; base.ComputationalSecurityBits </span><span class="cov0" title="0">{
                return nil, ErrInvalid.WithMessage("sigmaProtocol soundness (%d) is too low (&lt;%d) for a non-interactive proof",
                        s, base.ComputationalSecurityBits)
        }</span>
        <span class="cov8" title="1">return &amp;fs[X, W, A, S, Z]{
                sigmaProtocol: sigmaProtocol,
        }, nil</span>
}

// NewProver creates a new non-interactive prover for generating Fiat-Shamir proofs.
// The sessionID and transcript are used for domain separation.
func (c *fs[X, W, A, S, Z]) NewProver(sessionID network.SID, transcript transcripts.Transcript) (compiler.NIProver[X, W], error) <span class="cov8" title="1">{
        dst := fmt.Sprintf("%s-%s-%s", sessionID, transcriptLabel, c.sigmaProtocol.Name())
        transcript.AppendDomainSeparator(dst)

        return &amp;prover[X, W, A, S, Z]{
                transcript:    transcript,
                sigmaProtocol: c.sigmaProtocol,
        }, nil
}</span>

// NewVerifier creates a new non-interactive verifier for checking Fiat-Shamir proofs.
// The sessionID and transcript must match those used by the prover.
func (c *fs[X, W, A, S, Z]) NewVerifier(sessionID network.SID, transcript transcripts.Transcript) (compiler.NIVerifier[X], error) <span class="cov8" title="1">{
        dst := fmt.Sprintf("%s-%s-%s", sessionID, transcriptLabel, c.sigmaProtocol.Name())
        transcript.AppendDomainSeparator(dst)

        return &amp;verifier[X, W, A, S, Z]{
                transcript:    transcript,
                sigmaProtocol: c.sigmaProtocol,
        }, nil
}</span>

// Name returns the compiler name ("FiatShamir").
func (*fs[_, _, _, _, _]) Name() compiler.Name <span class="cov0" title="0">{
        return Name
}</span>

// SigmaProtocolName returns the name of the underlying sigma protocol.
func (c *fs[_, _, _, _, _]) SigmaProtocolName() sigma.Name <span class="cov0" title="0">{
        return c.sigmaProtocol.Name()
}</span>
</pre>
		
		<pre class="file" id="file273" style="display: none">package fiatshamir

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// prover implements the NIProver interface for Fiat-Shamir proofs.
type prover[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] struct {
        transcript    transcripts.Transcript
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
}

// Prove generates a non-interactive proof for the given statement and witness.
// It computes the sigma protocol commitment, derives the challenge from the transcript
// hash, computes the response, and returns the serialised proof.
func (p prover[X, W, A, S, Z]) Prove(statement X, witness W) (compiler.NIZKPoKProof, error) <span class="cov8" title="1">{
        p.transcript.AppendBytes(statementLabel, statement.Bytes())

        a, s, err := p.sigmaProtocol.ComputeProverCommitment(statement, witness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate commitment")
        }</span>
        <span class="cov8" title="1">p.transcript.AppendBytes(commitmentLabel, a.Bytes())

        e, err := p.transcript.ExtractBytes(challengeLabel, uint(p.sigmaProtocol.GetChallengeBytesLength()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot extract bytes from transcript")
        }</span>

        <span class="cov8" title="1">z, err := p.sigmaProtocol.ComputeProverResponse(statement, witness, a, s, e)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate response")
        }</span>

        <span class="cov8" title="1">proof := &amp;Proof[A, Z]{
                a: a,
                z: z,
        }

        proofBytes, err := serde.MarshalCBOR(proof)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot serialise proof")
        }</span>
        <span class="cov8" title="1">return proofBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file274" style="display: none">package fiatshamir

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// verifier implements the NIVerifier interface for Fiat-Shamir proofs.
type verifier[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] struct {
        transcript    transcripts.Transcript
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
}

// Verify checks that a Fiat-Shamir proof is valid for the given statement.
// It deserializes the proof, recomputes the challenge from the transcript,
// and verifies the sigma protocol relation.
func (v verifier[X, W, A, S, Z]) Verify(statement X, proofBytes compiler.NIZKPoKProof) error <span class="cov8" title="1">{
        if len(proofBytes) == 0 </span><span class="cov8" title="1">{
                return ErrNil.WithMessage("proof")
        }</span>

        <span class="cov8" title="1">fsProof, err := serde.UnmarshalCBOR[*Proof[A, Z]](proofBytes)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("cannot deserialize proof")
        }</span>
        <span class="cov8" title="1">v.transcript.AppendBytes(statementLabel, statement.Bytes())

        a := fsProof.a
        v.transcript.AppendBytes(commitmentLabel, a.Bytes())

        e, err := v.transcript.ExtractBytes(challengeLabel, uint(v.sigmaProtocol.GetChallengeBytesLength()))
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot extract bytes from transcript")
        }</span>

        <span class="cov8" title="1">z := fsProof.z
        if err := v.sigmaProtocol.Verify(statement, a, e, z); err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file275" style="display: none">// Package fischlin implements the Fischlin transform for compiling interactive
// sigma protocols into non-interactive zero-knowledge proofs with UC security.
//
// Fischlin's transform provides universally composable (UC) security, which is
// stronger than the standard Fiat-Shamir transform. It achieves this by requiring
// the prover to find challenge/response pairs that hash to zero.
//
// The parameters rho (number of repetitions), b (hash output bits), and t (search
// bound) are computed based on the sigma protocol's special soundness property to
// achieve a target soundness error of 2^(-128).
//
// Reference: "Optimising and Implementing Fischlin's Transform for UC-Secure
// Zero-Knowledge" by Chen &amp; Lindell.
package fischlin

import (
        "crypto/sha3"
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        // Name is the identifier for the Fischlin compiler.
        Name compiler.Name = "Fischlin"

        transcriptLabel = "BRON_CRYPTO_NIZK_FISCHLIN-"

        commonHLabel    = "commonHLabel-"
        rhoLabel        = "rhoLabel-"
        statementLabel  = "statementLabel-"
        commitmentLabel = "commitmentLabel-"
        challengeLabel  = "challengeLabel-"
        responseLabel   = "responseLabel-"
)

var (
        randomOracle = sha3.New256
)

// Proof represents a Fischlin non-interactive proof containing rho parallel
// executions of the sigma protocol. Each execution includes a commitment (A),
// challenge (E), and response (Z). The Rho and B parameters are included
// for verification.
type Proof[A sigma.Commitment, Z sigma.Response] struct {
        Rho uint64   `cbor:"rho"`
        B   uint64   `cbor:"b"`
        A   []A      `cbor:"a"`
        E   [][]byte `cbor:"e"`
        Z   []Z      `cbor:"z"`
}

var _ compiler.NonInteractiveProtocol[sigma.Statement, sigma.Witness] = (*simplifiedFischlin[
        sigma.Statement, sigma.Witness, sigma.Statement, sigma.State, sigma.Response,
])(nil)

type simplifiedFischlin[X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response] struct {
        rho           uint64
        b             uint64
        t             uint64
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
        prng          io.Reader
}

// NewCompiler creates a new Fischlin compiler for the given sigma protocol.
// The prng is used for randomness during proof generation.
func NewCompiler[X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response](sigmaProtocol sigma.Protocol[X, W, A, S, Z], prng io.Reader) (compiler.NonInteractiveProtocol[X, W], error) <span class="cov8" title="1">{
        if sigmaProtocol == nil || prng == nil </span><span class="cov8" title="1">{
                return nil, ErrNil.WithMessage("sigmaProtocol or prng")
        }</span>

        <span class="cov8" title="1">rho := getRho(sigmaProtocol)
        b1 := (base.ComputationalSecurityBits + rho - 1) / rho
        b2 := uint64(mathutils.CeilLog2(int(sigmaProtocol.SpecialSoundness()) - 1))
        b := b1 + b2
        t := b + 5
        if rho &gt; 64 </span><span class="cov0" title="0">{
                t = b + 6
        }</span>
        <span class="cov8" title="1">if rho &lt; 2 || b &lt; 2 || t &gt;= 64 </span><span class="cov0" title="0">{
                return nil, ErrInvalid.WithMessage("invalid rho")
        }</span>

        <span class="cov8" title="1">return &amp;simplifiedFischlin[X, W, A, S, Z]{
                rho:           rho,
                b:             b,
                t:             t,
                sigmaProtocol: sigmaProtocol,
                prng:          prng,
        }, nil</span>
}

// NewProver creates a new non-interactive prover for generating Fischlin proofs.
// The sessionID and transcript are used for domain separation.
func (c *simplifiedFischlin[X, W, A, S, Z]) NewProver(sessionID network.SID, transcript transcripts.Transcript) (compiler.NIProver[X, W], error) <span class="cov8" title="1">{
        if transcript == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("transcript")
        }</span>

        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%s-%s", transcriptLabel, c.sigmaProtocol.Name(), hex.EncodeToString(sessionID[:]))
        transcript.AppendDomainSeparator(dst)

        return &amp;prover[X, W, A, S, Z]{
                sessionID:     sessionID,
                transcript:    transcript,
                sigmaProtocol: c.sigmaProtocol,
                prng:          c.prng,
                rho:           c.rho,
                b:             c.b,
                t:             c.t,
        }, nil</span>
}

// NewVerifier creates a new non-interactive verifier for checking Fischlin proofs.
// The sessionID and transcript must match those used by the prover.
func (c *simplifiedFischlin[X, W, A, S, Z]) NewVerifier(sessionID network.SID, transcript transcripts.Transcript) (compiler.NIVerifier[X], error) <span class="cov8" title="1">{
        if transcript == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("transcript")
        }</span>

        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%s-%s", transcriptLabel, c.sigmaProtocol.Name(), hex.EncodeToString(sessionID[:]))
        transcript.AppendDomainSeparator(dst)

        return &amp;verifier[X, W, A, S, Z]{
                sessionID:     sessionID,
                transcript:    transcript,
                sigmaProtocol: c.sigmaProtocol,
        }, nil</span>
}

// Name returns the compiler name ("Fischlin").
func (*simplifiedFischlin[_, _, _, _, _]) Name() compiler.Name <span class="cov0" title="0">{
        return Name
}</span>

// SigmaProtocolName returns the name of the underlying sigma protocol.
func (c *simplifiedFischlin[_, _, _, _, _]) SigmaProtocolName() sigma.Name <span class="cov0" title="0">{
        return c.sigmaProtocol.Name()
}</span>
</pre>
		
		<pre class="file" id="file276" style="display: none">package fischlin

import (
        "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/nthroot"
        paillierrange "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/range"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

const (
        defaultRho = uint64(16)
)

func getRho[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response](sigmaProtocol sigma.Protocol[X, W, A, S, Z]) uint64 <span class="cov8" title="1">{
        switch sigmaProtocol.Name() </span>{
        case schnorr.Name:<span class="cov8" title="1">
                return 16</span>
        case nthroot.Name:<span class="cov0" title="0">
                return 32</span>
        case paillierrange.Name:<span class="cov0" title="0">
                return 16</span>
        default:<span class="cov0" title="0">
                return defaultRho</span>
        }
}
</pre>
		
		<pre class="file" id="file277" style="display: none">package fischlin

import (
        "encoding/binary"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

var _ compiler.NIProver[sigma.Statement, sigma.Witness] = (*prover[
        sigma.Statement, sigma.Witness, sigma.Commitment, sigma.State, sigma.Response,
])(nil)

// prover implements the NIProver interface for Fischlin proofs.
type prover[X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response] struct {
        sessionID     network.SID
        transcript    transcripts.Transcript
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
        prng          io.Reader
        rho           uint64
        b             uint64
        t             uint64
}

// Prove generates a non-interactive Fischlin proof for the given statement and witness.
// It runs rho parallel executions of the sigma protocol, searching for challenge/response
// pairs that hash to zero. Returns the serialised proof containing all rho transcripts.
func (p *prover[X, W, A, S, Z]) Prove(statement X, witness W) (compiler.NIZKPoKProof, error) <span class="cov8" title="1">{
        p.transcript.AppendBytes(rhoLabel, binary.LittleEndian.AppendUint64(nil, p.rho))
        p.transcript.AppendBytes(statementLabel, statement.Bytes())
        commonHKey, err := p.transcript.ExtractBytes(commonHLabel, base.CollisionResistanceBytesCeil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot extract h")
        }</span>

        <span class="cov8" title="1">a := make([]byte, 0)
        aI := make([]A, p.rho)
        stateI := make([]S, p.rho)
        eI := make([][]byte, p.rho)
        zI := make([]Z, p.rho)

redo:
        for </span><span class="cov8" title="1">{
                // 1. For i = 1, ..., :
                for i := range p.rho </span><span class="cov8" title="1">{
                        var err error

                        // 1.a. compute (m_i, _i)  ProverFirstMessage(x, w) independently for each i
                        aI[i], stateI[i], err = p.sigmaProtocol.ComputeProverCommitment(statement, witness)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot generate commitment")
                        }</span>

                        <span class="cov8" title="1">a = append(a, aI[i].Bytes()...)</span>
                }

                // 3. common-h  H(x, m, sid)
                // (This is a full hash, with output length 2*c)
                <span class="cov8" title="1">commonH, err := hashing.Hash(randomOracle, commonHKey, statement.Bytes(), a, p.sessionID[:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot generate commitment")
                }</span>

                // 4. For i = 1, ..., :
                <span class="cov8" title="1">for i := range p.rho </span><span class="cov8" title="1">{
                        // 4.a. For ei = 0, ..., 2^t  1:
                        for j := range uint64(1 &lt;&lt; p.t) </span><span class="cov8" title="1">{
                                // 4.a.i. z_i  ProverSecondMessage(x, w, _i, e_i)
                                eI[i], zI[i], err = p.challengeBytesAndResponse(j, statement, witness, aI[i], stateI[i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, errs2.Wrap(err).WithMessage("cannot compute proof")
                                }</span>

                                // 4.a.ii. h_i  H(common-h, i, e_i, z_i), where H is the first b bits of output of hash
                                <span class="cov8" title="1">hI, err := hash(p.b, commonH, i, eI[i], zI[i].Bytes())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, errs2.Wrap(err).WithMessage("cannot compute proof")
                                }</span>

                                // 4.a.iii. If hi == 0, break
                                <span class="cov8" title="1">if isAllZeros(hI) </span><span class="cov8" title="1">{
                                        break</span>
                                }

                                // 4.a.iv. If e_i == 2^t  1, redo the entire proof from the beginning
                                // (If this occurs, then it means that no break ever took place, meaning that the proof failed)
                                <span class="cov8" title="1">if j == ((1 &lt;&lt; p.t) - 1) </span><span class="cov0" title="0">{
                                        continue redo</span>
                                }
                        }
                }

                <span class="cov8" title="1">break redo</span>
        }

        <span class="cov8" title="1">commitmentSerialized := make([][]byte, 0)
        for i := range p.rho </span><span class="cov8" title="1">{
                commitmentSerialized = append(commitmentSerialized, aI[i].Bytes())
        }</span>
        <span class="cov8" title="1">responseSerialized := make([][]byte, 0)
        for i := range p.rho </span><span class="cov8" title="1">{
                responseSerialized = append(responseSerialized, zI[i].Bytes())
        }</span>
        <span class="cov8" title="1">p.transcript.AppendBytes(commitmentLabel, commitmentSerialized...)
        p.transcript.AppendBytes(challengeLabel, eI...)
        p.transcript.AppendBytes(responseLabel, responseSerialized...)

        // 7.   (m, e, z)
        proof := &amp;Proof[A, Z]{
                Rho: p.rho,
                B:   p.b,
                A:   aI, // 2. m  (m_1, ..., m_)
                E:   eI, // 5. e  (e_1, ..., e_)
                Z:   zI, // 6. z  (z_1, ..., z_)
        }
        proofBytes, err := serde.MarshalCBOR(proof)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot serialise proof")
        }</span>

        // 8. Output 
        <span class="cov8" title="1">return proofBytes, nil</span>
}

func (p *prover[X, W, A, S, Z]) challengeBytesAndResponse(t uint64, statement X, witness W, commitment A, state S) (e []byte, response Z, err error) <span class="cov8" title="1">{
        e = make([]byte, 8)
        binary.BigEndian.PutUint64(e, t)
        eBytes := make([]byte, p.sigmaProtocol.GetChallengeBytesLength())
        copy(eBytes[len(eBytes)-len(e):], e)
        z, err := p.sigmaProtocol.ComputeProverResponse(statement, witness, commitment, state, eBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, z, errs2.Wrap(err).WithMessage("cannot compute z_i")
        }</span>

        <span class="cov8" title="1">eLen := int((p.t + 7) / 8)
        return eBytes[len(eBytes)-eLen:], z, nil</span>
}
</pre>
		
		<pre class="file" id="file278" style="display: none">package fischlin

import (
        "encoding/binary"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

func hash(b uint64, commonH []byte, i uint64, challenge sigma.ChallengeBytes, serializedResponse []byte) ([]byte, error) <span class="cov8" title="1">{
        // if b is divisible by 8, it will have one extra byte, but this is not a problem since it will always be zero
        bBytes := b/8 + 1
        bMask := byte((1 &lt;&lt; (b % 8)) - 1)
        h, err := hashing.Hash(randomOracle, commonH, binary.LittleEndian.AppendUint64(make([]byte, 8), i), challenge, serializedResponse)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash challenge")
        }</span>
        <span class="cov8" title="1">h[bBytes-1] &amp;= bMask
        return h[:bBytes], nil</span>
}

func isAllZeros(data []byte) bool <span class="cov8" title="1">{
        zeros := byte(0)
        for _, b := range data </span><span class="cov8" title="1">{
                zeros |= b
        }</span>
        <span class="cov8" title="1">return zeros == 0</span>
}
</pre>
		
		<pre class="file" id="file279" style="display: none">package fischlin

import (
        "encoding/binary"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

var _ compiler.NIVerifier[sigma.Statement] = (*verifier[
        sigma.Statement, sigma.Witness, sigma.Commitment, sigma.State, sigma.Response,
])(nil)

// verifier implements the NIVerifier interface for Fischlin proofs.
type verifier[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] struct {
        sessionID     network.SID
        transcript    transcripts.Transcript
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
}

// Verify checks that a Fischlin proof is valid for the given statement.
// It verifies that all rho challenge/response pairs hash to zero and that
// each sigma protocol transcript is valid.
func (v *verifier[X, W, A, S, Z]) Verify(statement X, proofBytes compiler.NIZKPoKProof) error <span class="cov8" title="1">{
        if proofBytes == nil </span><span class="cov8" title="1">{
                return ErrNil.WithMessage("proof")
        }</span>

        <span class="cov8" title="1">fischlinProof, err := serde.UnmarshalCBOR[*Proof[A, Z]](proofBytes)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("cannot deserialize proof")
        }</span>

        // 2. If m, e, and z do not each have  elements, then output 'reject'
        <span class="cov8" title="1">if uint64(len(fischlinProof.A)) != fischlinProof.Rho || uint64(len(fischlinProof.E)) != fischlinProof.Rho || uint64(len(fischlinProof.Z)) != fischlinProof.Rho </span><span class="cov0" title="0">{
                return ErrInvalid.WithMessage("invalid length")
        }</span>
        <span class="cov8" title="1">if fischlinProof.Rho &lt; 2 || fischlinProof.B &lt; 2 </span><span class="cov0" title="0">{
                return ErrInvalid.WithMessage("invalid length")
        }</span>

        <span class="cov8" title="1">b := fischlinProof.B - uint64(mathutils.CeilLog2(int(v.sigmaProtocol.SpecialSoundness())-1))
        if (fischlinProof.Rho * b) &lt; base.ComputationalSecurityBits </span><span class="cov0" title="0">{
                return ErrVerification.WithMessage("insufficient soundness")
        }</span>

        <span class="cov8" title="1">v.transcript.AppendBytes(rhoLabel, binary.LittleEndian.AppendUint64(nil, fischlinProof.Rho))
        v.transcript.AppendBytes(statementLabel, statement.Bytes())
        commonHKey, err := v.transcript.ExtractBytes(commonHLabel, 32)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot extract h")
        }</span>

        <span class="cov8" title="1">commitmentSerialized := make([][]byte, 0)
        for i := range fischlinProof.Rho </span><span class="cov8" title="1">{
                commitmentSerialized = append(commitmentSerialized, fischlinProof.A[i].Bytes())
        }</span>
        <span class="cov8" title="1">v.transcript.AppendBytes(commitmentLabel, commitmentSerialized...)
        v.transcript.AppendBytes(challengeLabel, fischlinProof.E...)

        a := make([]byte, 0)
        for i := range fischlinProof.Rho </span><span class="cov8" title="1">{
                a = append(a, fischlinProof.A[i].Bytes()...)
        }</span>

        // 3. common-h  H(x, m, sid)
        <span class="cov8" title="1">commonH, err := hashing.Hash(randomOracle, commonHKey, statement.Bytes(), a, v.sessionID[:])
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot serialise statement")
        }</span>

        // 4. For i  {1, ..., }
        <span class="cov8" title="1">for i := range fischlinProof.Rho </span><span class="cov8" title="1">{
                digest, err := hash(fischlinProof.B, commonH, i, fischlinProof.E[i], fischlinProof.Z[i].Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot compute digest")
                }</span>

                // 4.b. Halt and output 'reject' if Hb(common-h, i, e_i, z_i) != 0
                <span class="cov8" title="1">if !isAllZeros(digest) </span><span class="cov8" title="1">{
                        return ErrVerification.WithMessage("invalid challenge")
                }</span>

                // 4.a. Halt and output 'reject' if VerifyProof(x, m_i, e_i, z_i) == 0
                <span class="cov8" title="1">eBytes := make([]byte, v.sigmaProtocol.GetChallengeBytesLength())
                if (len(eBytes) - len(fischlinProof.E[i])) &lt; 0 </span><span class="cov0" title="0">{
                        return ErrVerification.WithMessage("invalid challenge")
                }</span>

                <span class="cov8" title="1">copy(eBytes[len(eBytes)-len(fischlinProof.E[i]):], fischlinProof.E[i])
                err = v.sigmaProtocol.Verify(statement, fischlinProof.A[i], eBytes, fischlinProof.Z[i])
                if err != nil </span><span class="cov8" title="1">{
                        return errs2.Wrap(err).WithMessage("verification failed")
                }</span>
        }

        <span class="cov8" title="1">responseSerialized := make([][]byte, 0)
        for i := range fischlinProof.Rho </span><span class="cov8" title="1">{
                responseSerialized = append(responseSerialized, fischlinProof.Z[i].Bytes())
        }</span>
        <span class="cov8" title="1">v.transcript.AppendBytes(responseLabel, responseSerialized...)

        // 5. Output 'accept'
        return nil</span>
}
</pre>
		
		<pre class="file" id="file280" style="display: none">// Package randfischlin implements a randomised variant of Fischlin's transform
// for compiling interactive sigma protocols into non-interactive zero-knowledge proofs.
//
// This variant uses fixed parameters (Lambda=128, L=8, R=16) rather than computing
// them from the protocol's special soundness. Challenges are sampled randomly and
// searched until a hash-to-zero condition is met.
//
// The randomised approach can be more efficient than standard Fischlin for certain
// protocols while maintaining 128-bit computational security.
package randfischlin

import (
        "crypto/sha3"
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        // Name is the identifier for the Randomised Fischlin compiler.
        Name compiler.Name = "RandomisedFischlin"

        transcriptLabel = "BRON_CRYPTO_NIZK_RANDOMISED_FISCHLIN-"
        crsLabel        = "crsLabel-"
        statementLabel  = "statementLabel-"
        commitmentLabel = "commitmentLabel-"
        challengeLabel  = "challengeLabel-"

        // Lambda is the computational security parameter in bits.
        Lambda = base.ComputationalSecurityBits
        // LambdaLog2 is the ceiling of log2(Lambda).
        LambdaLog2 = base.ComputationalSecurityLog2Ceil
        // L is the hash output length parameter.
        L = 8
        // R is the number of parallel repetitions.
        R = Lambda / L
        // T is the challenge sampling bound in bits.
        T = LambdaLog2 * L
        // LBytes is L converted to bytes.
        LBytes = L / 8
        // TBytes is T converted to bytes.
        TBytes = T / 8
)

var (
        randomOracle = sha3.New256
)

// Proof represents a randomised Fischlin non-interactive proof containing R
// parallel executions of the sigma protocol. Each execution includes a
// commitment (A), challenge (E), and response (Z).
type Proof[A sigma.Commitment, Z sigma.Response] struct {
        A []A      `cbor:"a"`
        E [][]byte `cbor:"e"`
        Z []Z      `cbor:"z"`
}

var _ compiler.NonInteractiveProtocol[sigma.Statement, sigma.Witness] = (*rf[
        sigma.Statement, sigma.Witness, sigma.Statement, sigma.State, sigma.Response,
])(nil)

type rf[X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response] struct {
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
        prng          io.Reader
}

// NewCompiler creates a new randomised Fischlin compiler for the given sigma protocol.
// The sigma protocol must have soundness error at least 2^(-128). The prng is used
// for randomness during proof generation.
func NewCompiler[X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response](sigmaProtocol sigma.Protocol[X, W, A, S, Z], prng io.Reader) (compiler.NonInteractiveProtocol[X, W], error) <span class="cov8" title="1">{
        if sigmaProtocol == nil || prng == nil </span><span class="cov8" title="1">{
                return nil, ErrNil.WithMessage("sigmaProtocol or prng")
        }</span>

        <span class="cov8" title="1">if s := sigmaProtocol.SoundnessError(); s &lt; base.ComputationalSecurityBits </span><span class="cov0" title="0">{
                return nil, ErrInvalid.WithMessage("sigmaProtocol soundness (%d) is too low (&lt;%d) for a non-interactive proof",
                        s, base.ComputationalSecurityBits)
        }</span>

        <span class="cov8" title="1">return &amp;rf[X, W, A, S, Z]{
                sigmaProtocol: sigmaProtocol,
                prng:          prng,
        }, nil</span>
}

// NewProver creates a new non-interactive prover for generating randomised Fischlin proofs.
// The sessionID and transcript are used for domain separation.
func (c *rf[X, W, A, S, Z]) NewProver(sessionID network.SID, transcript transcripts.Transcript) (compiler.NIProver[X, W], error) <span class="cov8" title="1">{
        if transcript == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("transcript")
        }</span>

        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%s-%s", transcriptLabel, c.sigmaProtocol.Name(), hex.EncodeToString(sessionID[:]))
        transcript.AppendDomainSeparator(dst)

        return &amp;prover[X, W, A, S, Z]{
                sessionID:     sessionID,
                transcript:    transcript,
                sigmaProtocol: c.sigmaProtocol,
                prng:          c.prng,
        }, nil</span>
}

// NewVerifier creates a new non-interactive verifier for checking randomised Fischlin proofs.
// The sessionID and transcript must match those used by the prover.
func (c *rf[X, W, A, S, Z]) NewVerifier(sessionID network.SID, transcript transcripts.Transcript) (compiler.NIVerifier[X], error) <span class="cov8" title="1">{
        if transcript == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("transcript")
        }</span>

        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%s-%s", transcriptLabel, c.sigmaProtocol.Name(), hex.EncodeToString(sessionID[:]))
        transcript.AppendDomainSeparator(dst)

        return &amp;verifier[X, W, A, S, Z]{
                sessionID:     sessionID,
                transcript:    transcript,
                sigmaProtocol: c.sigmaProtocol,
        }, nil</span>
}

// Name returns the compiler name ("RandomisedFischlin").
func (*rf[_, _, _, _, _]) Name() compiler.Name <span class="cov0" title="0">{
        return Name
}</span>

// SigmaProtocolName returns the name of the underlying sigma protocol.
func (c *rf[_, _, _, _, _]) SigmaProtocolName() sigma.Name <span class="cov0" title="0">{
        return c.sigmaProtocol.Name()
}</span>
</pre>
		
		<pre class="file" id="file281" style="display: none">package randfischlin

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

var _ compiler.NIProver[sigma.Statement, sigma.Witness] = (*prover[
        sigma.Statement, sigma.Witness, sigma.Commitment, sigma.State, sigma.Response,
])(nil)

// prover implements the NIProver interface for randomised Fischlin proofs.
type prover[X sigma.Statement, W sigma.Witness, A sigma.Statement, S sigma.State, Z sigma.Response] struct {
        sessionID     network.SID
        transcript    transcripts.Transcript
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
        prng          io.Reader
}

// Prove generates a non-interactive randomised Fischlin proof for the given statement
// and witness. It runs R parallel executions, randomly sampling challenges until
// finding ones that hash to zero. Returns the serialised proof containing all R transcripts.
func (p prover[X, W, A, S, Z]) Prove(statement X, witness W) (proofBytes compiler.NIZKPoKProof, err error) <span class="cov8" title="1">{
        p.transcript.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(p.sessionID[:])))
        crs, err := p.transcript.ExtractBytes(crsLabel, 32)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot extract crs")
        }</span>
        <span class="cov8" title="1">p.transcript.AppendBytes(statementLabel, statement.Bytes())

        a := make([]byte, 0)
        aI := make([]A, R)
        stateI := make([]S, R)

        // step 1. for each i in [r] compute SigmaP_a(x, w)
        for i := range R </span><span class="cov8" title="1">{
                var err error
                aI[i], stateI[i], err = p.sigmaProtocol.ComputeProverCommitment(statement, witness)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot generate commitment")
                }</span>

                // step 2. set a = (a_i) for i in [r]
                <span class="cov8" title="1">a = append(a, aI[i].Bytes()...)</span>
        }

        <span class="cov8" title="1">eI := make([][]byte, R)
        zI := make([]Z, R)

        // step 3. for each i [r]
        for i := range R </span><span class="cov8" title="1">{
                // step 3.a set e to empty
                eSet := make([][]byte, 0)
                for </span><span class="cov8" title="1">{
                        // gather some stats

                        // step 3.b sample e_i...
                        e, err := sample(eSet, p.sigmaProtocol.GetChallengeBytesLength(), p.prng)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot sample challenge bytes")
                        }</span>

                        // ...and compute z_i = SigmaP_z(state_i, e_i)
                        <span class="cov8" title="1">z, err := p.sigmaProtocol.ComputeProverResponse(statement, witness, aI[i], stateI[i], e)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot generate response")
                        }</span>
                        <span class="cov8" title="1">digest, err := hash(crs, a, binary.LittleEndian.AppendUint64(nil, uint64(i)), e, z.Bytes())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot compute digest")
                        }</span>

                        // step 3.c if hash(a, i, e_i, z_i) != 0 append e_i to e and repeat step 3.b
                        <span class="cov8" title="1">if isAllZeros(digest) </span><span class="cov8" title="1">{
                                eI[i] = e
                                zI[i] = z
                                break</span>
                        }
                        <span class="cov8" title="1">eSet = append(eSet, e)</span>
                }
        }

        <span class="cov8" title="1">commitmentSerialized := make([]byte, 0)
        for i := range R </span><span class="cov8" title="1">{
                commitmentSerialized = append(commitmentSerialized, aI[i].Bytes()...)
        }</span>
        <span class="cov8" title="1">p.transcript.AppendBytes(commitmentLabel, commitmentSerialized)
        p.transcript.AppendBytes(challengeLabel, eI...)

        // step 4. output (a_i, e_i, z_i) for every i in [r]
        proof := &amp;Proof[A, Z]{
                A: aI,
                E: eI,
                Z: zI,
        }
        proofBytes, err = serde.MarshalCBOR(proof)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot serialise proof")
        }</span>

        <span class="cov8" title="1">return proofBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file282" style="display: none">package randfischlin

import (
        "bytes"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

func isAllZeros(data []byte) bool <span class="cov8" title="1">{
        zeros := byte(0)
        for _, b := range data </span><span class="cov8" title="1">{
                zeros |= b
        }</span>
        <span class="cov8" title="1">return zeros == 0</span>
}

func hash(data ...[]byte) ([]byte, error) <span class="cov8" title="1">{
        result, err := hashing.HashPrefixedLength(randomOracle, data...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash values")
        }</span>

        <span class="cov8" title="1">return result[:LBytes], nil</span>
}

func sample(existing [][]byte, length int, prng io.Reader) ([]byte, error) <span class="cov8" title="1">{
outer:
        for </span><span class="cov8" title="1">{
                ei := make([]byte, length)
                _, err := io.ReadFull(prng, ei[:TBytes])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot read from PRNG")
                }</span>

                <span class="cov8" title="1">for _, e := range existing </span><span class="cov8" title="1">{
                        if bytes.Equal(e, ei) </span><span class="cov0" title="0">{
                                continue outer</span>
                        }
                }
                <span class="cov8" title="1">return ei, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file283" style="display: none">package randfischlin

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        compiler "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/internal"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

var _ compiler.NIVerifier[sigma.Statement] = (*verifier[
        sigma.Statement, sigma.Witness, sigma.Commitment, sigma.State, sigma.Response,
])(nil)

// verifier implements the NIVerifier interface for randomised Fischlin proofs.
type verifier[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] struct {
        sessionID     network.SID
        transcript    transcripts.Transcript
        sigmaProtocol sigma.Protocol[X, W, A, S, Z]
}

// Verify checks that a randomised Fischlin proof is valid for the given statement.
// It verifies that all R challenge/response pairs hash to zero and that each
// sigma protocol transcript is valid.
func (v verifier[X, W, A, S, Z]) Verify(statement X, proofBytes compiler.NIZKPoKProof) (err error) <span class="cov8" title="1">{
        if proofBytes == nil </span><span class="cov8" title="1">{
                return ErrNil.WithMessage("proof")
        }</span>

        <span class="cov8" title="1">rfProof, err := serde.UnmarshalCBOR[*Proof[A, Z]](proofBytes)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("input proof")
        }</span>

        <span class="cov8" title="1">if len(rfProof.A) != R || len(rfProof.E) != R || len(rfProof.Z) != R </span><span class="cov0" title="0">{
                return ErrInvalid.WithMessage("invalid length")
        }</span>

        <span class="cov8" title="1">v.transcript.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(v.sessionID[:])))
        crs, err := v.transcript.ExtractBytes(crsLabel, 32)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot extract crs")
        }</span>
        <span class="cov8" title="1">v.transcript.AppendBytes(statementLabel, statement.Bytes())

        commitmentSerialized := make([]byte, 0)
        for i := range R </span><span class="cov8" title="1">{
                commitmentSerialized = append(commitmentSerialized, rfProof.A[i].Bytes()...)
        }</span>
        <span class="cov8" title="1">v.transcript.AppendBytes(commitmentLabel, commitmentSerialized)
        v.transcript.AppendBytes(challengeLabel, rfProof.E...)

        // step 1. parse (a_i, e_i, z_i) for i in [r] and set a = (a_i) for every i in [r]
        a := make([]byte, 0)
        for i := range R </span><span class="cov8" title="1">{
                a = append(a, rfProof.A[i].Bytes()...)
        }</span>

        // step 2. for each i in [r] verify that hash(a, i, e_i, z_i) == 0 and SigmaV(x, (a_i, e_i, z_i)) is true, abort if not
        <span class="cov8" title="1">for i := range R </span><span class="cov8" title="1">{
                digest, err := hash(crs, a, binary.LittleEndian.AppendUint64(nil, uint64(i)), rfProof.E[i], rfProof.Z[i].Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot hash")
                }</span>
                <span class="cov8" title="1">if !isAllZeros(digest) </span><span class="cov8" title="1">{
                        return ErrVerification.WithMessage("invalid challenge")
                }</span>
                <span class="cov8" title="1">err = v.sigmaProtocol.Verify(statement, rfProof.A[i], rfProof.E[i], rfProof.Z[i])
                if err != nil </span><span class="cov8" title="1">{
                        return errs2.Wrap(err).WithMessage("verification failed")
                }</span>
        }

        // step 3. accept
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file284" style="display: none">// Package zk implements a zero-knowledge compiler that transforms honest-verifier
// zero-knowledge (HVZK) sigma protocols into fully zero-knowledge interactive
// protocols using commitment schemes.
//
// The compiler adds a preliminary round where the verifier commits to the challenge
// before seeing the prover's commitment. This prevents a malicious verifier from
// choosing challenges adaptively, ensuring zero-knowledge against any verifier.
//
// The resulting protocol has 5 rounds:
//  1. Verifier commits to challenge
//  2. Prover sends commitment (a)
//  3. Verifier opens challenge commitment
//  4. Prover sends response (z)
//  5. Verifier verifies the proof
package zk

import (
        "fmt"

        "github.com/bronlabs/bron-crypto/pkg/base"
        k256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/commitments"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel          = "zkCompiler"
        statementLabel           = "zkCompilerStatement"
        challengeCommitmentLabel = "zkCompilerChallengeCommitment"
        commitmentLabel          = "zkCompilerCommitment"
        challengeLabel           = "zkCompilerChallenge"
        responseLabel            = "zkCompilerResponse"
)

// CommitmentScheme is the type alias for the hash-based commitment scheme used
// to commit to verifier challenges.
type CommitmentScheme commitments.Scheme[hash_comm.Key, hash_comm.Witness, hash_comm.Message, hash_comm.Commitment, *hash_comm.Committer, *hash_comm.Verifier]

type participant[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] struct {
        sessionID network.SID
        tape      transcripts.Transcript

        protocol   sigma.Protocol[X, W, A, S, Z]
        statement  X
        commitment A
        response   Z
        comm       *hash_comm.Scheme

        round uint
}

func newParticipant[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response](sessionID network.SID, tape transcripts.Transcript, sigmaProtocol sigma.Protocol[X, W, A, S, Z], statement X) (*participant[X, W, A, S, Z], error) <span class="cov8" title="1">{
        if len(sessionID) == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalid.WithMessage("sessionID is empty")
        }</span>
        <span class="cov8" title="1">if sigmaProtocol == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("protocol")
        }</span>
        <span class="cov8" title="1">if s := sigmaProtocol.SoundnessError(); s &lt; base.StatisticalSecurityBits </span><span class="cov0" title="0">{
                return nil, ErrInvalid.WithMessage("soundness of the interactive protocol (%d) is too low (below %d)", s, base.StatisticalSecurityBits)
        }</span>
        <span class="cov8" title="1">if sigmaProtocol.GetChallengeBytesLength() &gt; k256Impl.FqBytes </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("challengeBytes is too long for the compiler")
        }</span>

        <span class="cov8" title="1">if tape == nil </span><span class="cov8" title="1">{
                return nil, ErrNil.WithMessage("tape")
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%s-%x", transcriptLabel, sigmaProtocol.Name(), sessionID)
        tape.AppendDomainSeparator(dst)

        tape.AppendBytes(statementLabel, statement.Bytes())

        ck, err := hash_comm.NewKeyFromCRSBytes(sessionID, dst)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("couldn't create hash commitment key")
        }</span>

        <span class="cov8" title="1">comm, err := hash_comm.NewScheme(ck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't create commitment scheme")
        }</span>

        <span class="cov8" title="1">return &amp;participant[X, W, A, S, Z]{
                sessionID:  sessionID,
                tape:       tape,
                protocol:   sigmaProtocol,
                statement:  statement,
                commitment: *new(A),
                response:   *new(Z),
                comm:       comm,
                round:      1,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file285" style="display: none">package zk

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// Prover is the prover in the zero-knowledge compiled protocol.
// It participates in rounds 2 and 4 of the 5-round protocol.
type Prover[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] struct {
        participant[X, W, A, S, Z]

        challengeCommitment hash_comm.Commitment
        witness             W
        state               S
}

// NewProver creates a new prover for the zero-knowledge compiled protocol.
// The sigma protocol must have soundness error at least 2^(-80) (statistical security).
// The prover will execute rounds 2 and 4 of the protocol.
func NewProver[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response](sessionID network.SID, tape transcripts.Transcript, sigmaProtocol sigma.Protocol[X, W, A, S, Z], statement X, witness W) (*Prover[X, W, A, S, Z], error) <span class="cov8" title="1">{
        if utils.IsNil(witness) </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("witness")
        }</span>
        <span class="cov8" title="1">p, err := newParticipant(sessionID, tape, sigmaProtocol, statement)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("cannot create participant")
        }</span>
        <span class="cov8" title="1">p.round = 2 // Prover starts at round 2 (receives verifier's challenge commitment first)
        return &amp;Prover[X, W, A, S, Z]{
                participant:         *p,
                challengeCommitment: hash_comm.Commitment{},
                witness:             witness,
                state:               *new(S),
        }, nil</span>
}

// Round2 processes the verifier's challenge commitment and returns the prover's
// sigma protocol commitment. This is the first prover round in the 5-round protocol.
func (p *Prover[X, W, A, S, Z]) Round2(eCommitment hash_comm.Commitment) (A, error) <span class="cov8" title="1">{
        var zero A
        if p.round != 2 </span><span class="cov0" title="0">{
                return zero, ErrRound.WithMessage("r != 2 (%d)", p.round)
        }</span>

        <span class="cov8" title="1">transcripts.Append(p.tape, challengeCommitmentLabel, eCommitment)

        p.challengeCommitment = eCommitment

        commitment, state, err := p.protocol.ComputeProverCommitment(p.statement, p.witness)
        if err != nil </span><span class="cov0" title="0">{
                return zero, errs2.Wrap(err).WithMessage("cannot create commitment")
        }</span>

        <span class="cov8" title="1">transcripts.Append(p.tape, commitmentLabel, commitment)
        p.commitment = commitment
        p.state = state
        p.round += 2
        return commitment, nil</span>
}

// Round4 verifies the verifier's challenge commitment opening and computes the
// prover's response. Returns the sigma protocol response (z).
func (p *Prover[X, W, A, S, Z]) Round4(challenge hash_comm.Message, witness hash_comm.Witness) (Z, error) <span class="cov8" title="1">{
        var zero Z
        p.tape.AppendBytes(challengeLabel, challenge)

        if p.round != 4 </span><span class="cov8" title="1">{
                return zero, ErrRound.WithMessage("r != 4 (%d)", p.round)
        }</span>
        <span class="cov8" title="1">if err := p.comm.Verifier().Verify(p.challengeCommitment, challenge, witness); err != nil </span><span class="cov0" title="0">{
                return zero, errs2.Wrap(err).WithMessage("invalid challenge")
        }</span>

        <span class="cov8" title="1">response, err := p.protocol.ComputeProverResponse(p.statement, p.witness, p.commitment, p.state, sigma.ChallengeBytes(challenge))
        if err != nil </span><span class="cov0" title="0">{
                return zero, errs2.Wrap(err).WithMessage("cannot generate response")
        }</span>
        <span class="cov8" title="1">transcripts.Append(p.tape, responseLabel, response)

        p.response = response
        p.round += 2
        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file286" style="display: none">package zk

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// Verifier is the verifier in the zero-knowledge compiled protocol.
// It participates in rounds 1, 3, and 5 (verification) of the 5-round protocol.
type Verifier[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] struct {
        participant[X, W, A, S, Z]

        challengeBytes []byte
        eWitness       hash_comm.Witness
        prng           io.Reader
}

// NewVerifier creates a new verifier for the zero-knowledge compiled protocol.
// The sigma protocol must have soundness error at least 2^(-80) (statistical security).
// The prng is used to sample the random challenge. The verifier will execute
// rounds 1, 3, and 5 of the protocol.
func NewVerifier[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response](sessionID network.SID, tape transcripts.Transcript, sigmaProtocol sigma.Protocol[X, W, A, S, Z], statement X, prng io.Reader) (*Verifier[X, W, A, S, Z], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("prng")
        }</span>
        <span class="cov8" title="1">p, err := newParticipant(sessionID, tape, sigmaProtocol, statement)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("cannot create participant")
        }</span>
        <span class="cov8" title="1">return &amp;Verifier[X, W, A, S, Z]{
                participant:    *p,
                challengeBytes: nil,
                eWitness:       hash_comm.Witness{},
                prng:           prng,
        }, nil</span>
}

// Round1 generates a random challenge, commits to it, and returns the commitment.
// This is the first round of the 5-round protocol.
func (v *Verifier[X, W, A, S, Z]) Round1() (hash_comm.Commitment, error) <span class="cov8" title="1">{
        if v.round != 1 </span><span class="cov0" title="0">{
                return hash_comm.Commitment{}, ErrRound.WithMessage("r != 1 (%d)", v.round)
        }</span>

        <span class="cov8" title="1">v.challengeBytes = make([]byte, v.protocol.GetChallengeBytesLength())
        _, err := io.ReadFull(v.prng, v.challengeBytes)
        if err != nil </span><span class="cov0" title="0">{
                return hash_comm.Commitment{}, errs2.Wrap(err).WithMessage("couldn't sample challenge")
        }</span>

        <span class="cov8" title="1">eCommitment, eWitness, err := v.comm.Committer().Commit(v.challengeBytes, v.prng)
        if err != nil </span><span class="cov0" title="0">{
                return hash_comm.Commitment{}, errs2.Wrap(err).WithMessage("couldn't commit to challenge")
        }</span>
        <span class="cov8" title="1">v.eWitness = eWitness

        transcripts.Append(v.tape, challengeCommitmentLabel, eCommitment)
        v.round += 2
        return eCommitment, nil</span>
}

// Round3 receives the prover's commitment and opens the challenge commitment.
// Returns the challenge message and witness for the prover to verify.
func (v *Verifier[X, W, A, S, Z]) Round3(commitment A) (hash_comm.Message, hash_comm.Witness, error) <span class="cov8" title="1">{
        if v.round != 3 </span><span class="cov8" title="1">{
                return hash_comm.Message(nil), hash_comm.Witness{}, ErrRound.WithMessage("r != 3 (%d)", v.round)
        }</span>
        <span class="cov8" title="1">transcripts.Append(v.tape, commitmentLabel, commitment)
        v.tape.AppendBytes(challengeLabel, v.challengeBytes)

        v.commitment = commitment
        v.round += 2

        return v.challengeBytes, v.eWitness, nil</span>
}

// Verify checks the prover's response against the sigma protocol.
// Returns nil if verification succeeds, or an error if it fails.
func (v *Verifier[X, W, A, S, Z]) Verify(response Z) error <span class="cov8" title="1">{
        if v.round != 5 </span><span class="cov8" title="1">{
                return ErrRound.WithMessage("r != 5 (%d)", v.round)
        }</span>

        <span class="cov8" title="1">transcripts.Append(v.tape, responseLabel, response)

        err := v.protocol.Verify(v.statement, v.commitment, v.challengeBytes, response)
        if err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file287" style="display: none">// Package sigand implements AND composition of sigma protocols.
//
// AND composition allows a prover to demonstrate knowledge of valid witnesses
// for ALL statements simultaneously. Unlike OR composition, the prover must
// know witnesses for every statement in the composition.
//
// The verifier sends a single challenge, and the same challenge is used for
// all sub-protocols. This ensures the prover cannot selectively respond to
// different challenges for different statements.
//
// The package provides two composition variants:
//   - Compose: n-way composition using the same protocol type for all statements
//   - CartesianCompose: binary composition allowing different protocol types
package sigand

import (
        "encoding/binary"
        "fmt"
        "slices"

        "golang.org/x/sync/errgroup"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// Statement represents an n-way AND-composed statement as a slice of individual statements.
// The prover claims to know valid witnesses for all statements in the slice.
type Statement[X sigma.Statement] []X

func (s Statement[X]) Bytes() []byte <span class="cov0" title="0">{
        return sliceutils.Fold(func(acc []byte, x X) []byte </span><span class="cov0" title="0">{ return slices.Concat(acc, x.Bytes()) }</span>,
                binary.BigEndian.AppendUint64(nil, uint64(len(s))),
                s...,
        )
}

var _ sigma.Statement = (Statement[sigma.Statement])(nil)

// Witness represents an n-way AND-composed witness as a slice of individual witnesses.
// Every witness must be valid for its corresponding statement in AND composition.
type Witness[W sigma.Witness] []W

func (w Witness[W]) Bytes() []byte <span class="cov0" title="0">{
        return sliceutils.Fold(func(acc []byte, x W) []byte </span><span class="cov0" title="0">{ return slices.Concat(acc, x.Bytes()) }</span>,
                binary.BigEndian.AppendUint64(nil, uint64(len(w))),
                w...,
        )
}

var _ sigma.Witness = (Witness[sigma.Witness])(nil)

// Commitment represents the prover's commitments for all branches in AND composition.
type Commitment[A sigma.Commitment] []A

func (c Commitment[A]) Bytes() []byte <span class="cov0" title="0">{
        return sliceutils.Fold(func(acc []byte, x A) []byte </span><span class="cov0" title="0">{ return slices.Concat(acc, x.Bytes()) }</span>,
                binary.BigEndian.AppendUint64(nil, uint64(len(c))),
                c...,
        )
}

var _ sigma.Commitment = (Commitment[sigma.Commitment])(nil)

// State holds the prover's internal states for all branches in AND composition.
// Each element corresponds to the prover state for the respective sub-protocol.
type State[S sigma.State] []S

var _ sigma.State = (State[sigma.State])(nil)

// Response contains the prover's responses for all branches in AND composition.
// Each element is computed using the same verifier challenge.
type Response[Z sigma.Response] []Z

func (r Response[Z]) Bytes() []byte <span class="cov0" title="0">{
        return sliceutils.Fold(func(acc []byte, x Z) []byte </span><span class="cov0" title="0">{ return slices.Concat(acc, x.Bytes()) }</span>,
                binary.BigEndian.AppendUint64(nil, uint64(len(r))),
                r...,
        )
}

var _ sigma.Response = (Response[sigma.Response])(nil)

// ComposeStatements creates an AND-composed statement from individual statements.
// All statements will be proven simultaneously using the same challenge.
func ComposeStatements[X sigma.Statement](statements ...X) Statement[X] <span class="cov0" title="0">{
        return statements
}</span>

// ComposeWitnesses creates an AND-composed witness from individual witnesses.
// Every witness must be valid for its corresponding statement.
func ComposeWitnesses[W sigma.Witness](witnesses ...W) Witness[W] <span class="cov0" title="0">{
        return witnesses
}</span>

type protocol[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] []sigma.Protocol[X, W, A, S, Z]

// Compose creates an n-way AND composition of a sigma protocol.
//
// The prover demonstrates knowledge of valid witnesses for all n statements
// simultaneously. The verifier sends a single challenge, which is used
// identically for all sub-protocol instances.
//
// Parameters:
//   - p: The sigma protocol to compose (used for all statements)
//   - count: The number of statements to compose (must be positive)
//
// Returns an error if p is nil or count is zero.
func Compose[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response](
        p sigma.Protocol[X, W, A, S, Z], count uint,
) (sigma.Protocol[Statement[X], Witness[W], Commitment[A], State[S], Response[Z]], error) <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithMessage("protocol is nil")
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("count must be positive")
        }</span>
        <span class="cov8" title="1">return sliceutils.Repeat[protocol[X, W, A, S, Z]](p, int(count)), nil</span>
}

// ComputeProverCommitment generates the prover's first message in the AND composition.
//
// This computes commitments for all branches in parallel using the underlying protocol.
func (p protocol[X, W, A, S, Z]) ComputeProverCommitment(statement Statement[X], witness Witness[W]) (Commitment[A], State[S], error) <span class="cov8" title="1">{
        if len(statement) != len(p) </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidLength.WithMessage("invalid number of statements")
        }</span>
        <span class="cov8" title="1">if len(witness) != len(p) </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidLength.WithMessage("invalid number of witnesses")
        }</span>
        <span class="cov8" title="1">a := make(Commitment[A], len(p))
        s := make(State[S], len(p))
        var eg errgroup.Group
        for i, sigmai := range p </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        a[i], s[i], err = sigmai.ComputeProverCommitment(statement[i], witness[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("failed to compute prover commitment")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute commitments")
        }</span>
        <span class="cov8" title="1">return a, s, nil</span>
}

// ComputeProverResponse generates the prover's response to the verifier's challenge.
//
// The same challenge is used for all branches, computed in parallel.
func (p protocol[X, W, A, S, Z]) ComputeProverResponse(statement Statement[X], witness Witness[W], commitment Commitment[A], state State[S], challengeBytes sigma.ChallengeBytes) (Response[Z], error) <span class="cov8" title="1">{
        if len(statement) != len(p) </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid number of statements")
        }</span>
        <span class="cov8" title="1">if len(witness) != len(p) </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid number of witnesses")
        }</span>
        <span class="cov8" title="1">if len(commitment) != len(p) </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid number of commitments")
        }</span>
        <span class="cov8" title="1">if len(state) != len(p) </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid number of states")
        }</span>
        <span class="cov8" title="1">z := make(Response[Z], len(p))
        var eg errgroup.Group
        for i, sigmai := range p </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        z[i], err = sigmai.ComputeProverResponse(statement[i], witness[i], commitment[i], state[i], challengeBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("failed to compute prover response")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute responses")
        }</span>
        <span class="cov8" title="1">return z, nil</span>
}

// Verify checks that the AND proof is valid.
//
// Each branch's transcript is verified using the same challenge in parallel.
func (p protocol[X, W, A, S, Z]) Verify(statement Statement[X], commitment Commitment[A], challengeBytes sigma.ChallengeBytes, response Response[Z]) error <span class="cov8" title="1">{
        if len(statement) != len(p) </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid number of statements")
        }</span>
        <span class="cov8" title="1">if len(commitment) != len(p) </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid number of commitments")
        }</span>
        <span class="cov8" title="1">if len(response) != len(p) </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid number of responses")
        }</span>
        <span class="cov8" title="1">var eg errgroup.Group
        for i, sigmai := range p </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        return sigmai.Verify(statement[i], commitment[i], challengeBytes, response[i])
                }</span>)
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RunSimulator produces a simulated transcript for the AND composition.
//
// This runs the simulator for each branch in parallel using the same challenge.
func (p protocol[X, W, A, S, Z]) RunSimulator(statement Statement[X], challengeBytes sigma.ChallengeBytes) (Commitment[A], Response[Z], error) <span class="cov8" title="1">{
        if len(statement) != len(p) </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidLength.WithMessage("invalid number of statements")
        }</span>
        <span class="cov8" title="1">a := make(Commitment[A], len(p))
        s := make(Response[Z], len(p))
        var eg errgroup.Group
        for i, sigmai := range p </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        a[i], s[i], err = sigmai.RunSimulator(statement[i], challengeBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("failed to run simulator")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run simulator")
        }</span>
        <span class="cov8" title="1">return a, s, nil</span>
}

// SpecialSoundness returns the special soundness parameter of the composed protocol.
func (p protocol[X, W, A, S, Z]) SpecialSoundness() uint <span class="cov0" title="0">{
        return p[0].SpecialSoundness()
}</span>

// GetChallengeBytesLength returns the challenge length in bytes for the composed protocol.
func (p protocol[X, W, A, S, Z]) GetChallengeBytesLength() int <span class="cov8" title="1">{
        return p[0].GetChallengeBytesLength()
}</span>

// SoundnessError returns the soundness error of the composed protocol.
func (p protocol[X, W, A, S, Z]) SoundnessError() uint <span class="cov0" title="0">{
        return p[0].SoundnessError()
}</span>

// ValidateStatement checks that all statement/witness pairs are valid.
// For AND composition, every pair must be valid.
func (p protocol[X, W, A, S, Z]) ValidateStatement(statement Statement[X], witness Witness[W]) error <span class="cov8" title="1">{
        if len(statement) != len(p) </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid number of statements")
        }</span>
        <span class="cov8" title="1">if len(witness) != len(p) </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid number of witnesses")
        }</span>
        <span class="cov8" title="1">for i := range p </span><span class="cov8" title="1">{
                if err := p[i].ValidateStatement(statement[i], witness[i]); err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("invalid statement/witness at index %d", i)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Name returns a human-readable name for the composed protocol.
func (p protocol[X, W, A, S, Z]) Name() sigma.Name <span class="cov0" title="0">{
        return sigma.Name(fmt.Sprintf("(%s)^%d", p[0].Name(), len(p)))
}</span>

// Sentinel errors for the sigand package.
var (
        // ErrIsNil indicates a nil argument was provided where a non-nil value was required.
        ErrIsNil = errs2.New("is nil")
        // ErrInvalidArgument indicates an invalid argument value was provided.
        ErrInvalidArgument = errs2.New("invalid argument")
        // ErrInvalidLength indicates a slice has incorrect length for the operation.
        ErrInvalidLength = errs2.New("invalid length")
)
</pre>
		
		<pre class="file" id="file288" style="display: none">package sigand

import (
        "fmt"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// StatementCartesian represents a binary AND-composed statement with two potentially
// different statement types. The prover claims to know witnesses for both statements.
type StatementCartesian[X0, X1 sigma.Statement] struct {
        // X0 is the first statement.
        X0 X0
        // X1 is the second statement.
        X1 X1
}

func (s *StatementCartesian[X0, X1]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(s.X0.Bytes(), s.X1.Bytes())
}</span>

var _ sigma.Statement = (*StatementCartesian[sigma.Statement, sigma.Statement])(nil)

// WitnessCartesian represents a binary AND-composed witness with two potentially
// different witness types. Both witnesses must be valid for their corresponding statements.
type WitnessCartesian[W0, W1 sigma.Witness] struct {
        // W0 is the witness for the first statement.
        W0 W0
        // W1 is the witness for the second statement.
        W1 W1
}

func (w *WitnessCartesian[W0, W1]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(w.W0.Bytes(), w.W1.Bytes())
}</span>

var _ sigma.Witness = (*WitnessCartesian[sigma.Witness, sigma.Witness])(nil)

// CommitmentCartesian represents a binary AND-composed commitment.
type CommitmentCartesian[A0, A1 sigma.Commitment] struct {
        // A0 is the commitment for the first branch.
        A0 A0
        // A1 is the commitment for the second branch.
        A1 A1
}

func (c *CommitmentCartesian[A0, A1]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(c.A0.Bytes(), c.A1.Bytes())
}</span>

var _ sigma.Commitment = (*CommitmentCartesian[sigma.Commitment, sigma.Commitment])(nil)

// StateCartesian holds the prover's internal state for binary AND composition.
type StateCartesian[S0, S1 sigma.State] struct {
        // S0 is the prover state for the first branch.
        S0 S0
        // S1 is the prover state for the second branch.
        S1 S1
}

var _ sigma.State = (*StateCartesian[sigma.State, sigma.State])(nil)

// ResponseCartesian represents the prover's response for binary AND composition.
type ResponseCartesian[Z0, Z1 sigma.Response] struct {
        // Z0 is the response for the first branch.
        Z0 Z0
        // Z1 is the response for the second branch.
        Z1 Z1
}

func (r *ResponseCartesian[Z0, Z1]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(r.Z0.Bytes(), r.Z1.Bytes())
}</span>

var _ sigma.Response = (*ResponseCartesian[sigma.Response, sigma.Response])(nil)

// CartesianComposeStatements creates a binary AND-composed statement from two statements.
func CartesianComposeStatements[X0, X1 sigma.Statement](statement0 X0, statement1 X1) *StatementCartesian[X0, X1] <span class="cov8" title="1">{
        return &amp;StatementCartesian[X0, X1]{
                X0: statement0,
                X1: statement1,
        }
}</span>

// CartesianComposeWitnesses creates a binary AND-composed witness from two witnesses.
// Both witnesses must be valid for their corresponding statements.
func CartesianComposeWitnesses[W0, W1 sigma.Witness](witness0 W0, witness1 W1) *WitnessCartesian[W0, W1] <span class="cov8" title="1">{
        return &amp;WitnessCartesian[W0, W1]{
                W0: witness0,
                W1: witness1,
        }
}</span>

type protocolCartesian[X0, X1 sigma.Statement, W0, W1 sigma.Witness, A0, A1 sigma.Commitment, S0, S1 sigma.State, Z0, Z1 sigma.Response] struct {
        sigma0               sigma.Protocol[X0, W0, A0, S0, Z0]
        sigma1               sigma.Protocol[X1, W1, A1, S1, Z1]
        challengeBytesLength int
}

// CartesianCompose creates a binary AND composition of two potentially different sigma protocols.
//
// This allows proving knowledge of witnesses for two statements simultaneously,
// even when the statements use different underlying protocols. The same challenge
// is used for both sub-protocols.
//
// Parameters:
//   - sigma0: The sigma protocol for the first statement
//   - sigma1: The sigma protocol for the second statement
func CartesianCompose[X0, X1 sigma.Statement, W0, W1 sigma.Witness, A0, A1 sigma.Commitment, S0, S1 sigma.State, Z0, Z1 sigma.Response](sigma0 sigma.Protocol[X0, W0, A0, S0, Z0], sigma1 sigma.Protocol[X1, W1, A1, S1, Z1]) sigma.Protocol[*StatementCartesian[X0, X1], *WitnessCartesian[W0, W1], *CommitmentCartesian[A0, A1], *StateCartesian[S0, S1], *ResponseCartesian[Z0, Z1]] <span class="cov8" title="1">{
        challengeBytesLength := max(sigma0.GetChallengeBytesLength(), sigma1.GetChallengeBytesLength())

        return &amp;protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]{
                sigma0:               sigma0,
                sigma1:               sigma1,
                challengeBytesLength: challengeBytesLength,
        }
}</span>

// ComputeProverCommitment generates the prover's first message in the binary AND composition.
//
// This computes commitments for both branches using their respective protocols.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) ComputeProverCommitment(statement *StatementCartesian[X0, X1], witness *WitnessCartesian[W0, W1]) (*CommitmentCartesian[A0, A1], *StateCartesian[S0, S1], error) <span class="cov8" title="1">{
        var err error
        a := new(CommitmentCartesian[A0, A1])
        s := new(StateCartesian[S0, S1])

        if a.A0, s.S0, err = p.sigma0.ComputeProverCommitment(statement.X0, witness.W0); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute commitment")
        }</span>
        <span class="cov8" title="1">if a.A1, s.S1, err = p.sigma1.ComputeProverCommitment(statement.X1, witness.W1); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute commitment")
        }</span>

        <span class="cov8" title="1">return a, s, nil</span>
}

// ComputeProverResponse generates the prover's response to the verifier's challenge.
//
// The same challenge is used for both branches.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) ComputeProverResponse(statement *StatementCartesian[X0, X1], witness *WitnessCartesian[W0, W1], commitment *CommitmentCartesian[A0, A1], state *StateCartesian[S0, S1], challengeBytes sigma.ChallengeBytes) (*ResponseCartesian[Z0, Z1], error) <span class="cov8" title="1">{
        var err error
        z := new(ResponseCartesian[Z0, Z1])

        if z.Z0, err = p.sigma0.ComputeProverResponse(statement.X0, witness.W0, commitment.A0, state.S0, challengeBytes[:p.sigma0.GetChallengeBytesLength()]); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute response")
        }</span>
        <span class="cov8" title="1">if z.Z1, err = p.sigma1.ComputeProverResponse(statement.X1, witness.W1, commitment.A1, state.S1, challengeBytes[:p.sigma1.GetChallengeBytesLength()]); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute response")
        }</span>

        <span class="cov8" title="1">return z, nil</span>
}

// Verify checks that the binary AND proof is valid.
//
// Both branch transcripts are verified using the same challenge.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) Verify(statement *StatementCartesian[X0, X1], commitment *CommitmentCartesian[A0, A1], challengeBytes sigma.ChallengeBytes, response *ResponseCartesian[Z0, Z1]) error <span class="cov8" title="1">{
        if err := p.sigma0.Verify(statement.X0, commitment.A0, challengeBytes[:p.sigma0.GetChallengeBytesLength()], response.Z0); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>
        <span class="cov8" title="1">if err := p.sigma1.Verify(statement.X1, commitment.A1, challengeBytes[:p.sigma1.GetChallengeBytesLength()], response.Z1); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RunSimulator produces a simulated transcript for the binary AND composition.
//
// This runs the simulator for both branches using the same challenge.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) RunSimulator(statement *StatementCartesian[X0, X1], challengeBytes sigma.ChallengeBytes) (*CommitmentCartesian[A0, A1], *ResponseCartesian[Z0, Z1], error) <span class="cov8" title="1">{
        var err error
        a := new(CommitmentCartesian[A0, A1])
        z := new(ResponseCartesian[Z0, Z1])

        if a.A0, z.Z0, err = p.sigma0.RunSimulator(statement.X0, challengeBytes[:p.sigma0.GetChallengeBytesLength()]); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run simulator")
        }</span>
        <span class="cov8" title="1">if a.A1, z.Z1, err = p.sigma1.RunSimulator(statement.X1, challengeBytes[:p.sigma1.GetChallengeBytesLength()]); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run simulator")
        }</span>

        <span class="cov8" title="1">return a, z, nil</span>
}

// SpecialSoundness returns the special soundness parameter of the composed protocol.
func (p *protocolCartesian[_, _, _, _, _, _, _, _, _, _]) SpecialSoundness() uint <span class="cov0" title="0">{
        return max(p.sigma0.SpecialSoundness(), p.sigma1.SpecialSoundness())
}</span>

// GetChallengeBytesLength returns the challenge length in bytes for the composed protocol.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) GetChallengeBytesLength() int <span class="cov8" title="1">{
        return p.challengeBytesLength
}</span>

// SoundnessError returns the soundness error of the composed protocol,
// which is the minimum of the two underlying protocols' soundness errors.
func (p protocolCartesian[_, _, _, _, _, _, _, _, _, _]) SoundnessError() uint <span class="cov0" title="0">{
        return min(p.sigma0.SoundnessError(), p.sigma1.SoundnessError())
}</span>

// ValidateStatement checks that both statement/witness pairs are valid.
// For AND composition, both pairs must be valid.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) ValidateStatement(statement *StatementCartesian[X0, X1], witness *WitnessCartesian[W0, W1]) error <span class="cov8" title="1">{
        if err := p.sigma0.ValidateStatement(statement.X0, witness.W0); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid statement")
        }</span>
        <span class="cov8" title="1">if err := p.sigma1.ValidateStatement(statement.X1, witness.W1); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("invalid statement")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Name returns a human-readable name for the composed protocol.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) Name() sigma.Name <span class="cov0" title="0">{
        return sigma.Name(fmt.Sprintf("(%s)_AND_(%s)", p.sigma0.Name(), p.sigma1.Name()))
}</span>
</pre>
		
		<pre class="file" id="file289" style="display: none">package sigor

import (
        "crypto/subtle"
        "fmt"
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// StatementCartesian represents a binary OR-composed statement with two potentially
// different statement types. The prover claims to know a witness for at least one.
type StatementCartesian[X0, X1 sigma.Statement] struct {
        // X0 is the first statement.
        X0 X0
        // X1 is the second statement.
        X1 X1
}

// Bytes returns the canonical byte representation of the composed statement.
func (s *StatementCartesian[X0, X1]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(s.X0.Bytes(), s.X1.Bytes())
}</span>

var _ sigma.Statement = (*StatementCartesian[sigma.Statement, sigma.Statement])(nil)

// WitnessCartesian represents a binary OR-composed witness with two potentially
// different witness types. Only one needs to be valid for its corresponding statement.
type WitnessCartesian[W0, W1 sigma.Witness] struct {
        // W0 is the witness for the first statement.
        W0 W0
        // W1 is the witness for the second statement.
        W1 W1
}

// Bytes returns the canonical byte representation of the composed witness.
func (w *WitnessCartesian[W0, W1]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(w.W0.Bytes(), w.W1.Bytes())
}</span>

var _ sigma.Witness = (*WitnessCartesian[sigma.Witness, sigma.Witness])(nil)

// CommitmentCartesian represents a binary OR-composed commitment.
type CommitmentCartesian[A0, A1 sigma.Commitment] struct {
        // A0 is the commitment for the first branch.
        A0 A0
        // A1 is the commitment for the second branch.
        A1 A1
}

// Bytes returns the canonical byte representation of the composed commitment.
func (c *CommitmentCartesian[A0, A1]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(c.A0.Bytes(), c.A1.Bytes())
}</span>

var _ sigma.Commitment = (*CommitmentCartesian[sigma.Commitment, sigma.Commitment])(nil)

// StateCartesian holds the prover's internal state for binary OR composition.
type StateCartesian[S0, S1 sigma.State, Z0, Z1 sigma.Response] struct {
        // B indicates which branch has the valid witness (0 or 1).
        B uint
        // S0 is the prover state for the first branch (meaningful only if B=0).
        S0 S0
        // S1 is the prover state for the second branch (meaningful only if B=1).
        S1 S1
        // E is the random challenge used for simulating the false branch.
        E []byte
        // Z0 is the simulated response for the first branch (meaningful only if B=1).
        Z0 Z0
        // Z1 is the simulated response for the second branch (meaningful only if B=0).
        Z1 Z1
}

var _ sigma.State = (*StateCartesian[sigma.State, sigma.State, sigma.Response, sigma.Response])(nil)

// ResponseCartesian represents the prover's response for binary OR composition.
type ResponseCartesian[Z0, Z1 sigma.Response] struct {
        // E0 is the challenge for the first branch.
        E0 []byte
        // E1 is the challenge for the second branch.
        // E0 XOR E1 equals the verifier's challenge.
        E1 []byte
        // Z0 is the response for the first branch.
        Z0 Z0
        // Z1 is the response for the second branch.
        Z1 Z1
}

// Bytes returns the canonical byte representation of the response.
func (r *ResponseCartesian[Z0, Z1]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(r.E0, r.E1, r.Z0.Bytes(), r.Z1.Bytes())
}</span>

var _ sigma.Response = (*ResponseCartesian[sigma.Response, sigma.Response])(nil)

// CartesianComposeStatements creates a binary OR-composed statement from two statements.
func CartesianComposeStatements[X0, X1 sigma.Statement](statement0 X0, statement1 X1) *StatementCartesian[X0, X1] <span class="cov8" title="1">{
        return &amp;StatementCartesian[X0, X1]{
                X0: statement0,
                X1: statement1,
        }
}</span>

// CartesianComposeWitnesses creates a binary OR-composed witness from two witnesses.
// Only one witness needs to be valid for its corresponding statement.
func CartesianComposeWitnesses[W0, W1 sigma.Witness](witness0 W0, witness1 W1) *WitnessCartesian[W0, W1] <span class="cov8" title="1">{
        return &amp;WitnessCartesian[W0, W1]{
                W0: witness0,
                W1: witness1,
        }
}</span>

type protocolCartesian[X0, X1 sigma.Statement, W0, W1 sigma.Witness, A0, A1 sigma.Commitment, S0, S1 sigma.State, Z0, Z1 sigma.Response] struct {
        sigma0               sigma.Protocol[X0, W0, A0, S0, Z0]
        sigma1               sigma.Protocol[X1, W1, A1, S1, Z1]
        challengeBytesLength int
        prng                 io.Reader
}

// CartesianCompose creates a binary OR composition of two potentially different sigma protocols.
//
// This allows proving knowledge of a witness for at least one of two statements,
// even when the statements use different underlying protocols. The XOR technique ensures
// the verifier cannot determine which statement the prover knows the witness for.
//
// Parameters:
//   - sigma0: The sigma protocol for the first statement
//   - sigma1: The sigma protocol for the second statement
//   - prng: Cryptographically secure random number generator
func CartesianCompose[X0, X1 sigma.Statement, W0, W1 sigma.Witness, A0, A1 sigma.Commitment, S0, S1 sigma.State, Z0, Z1 sigma.Response](sigma0 sigma.Protocol[X0, W0, A0, S0, Z0], sigma1 sigma.Protocol[X1, W1, A1, S1, Z1], prng io.Reader) sigma.Protocol[*StatementCartesian[X0, X1], *WitnessCartesian[W0, W1], *CommitmentCartesian[A0, A1], *StateCartesian[S0, S1, Z0, Z1], *ResponseCartesian[Z0, Z1]] <span class="cov8" title="1">{
        challengeBytesLength := max(sigma0.GetChallengeBytesLength(), sigma1.GetChallengeBytesLength())

        return &amp;protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]{
                sigma0:               sigma0,
                sigma1:               sigma1,
                challengeBytesLength: challengeBytesLength,
                prng:                 prng,
        }
}</span>

// SoundnessError returns the soundness error of the composed protocol,
// which is the minimum of the two underlying protocols' soundness errors.
func (p protocolCartesian[_, _, _, _, _, _, _, _, _, _]) SoundnessError() uint <span class="cov0" title="0">{
        return min(p.sigma0.SoundnessError(), p.sigma1.SoundnessError())
}</span>

// ComputeProverCommitment generates the prover's first message in the binary OR composition.
//
// For the branch with a valid witness, this computes a real commitment.
// For the other branch, it samples a random challenge and runs the simulator.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) ComputeProverCommitment(statement *StatementCartesian[X0, X1], witness *WitnessCartesian[W0, W1]) (*CommitmentCartesian[A0, A1], *StateCartesian[S0, S1, Z0, Z1], error) <span class="cov8" title="1">{
        var err error

        if statement == nil || witness == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrIsNil.WithMessage("statement/commitment is nil")
        }</span>

        <span class="cov8" title="1">a := new(CommitmentCartesian[A0, A1])
        s := new(StateCartesian[S0, S1, Z0, Z1])
        s.E = make([]byte, p.challengeBytesLength)
        _, err = io.ReadFull(p.prng, s.E)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot generate challenge")
        }</span>

        <span class="cov8" title="1">if invalid := p.sigma0.ValidateStatement(statement.X0, witness.W0); invalid == nil </span><span class="cov8" title="1">{
                s.B = 0

                a.A0, s.S0, err = p.sigma0.ComputeProverCommitment(statement.X0, witness.W0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot compute commitment")
                }</span>

                <span class="cov8" title="1">a.A1, s.Z1, err = p.sigma1.RunSimulator(statement.X1, s.E[:p.sigma1.GetChallengeBytesLength()])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run simulator")
                }</span>
        } else<span class="cov8" title="1"> {
                s.B = 1

                a.A1, s.S1, err = p.sigma1.ComputeProverCommitment(statement.X1, witness.W1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot compute commitment")
                }</span>

                <span class="cov8" title="1">a.A0, s.Z0, err = p.sigma0.RunSimulator(statement.X0, s.E[:p.sigma0.GetChallengeBytesLength()])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run simulator")
                }</span>
        }

        <span class="cov8" title="1">return a, s, nil</span>
}

// ComputeProverResponse generates the prover's response to the verifier's challenge.
//
// The challenge for the true branch is computed so that E0 XOR E1 equals the
// verifier's challenge. The response for the true branch is computed using the real protocol.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) ComputeProverResponse(statement *StatementCartesian[X0, X1], witness *WitnessCartesian[W0, W1], commitment *CommitmentCartesian[A0, A1], state *StateCartesian[S0, S1, Z0, Z1], challengeBytes sigma.ChallengeBytes) (*ResponseCartesian[Z0, Z1], error) <span class="cov8" title="1">{
        if statement == nil || witness == nil || commitment == nil || state == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("statement/witness/commitment/statement is nil")
        }</span>
        <span class="cov8" title="1">if len(challengeBytes) != p.challengeBytesLength </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid challenge bytes length")
        }</span>

        <span class="cov8" title="1">var err error
        z := new(ResponseCartesian[Z0, Z1])
        switch state.B </span>{
        case 0:<span class="cov8" title="1">
                z.E0 = make([]byte, p.challengeBytesLength)
                subtle.XORBytes(z.E0, state.E, challengeBytes)
                z.Z0, err = p.sigma0.ComputeProverResponse(statement.X0, witness.W0, commitment.A0, state.S0, z.E0[:p.sigma0.GetChallengeBytesLength()])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot compute response")
                }</span>

                <span class="cov8" title="1">z.E1 = state.E
                z.Z1 = state.Z1</span>

        case 1:<span class="cov8" title="1">
                z.E1 = make([]byte, p.challengeBytesLength)
                subtle.XORBytes(z.E1, state.E, challengeBytes)
                z.Z1, err = p.sigma1.ComputeProverResponse(statement.X1, witness.W1, commitment.A1, state.S1, z.E1[:p.sigma1.GetChallengeBytesLength()])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot compute response")
                }</span>

                <span class="cov8" title="1">z.E0 = state.E
                z.Z0 = state.Z0</span>

        default:<span class="cov0" title="0">
                return nil, ErrInvalidArgument.WithMessage("invalid state")</span>
        }

        <span class="cov8" title="1">return z, nil</span>
}

// Verify checks that the binary OR proof is valid.
//
// Verification ensures: (1) E0 XOR E1 equals the verifier's challenge,
// and (2) both branch transcripts are accepting under their respective protocols.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) Verify(statement *StatementCartesian[X0, X1], commitment *CommitmentCartesian[A0, A1], challengeBytes sigma.ChallengeBytes, response *ResponseCartesian[Z0, Z1]) error <span class="cov8" title="1">{
        if statement == nil || commitment == nil || response == nil </span><span class="cov0" title="0">{
                return ErrIsNil.WithMessage("statement/commitment/response is nil")
        }</span>
        <span class="cov8" title="1">if len(challengeBytes) != p.challengeBytesLength </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid challenge bytes length")
        }</span>

        <span class="cov8" title="1">e0XorE1 := make([]byte, p.challengeBytesLength)
        subtle.XORBytes(e0XorE1, response.E0, response.E1)
        if ct.SliceEqual(challengeBytes, e0XorE1) == ct.False </span><span class="cov0" title="0">{
                return ErrVerification.WithMessage("verification failed")
        }</span>

        // check that conversation (a_0, e_0, z_0) are accepting in Protocol on input x_0
        <span class="cov8" title="1">if err := p.sigma0.Verify(statement.X0, commitment.A0, response.E0[:p.sigma0.GetChallengeBytesLength()], response.Z0); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>

        // check that conversation (a_1, e_1, z_1) are accepting in Protocol on input x_1
        <span class="cov8" title="1">if err := p.sigma1.Verify(statement.X1, commitment.A1, response.E1[:p.sigma1.GetChallengeBytesLength()], response.Z1); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RunSimulator produces a simulated transcript for the binary OR composition.
//
// This generates a random challenge E0, computes E1 so that E0 XOR E1 equals the
// given challenge, and runs the simulator for both branches.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) RunSimulator(statement *StatementCartesian[X0, X1], challengeBytes sigma.ChallengeBytes) (*CommitmentCartesian[A0, A1], *ResponseCartesian[Z0, Z1], error) <span class="cov8" title="1">{
        if statement == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrIsNil.WithMessage("statement")
        }</span>
        <span class="cov8" title="1">if len(challengeBytes) != p.challengeBytesLength </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidLength.WithMessage("challengeBytes")
        }</span>

        <span class="cov8" title="1">a := new(CommitmentCartesian[A0, A1])
        z := new(ResponseCartesian[Z0, Z1])

        z.E0 = make([]byte, p.challengeBytesLength)
        _, err := io.ReadFull(p.prng, z.E0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("prng failed")
        }</span>
        <span class="cov8" title="1">z.E1 = make([]byte, p.challengeBytesLength)
        subtle.XORBytes(z.E1, challengeBytes, z.E0)

        a.A0, z.Z0, err = p.sigma0.RunSimulator(statement.X0, z.E0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run simulator")
        }</span>
        <span class="cov8" title="1">a.A1, z.Z1, err = p.sigma1.RunSimulator(statement.X1, z.E1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run simulator")
        }</span>

        <span class="cov8" title="1">return a, z, nil</span>
}

// SpecialSoundness returns the special soundness parameter of the composed protocol.
func (p *protocolCartesian[_, _, _, _, _, _, _, _, _, _]) SpecialSoundness() uint <span class="cov0" title="0">{
        return max(p.sigma0.SpecialSoundness(), p.sigma1.SpecialSoundness())
}</span>

// GetChallengeBytesLength returns the challenge length in bytes for the composed protocol.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) GetChallengeBytesLength() int <span class="cov8" title="1">{
        return p.challengeBytesLength
}</span>

// ValidateStatement checks that at least one statement/witness pair is valid.
// For OR composition, only one valid pair is required.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) ValidateStatement(statement *StatementCartesian[X0, X1], witness *WitnessCartesian[W0, W1]) error <span class="cov0" title="0">{
        err0 := p.sigma0.ValidateStatement(statement.X0, witness.W0)
        err1 := p.sigma1.ValidateStatement(statement.X1, witness.W1)

        if err0 != nil &amp;&amp; err1 != nil </span><span class="cov0" title="0">{
                return ErrNotAtLeastOneOutOfN.WithStackFrame()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Name returns a human-readable name for the composed protocol.
func (p *protocolCartesian[X0, X1, W0, W1, A0, A1, S0, S1, Z0, Z1]) Name() sigma.Name <span class="cov0" title="0">{
        return sigma.Name(fmt.Sprintf("(%s)_OR_(%s)", p.sigma0.Name(), p.sigma1.Name()))
}</span>
</pre>
		
		<pre class="file" id="file290" style="display: none">// Package sigor implements OR composition of sigma protocols.
//
// OR composition allows a prover to demonstrate knowledge of a witness for at least one
// of n statements, without revealing which statement they know the witness for.
// This provides witness indistinguishability - the verifier cannot determine which
// branch the prover actually knows.
//
// The composition uses the XOR technique: challenges for all branches XOR together
// to equal the verifier's challenge. The prover runs the real protocol for the branch
// they know, and simulates the other branches using the simulator.
package sigor

import (
        "crypto/subtle"
        "encoding/binary"
        "fmt"
        "io"
        "slices"

        "golang.org/x/sync/errgroup"

        "github.com/bronlabs/bron-crypto/pkg/base/ct"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma"
)

// Statement represents an OR-composed statement consisting of n sub-statements.
// The prover claims to know a witness for at least one of these statements.
type Statement[X sigma.Statement] []X

// Bytes returns the canonical byte representation of the composed statement.
func (s Statement[X]) Bytes() []byte <span class="cov0" title="0">{
        return sliceutils.Fold(func(acc []byte, x X) []byte </span><span class="cov0" title="0">{ return slices.Concat(acc, x.Bytes()) }</span>,
                binary.BigEndian.AppendUint64(nil, uint64(len(s))),
                s...,
        )
}

var _ sigma.Statement = (Statement[sigma.Statement])(nil)

// Witness represents an OR-composed witness.
type Witness[W sigma.Witness] struct {
        v W
}

// Bytes returns the canonical byte representation of the composed witness.
func (w Witness[W]) Bytes() []byte <span class="cov0" title="0">{
        return w.v.Bytes()
}</span>

func NewWitness[W sigma.Witness](witness W) Witness[W] <span class="cov8" title="1">{
        return Witness[W]{witness}
}</span>

var _ sigma.Witness = (*Witness[sigma.Witness])(nil)

// Commitment represents an OR-composed commitment consisting of n sub-commitments,
// one for each branch of the OR composition.
type Commitment[A sigma.Commitment] []A

// Bytes returns the canonical byte representation of the composed commitment.
func (c Commitment[A]) Bytes() []byte <span class="cov0" title="0">{
        return sliceutils.Fold(func(acc []byte, x A) []byte </span><span class="cov0" title="0">{ return slices.Concat(acc, x.Bytes()) }</span>,
                binary.BigEndian.AppendUint64(nil, uint64(len(c))),
                c...,
        )
}

var _ sigma.Commitment = (Commitment[sigma.Commitment])(nil)

// State holds the prover's internal state between commitment and response phases.
// It stores information needed to compute the final response, including which branch
// is the "true" branch and the simulated responses for false branches.
type State[S sigma.State, Z sigma.Response] struct {
        // B is the index of the branch for which the prover knows a valid witness.
        B uint
        // S contains the prover states for each branch. Only S[B] is meaningful;
        // other entries are zero values since those branches are simulated.
        S []S
        // E contains the random challenges used for simulating false branches.
        // E[i] is the challenge used for branch i when i != B. E[B] is unused.
        E [][]byte
        // Z contains the simulated responses for false branches.
        // Z[i] is the simulated response for branch i when i != B. Z[B] is unused.
        Z []Z
}

var _ sigma.State = (*State[sigma.State, sigma.Response])(nil)

// Response represents the prover's response in the OR composition.
// It contains challenges and responses for all branches, satisfying the XOR constraint.
type Response[Z sigma.Response] struct {
        // E contains the challenges for each branch. These satisfy the constraint:
        // E[0] XOR E[1] XOR ... XOR E[n-1] = verifier's challenge.
        E [][]byte
        // Z contains the responses for each branch. For the true branch, this is
        // computed honestly; for false branches, these are simulated responses.
        Z []Z
}

// Bytes returns the canonical byte representation of the response.
func (r Response[Z]) Bytes() []byte <span class="cov0" title="0">{
        return sliceutils.Fold(func(acc []byte, x Z) []byte </span><span class="cov0" title="0">{ return slices.Concat(acc, x.Bytes()) }</span>,
                binary.BigEndian.AppendUint64(nil, uint64(len(r.Z))),
                r.Z...,
        )
}

var _ sigma.Response = (*Response[sigma.Response])(nil)

// ComposeStatements creates an OR-composed statement from individual statements.
func ComposeStatements[X sigma.Statement](statements ...X) Statement[X] <span class="cov0" title="0">{
        return statements
}</span>

type protocol[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response] struct {
        sigma sigma.Protocol[X, W, A, S, Z]
        count int
        prng  io.Reader
}

// Compose creates an n-way OR composition of sigma protocols.
//
// The resulting protocol proves knowledge of a witness for at least one of n statements,
// without revealing which one. This is achieved using the XOR technique where challenges
// for all branches XOR to equal the verifier's challenge.
//
// Parameters:
//   - p: The base sigma protocol to compose (used for all n branches)
//   - count: Number of branches (must be &gt;= 2)
//   - prng: Cryptographically secure random number generator
//
// Returns an error if p is nil, prng is nil, or count &lt; 2.
func Compose[X sigma.Statement, W sigma.Witness, A sigma.Commitment, S sigma.State, Z sigma.Response](
        p sigma.Protocol[X, W, A, S, Z], count uint, prng io.Reader,
) (sigma.Protocol[Statement[X], Witness[W], Commitment[A], *State[S, Z], *Response[Z]], error) <span class="cov8" title="1">{
        if p == nil || prng == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithMessage("p or prng is nil")
        }</span>
        <span class="cov8" title="1">if count &lt; 2 </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("count must be positive and greater than 2")
        }</span>
        <span class="cov8" title="1">return &amp;protocol[X, W, A, S, Z]{
                sigma: p,
                count: int(count),
                prng:  prng,
        }, nil</span>
}

// SoundnessError returns the soundness error of the composed protocol,
// which equals the soundness error of the underlying protocol.
func (p *protocol[X, W, A, S, Z]) SoundnessError() uint <span class="cov0" title="0">{
        return p.sigma.SoundnessError()
}</span>

// ComputeProverCommitment generates the prover's first message in the OR composition.
//
// For the branch with a valid witness (the "true" branch), this computes a real
// commitment using the underlying protocol. For all other branches, it samples
// random challenges and runs the simulator to generate fake commitments and responses.
func (p *protocol[X, W, A, S, Z]) ComputeProverCommitment(statement Statement[X], witness Witness[W]) (Commitment[A], *State[S, Z], error) <span class="cov8" title="1">{
        if len(statement) != p.count </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidLength.WithMessage("invalid statement length")
        }</span>
        <span class="cov8" title="1">a := make(Commitment[A], p.count)
        s := &amp;State[S, Z]{
                B: 0,
                S: make([]S, p.count),
                E: make([][]byte, p.count),
                Z: make([]Z, p.count),
        }

        var err error
        s.B, err = p.getB(statement, witness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot determine valid statement index")
        }</span>

        // Sample random challenges for all false branches
        <span class="cov8" title="1">var eg errgroup.Group
        for i := range p.count </span><span class="cov8" title="1">{
                if i == int(s.B) </span><span class="cov8" title="1">{
                        // True branch: compute real commitment
                        eg.Go(func() error </span><span class="cov8" title="1">{
                                var err error
                                a[i], s.S[i], err = p.sigma.ComputeProverCommitment(statement[i], witness.v)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errs2.Wrap(err)
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        })
                } else<span class="cov8" title="1"> {
                        // False branch: sample random challenge and run simulator
                        eg.Go(func() error </span><span class="cov8" title="1">{
                                s.E[i] = make([]byte, p.GetChallengeBytesLength())
                                _, err := io.ReadFull(p.prng, s.E[i])
                                if err != nil </span><span class="cov0" title="0">{
                                        return errs2.Wrap(err)
                                }</span>
                                <span class="cov8" title="1">var simErr error
                                a[i], s.Z[i], simErr = p.sigma.RunSimulator(statement[i], s.E[i])
                                if simErr != nil </span><span class="cov0" title="0">{
                                        return errs2.Wrap(simErr)
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        })
                }
        }

        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return a, s, nil</span>
}

// ComputeProverResponse generates the prover's response to the verifier's challenge.
//
// The challenge for the true branch is computed so that all challenges XOR to the
// verifier's challenge: e_B = challenge XOR e_0 XOR ... XOR e_{n-1} (excluding e_B).
// The response for the true branch is then computed using the real protocol.
func (p *protocol[X, W, A, S, Z]) ComputeProverResponse(statement Statement[X], witness Witness[W], commitment Commitment[A], state *State[S, Z], challenge sigma.ChallengeBytes) (*Response[Z], error) <span class="cov8" title="1">{
        if len(statement) != p.count </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid statement length")
        }</span>
        <span class="cov8" title="1">if len(commitment) != p.count </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid commitment length")
        }</span>
        <span class="cov8" title="1">if len(state.S) != p.count || len(state.Z) != p.count || len(state.E) != p.count </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid state length")
        }</span>
        <span class="cov8" title="1">if len(challenge) != p.GetChallengeBytesLength() </span><span class="cov0" title="0">{
                return nil, ErrInvalidLength.WithMessage("invalid challenge length")
        }</span>

        <span class="cov8" title="1">z := &amp;Response[Z]{
                E: make([][]byte, p.count),
                Z: make([]Z, p.count),
        }

        // Compute the challenge for the true branch so that XOR of all challenges equals verifier's challenge:
        // e_B = challenge XOR e_0 XOR e_1 XOR ... XOR e_{n-1} (excluding e_B)
        z.E[state.B] = make([]byte, p.GetChallengeBytesLength())
        copy(z.E[state.B], challenge)
        for i := range p.count </span><span class="cov8" title="1">{
                if i != int(state.B) </span><span class="cov8" title="1">{
                        z.E[i] = state.E[i]
                        z.Z[i] = state.Z[i]
                        subtle.XORBytes(z.E[state.B], z.E[state.B], state.E[i])
                }</span>
        }

        // Compute response for the true branch
        <span class="cov8" title="1">var err error
        z.Z[state.B], err = p.sigma.ComputeProverResponse(
                statement[state.B], witness.v, commitment[state.B], state.S[state.B],
                z.E[state.B],
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">return z, nil</span>
}

// Verify checks that the OR proof is valid.
//
// Verification ensures: (1) the XOR of all branch challenges equals the verifier's
// challenge, and (2) each branch's transcript is accepting under the underlying protocol.
func (p *protocol[X, W, A, S, Z]) Verify(statement Statement[X], commitment Commitment[A], challenge sigma.ChallengeBytes, response *Response[Z]) error <span class="cov8" title="1">{
        if len(statement) != p.count </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid statement length")
        }</span>
        <span class="cov8" title="1">if len(commitment) != p.count </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid commitment length")
        }</span>
        <span class="cov8" title="1">if len(response.Z) != p.count </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid response length")
        }</span>
        <span class="cov8" title="1">if len(challenge) != p.GetChallengeBytesLength() </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid challenge length")
        }</span>
        <span class="cov8" title="1">xoredChallenges := make([]byte, p.GetChallengeBytesLength())
        subtle.XORBytes(xoredChallenges, response.E[0], response.E[1])
        sliceutils.Reduce(
                response.E[2:],
                xoredChallenges,
                func(acc []byte, e []byte) []byte </span><span class="cov8" title="1">{
                        subtle.XORBytes(acc, acc, e)
                        return acc
                }</span>,
        )
        <span class="cov8" title="1">if ct.SliceEqual(challenge, xoredChallenges) == ct.False </span><span class="cov0" title="0">{
                return ErrVerification.WithMessage("verification failed")
        }</span>

        <span class="cov8" title="1">var eg errgroup.Group
        for i := range p.count </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        return p.sigma.Verify(statement[i], commitment[i], response.E[i], response.Z[i])
                }</span>)
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RunSimulator produces a simulated transcript for the OR composition.
//
// This generates random challenges for all but the last branch, then computes
// the last challenge so that all challenges XOR to the given challenge.
// Each branch's transcript is then simulated using the underlying protocol's simulator.
func (p *protocol[X, W, A, S, Z]) RunSimulator(statement Statement[X], challenge sigma.ChallengeBytes) (Commitment[A], *Response[Z], error) <span class="cov8" title="1">{
        if len(statement) != p.count </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidLength.WithMessage("invalid statement length")
        }</span>
        <span class="cov8" title="1">if len(challenge) != p.GetChallengeBytesLength() </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidLength.WithMessage("invalid challenge length")
        }</span>

        <span class="cov8" title="1">a := make(Commitment[A], p.count)
        z := &amp;Response[Z]{
                E: make([][]byte, p.count),
                Z: make([]Z, p.count),
        }

        var eg errgroup.Group
        for i := range p.count - 1 </span><span class="cov8" title="1">{
                eg.Go(func() error </span><span class="cov8" title="1">{
                        z.E[i] = make([]byte, p.GetChallengeBytesLength())
                        if _, err := io.ReadFull(p.prng, z.E[i]); err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot sample challenge")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        }
        <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample challenges")
        }</span>
        // Compute last challenge so that XOR of all challenges equals the verifier's challenge:
        // e_{n-1} = challenge XOR e_0 XOR e_1 XOR ... XOR e_{n-2}
        <span class="cov8" title="1">z.E[p.count-1] = make([]byte, p.GetChallengeBytesLength())
        subtle.XORBytes(z.E[p.count-1], challenge, z.E[0])
        for i := 1; i &lt; p.count-1; i++ </span><span class="cov8" title="1">{
                subtle.XORBytes(z.E[p.count-1], z.E[p.count-1], z.E[i])
        }</span>

        <span class="cov8" title="1">var eg2 errgroup.Group
        for i := range p.count </span><span class="cov8" title="1">{
                eg2.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        a[i], z.Z[i], err = p.sigma.RunSimulator(statement[i], z.E[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot run simulator")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        }
        <span class="cov8" title="1">if err := eg2.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute responses")
        }</span>
        <span class="cov8" title="1">return a, z, nil</span>
}

// SpecialSoundness returns the special soundness parameter of the composed protocol.
func (p *protocol[X, W, A, S, Z]) SpecialSoundness() uint <span class="cov0" title="0">{
        return p.sigma.SpecialSoundness()
}</span>

// GetChallengeBytesLength returns the challenge length in bytes for the composed protocol.
func (p *protocol[X, W, A, S, Z]) GetChallengeBytesLength() int <span class="cov8" title="1">{
        return p.sigma.GetChallengeBytesLength()
}</span>

// ValidateStatement checks that at least one statement/witness pair is valid.
// For OR composition, only one valid pair is required (unlike AND composition).
func (p *protocol[X, W, A, S, Z]) ValidateStatement(statement Statement[X], witness Witness[W]) error <span class="cov8" title="1">{
        if len(statement) != p.count </span><span class="cov0" title="0">{
                return ErrInvalidLength.WithMessage("invalid statement length")
        }</span>
        // For OR composition, at least one statement/witness pair must be valid
        <span class="cov8" title="1">for i := range p.count </span><span class="cov8" title="1">{
                if invalid := p.sigma.ValidateStatement(statement[i], witness.v); invalid == nil </span><span class="cov8" title="1">{
                        return nil // Found a valid pair
                }</span>
        }
        <span class="cov0" title="0">return ErrNotAtLeastOneOutOfN.WithMessage("no valid statement/witness pair found")</span>
}

// getB finds the index of the branch with a valid statement/witness pair.
// Returns an error if no valid pair is found.
func (p *protocol[X, W, A, S, Z]) getB(statement Statement[X], witness Witness[W]) (uint, error) <span class="cov8" title="1">{
        B := uint(p.count) // invalid value
        for i := range p.count </span><span class="cov8" title="1">{
                if invalid := p.sigma.ValidateStatement(statement[i], witness.v); invalid == nil </span><span class="cov8" title="1">{
                        B = uint(i)
                }</span>
        }
        <span class="cov8" title="1">return B, nil</span>
}

// Name returns a human-readable name for the composed protocol.
func (p *protocol[X, W, A, S, Z]) Name() sigma.Name <span class="cov0" title="0">{
        return sigma.Name(fmt.Sprintf("SigmaOR(%s)^%d", p.sigma.Name(), p.count))
}</span>

// Sentinel errors for the sigor package.
var (
        // ErrIsNil is returned when a required argument is nil.
        ErrIsNil = errs2.New("is nil")
        // ErrNotAtLeastOneOutOfN is returned when no valid statement/witness pair is found.
        ErrNotAtLeastOneOutOfN = errs2.New("not at least one statement out of n is valid")
        // ErrInvalidLength is returned when input slices have incorrect lengths.
        ErrInvalidLength = errs2.New("invalid length")
        // ErrInvalidArgument is returned when an argument has an invalid value.
        ErrInvalidArgument = errs2.New("invalid argument")
        // ErrVerification is returned when proof verification fails.
        ErrVerification = errs2.New("verification failed")
)
</pre>
		
		<pre class="file" id="file291" style="display: none">package sigma

import (
        "encoding/hex"
        "fmt"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// Prover implements the interactive sigma prover.
type Prover[X Statement, W Witness, A Commitment, S State, Z Response] struct {
        participant[X, W, A, S, Z]

        witness W
        state   S
}

// NewProver constructs a sigma protocol prover.
func NewProver[X Statement, W Witness, A Commitment, S State, Z Response](sessionID network.SID, transcript transcripts.Transcript, sigmaProtocol Protocol[X, W, A, S, Z], statement X, witness W) (*Prover[X, W, A, S, Z], error) <span class="cov0" title="0">{
        if sigmaProtocol == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("protocol, statement or witness is nil")
        }</span>
        <span class="cov0" title="0">if s := sigmaProtocol.SoundnessError(); s &lt; base.StatisticalSecurityBits </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("soundness of the interactive protocol (%d) is too low (below %d)", s, base.StatisticalSecurityBits)
        }</span>

        <span class="cov0" title="0">dst := fmt.Sprintf("%s-%s-%s", hex.EncodeToString(sessionID[:]), transcriptLabel, sigmaProtocol.Name())
        transcript.AppendDomainSeparator(dst)
        transcript.AppendBytes(statementLabel, statement.Bytes())

        //nolint:exhaustruct // initial state
        return &amp;Prover[X, W, A, S, Z]{
                //nolint:exhaustruct // initial state
                participant: participant[X, W, A, S, Z]{
                        sessionID:     sessionID,
                        transcript:    transcript,
                        sigmaProtocol: sigmaProtocol,
                        statement:     statement,
                        round:         1,
                },
                witness: witness,
        }, nil</span>
}

// Round1 runs the prover's first round.
func (p *Prover[X, W, A, S, Z]) Round1() (A, error) <span class="cov0" title="0">{
        var zero A

        if p.round != 1 </span><span class="cov0" title="0">{
                return zero, ErrRound.WithMessage("r != 1 (%d)", p.round)
        }</span>

        <span class="cov0" title="0">commitment, state, err := p.sigmaProtocol.ComputeProverCommitment(p.statement, p.witness)
        if err != nil </span><span class="cov0" title="0">{
                return zero, errs2.Wrap(err).WithMessage("cannot create commitment")
        }</span>

        <span class="cov0" title="0">p.transcript.AppendBytes(commitmentLabel, commitment.Bytes())
        p.commitment = commitment
        p.state = state
        p.round += 2 // prover doesn't send anything in round 2 (skip to round 3)
        return commitment, nil</span>
}

// Round3 runs the prover's third round.
func (p *Prover[X, W, A, S, Z]) Round3(challengeBytes []byte) (Z, error) <span class="cov0" title="0">{
        var zero Z
        p.transcript.AppendBytes(challengeLabel, challengeBytes)

        if p.round != 3 </span><span class="cov0" title="0">{
                return zero, ErrRound.WithMessage("r != 3 (%d)", p.round)
        }</span>

        <span class="cov0" title="0">response, err := p.sigmaProtocol.ComputeProverResponse(p.statement, p.witness, p.commitment, p.state, challengeBytes)
        if err != nil </span><span class="cov0" title="0">{
                return zero, errs2.Wrap(err).WithMessage("cannot generate response")
        }</span>
        <span class="cov0" title="0">p.transcript.AppendBytes(responseLabel, response.Bytes())

        p.challengeBytes = challengeBytes
        p.response = response
        p.round += 2
        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file292" style="display: none">package sigma

import (
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// Verifier implements the interactive sigma verifier.
type Verifier[X Statement, W Witness, A Commitment, S State, Z Response] struct {
        participant[X, W, A, S, Z]

        prng io.Reader
}

// NewVerifier constructs a sigma protocol verifier.
func NewVerifier[X Statement, W Witness, A Commitment, S State, Z Response](sessionID network.SID, transcript transcripts.Transcript, sigmaProtocol Protocol[X, W, A, S, Z], statement X, prng io.Reader) (*Verifier[X, W, A, S, Z], error) <span class="cov0" title="0">{
        if sigmaProtocol == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("protocol or is nil")
        }</span>
        <span class="cov0" title="0">if s := sigmaProtocol.SoundnessError(); s &lt; base.StatisticalSecurityBits </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("soundness of the interactive protocol (%d) is too low (below %d)", s, base.StatisticalSecurityBits)
        }</span>

        <span class="cov0" title="0">dst := fmt.Sprintf("%s-%s-%s", hex.EncodeToString(sessionID[:]), transcriptLabel, sigmaProtocol.Name())
        transcript.AppendDomainSeparator(dst)
        transcript.AppendBytes(statementLabel, statement.Bytes())

        return &amp;Verifier[X, W, A, S, Z]{
                //nolint:exhaustruct // initial state
                participant: participant[X, W, A, S, Z]{
                        sessionID:     sessionID,
                        transcript:    transcript,
                        sigmaProtocol: sigmaProtocol,
                        statement:     statement,
                        round:         2,
                },
                prng: prng,
        }, nil</span>
}

// Round2 runs the verifier's second round and samples a challenge.
func (v *Verifier[X, W, A, S, Z]) Round2(commitment A) ([]byte, error) <span class="cov0" title="0">{
        v.transcript.AppendBytes(commitmentLabel, commitment.Bytes())

        if v.round != 2 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("r != 2 (%d)", v.round)
        }</span>

        <span class="cov0" title="0">challengeBytes := make([]byte, v.sigmaProtocol.GetChallengeBytesLength())
        _, err := io.ReadFull(v.prng, challengeBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot read PRNG")
        }</span>

        <span class="cov0" title="0">v.transcript.AppendBytes(challengeLabel, challengeBytes)

        v.commitment = commitment
        v.challengeBytes = challengeBytes
        v.round += 2
        return challengeBytes, nil</span>
}

// Verify checks the prover's response.
func (v *Verifier[X, W, A, S, Z]) Verify(response Z) error <span class="cov0" title="0">{
        v.transcript.AppendBytes(responseLabel, response.Bytes())

        if v.round != 4 </span><span class="cov0" title="0">{
                return ErrRound.WithMessage("r != 4 (%d)", v.round)
        }</span>

        <span class="cov0" title="0">err := v.sigmaProtocol.Verify(v.statement, v.commitment, v.challengeBytes, response)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("verification failed")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file293" style="display: none">package signatures

import (
        "bytes"
        "crypto/sha512"
        "encoding/binary"
        "io"
        "slices"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/k256"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

type AdditivelyDerivablePublicKey[
        PK interface {
                PublicKey[PK]
                base.Transparent[PKV]
        }, PKV interface {
                algebra.AbelianGroupElement[PKV, SH]
                algebra.AdditiveGroupElement[PKV]
        }, SH algebra.PrimeFieldElement[SH],
] interface {
        PublicKey[PK]
        base.Transparent[PKV]
}

func DeriveChildKeys[
        PK AdditivelyDerivablePublicKey[PK, PKV, SH],
        PKV interface {
                algebra.AbelianGroupElement[PKV, SH]
                algebra.AdditiveGroupElement[PKV]
        }, SH algebra.PrimeFieldElement[SH],
](publicKey PK, chainCode []byte, i uint32) (shift SH, childChainCode []byte, err error) <span class="cov0" title="0">{
        if utils.IsNil(publicKey) </span><span class="cov0" title="0">{
                return *new(SH), nil, ErrInvalidArgument.WithMessage("public key is nil")
        }</span>
        <span class="cov0" title="0">if i &gt;= (1 &lt;&lt; 31) </span><span class="cov0" title="0">{
                return *new(SH), nil, ErrInvalidDerivation.WithStackFrame()
        }</span>
        <span class="cov0" title="0">if publicKey.Value().Structure().Name() == k256.NewCurve().Name() </span><span class="cov0" title="0">{
                shift, childChainCode, err := bip32(any(publicKey.Value()).(*k256.Point), chainCode, i) //nolint:errcheck // false positive
                if err != nil </span><span class="cov0" title="0">{
                        return *new(SH), nil, errs2.Wrap(err).WithMessage("cannot derive child key")
                }</span>
                <span class="cov0" title="0">return any(shift).(SH), childChainCode, nil</span> //nolint:errcheck // false positive
        } else<span class="cov0" title="0"> {
                return bip32Like(publicKey, chainCode, i)
        }</span>
}

func bip32(publicKey *k256.Point, chainCode []byte, i uint32) (*k256.Scalar, []byte, error) <span class="cov0" title="0">{
        digest, err := hashing.Hmac(chainCode, sha512.New, publicKey.ToCompressed(), binary.BigEndian.AppendUint32(nil, i))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash public key")
        }</span>

        <span class="cov0" title="0">childChainCode := digest[32:]
        sf := k256.NewScalarField()
        shift, err := sf.FromBytes(digest[:32])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create scalar from bytes")
        }</span>
        // make sure it wasn't reduced
        <span class="cov0" title="0">if !bytes.Equal(digest[:32], shift.Bytes()) </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidDerivation.WithStackFrame()
        }</span>
        <span class="cov0" title="0">return shift, childChainCode, nil</span>
}

func bip32Like[
        PK AdditivelyDerivablePublicKey[PK, PKV, SH],
        PKV interface {
                algebra.AbelianGroupElement[PKV, SH]
                algebra.AdditiveGroupElement[PKV]
        }, SH algebra.PrimeFieldElement[SH],
](publicKey PK, chainCode []byte, i uint32) (shift SH, childChainCode []byte, err error) <span class="cov0" title="0">{
        pkSpace, ok := publicKey.Value().Structure().(algebra.AbelianGroup[PKV, SH])
        if !ok </span><span class="cov0" title="0">{
                return *new(SH), nil, ErrInvalidArgument.WithMessage("public key does not implement FiniteAbelianGroup")
        }</span>
        <span class="cov0" title="0">sf, ok := pkSpace.ScalarStructure().(algebra.PrimeField[SH])
        if !ok </span><span class="cov0" title="0">{
                return *new(SH), nil, ErrInvalidArgument.WithMessage("public key does not implement PrimeField")
        }</span>
        <span class="cov0" title="0">scalarWideLen := sf.WideElementSize()
        digestLen := scalarWideLen + 32

        xof, err := blake2b.NewXOF(uint32(digestLen), chainCode)
        if err != nil </span><span class="cov0" title="0">{
                return *new(SH), nil, errs2.Wrap(err).WithMessage("cannot create blake2b xof")
        }</span>

        <span class="cov0" title="0">if _, err := xof.Write(slices.Concat(publicKey.Value().Bytes(), binary.BigEndian.AppendUint32(nil, i))); err != nil </span><span class="cov0" title="0">{
                return *new(SH), nil, errs2.Wrap(err).WithMessage("cannot hash public key")
        }</span>
        <span class="cov0" title="0">digest := make([]byte, digestLen)
        if _, err := io.ReadFull(xof, digest); err != nil </span><span class="cov0" title="0">{
                return *new(SH), nil, errs2.Wrap(err).WithMessage("cannot read digest")
        }</span>

        <span class="cov0" title="0">childChainCode = digest[scalarWideLen:]
        shift, err = sf.FromWideBytes(digest[:scalarWideLen])
        if err != nil </span><span class="cov0" title="0">{
                return *new(SH), nil, errs2.Wrap(err).WithMessage("cannot create scalar from bytes")
        }</span>

        <span class="cov0" title="0">return shift, childChainCode, nil</span>
}

var (
        ErrInvalidDerivation = errs2.New("invalid derivation")
        ErrInvalidArgument   = errs2.New("invalid argument")
)
</pre>
		
		<pre class="file" id="file294" style="display: none">package bls

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
)

// NewShortKeyScheme creates a BLS signature scheme with minimal public key size.
// Public keys reside in G1 (48 bytes compressed) and signatures in G2 (96 bytes compressed).
//
// This variant is preferred when public keys are transmitted or stored more frequently than
// signatures, as the smaller key size reduces bandwidth and storage costs.
//
// The rogueKeyAlg parameter specifies the rogue key attack prevention mechanism:
//   - Basic: requires distinct messages in aggregate signatures
//   - MessageAugmentation: prepends public key to messages before signing
//   - POP: requires proof of possession for each public key
func NewShortKeyScheme[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](curveFamily curves.PairingFriendlyFamily[P1, FE1, P2, FE2, E, S], rogueKeyAlg RogueKeyPreventionAlgorithm) (*Scheme[P1, FE1, P2, FE2, E, S], error) <span class="cov8" title="1">{
        cipherSuite, err := newScheme(curveFamily, rogueKeyAlg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create cipher suite")
        }</span>
        <span class="cov8" title="1">keySubGroup := curveFamily.SourceSubGroup()
        signatureSubGroup := curveFamily.TwistedSubGroup()
        return &amp;Scheme[P1, FE1, P2, FE2, E, S]{
                variant:           ShortKey,
                rogueKeyAlg:       rogueKeyAlg,
                cipherSuite:       cipherSuite,
                keySubGroup:       keySubGroup,
                signatureSubGroup: signatureSubGroup,
        }, nil</span>
}

// NewLongKeyScheme creates a BLS signature scheme with minimal signature size.
// Public keys reside in G2 (96 bytes compressed) and signatures in G1 (48 bytes compressed).
//
// This variant is preferred when signatures are transmitted or stored more frequently than
// public keys, as the smaller signature size reduces bandwidth and storage costs.
//
// The rogueKeyAlg parameter specifies the rogue key attack prevention mechanism:
//   - Basic: requires distinct messages in aggregate signatures
//   - MessageAugmentation: prepends public key to messages before signing
//   - POP: requires proof of possession for each public key
func NewLongKeyScheme[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](curveFamily curves.PairingFriendlyFamily[P1, FE1, P2, FE2, E, S], rogueKeyAlg RogueKeyPreventionAlgorithm) (*Scheme[P2, FE2, P1, FE1, E, S], error) <span class="cov8" title="1">{
        cipherSuite, err := newScheme(curveFamily, rogueKeyAlg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create cipher suite")
        }</span>
        <span class="cov8" title="1">keySubGroup := curveFamily.TwistedSubGroup()
        signatureSubGroup := curveFamily.SourceSubGroup()
        return &amp;Scheme[P2, FE2, P1, FE1, E, S]{
                variant:           LongKey,
                rogueKeyAlg:       rogueKeyAlg,
                cipherSuite:       cipherSuite,
                keySubGroup:       keySubGroup,
                signatureSubGroup: signatureSubGroup,
        }, nil</span>
}

func newScheme[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](curveFamily curves.PairingFriendlyFamily[P1, FE1, P2, FE2, E, S], rogueKeyAlg RogueKeyPreventionAlgorithm) (*CipherSuite, error) <span class="cov8" title="1">{
        if curveFamily == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("curveFamily is nil")
        }</span>
        <span class="cov8" title="1">var cipherSuite *CipherSuite
        switch curveFamily.Name() </span>{
        case bls12381.FamilyName:<span class="cov8" title="1">
                cipherSuite = BLS12381CipherSuite()</span>
        default:<span class="cov0" title="0">
                return nil, ErrNotSupported.WithMessage("no ciphersuite for curve family %s", curveFamily.Name())</span>
        }
        <span class="cov8" title="1">if !RogueKeyPreventionAlgorithmIsSupported(rogueKeyAlg) </span><span class="cov0" title="0">{
                return nil, ErrNotSupported.WithMessage("rogue key prevention algorithm %d is not supported", rogueKeyAlg)
        }</span>
        <span class="cov8" title="1">return cipherSuite, nil</span>
}

// Scheme represents a configured BLS signature scheme instance with a specific curve family,
// key/signature variant, and rogue key prevention algorithm.
//
// The Scheme provides factory methods for creating key generators, signers, and verifiers,
// as well as signature aggregation functionality.
type Scheme[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],

] struct {
        variant           Variant
        rogueKeyAlg       RogueKeyPreventionAlgorithm
        cipherSuite       *CipherSuite
        keySubGroup       curves.PairingFriendlyCurve[PK, PKFE, SG, SGFE, E, S]
        signatureSubGroup curves.PairingFriendlyCurve[SG, SGFE, PK, PKFE, E, S]
}

// Name returns the signature scheme identifier ("BLS").
func (*Scheme[PK, PKFE, SG, SGFE, E, S]) Name() signatures.Name <span class="cov0" title="0">{
        return Name
}</span>

// Variant returns whether this scheme uses minimal public key size (ShortKey)
// or minimal signature size (LongKey).
func (s *Scheme[PK, PKFE, SG, SGFE, E, S]) Variant() Variant <span class="cov0" title="0">{
        return s.variant
}</span>

// RogueKeyPreventionAlgorithm returns the rogue key attack prevention mechanism
// configured for this scheme (Basic, MessageAugmentation, or POP).
func (s *Scheme[PK, PKFE, SG, SGFE, E, S]) RogueKeyPreventionAlgorithm() RogueKeyPreventionAlgorithm <span class="cov0" title="0">{
        return s.rogueKeyAlg
}</span>

// CipherSuite returns the cryptographic parameters including domain separation tags
// for hash-to-curve operations.
func (s *Scheme[PK, PKFE, SG, SGFE, E, S]) CipherSuite() *CipherSuite <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.cipherSuite</span>
}

// KeySubGroup returns the elliptic curve subgroup used for public keys.
// For ShortKey: G1. For LongKey: G2.
func (s *Scheme[PK, PKFE, SG, SGFE, E, S]) KeySubGroup() curves.PairingFriendlyCurve[PK, PKFE, SG, SGFE, E, S] <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.keySubGroup</span>
}

// SignatureSubGroup returns the elliptic curve subgroup used for signatures.
// For ShortKey: G2. For LongKey: G1.
func (s *Scheme[PK, PKFE, SG, SGFE, E, S]) SignatureSubGroup() curves.PairingFriendlyCurve[SG, SGFE, PK, PKFE, E, S] <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.signatureSubGroup</span>
}

// Keygen creates a key generator for producing BLS key pairs.
// Options can be used to provide deterministic seed material.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.3
func (s *Scheme[PK, PKFE, SG, SGFE, E, S]) Keygen(opts ...KeyGeneratorOption[PK, PKFE, SG, SGFE, E, S]) (*KeyGenerator[PK, PKFE, SG, SGFE, E, S], error) <span class="cov8" title="1">{
        kg := &amp;KeyGenerator[PK, PKFE, SG, SGFE, E, S]{
                group: s.keySubGroup,
                seed:  nil,
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if err := opt(kg); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("key generator option failed")
                }</span>
        }
        <span class="cov8" title="1">return kg, nil</span>
}

// Signer creates a signer for producing BLS signatures with the given private key.
// Options can be used to customise the domain separation tag.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.6
func (s *Scheme[PK, PKFE, SG, SGFE, E, S]) Signer(privateKey *PrivateKey[PK, PKFE, SG, SGFE, E, S], opts ...SignerOption[PK, PKFE, SG, SGFE, E, S]) (*Signer[PK, PKFE, SG, SGFE, E, S], error) <span class="cov8" title="1">{
        if privateKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("privateKey is nil")
        }</span>
        <span class="cov8" title="1">out := &amp;Signer[PK, PKFE, SG, SGFE, E, S]{
                privateKey:        privateKey,
                rogueKeyAlg:       s.rogueKeyAlg,
                cipherSuite:       s.cipherSuite,
                signatureSubGroup: s.signatureSubGroup,
                variant:           s.variant,
                dst:               "",
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if err := opt(out); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("signer option failed")
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// Verifier creates a verifier for validating BLS signatures.
// Options can be used to customise the domain separation tag or provide proofs of possession.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.7
func (s *Scheme[PK, PKFE, SG, SGFE, E, S]) Verifier(opts ...VerifierOption[PK, PKFE, SG, SGFE, E, S]) (*Verifier[PK, PKFE, SG, SGFE, E, S], error) <span class="cov8" title="1">{
        out := &amp;Verifier[PK, PKFE, SG, SGFE, E, S]{
                cipherSuite:       s.cipherSuite,
                signatureSubGroup: s.signatureSubGroup,
                rogueKeyAlg:       s.rogueKeyAlg,
                variant:           s.variant,
                pops:              nil,
                dst:               "",
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if err := opt(out); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("verifier option failed")
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// AggregateSignatures combines multiple BLS signatures into a single aggregate signature
// via elliptic curve point addition. The resulting signature can be verified against
// the corresponding aggregate public key or set of public keys.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.8
func (*Scheme[PK, PKFE, SG, SGFE, E, S]) AggregateSignatures(sigs ...*Signature[SG, SGFE, PK, PKFE, E, S]) (*Signature[SG, SGFE, PK, PKFE, E, S], error) <span class="cov0" title="0">{
        if sigs == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("signature is nil")
        }</span>
        <span class="cov0" title="0">return AggregateAll[PK](sigs)</span>
}
</pre>
		
		<pre class="file" id="file295" style="display: none">package bls

import (
        "crypto/sha3"
        "io"
        "slices"

        "golang.org/x/crypto/hkdf"
        "golang.org/x/sync/errgroup"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381/impl"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

// RandomOracleHashFunction is the hash function used for key derivation.
// SHA3-256 is used as it models a random oracle for salt generation.
var RandomOracleHashFunction = sha3.New256

// HKDFKeyGenSalt is the initial salt value for key generation using HKDF.
// Per the spec, if the initial hash produces a zero scalar, the salt is re-hashed
// and the process repeated until a valid non-zero key is derived.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.3
const HKDFKeyGenSalt = "BLS-SIG-KEYGEN-SALT-"

func generateWithSeed[K curves.Point[K, FK, S], FK algebra.FieldElement[FK], S algebra.PrimeFieldElement[S]](group curves.Curve[K, FK, S], ikm []byte) (secret S, publicKey K, err error) <span class="cov8" title="1">{
        sf := algebra.StructureMustBeAs[algebra.PrimeField[S]](group.ScalarStructure())
        if len(ikm) &lt; sf.ElementSize() </span><span class="cov0" title="0">{
                return *new(S), *new(K), ErrInvalidArgument.WithMessage("ikm is too short, must be at least %d bytes", sf.ElementSize())
        }</span>
        <span class="cov8" title="1">d := sf.Zero()
        // We assume h models a random oracle, so we don't parametrize salt.
        // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#choosesalt
        salt, err := hashing.Hash(RandomOracleHashFunction, []byte(HKDFKeyGenSalt))
        if err != nil </span><span class="cov0" title="0">{
                return *new(S), *new(K), errs2.Wrap(err)
        }</span>
        // step 2.3.1
        <span class="cov8" title="1">for d.IsZero() </span><span class="cov8" title="1">{
                // step 2.3.2
                kdf := hkdf.New(hashing.HashFuncTypeErase(RandomOracleHashFunction), slices.Concat(ikm, []byte{0}), salt, []byte{0, bls12381Impl.FpBytes}) // TODO: make sure this is correct
                // Leaves key_info parameter as the default empty string
                // step 2.3.3
                okm := make([]byte, bls12381Impl.FpBytes)
                if _, err := io.ReadFull(kdf, okm); err != nil </span><span class="cov0" title="0">{
                        return *new(S), *new(K), errs2.Wrap(err)
                }</span>

                // step 2.3.4
                <span class="cov8" title="1">d, err = sf.FromWideBytes(okm)
                if err != nil </span><span class="cov0" title="0">{
                        return *new(S), *new(K), errs2.Wrap(err)
                }</span>
                <span class="cov8" title="1">salt, err = hashing.Hash(RandomOracleHashFunction, salt)
                if err != nil </span><span class="cov0" title="0">{
                        return *new(S), *new(K), errs2.Wrap(err)
                }</span>
        }
        // 2.4: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-sktopk
        <span class="cov8" title="1">Y := group.ScalarBaseMul(d)
        return d, Y, nil</span>
}

// Warning: this is an internal method. We don't check if key and signature subgroups are different.
// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-coresign
func coreSign[
        Sig curves.Point[Sig, SigFE, S], SigFE algebra.FieldElement[SigFE], S algebra.PrimeFieldElement[S],
](signatureSubGroup curves.Curve[Sig, SigFE, S], privateKey S, message []byte, dst string) (Sig, error) <span class="cov8" title="1">{
        if signatureSubGroup == nil || message == nil || dst == "" </span><span class="cov0" title="0">{
                return *new(Sig), ErrInvalidArgument.WithMessage("signature subgroup, private key, message or dst cannot be nil or zero")
        }</span>
        <span class="cov8" title="1">if privateKey.IsZero() </span><span class="cov0" title="0">{
                return *new(Sig), ErrInvalidSubGroup.WithMessage("private key is zero")
        }</span>
        // step 2.6.1
        <span class="cov8" title="1">Hm, err := signatureSubGroup.HashWithDst(dst, message)
        if err != nil </span><span class="cov0" title="0">{
                return *new(Sig), errs2.Wrap(err)
        }</span>
        // step 2.6.2
        <span class="cov8" title="1">result := Hm.ScalarMul(privateKey)
        if !result.IsTorsionFree() </span><span class="cov0" title="0">{
                return *new(Sig), ErrInvalidSubGroup.WithMessage("point is not on correct subgroup")
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

func coreAggregateSign[
        Sig curves.Point[Sig, SigFE, S], SigFE algebra.FieldElement[SigFE], S algebra.PrimeFieldElement[S],
](signatureSubGroup curves.Curve[Sig, SigFE, S], privateKey S, messages [][]byte, dst string) (Sig, error) <span class="cov0" title="0">{
        if signatureSubGroup == nil || dst == "" </span><span class="cov0" title="0">{
                return *new(Sig), ErrInvalidArgument.WithMessage("signature subgroup or dst cannot be nil or zero")
        }</span>
        <span class="cov0" title="0">if privateKey.IsZero() </span><span class="cov0" title="0">{
                return *new(Sig), ErrInvalidArgument.WithMessage("private key is zero")
        }</span>
        <span class="cov0" title="0">var err error
        Hms := make([]Sig, len(messages))
        for i, message := range messages </span><span class="cov0" title="0">{
                Hms[i], err = signatureSubGroup.HashWithDst(dst, message)
                if err != nil </span><span class="cov0" title="0">{
                        return *new(Sig), errs2.Wrap(err)
                }</span>
        }
        <span class="cov0" title="0">scs := sliceutils.Repeat[[]S](privateKey, len(messages))
        sig := algebrautils.MultiScalarMul(scs, Hms)
        return sig, nil</span>
}

func coreBatchSign[
        Sig curves.Point[Sig, SigFE, S], SigFE algebra.FieldElement[SigFE], S algebra.PrimeFieldElement[S],
](signatureSubGroup curves.Curve[Sig, SigFE, S], privateKey S, messages [][]byte, dst string) ([]Sig, error) <span class="cov8" title="1">{
        if signatureSubGroup == nil || dst == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("signature subgroup or dst cannot be nil or zero")
        }</span>
        <span class="cov8" title="1">if privateKey.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("private key is zero")
        }</span>
        <span class="cov8" title="1">batch := make([]Sig, len(messages))
        var err error
        errGroup := errgroup.Group{}
        for i, message := range messages </span><span class="cov8" title="1">{
                errGroup.Go(func() error </span><span class="cov8" title="1">{
                        batch[i], err = coreSign(signatureSubGroup, privateKey, message, dst)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("could not sign message %s", message)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        }
        <span class="cov8" title="1">if err := errGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">return batch, nil</span>
}

// Warning: this is an internal method. We don't check if key and signature subgroups are different.
// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-coreverify
func coreVerify[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, ET, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, ET, S], SigFE algebra.FieldElement[SigFE],
        ET algebra.MultiplicativeGroupElement[ET], S algebra.PrimeFieldElement[S],
](publicKey PK, message []byte, signature Sig, dst string, signatureSubGroup curves.PairingFriendlyCurve[Sig, SigFE, PK, PKFE, ET, S]) error <span class="cov8" title="1">{
        // step 2.7.2
        if message == nil || signatureSubGroup == nil || dst == "" </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("signature or message or public key or signature subgroup or pairing or dst cannot be nil or zero")
        }</span>
        // step 2.7.3
        <span class="cov8" title="1">if signature.IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("signature is identity")
        }</span>
        <span class="cov8" title="1">if !signature.IsTorsionFree() </span><span class="cov0" title="0">{
                return ErrInvalidSubGroup.WithMessage("signature is not torsion free")
        }</span>

        // step 2.7.4
        <span class="cov8" title="1">if publicKey.IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("public key is identity")
        }</span>
        <span class="cov8" title="1">if !publicKey.IsTorsionFree() </span><span class="cov0" title="0">{
                return ErrInvalidSubGroup.WithMessage("public key is not torsion free")
        }</span>

        // e(pk, H(m)) == e(g1, s)  OR if signature in G1  e(H(m), pk) == e(s, g2)
        // However, we can reduce the number of miller loops
        // by doing the equivalent of
        // e(pk^-1, H(m)) * e(g1, s) == 1  OR if signature in G1 e(H(m), pk^-1) * e(s, g2) == 1
        // that'll be done in multipairing

        // step 2.7.6
        <span class="cov8" title="1">Hm, err := signatureSubGroup.HashWithDst(dst, message)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>

        <span class="cov8" title="1">out, err := signatureSubGroup.MultiPair(
                []Sig{Hm, signature},
                []PK{publicKey.Neg(), signatureSubGroup.DualStructure().Generator()},
        )
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">if !out.IsOpIdentity() </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("incorrect multipairing result")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Warning: this is an internal method. We don't check if K and S are different subgroups.
// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-coreaggregateverify
func coreAggregateVerify[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, ET, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, ET, S], SigFE algebra.FieldElement[SigFE],
        ET algebra.MultiplicativeGroupElement[ET], S algebra.PrimeFieldElement[S],
](publicKeys []PK, messages [][]byte, aggregatedSignature Sig, dst string, signatureSubGroup curves.PairingFriendlyCurve[Sig, SigFE, PK, PKFE, ET, S]) error <span class="cov8" title="1">{
        if len(publicKeys) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("at least one public key is required")
        }</span>
        <span class="cov8" title="1">if len(publicKeys) != len(messages) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("the number of public keys does not match the number of messages: %v != %v", len(publicKeys), len(messages))
        }</span>
        <span class="cov8" title="1">if dst == "" || signatureSubGroup == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("dst or signature subgroup cannot be nil or zero")
        }</span>

        // step 2.9.3
        <span class="cov8" title="1">if aggregatedSignature.IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("signature is identity")
        }</span>
        <span class="cov8" title="1">if !aggregatedSignature.IsTorsionFree() </span><span class="cov0" title="0">{
                return ErrInvalidSubGroup.WithMessage("signature is not torsion free")
        }</span>

        // e(pk_1, H(m_1))*...*e(pk_N, H(m_N)) == e(g1, s) OR if signature in G1 e(H(m_1), pk_1)*...*e(H(m_N), pk_N) == e(s, g2)
        // However, we use only one miller loop
        // by doing the equivalent of
        // e(pk_1, H(m_1))*...*e(pk_N, H(m_N)) * e(g1, s^-1) == 1 OR if signature in G1 e(H(m_1), pk_1)*...*e(H(m_N), pk_N) * e(s^-1, g2) == 1

        <span class="cov8" title="1">var err error
        keySubGroupInputs := make([]PK, len(publicKeys)+1)
        signatureSubGroupInputs := make([]Sig, len(publicKeys)+1)
        for i, pk := range publicKeys </span><span class="cov8" title="1">{
                message := messages[i]
                if message == nil </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("nil message is not allowed at index %d", i)
                }</span>
                <span class="cov8" title="1">keySubGroupInputs[i] = pk
                signatureSubGroupInputs[i], err = signatureSubGroup.HashWithDst(dst, message)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("could not hash message %d", i)
                }</span>
                // step 2.9.6
                <span class="cov8" title="1">if pk.IsOpIdentity() </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("invalid public key")
                }</span>
                <span class="cov8" title="1">if !pk.IsTorsionFree() </span><span class="cov0" title="0">{
                        return ErrInvalidSubGroup.WithMessage("public key is not torsion free")
                }</span>
        }
        <span class="cov8" title="1">keySubGroupInputs[len(publicKeys)] = signatureSubGroup.DualStructure().Generator()
        signatureSubGroupInputs[len(publicKeys)] = aggregatedSignature.Neg()

        out, err := signatureSubGroup.MultiPair(signatureSubGroupInputs, keySubGroupInputs)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("could not compute multipairing")
        }</span>
        <span class="cov8" title="1">if !out.IsOpIdentity() </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("incorrect multipairing result")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// PopProve(SK) -&gt; (proof, error): an algorithm that generates a proof of possession for the public key corresponding to secret key SK.
// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-popprove
func popProve[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, ET, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, ET, S], SigFE algebra.FieldElement[SigFE],
        ET algebra.MultiplicativeGroupElement[ET], S algebra.PrimeFieldElement[S],
](privateKey S, publicKey PK, signatureSubGroup curves.Curve[Sig, SigFE, S], dst string) (Sig, error) <span class="cov8" title="1">{
        message := publicKey.Bytes()
        pop, err := coreSign(signatureSubGroup, privateKey, message, dst)
        if err != nil </span><span class="cov0" title="0">{
                return *new(Sig), errs2.Wrap(err).WithMessage("could not produce pop")
        }</span>
        <span class="cov8" title="1">return pop, nil</span>
}

// PopVerify verifies proof of possession of public key
// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-popverify
func popVerify[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, ET, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, ET, S], SigFE algebra.FieldElement[SigFE],
        ET algebra.MultiplicativeGroupElement[ET], S algebra.PrimeFieldElement[S],
](publicKey PK, pop Sig, signatureSubGroup curves.PairingFriendlyCurve[Sig, SigFE, PK, PKFE, ET, S], popDst string) error <span class="cov8" title="1">{
        if publicKey.IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("public key is identity")
        }</span>
        <span class="cov8" title="1">if !publicKey.IsTorsionFree() </span><span class="cov0" title="0">{
                return ErrInvalidSubGroup.WithMessage("Public Key not in the prime subgroup")
        }</span>
        <span class="cov8" title="1">message := publicKey.Bytes()
        return coreVerify(publicKey, message, pop, popDst, signatureSubGroup)</span>
}

// AugmentMessage prepends the serialised public key to the message for the Message Augmentation
// signature scheme. This creates a unique message per signer, preventing rogue key attacks
// without requiring additional proofs or message distinctness checks.
//
// The augmented message is: pk || msg
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-3.2.1
func AugmentMessage[
        PK curves.Point[PK, PKFE, S], PKFE algebra.FieldElement[PKFE], S algebra.PrimeFieldElement[S],
](message []byte, publicKey PK) ([]byte, error) <span class="cov8" title="1">{
        if publicKey.IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key is identity")
        }</span>
        <span class="cov8" title="1">if !publicKey.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidSubGroup.WithMessage("Public Key not in the prime subgroup")
        }</span>
        <span class="cov8" title="1">return slices.Concat(publicKey.Bytes(), message), nil</span>
}
</pre>
		
		<pre class="file" id="file296" style="display: none">package bls

import (
        "encoding/hex"
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
)

// KeyGeneratorOption is a functional option for configuring a KeyGenerator.
type KeyGeneratorOption[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] = signatures.KeyGeneratorOption[
        *KeyGenerator[PK, PKFE, SG, SGFE, E, S],
        *PrivateKey[PK, PKFE, SG, SGFE, E, S],
        *PublicKey[PK, PKFE, SG, SGFE, E, S],
]

// GenerateWithSeed returns a KeyGeneratorOption that uses the provided seed for
// deterministic key generation instead of random sampling.
//
// The seed must be at least as long as the scalar field element size (32 bytes for BLS12-381).
// Using the same seed will always produce the same key pair.
func GenerateWithSeed[PK curves.PairingFriendlyPoint[PK, FE, Sig, SigFE, E, S], FE algebra.FieldElement[FE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, FE, E, S], SigFE algebra.FieldElement[SigFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](seed []byte) KeyGeneratorOption[PK, FE, Sig, SigFE, E, S] <span class="cov8" title="1">{
        return func(kg *KeyGenerator[PK, FE, Sig, SigFE, E, S]) error </span><span class="cov8" title="1">{
                kg.seed = seed
                return nil
        }</span>
}

// KeyGenerator generates BLS key pairs using the KeyGen algorithm from the specification.
// Key generation uses HKDF with SHA3-256 to derive secret keys from input keying material.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.3
type KeyGenerator[
        PK curves.PairingFriendlyPoint[PK, FE, Sig, SigFE, E, S], FE algebra.FieldElement[FE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, FE, E, S], SigFE algebra.FieldElement[SigFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        group curves.PairingFriendlyCurve[PK, FE, Sig, SigFE, E, S]
        seed  []byte
}

// GenerateWithSeed derives a BLS key pair from the provided input keying material (IKM).
// The IKM must be at least 32 bytes and should contain high-entropy random data.
//
// This implements the KeyGen algorithm:
//  1. Hash the salt to get initial HKDF salt
//  2. Use HKDF-Extract and HKDF-Expand to derive key material
//  3. Convert to scalar, re-hash salt if result is zero
//  4. Compute public key as sk * G
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.3
func (kg *KeyGenerator[PK, FE, Sig, SigFE, E, S]) GenerateWithSeed(ikm []byte) (*PrivateKey[PK, FE, Sig, SigFE, E, S], *PublicKey[PK, FE, Sig, SigFE, E, S], error) <span class="cov8" title="1">{
        skv, _, err := generateWithSeed(kg.group, ikm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not generate key pair")
        }</span>
        <span class="cov8" title="1">sk, err := NewPrivateKey(kg.group, skv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not create private key")
        }</span>
        <span class="cov8" title="1">pk := sk.PublicKey()
        return sk, pk, nil</span>
}

// Generate creates a new BLS key pair using random bytes from the provided reader.
// If a seed was previously set via GenerateWithSeed option, that seed is used instead.
//
// The prng should be a cryptographically secure random source (e.g., crypto/rand.Reader).
func (kg *KeyGenerator[PK, FE, Sig, SigFE, E, S]) Generate(prng io.Reader) (*PrivateKey[PK, FE, Sig, SigFE, E, S], *PublicKey[PK, FE, Sig, SigFE, E, S], error) <span class="cov8" title="1">{
        if kg.seed == nil </span><span class="cov8" title="1">{
                sf := algebra.StructureMustBeAs[algebra.PrimeField[S]](kg.group.ScalarStructure())
                kg.seed = make([]byte, sf.ElementSize())
                if _, err := io.ReadFull(prng, kg.seed); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("could not read from PRNG")
                }</span>
        }
        <span class="cov8" title="1">return kg.GenerateWithSeed(kg.seed)</span>
}

// SignerOption is a functional option for configuring a Signer.
type SignerOption[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] = signatures.SignerOption[
        *Signer[PK, PKFE, SG, SGFE, E, S],
        []byte,
        *Signature[SG, SGFE, PK, PKFE, E, S],
]

// SignWithCustomDST returns a SignerOption that overrides the default domain separation tag
// for hash-to-curve operations. This allows interoperability with systems using non-standard DSTs.
//
// Warning: Using non-standard DSTs may break compatibility with other BLS implementations.
func SignWithCustomDST[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](dst string) SignerOption[PK, PKFE, SG, SGFE, E, S] <span class="cov8" title="1">{
        return func(s *Signer[PK, PKFE, SG, SGFE, E, S]) error </span><span class="cov8" title="1">{
                if dst == "" </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("domain separation tag cannot be empty")
                }</span>
                <span class="cov8" title="1">s.dst = dst
                return nil</span>
        }
}

// Signer produces BLS signatures using the CoreSign algorithm. The signing behaviour
// depends on the configured rogue key prevention algorithm:
//   - Basic: signs the message directly
//   - MessageAugmentation: signs pk || message
//   - POP: signs message and attaches a proof of possession
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.6
type Signer[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        privateKey        *PrivateKey[PK, PKFE, SG, SGFE, E, S]
        signatureSubGroup curves.PairingFriendlyCurve[SG, SGFE, PK, PKFE, E, S]
        rogueKeyAlg       RogueKeyPreventionAlgorithm
        cipherSuite       *CipherSuite
        variant           Variant

        dst string
}

// Sign creates a BLS signature on the given message.
// The signature is computed as: sig = sk * H(msg) where H is hash-to-curve.
//
// For MessageAugmentation scheme, the public key is prepended to the message.
// For POP scheme, a proof of possession is attached to the signature.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.6
func (s *Signer[PK, PKFE, SG, SGFE, E, S]) Sign(message []byte) (*Signature[SG, SGFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if len(message) == 0 </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("message cannot be nil")
        }</span>

        <span class="cov8" title="1">var err error
        if s.dst == "" </span><span class="cov8" title="1">{
                s.dst, err = s.cipherSuite.GetDst(s.rogueKeyAlg, s.variant)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not get domain separation tag")
                }</span>
        }
        <span class="cov8" title="1">pop := ProofOfPossession[SG, SGFE, PK, PKFE, E, S]{}
        switch s.rogueKeyAlg </span>{
        // identical to coreSign: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-3.1-2
        case Basic:<span class="cov8" title="1"></span>
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-sign
        case MessageAugmentation:<span class="cov8" title="1">
                // step 3.2.1.2 (namely, the pk || message portion)
                message, err = AugmentMessage(message, s.privateKey.PublicKey().Value())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not augment message")
                }</span>
        // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-proof-of-possession
        case POP:<span class="cov8" title="1">
                popv, err := popProve(s.privateKey.Value(), s.privateKey.PublicKey().Value(), s.signatureSubGroup, s.cipherSuite.GetPopDst(s.variant))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not produce proof of possession")
                }</span>
                <span class="cov8" title="1">pop.v = popv</span>
        default:<span class="cov0" title="0">
                return nil, ErrNotSupported.WithMessage("rogue key prevention algorithm %d is not supported", s.rogueKeyAlg)</span>
        }

        <span class="cov8" title="1">sgv, err := coreSign(s.signatureSubGroup, s.privateKey.Value(), message, s.dst)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not sign")
        }</span>
        <span class="cov8" title="1">out := &amp;Signature[SG, SGFE, PK, PKFE, E, S]{v: sgv, pop: nil}
        if s.rogueKeyAlg == POP </span><span class="cov8" title="1">{
                out.pop = &amp;pop
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// AggregateSign creates a single aggregate signature over multiple messages using the same key.
// This is more efficient than signing each message individually and then aggregating.
//
// The resulting signature can be verified against the signer's public key and all messages.
func (s *Signer[PK, PKFE, SG, SGFE, E, S]) AggregateSign(messages ...Message) (*Signature[SG, SGFE, PK, PKFE, E, S], error) <span class="cov0" title="0">{
        if len(messages) == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("need at least one message to batch sign")
        }</span>

        <span class="cov0" title="0">var err error
        if s.dst == "" </span><span class="cov0" title="0">{
                s.dst, err = s.cipherSuite.GetDst(s.rogueKeyAlg, s.variant)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not get domain separation tag")
                }</span>
        }

        <span class="cov0" title="0">pop := ProofOfPossession[SG, SGFE, PK, PKFE, E, S]{}
        switch s.rogueKeyAlg </span>{
        case Basic:<span class="cov0" title="0"></span>
        case MessageAugmentation:<span class="cov0" title="0">
                for i, message := range messages </span><span class="cov0" title="0">{
                        messages[i], err = AugmentMessage(message, s.privateKey.PublicKey().Value())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("could not augment message")
                        }</span>
                }
        case POP:<span class="cov0" title="0">
                popv, err := popProve(s.privateKey.Value(), s.privateKey.PublicKey().Value(), s.signatureSubGroup, s.cipherSuite.GetPopDst(s.variant))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not produce proof of possession")
                }</span>
                <span class="cov0" title="0">pop.v = popv</span>
        default:<span class="cov0" title="0">
                return nil, ErrNotSupported.WithMessage("rogue key prevention algorithm %d is not supported", s.rogueKeyAlg)</span>
        }

        <span class="cov0" title="0">sgv, err := coreAggregateSign(s.signatureSubGroup, s.privateKey.Value(), messages, s.dst)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not sign")
        }</span>
        <span class="cov0" title="0">out := &amp;Signature[SG, SGFE, PK, PKFE, E, S]{v: sgv, pop: nil}
        if s.rogueKeyAlg == POP </span><span class="cov0" title="0">{
                out.pop = &amp;pop
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// BatchSign creates individual signatures for each message in parallel.
// Returns a slice of signatures, one per message, in the same order as the input.
//
// This is useful when you need separate signatures that can be independently verified
// or selectively aggregated later.
func (s *Signer[PK, PKFE, SG, SGFE, E, S]) BatchSign(messages ...Message) ([]*Signature[SG, SGFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if len(messages) == 0 </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("need at least one message to batch sign")
        }</span>

        <span class="cov8" title="1">var err error
        if s.dst == "" </span><span class="cov8" title="1">{
                s.dst, err = s.cipherSuite.GetDst(s.rogueKeyAlg, s.variant)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not get domain separation tag")
                }</span>
        }

        <span class="cov8" title="1">pop := ProofOfPossession[SG, SGFE, PK, PKFE, E, S]{}
        switch s.rogueKeyAlg </span>{
        case Basic:<span class="cov8" title="1"></span>
        case MessageAugmentation:<span class="cov8" title="1">
                for i, message := range messages </span><span class="cov8" title="1">{
                        messages[i], err = AugmentMessage(message, s.privateKey.PublicKey().Value())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("could not augment message")
                        }</span>
                }
        case POP:<span class="cov8" title="1">
                popv, err := popProve(s.privateKey.Value(), s.privateKey.PublicKey().Value(), s.signatureSubGroup, s.cipherSuite.GetPopDst(s.variant))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not produce proof of possession")
                }</span>
                <span class="cov8" title="1">pop.v = popv</span>
        default:<span class="cov0" title="0">
                return nil, ErrNotSupported.WithMessage("rogue key prevention algorithm %d is not supported", s.rogueKeyAlg)</span>
        }

        <span class="cov8" title="1">batch := make([]*Signature[SG, SGFE, PK, PKFE, E, S], len(messages))

        batchValues, err := coreBatchSign(
                s.signatureSubGroup, s.privateKey.Value(), messages, s.dst,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not batch sign")
        }</span>

        <span class="cov8" title="1">for i, v := range batchValues </span><span class="cov8" title="1">{
                batch[i] = &amp;Signature[SG, SGFE, PK, PKFE, E, S]{v: v, pop: nil}
                if s.rogueKeyAlg == POP </span><span class="cov8" title="1">{
                        batch[i].pop = &amp;pop
                        continue</span>
                }
        }

        <span class="cov8" title="1">return batch, nil</span>
}

// VerifierOption is a functional option for configuring a Verifier.
type VerifierOption[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] = signatures.VerifierOption[
        *Verifier[PK, PKFE, SG, SGFE, E, S],
        *PublicKey[PK, PKFE, SG, SGFE, E, S],
        []byte,
        *Signature[SG, SGFE, PK, PKFE, E, S],
]

// VerifyWithCustomDST returns a VerifierOption that overrides the default domain separation tag.
// The DST must match the one used during signing for verification to succeed.
//
// Warning: Using non-standard DSTs may break compatibility with other BLS implementations.
func VerifyWithCustomDST[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](dst string) VerifierOption[PK, PKFE, SG, SGFE, E, S] <span class="cov8" title="1">{
        return func(s *Verifier[PK, PKFE, SG, SGFE, E, S]) error </span><span class="cov8" title="1">{
                if dst == "" </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("domain separation tag cannot be empty")
                }</span>
                <span class="cov8" title="1">s.dst = dst
                return nil</span>
        }
}

// VerifyWithProofsOfPossession returns a VerifierOption that provides pre-validated proofs
// of possession for aggregate signature verification. This is required for AggregateVerify
// when using the POP rogue key prevention scheme.
//
// The number of proofs must match the number of public keys in the verification.
func VerifyWithProofsOfPossession[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](pops ...*ProofOfPossession[SG, SGFE, PK, PKFE, E, S]) VerifierOption[PK, PKFE, SG, SGFE, E, S] <span class="cov8" title="1">{
        return func(v *Verifier[PK, PKFE, SG, SGFE, E, S]) error </span><span class="cov8" title="1">{
                for i, pop := range pops </span><span class="cov8" title="1">{
                        if pop == nil </span><span class="cov0" title="0">{
                                return ErrInvalidArgument.WithMessage("proof of possession %d is nil", i)
                        }</span>
                }
                <span class="cov8" title="1">v.pops = pops
                return nil</span>
        }
}

// Verifier validates BLS signatures using the CoreVerify algorithm.
// Verification uses the pairing equation to check: e(pk, H(m)) = e(G, sig)
//
// The verification behaviour depends on the rogue key prevention algorithm:
//   - Basic: verifies signature directly
//   - MessageAugmentation: reconstructs pk || message before verification
//   - POP: verifies attached proof of possession before signature verification
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.7
type Verifier[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        signatureSubGroup curves.PairingFriendlyCurve[SG, SGFE, PK, PKFE, E, S]
        rogueKeyAlg       RogueKeyPreventionAlgorithm
        cipherSuite       *CipherSuite
        variant           Variant

        pops []*ProofOfPossession[SG, SGFE, PK, PKFE, E, S]
        dst  string
}

// Verify validates a BLS signature against a public key and message.
//
// The verification uses an optimised pairing check: e(pk^-1, H(m)) * e(G, sig) = 1
// which reduces the number of Miller loop iterations.
//
// Security: Validates that both the public key and signature are valid non-identity
// points in their respective prime-order subgroups before performing verification.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.7
func (v *Verifier[PK, PKFE, SG, SGFE, E, S]) Verify(signature *Signature[SG, SGFE, PK, PKFE, E, S], publicKey *PublicKey[PK, PKFE, SG, SGFE, E, S], message Message) error <span class="cov8" title="1">{
        if len(message) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("message cannot be nil")
        }</span>
        <span class="cov8" title="1">if !publicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return ErrInvalidSubGroup.WithMessage("public key is not torsion-free")
        }</span>
        <span class="cov8" title="1">if publicKey.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("public key is the identity element")
        }</span>
        <span class="cov8" title="1">if !signature.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return ErrInvalidSubGroup.WithMessage("signature is not torsion-free")
        }</span>
        <span class="cov8" title="1">if signature.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("signature is the identity element")
        }</span>

        <span class="cov8" title="1">var err error
        if v.dst == "" </span><span class="cov8" title="1">{
                v.dst, err = v.cipherSuite.GetDst(v.rogueKeyAlg, v.variant)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("could not get domain separation tag")
                }</span>
        }

        <span class="cov8" title="1">switch v.rogueKeyAlg </span>{
        // identical to coreSign: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-3.1-2
        case Basic:<span class="cov8" title="1"></span>
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-sign
        case MessageAugmentation:<span class="cov8" title="1">
                // step 3.2.1.2 (namely, the pk || message portion)
                message, err = AugmentMessage(message, publicKey.Value())
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("could not augment message")
                }</span>
        // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-proof-of-possession
        case POP:<span class="cov8" title="1">
                pop := signature.Pop()
                if pop == nil </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("signature does not contain proof of possession")
                }</span>
                <span class="cov8" title="1">if err := popVerify(publicKey.Value(), pop.v, v.signatureSubGroup, v.cipherSuite.GetPopDst(v.variant)); err != nil </span><span class="cov0" title="0">{
                        return ErrVerificationFailed.WithMessage("could not verify proof of possession")
                }</span>
        default:<span class="cov0" title="0">
                return ErrNotSupported.WithMessage("rogue key prevention algorithm %d is not supported", v.rogueKeyAlg)</span>
        }
        <span class="cov8" title="1">if err := coreVerify(publicKey.Value(), message, signature.Value(), v.dst, v.signatureSubGroup); err != nil </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("could not verify signature")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AggregateVerify validates an aggregate signature against multiple public keys and messages.
// The verification behaviour depends on the rogue key prevention algorithm:
//
//   - Basic: requires all messages to be distinct to prevent rogue key attacks
//   - MessageAugmentation: augments each message with its corresponding public key
//   - POP: requires valid proofs of possession for each public key (via VerifyWithProofsOfPossession)
//
// When all messages are identical and using the POP scheme, the optimised FastAggregateVerify
// algorithm is used, which aggregates public keys before verification.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.9
func (v *Verifier[PK, PKFE, SG, SGFE, E, S]) AggregateVerify(signature *Signature[SG, SGFE, PK, PKFE, E, S], publicKeys []*PublicKey[PK, PKFE, SG, SGFE, E, S], messages []Message) error <span class="cov8" title="1">{
        if len(publicKeys) != len(messages) </span><span class="cov8" title="1">{
                return ErrInvalidArgument.WithMessage("#public keys != #messages")
        }</span>
        <span class="cov8" title="1">for i, publicKey := range publicKeys </span><span class="cov8" title="1">{
                if !publicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                        return ErrInvalidSubGroup.WithMessage("public key %d is not torsion-free", i)
                }</span>
                <span class="cov8" title="1">if publicKey.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("public key %d is the identity element", i)
                }</span>
        }
        <span class="cov8" title="1">if !signature.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return ErrInvalidSubGroup.WithMessage("signature is not torsion-free")
        }</span>
        <span class="cov8" title="1">if signature.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("signature is the identity element")
        }</span>

        <span class="cov8" title="1">var err error
        if v.dst == "" </span><span class="cov8" title="1">{
                v.dst, err = v.cipherSuite.GetDst(v.rogueKeyAlg, v.variant)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("could not get domain separation tag")
                }</span>
        }

        <span class="cov8" title="1">switch v.rogueKeyAlg </span>{
        // case 3.1.1
        case Basic:<span class="cov8" title="1">
                if len(v.pops) &gt; 0 </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("nonzero number of pops when scheme is basic")
                }</span>
                // step 3.1.1.1
                <span class="cov8" title="1">if !sliceutils.IsAllUnique(sliceutils.Map(messages, hex.EncodeToString)) </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("messages are not unique")
                }</span>
        // case 3.3
        case POP:<span class="cov8" title="1">
                if len(publicKeys) != len(v.pops) </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("#publicKeys != #pops")
                }</span>
                <span class="cov8" title="1">popDst := v.cipherSuite.GetPopDst(v.variant)
                for i, pop := range v.pops </span><span class="cov8" title="1">{
                        if err := popVerify(publicKeys[i].Value(), pop.Value(), v.signatureSubGroup, popDst); err != nil </span><span class="cov0" title="0">{
                                return ErrVerificationFailed.WithMessage("pop %d is invalid", i)
                        }</span>
                }
        // case 3.2.3 https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-aggregateverify-2
        case MessageAugmentation:<span class="cov8" title="1">
                if len(v.pops) &gt; 0 </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("nonzero number of pops when scheme is message augmentation")
                }</span>
                // step 3.2.3.1
                <span class="cov8" title="1">for i, publicKey := range publicKeys </span><span class="cov8" title="1">{
                        // step 3.2.3.2
                        augmentedMessage, err := AugmentMessage(messages[i], publicKey.Value())
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("could not augment message")
                        }</span>
                        <span class="cov8" title="1">messages[i] = augmentedMessage</span>
                }
        default:<span class="cov0" title="0">
                return ErrNotSupported.WithMessage("rogue key prevention scheme %d is not supported", v.rogueKeyAlg)</span>
        }

        // FastAggregateVerify is a verification algorithm for the aggregate of multiple signatures on the same message. This function is faster than AggregateVerify.
        //
        // All public keys passed as arguments to this algorithm MUST have a corresponding proof of possession, and the result of evaluating PopVerify on each public key and its proof MUST be VALID. The caller is responsible for ensuring that this precondition is met. If it is violated, this scheme provides no security against aggregate signature forgery.
        // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-fastaggregateverify
        <span class="cov8" title="1">canRunFastAggregateVerify := (sliceutils.CountUnique(sliceutils.Map(messages, hex.EncodeToString)) == 1) &amp;&amp; v.rogueKeyAlg == POP
        if canRunFastAggregateVerify </span><span class="cov8" title="1">{
                aggregatedPublicKey, err := AggregateAll[PK](publicKeys)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("could not aggregate public keys")
                }</span>
                <span class="cov8" title="1">if err := coreVerify(aggregatedPublicKey.Value(), messages[0], signature.Value(), v.dst, v.signatureSubGroup); err != nil </span><span class="cov0" title="0">{
                        return ErrVerificationFailed.WithMessage("could not verify fast aggregate signature")
                }</span>
                <span class="cov8" title="1">return nil</span>
        } else<span class="cov8" title="1"> {
                unwrappedPublicKeys := slices.Collect(iterutils.Map(slices.Values(publicKeys), func(pk *PublicKey[PK, PKFE, SG, SGFE, E, S]) PK </span><span class="cov8" title="1">{
                        return pk.Value()
                }</span>))
                <span class="cov8" title="1">if err := coreAggregateVerify(unwrappedPublicKeys, messages, signature.Value(), v.dst, v.signatureSubGroup); err != nil </span><span class="cov8" title="1">{
                        return ErrVerificationFailed.WithMessage("could not verify aggregate signature")
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file297" style="display: none">// Package bls implements BLS (Boneh-Lynn-Shacham) digital signatures as specified in
// draft-irtf-cfrg-bls-signature-06.
//
// BLS signatures are built on pairing-friendly elliptic curves and support signature aggregation,
// where multiple signatures can be combined into a single compact signature while maintaining
// cryptographic security. This implementation supports the BLS12-381 curve family.
//
// The package provides three signature schemes for rogue key attack prevention:
//   - Basic: requires all messages in an aggregate to be distinct
//   - Message Augmentation: prepends the public key to each message before signing
//   - Proof of Possession (POP): requires signers to prove knowledge of their secret key
//
// Reference: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html
package bls

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
)

const (
        // Name is the canonical identifier for this signature scheme.
        Name signatures.Name = "BLS"

        // Basic is a rogue key prevention algorithm that protects against rogue key attacks by
        // requiring all messages in an aggregate signature to be distinct.
        // See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-3.1
        Basic RogueKeyPreventionAlgorithm = 1

        // MessageAugmentation is a rogue key prevention algorithm where signatures are computed
        // over the concatenation of the public key and message (pk || msg). This ensures messages
        // signed by different keys are inherently distinct, preventing rogue key attacks without
        // additional validation.
        // See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-3.2
        MessageAugmentation RogueKeyPreventionAlgorithm = 2

        // POP (Proof of Possession) is a rogue key prevention algorithm where signers must
        // provide a proof demonstrating knowledge of their secret key. This enables the optimised
        // FastAggregateVerify algorithm for verifying multiple signatures on identical messages.
        // See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-3.3
        POP RogueKeyPreventionAlgorithm = 3

        // ShortKey indicates the minimal-pubkey-size variant where public keys are points on
        // the G1 curve (48 bytes compressed) and signatures are points on G2 (96 bytes compressed).
        // This variant is preferred when public keys are transmitted more frequently than signatures.
        ShortKey Variant = 1

        // LongKey indicates the minimal-signature-size variant where public keys are points on
        // the G2 curve (96 bytes compressed) and signatures are points on G1 (48 bytes compressed).
        // This variant is preferred when signatures are transmitted more frequently than public keys.
        LongKey Variant = 2
)

// RogueKeyPreventionAlgorithm specifies the scheme used to prevent rogue key attacks in
// BLS signature aggregation. A rogue key attack occurs when an adversary creates a malicious
// public key that cancels out honest signers' contributions in an aggregate signature.
type RogueKeyPreventionAlgorithm int

// Variant specifies whether to use minimal public key size (ShortKey) or minimal signature
// size (LongKey). The choice determines which curve subgroup is used for keys vs signatures.
type Variant int

// Message is the type alias for message bytes to be signed or verified.
type Message = []byte

// CipherSuite defines the cryptographic parameters for a BLS signature scheme instance.
// It specifies the curve family and domain separation tags (DSTs) for hash-to-curve operations.
//
// Domain separation tags ensure that hash outputs for different purposes (signing, POP proofs)
// and different curve subgroups remain cryptographically independent. The tag format follows:
// "BLS_SIG_&lt;curve&gt;_&lt;hash&gt;_&lt;map&gt;_&lt;variant&gt;_" for signatures and
// "BLS_POP_&lt;curve&gt;_&lt;hash&gt;_&lt;map&gt;_&lt;variant&gt;_" for proof of possession.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-4.2
type CipherSuite struct {
        FamilyName                      string
        DstSignatureBasicInTwistedGroup string
        DstSignatureAugInTwistedGroup   string
        DstSignaturePopInTwistedGroup   string
        DstPopProofInTwistedGroup       string
        DstSignatureBasicInSourceGroup  string
        DstSignatureAugInSourceGroup    string
        DstSignaturePopInSourceGroup    string
        DstPopProofInSourceGroup        string
}

// GetDst returns the domain separation tag for signing operations based on the rogue key
// prevention algorithm and key/signature variant. The DST is used in hash-to-curve operations
// to ensure cryptographic domain separation between different signature schemes.
func (c *CipherSuite) GetDst(alg RogueKeyPreventionAlgorithm, variant Variant) (string, error) <span class="cov8" title="1">{
        switch alg </span>{
        case Basic:<span class="cov8" title="1">
                if variant == ShortKey </span><span class="cov8" title="1">{
                        return (c.DstSignatureBasicInTwistedGroup), nil
                }</span>
                <span class="cov8" title="1">return (c.DstSignatureBasicInSourceGroup), nil</span>
        case MessageAugmentation:<span class="cov8" title="1">
                if variant == ShortKey </span><span class="cov8" title="1">{
                        return (c.DstSignatureAugInTwistedGroup), nil
                }</span>
                <span class="cov8" title="1">return (c.DstSignatureAugInSourceGroup), nil</span>
        case POP:<span class="cov8" title="1">
                if variant == ShortKey </span><span class="cov8" title="1">{
                        return (c.DstSignaturePopInTwistedGroup), nil
                }</span>
                <span class="cov8" title="1">return (c.DstSignaturePopInSourceGroup), nil</span>
        default:<span class="cov0" title="0">
                return "", ErrNotSupported.WithMessage("algorithm type %v not implemented", alg)</span>
        }
}

// GetPopDst returns the domain separation tag for proof of possession operations.
// Note: POP proofs hash the public key to the opposite subgroup from where the key lives,
// hence ShortKey (keys in G1) uses SourceGroup DST (hashing to G1 for POP proof).
func (c *CipherSuite) GetPopDst(variant Variant) string <span class="cov8" title="1">{
        if variant == ShortKey </span><span class="cov8" title="1">{
                return c.DstPopProofInSourceGroup
        }</span>
        <span class="cov8" title="1">return c.DstPopProofInTwistedGroup</span>
}

// BLS12381CipherSuite returns the standard ciphersuite for BLS12-381 curve.
// It uses SHA-256 for hashing and the simplified SWU map for hash-to-curve.
//
// The ciphersuite identifiers follow the format specified in:
// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-4.2
func BLS12381CipherSuite() *CipherSuite <span class="cov8" title="1">{
        return &amp;CipherSuite{
                FamilyName: bls12381.FamilyName,
                // Domain separation tag for basic signatures
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.1
                DstSignatureBasicInTwistedGroup: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
                // Domain separation tag for basic signatures
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.2
                DstSignatureAugInTwistedGroup: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_AUG_",
                // Domain separation tag for proof of possession signatures
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.3
                DstSignaturePopInTwistedGroup: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_",
                // Domain separation tag for proof of possession proofs
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.3
                DstPopProofInTwistedGroup: "BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_",
                // Domain separation tag for basic signatures
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.1
                DstSignatureBasicInSourceGroup: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_",
                // Domain separation tag for basic signatures
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.2
                DstSignatureAugInSourceGroup: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_AUG_",
                // Domain separation tag for proof of possession signatures
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.3
                DstSignaturePopInSourceGroup: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_POP_",
                // Domain separation tag for proof of possession proofs
                // https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#section-4.2.3
                DstPopProofInSourceGroup: "BLS_POP_BLS12381G1_XMD:SHA-256_SSWU_RO_POP_",
        }
}</span>

// RogueKeyPreventionAlgorithmIsSupported returns true if the given algorithm is one of
// the three supported rogue key prevention schemes: Basic, MessageAugmentation, or POP.
func RogueKeyPreventionAlgorithmIsSupported(alg RogueKeyPreventionAlgorithm) bool <span class="cov8" title="1">{
        return alg == Basic || alg == MessageAugmentation || alg == POP
}</span>

// NewPublicKey creates a PublicKey from an elliptic curve point.
// The point must be a valid, non-identity element in the correct prime-order subgroup.
//
// Security: Validates that the point is not the identity element and is torsion-free
// (lies in the prime-order subgroup). This prevents invalid key attacks.
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.5
func NewPublicKey[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](v PK) (*PublicKey[PK, PKFE, Sig, SigFE, E, S], error) <span class="cov8" title="1">{
        if v.IsOpIdentity() </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("cannot create public key from identity point")
        }</span>
        <span class="cov8" title="1">if !v.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot create public key from torsion point")
        }</span>
        <span class="cov8" title="1">return &amp;PublicKey[PK, PKFE, Sig, SigFE, E, S]{
                PublicKeyTrait: signatures.PublicKeyTrait[PK, S]{V: v},
        }, nil</span>
}

// NewPublicKeyFromBytes deserializes a PublicKey from its compressed byte representation.
// The input is validated to ensure it represents a valid curve point in the correct subgroup.
func NewPublicKeyFromBytes[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](subGroup curves.PairingFriendlyCurve[PK, PKFE, Sig, SigFE, E, S], input []byte) (*PublicKey[PK, PKFE, Sig, SigFE, E, S], error) <span class="cov8" title="1">{
        v, err := subGroup.FromBytes(input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not create public key from bytes")
        }</span>
        <span class="cov8" title="1">return NewPublicKey(v)</span>
}

// PublicKey represents a BLS public key as a point on a pairing-friendly elliptic curve.
// The public key is computed as pk = sk * G, where sk is the secret key scalar and G is
// the generator of the chosen subgroup (G1 for ShortKey variant, G2 for LongKey).
//
// Public keys can be aggregated via elliptic curve point addition to form aggregate
// public keys for multi-signature verification.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.4
type PublicKey[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        signatures.PublicKeyTrait[PK, S]
}

// Group returns the elliptic curve subgroup that this public key belongs to.
func (pk *PublicKey[P1, F1, P2, F2, E, S]) Group() curves.PairingFriendlyCurve[P1, F1, P2, F2, E, S] <span class="cov0" title="0">{
        group, ok := pk.V.Structure().(curves.PairingFriendlyCurve[P1, F1, P2, F2, E, S])
        if !ok </span><span class="cov0" title="0">{
                panic(ErrNotSupported.WithMessage("public key value does not implement curves.Curve interface"))</span>
        }
        <span class="cov0" title="0">return group</span>
}

// Name returns the signature scheme identifier ("BLS").
func (*PublicKey[P1, F1, P2, F2, E, S]) Name() signatures.Name <span class="cov0" title="0">{
        return Name
}</span>

// Clone returns a deep copy of the public key.
func (pk *PublicKey[P1, F1, P2, F2, E, S]) Clone() *PublicKey[P1, F1, P2, F2, E, S] <span class="cov8" title="1">{
        if pk == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;PublicKey[P1, F1, P2, F2, E, S]{PublicKeyTrait: *pk.PublicKeyTrait.Clone()}</span>
}

// Equal returns true if both public keys represent the same curve point.
func (pk *PublicKey[P1, F1, P2, F2, E, S]) Equal(other *PublicKey[P1, F1, P2, F2, E, S]) bool <span class="cov8" title="1">{
        return pk != nil &amp;&amp; other != nil &amp;&amp; pk.PublicKeyTrait.Equal(&amp;other.PublicKeyTrait)
}</span>

// HashCode returns a hash of the public key for use in hash-based data structures.
func (pk *PublicKey[P1, F1, P2, F2, E, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return pk.PublicKeyTrait.HashCode()
}</span>

// Bytes returns the compressed serialisation of the public key.
// For ShortKey variant (G1): 48 bytes. For LongKey variant (G2): 96 bytes.
func (pk *PublicKey[P1, F1, P2, F2, E, S]) Bytes() []byte <span class="cov8" title="1">{
        if pk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return pk.Value().ToCompressed()</span>
}

// IsShort returns true if this is a minimal-pubkey-size key (residing in G1).
func (pk *PublicKey[P1, F1, P2, F2, E, S]) IsShort() bool <span class="cov8" title="1">{
        return pk.Value().InSourceGroup()
}</span>

// TryAdd aggregates this public key with another by elliptic curve point addition.
// The result can be used as an aggregate public key for verifying aggregate signatures.
// Returns an error if other is nil, the identity element, or not in the correct subgroup.
func (pk *PublicKey[P1, F1, P2, F2, E, S]) TryAdd(other *PublicKey[P1, F1, P2, F2, E, S]) (*PublicKey[P1, F1, P2, F2, E, S], error) <span class="cov8" title="1">{
        if other == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot add nil public key")
        }</span>
        <span class="cov8" title="1">if other.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot add identity public key")
        }</span>
        <span class="cov8" title="1">if !other.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot add public key with torsion point")
        }</span>
        <span class="cov8" title="1">return &amp;PublicKey[P1, F1, P2, F2, E, S]{
                PublicKeyTrait: signatures.PublicKeyTrait[P1, S]{V: pk.Value().Add(other.Value())},
        }, nil</span>
}

// NewPrivateKey creates a PrivateKey from a scalar value and computes the corresponding public key.
// The scalar must be non-zero and in the range [1, r-1] where r is the subgroup order.
//
// The public key is derived as pk = sk * G (SkToPk operation in the spec).
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.4
func NewPrivateKey[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](subGroup curves.PairingFriendlyCurve[PK, PKFE, Sig, SigFE, E, S], v S) (*PrivateKey[PK, PKFE, Sig, SigFE, E, S], error) <span class="cov8" title="1">{
        if v.IsOpIdentity() </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("cannot create private key from identity scalar")
        }</span>
        <span class="cov8" title="1">publicKeyValue := subGroup.ScalarBaseMul(v)
        return &amp;PrivateKey[PK, PKFE, Sig, SigFE, E, S]{
                PrivateKeyTrait: signatures.PrivateKeyTrait[PK, S]{
                        V: v,
                        PublicKeyTrait: signatures.PublicKeyTrait[PK, S]{
                                V: publicKeyValue,
                        },
                },
        }, nil</span>
}

// NewPrivateKeyFromBytes deserializes a PrivateKey from its byte representation.
// The input is interpreted as a big-endian integer and validated to be non-zero.
func NewPrivateKeyFromBytes[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](subGroup curves.PairingFriendlyCurve[PK, PKFE, Sig, SigFE, E, S], input []byte) (*PrivateKey[PK, PKFE, Sig, SigFE, E, S], error) <span class="cov8" title="1">{
        sf := algebra.StructureMustBeAs[algebra.PrimeField[S]](subGroup.ScalarStructure())
        v, err := sf.FromBytes(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create private key from bytes")
        }</span>
        <span class="cov8" title="1">return NewPrivateKey(subGroup, v)</span>
}

// PrivateKey represents a BLS secret key as a scalar in the prime field Fr.
// The secret key sk is an integer in [1, r-1] where r is the order of the subgroups G1 and G2.
//
// Security: Private keys must be generated using a cryptographically secure random source
// and protected against side-channel attacks. The KeyGen algorithm uses HKDF for secure
// key derivation from random input keying material.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.3
type PrivateKey[
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        signatures.PrivateKeyTrait[PK, S]
}

// Name returns the signature scheme identifier ("BLS").
func (*PrivateKey[PK, PKFE, Sig, SigFE, E, S]) Name() signatures.Name <span class="cov0" title="0">{
        return Name
}</span>

// Group returns the elliptic curve associated with this private key's public key.
func (sk *PrivateKey[PK, PKFE, Sig, SigFE, E, S]) Group() curves.Curve[PK, PKFE, S] <span class="cov0" title="0">{
        group, ok := sk.V.Structure().(curves.Curve[PK, PKFE, S])
        if !ok </span><span class="cov0" title="0">{
                panic(ErrNotSupported.WithMessage("private key value does not implement curves.Curve interface"))</span>
        }
        <span class="cov0" title="0">return group</span>
}

// PublicKey returns the public key corresponding to this private key.
// The public key is computed as pk = sk * G during key creation.
func (sk *PrivateKey[PK, PKFE, Sig, SigFE, E, S]) PublicKey() *PublicKey[PK, PKFE, Sig, SigFE, E, S] <span class="cov8" title="1">{
        return &amp;PublicKey[PK, PKFE, Sig, SigFE, E, S]{PublicKeyTrait: sk.PublicKeyTrait}
}</span>

// Clone returns a deep copy of the private key.
func (sk *PrivateKey[PK, PKFE, Sig, SigFE, E, S]) Clone() *PrivateKey[PK, PKFE, Sig, SigFE, E, S] <span class="cov8" title="1">{
        if sk == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;PrivateKey[PK, PKFE, Sig, SigFE, E, S]{PrivateKeyTrait: *sk.PrivateKeyTrait.Clone()}</span>
}

// Equal returns true if both private keys have the same scalar value.
func (sk *PrivateKey[PK, PKFE, Sig, SigFE, E, S]) Equal(other *PrivateKey[PK, PKFE, Sig, SigFE, E, S]) bool <span class="cov8" title="1">{
        if sk == nil || other == nil </span><span class="cov0" title="0">{
                return sk == other
        }</span>
        <span class="cov8" title="1">return sk.PrivateKeyTrait.Equal(&amp;other.PrivateKeyTrait)</span>
}

// Bytes returns the little-endian byte representation of the secret key scalar.
// The output is 32 bytes for BLS12-381.
func (sk *PrivateKey[PK, PKFE, Sig, SigFE, E, S]) Bytes() []byte <span class="cov8" title="1">{
        if sk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return sliceutils.Reversed(sk.Value().Bytes())</span>
}

// NewSignature creates a Signature from an elliptic curve point, optionally with a proof of possession.
// The point must be a valid, non-identity element in the correct prime-order subgroup.
//
// Security: Validates subgroup membership to prevent attacks exploiting small subgroup elements.
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.5
func NewSignature[
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](v Sig, pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) (*Signature[Sig, SigFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if v.IsOpIdentity() </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("cannot create signature from identity point")
        }</span>
        <span class="cov8" title="1">if !v.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot create signature from torsion point")
        }</span>
        <span class="cov8" title="1">return &amp;Signature[Sig, SigFE, PK, PKFE, E, S]{
                v:   v,
                pop: pop,
        }, nil</span>
}

// NewSignatureFromBytes deserializes a Signature from its compressed byte representation.
// The input is validated to ensure it represents a valid curve point in the correct subgroup.
func NewSignatureFromBytes[
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](subGroup curves.PairingFriendlyCurve[Sig, SigFE, PK, PKFE, E, S], input []byte, pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) (*Signature[Sig, SigFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if subGroup == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("subgroup cannot be nil")
        }</span>
        <span class="cov8" title="1">v, err := subGroup.FromBytes(input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not create signature from bytes")
        }</span>
        <span class="cov8" title="1">return NewSignature(v, pop)</span>
}

// Signature represents a BLS signature as a point on a pairing-friendly elliptic curve.
// The signature is computed as sig = sk * H(m), where sk is the secret key and H(m) is
// the hash-to-curve output for message m.
//
// Signatures can be aggregated via elliptic curve point addition. When using the POP scheme,
// signatures may include an attached proof of possession.
//
// Verification uses the pairing equation: e(pk, H(m)) = e(G, sig)
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.6
type Signature[
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        v   Sig
        pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]
}

// Value returns the underlying curve point of the signature.
func (sig *Signature[Sig, SigFE, PK, PKFE, E, S]) Value() Sig <span class="cov8" title="1">{
        return sig.v
}</span>

// Bytes returns the compressed serialisation of the signature.
// For ShortKey variant (sig in G2): 96 bytes. For LongKey variant (sig in G1): 48 bytes.
func (sig *Signature[Sig, SigFE, PK, PKFE, E, S]) Bytes() []byte <span class="cov8" title="1">{
        return sig.v.ToCompressed()
}</span>

// IsLong returns true if this is a minimal-signature-size signature (residing in G1).
func (sig *Signature[Sig, SigFE, PK, PKFE, E, S]) IsLong() bool <span class="cov8" title="1">{
        return !sig.v.InSourceGroup()
}</span>

// Pop returns the attached proof of possession, or nil if none is attached.
// Only signatures created with the POP rogue key prevention algorithm have attached proofs.
func (sig *Signature[Sig, SigFE, PK, PKFE, E, S]) Pop() *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S] <span class="cov8" title="1">{
        if sig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return sig.pop</span>
}

// TryAdd aggregates this signature with another by elliptic curve point addition.
// If both signatures have proofs of possession, those are also aggregated.
// Returns an error if other is nil, the identity element, or not in the correct subgroup.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.8
func (sig *Signature[Sig, SigFE, PK, PKFE, E, S]) TryAdd(other *Signature[Sig, SigFE, PK, PKFE, E, S]) (*Signature[Sig, SigFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if other == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot add nil signature with proof of possession")
        }</span>
        <span class="cov8" title="1">if other.v.IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot add identity signature")
        }</span>
        <span class="cov8" title="1">if !other.v.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot add signature with torsion point")
        }</span>
        <span class="cov8" title="1">out := &amp;Signature[Sig, SigFE, PK, PKFE, E, S]{v: sig.v.Add(other.v), pop: nil}
        if sig.pop == nil &amp;&amp; other.pop == nil </span><span class="cov8" title="1">{
                return out, nil
        }</span>
        <span class="cov8" title="1">popAgg, err := sig.pop.TryAdd(other.pop)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not add proofs of possession in signature with proof of possession")
        }</span>
        <span class="cov8" title="1">out.pop = popAgg
        return out, nil</span>
}

// Equal returns true if both signatures represent the same curve point and have equal POPs.
func (sig *Signature[Sig, SigFE, PK, PKFE, E, S]) Equal(other *Signature[Sig, SigFE, PK, PKFE, E, S]) bool <span class="cov8" title="1">{
        return sig != nil &amp;&amp; other != nil &amp;&amp; sig.v.Equal(other.v) &amp;&amp; sig.pop.Equal(other.pop)
}</span>

// Clone returns a deep copy of the signature including any attached proof of possession.
func (sig *Signature[Sig, SigFE, PK, PKFE, E, S]) Clone() *Signature[Sig, SigFE, PK, PKFE, E, S] <span class="cov8" title="1">{
        return &amp;Signature[Sig, SigFE, PK, PKFE, E, S]{
                v:   sig.v.Clone(),
                pop: sig.pop.Clone(),
        }
}</span>

// HashCode returns a hash of the signature for use in hash-based data structures.
func (sig *Signature[Sig, SigFE, PK, PKFE, E, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return sig.v.HashCode()
}</span>

// NewProofOfPossession creates a ProofOfPossession from an elliptic curve point.
// A proof of possession is a signature on the public key itself, demonstrating that
// the signer knows the corresponding secret key.
//
// The proof is generated as: pop = sk * H(pk) where H hashes to the signature subgroup
// using a distinct domain separation tag from regular signatures.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-3.3.2
func NewProofOfPossession[
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](v Sig) (*ProofOfPossession[Sig, SigFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if v.IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot create proof of possession from identity signature")
        }</span>
        <span class="cov8" title="1">if !v.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot create proof of possession from signature with torsion point")
        }</span>
        <span class="cov8" title="1">sig, err := NewSignature(v, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create proof of possession from signature")
        }</span>
        <span class="cov8" title="1">return &amp;ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]{
                Signature: *sig,
        }, nil</span>
}

// NewProofOfPossessionFromBytes deserializes a ProofOfPossession from its compressed byte representation.
// The input is validated to ensure it represents a valid curve point in the correct subgroup.
func NewProofOfPossessionFromBytes[
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](subGroup curves.PairingFriendlyCurve[Sig, SigFE, PK, PKFE, E, S], input []byte) (*ProofOfPossession[Sig, SigFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if subGroup == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("subgroup cannot be nil")
        }</span>
        <span class="cov8" title="1">v, err := subGroup.FromBytes(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create proof of possession from bytes")
        }</span>
        <span class="cov8" title="1">pop, err := NewProofOfPossession(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create proof of possession from signature")
        }</span>
        <span class="cov8" title="1">return pop, nil</span>
}

// ProofOfPossession is a cryptographic proof that the holder of a public key knows
// the corresponding secret key. It prevents rogue key attacks in signature aggregation
// by requiring each participant to prove key ownership before their signatures are aggregated.
//
// The proof is verified using: e(pk, H(pk)) = e(G, pop)
// where H uses a domain separation tag distinct from signature generation.
//
// Proofs can be aggregated when verifying multiple signatures on the same message,
// enabling the efficient FastAggregateVerify algorithm.
//
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-3.3
type ProofOfPossession[
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        Signature[Sig, SigFE, PK, PKFE, E, S]
}

// Bytes returns the compressed serialisation of the proof of possession.
func (pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) Bytes() []byte <span class="cov8" title="1">{
        if pop == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return pop.Signature.Bytes()</span>
}

// Value returns the underlying curve point of the proof.
func (pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) Value() Sig <span class="cov8" title="1">{
        return pop.Signature.Value()
}</span>

// Equal returns true if both proofs represent the same curve point.
func (pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) Equal(other *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) bool <span class="cov8" title="1">{
        if pop == nil || other == nil </span><span class="cov8" title="1">{
                return pop == other
        }</span>
        <span class="cov8" title="1">return pop.Signature.Equal(&amp;other.Signature)</span>
}

// Clone returns a deep copy of the proof of possession.
func (pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) Clone() *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S] <span class="cov8" title="1">{
        if pop == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]{Signature: *pop.Signature.Clone()}</span>
}

// TryAdd aggregates this proof of possession with another by elliptic curve point addition.
// Used when aggregating signatures that each have attached proofs.
func (pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) TryAdd(other *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) (*ProofOfPossession[Sig, SigFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if other == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot add nil proof of possession")
        }</span>
        <span class="cov8" title="1">v, err := pop.Signature.TryAdd(&amp;other.Signature)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not add signatures in proof of possession")
        }</span>
        <span class="cov8" title="1">return &amp;ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]{
                Signature: *v,
        }, nil</span>
}

// HashCode returns a hash of the proof for use in hash-based data structures.
func (pop *ProofOfPossession[Sig, SigFE, PK, PKFE, E, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return pop.Signature.HashCode()
}</span>

// AggregateAll combines multiple BLS elements (public keys, signatures, or proofs) into a single
// aggregate element via elliptic curve point addition.
//
// For public keys: aggregate_pk = pk_1 + pk_2 + ... + pk_n
// For signatures: aggregate_sig = sig_1 + sig_2 + ... + sig_n
//
// The aggregation is homomorphic, enabling efficient batch verification of multiple signatures.
// See: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-06.html#section-2.8
func AggregateAll[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, ET, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, ET, S], SGFE algebra.FieldElement[SGFE],
        ET algebra.MultiplicativeGroupElement[ET], S algebra.PrimeFieldElement[S],
        Xs ~[]X, X interface {
                TryAdd(other X) (X, error)
        },
](xs Xs) (X, error) <span class="cov8" title="1">{
        if len(xs) == 0 </span><span class="cov8" title="1">{
                return *new(X), ErrInvalidArgument.WithMessage("cannot aggregate empty slice of elements")
        }</span>
        <span class="cov8" title="1">result, err := iterutils.ReduceOrError(
                slices.Values(xs[1:]),
                xs[0],
                func(acc X, pk X) (X, error) </span><span class="cov8" title="1">{
                        aggregated, err := acc.TryAdd(pk)
                        if err != nil </span><span class="cov0" title="0">{
                                return *new(X), errs2.Wrap(err).WithMessage("could not aggregate public keys")
                        }</span>
                        <span class="cov8" title="1">return aggregated, nil</span>
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return *new(X), errs2.Wrap(err).WithMessage("failed to aggregate BLS elements")
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file298" style="display: none">// Package ecdsa implements the Elliptic Curve Digital Signature Algorithm (ECDSA)
// as specified in FIPS 186-5 and SEC 1, Version 2.0.
//
// ECDSA is a widely-used digital signature scheme based on elliptic curve cryptography.
// It provides the same level of security as RSA but with smaller key sizes, making it
// efficient for constrained environments.
//
// This implementation supports:
//   - Standard randomised ECDSA (requires secure random source)
//   - Deterministic ECDSA per RFC 6979 (no random source needed)
//   - Public key recovery from signatures (Bitcoin-style recovery ID)
//   - Signature normalisation to low-S form (BIP-62 compatible)
//
// References:
//   - FIPS 186-5: https://csrc.nist.gov/pubs/fips/186-5/final
//   - SEC 1 v2.0: https://www.secg.org/sec1-v2.pdf
//   - RFC 6979: https://www.rfc-editor.org/rfc/rfc6979
package ecdsa

import (
        "bytes"
        "crypto/elliptic"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
)

// Name is the canonical identifier for this signature scheme.
const Name signatures.Name = "ECDSA"

// Curve extends the base curves.Curve interface with ECDSA-specific operations.
// It adds point recovery from x-coordinate and conversion to Go's standard library
// elliptic curve representation for interoperability.
type Curve[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] interface {
        curves.Curve[P, B, S]
        // FromAffineX recovers a curve point from its x-coordinate. The boolean parameter
        // selects which of the two possible y values to use (true for odd y).
        FromAffineX(x B, b bool) (P, error)
        // ToElliptic returns the equivalent Go standard library elliptic curve.
        ToElliptic() elliptic.Curve
}

// ComputeRecoveryID calculates the recovery ID (v) for public key recovery from an ECDSA signature.
//
// The recovery ID is not part of the ECDSA standard but is a Bitcoin-originated concept that
// enables recovering the public key from just the signature and message hash. This is useful
// when verifying signatures against addresses rather than full public keys.
//
// The recovery ID encodes:
//   - Bit 0: y-coordinate parity (0 = even, 1 = odd)
//   - Bit 1: x-coordinate overflow (0 = r &lt; n, 1 = r &gt;= n where n is the subgroup order)
//
// Due to order of the base field being ~== order of the curve group, v is typically 0 or 1 in practice.
//
// References:
//   - Bitcoin message signing: https://en.bitcoin.it/wiki/Message_signing
//   - SEC 1 v2.0 Section 4.1.6: https://www.secg.org/sec1-v2.pdf
//   - EIP-155 (Ethereum): recovery ID is equivalent to v in Ethereum transactions
func ComputeRecoveryID[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](bigR P) (int, error) <span class="cov0" title="0">{
        rx, err := bigR.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return -1, errs2.Wrap(err).WithMessage("cannot compute x")
        }</span>
        <span class="cov0" title="0">ry, err := bigR.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return -1, errs2.Wrap(err).WithMessage("cannot compute y")
        }</span>

        <span class="cov0" title="0">curve := algebra.StructureMustBeAs[Curve[P, B, S]](bigR.Structure())
        subGroupOrder := curve.Order()

        var recoveryID int
        if !ry.IsOdd() </span><span class="cov0" title="0">{
                recoveryID = 0
        }</span> else<span class="cov0" title="0"> {
                recoveryID = 1
        }</span>

        <span class="cov0" title="0">if base.PartialCompare(rx.Cardinal(), subGroupOrder).IsGreaterThan() </span><span class="cov0" title="0">{
                recoveryID += 2
        }</span>

        <span class="cov0" title="0">return recoveryID, nil</span>
}

// RecoverPublicKey recovers the signer's public key from an ECDSA signature with recovery ID.
//
// This implements the public key recovery algorithm from SEC 1 v2.0, Section 4.1.6.
// Given a valid signature (r, s, v) and the original message, the algorithm:
//  1. Reconstructs the curve point R from r and recovery ID v
//  2. Computes Q = r^(-1) * (s*R - z*G) where z is the message hash and G is the generator
//
// The signature must include a valid recovery ID (v field). If the recovered public key
// does not match the expected signer, verification will fail.
//
// Reference: SEC 1 v2.0 Section 4.1.6: https://www.secg.org/sec1-v2.pdf
func RecoverPublicKey[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](suite *Suite[P, B, S], signature *Signature[S], message []byte) (*PublicKey[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil || signature == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("suite or signature is nil")
        }</span>
        <span class="cov8" title="1">if signature.v == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("no recovery id")
        }</span>

        // Calculate point R = (x1, x2) where
        //  x1 = r if (v &amp; 2) == 0 or (r + n) if (v &amp; 2) == 1
        //  y1 = value such that the curve equation is satisfied, y1 should be even when (v &amp; 1) == 0, odd otherwise
        <span class="cov8" title="1">rx, err := suite.baseField.FromWideBytes(signature.r.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot calculate r_x")
        }</span>
        <span class="cov8" title="1">if (*signature.v &amp; 0b10) != 0 </span><span class="cov0" title="0">{
                n, err := suite.baseField.FromWideBytes(suite.curve.Order().Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot calculate n")
                }</span>
                <span class="cov0" title="0">rx = rx.Add(n)</span>
        }
        <span class="cov8" title="1">r, err := suite.curve.FromAffineX(rx, (*signature.v&amp;0b1) != 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot calculate r")
        }</span>

        // Calculate point Q (public key)
        //  Q = r^(-1)(sR - zG)
        <span class="cov8" title="1">digest, err := hashing.Hash(suite.hashFunc, message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash message")
        }</span>
        <span class="cov8" title="1">z, err := DigestToScalar(suite.scalarField, digest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot calculate z")
        }</span>

        <span class="cov8" title="1">rInv, err := signature.r.TryInv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot calculate inverse of r")
        }</span>
        <span class="cov8" title="1">pkValue := (r.ScalarMul(signature.s).Sub(suite.curve.ScalarBaseMul(z))).ScalarMul(rInv)
        pk, err := NewPublicKey(pkValue)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot calculate public key")
        }</span>

        <span class="cov8" title="1">return pk, nil</span>
}

// DigestToScalar converts a message digest to a scalar value for ECDSA operations.
//
// Per FIPS 186-5 Section 6.4, the leftmost min(bitlen(digest), bitlen(n)) bits of the
// hash are used, where n is the subgroup order. For curves like P-521 where the order
// is not byte-aligned, a right shift is performed to extract the correct bits.
//
// The result is reduced modulo n to produce a valid scalar in the curve's scalar field.
//
// Reference: FIPS 186-5 Section 6.4.1 point 2 and Section 6.4.2 point 3
func DigestToScalar[S algebra.PrimeFieldElement[S]](field algebra.PrimeField[S], digest []byte) (S, error) <span class="cov8" title="1">{
        // ECDSA asks us to take the left-most log2(N) bits of hash, and use them as
        // an integer modulo N. This is the absolute worst of all worlds: we still
        // have to reduce, because the result might still overflow N, but to take
        // the left-most bits for P-521 we have to do a right shift.
        var nilS S
        n := field.ElementSize()
        if size := n; len(digest) &gt;= size </span><span class="cov8" title="1">{
                digest = digest[:size]
                if excess := len(digest)*8 - field.BitLen(); excess &gt; 0 </span><span class="cov0" title="0">{
                        var err error
                        digest, err = rightShift(digest, excess)
                        if err != nil </span><span class="cov0" title="0">{
                                return nilS, errs2.Wrap(err).WithMessage("internal error")
                        }</span>
                }
        }
        <span class="cov8" title="1">s, err := field.FromWideBytes(digest)
        if err != nil </span><span class="cov0" title="0">{
                return nilS, errs2.Wrap(err).WithMessage("truncated digest is too long")
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

// rightShift implements the right shift necessary for bits2int, which takes the
// leftmost bits of either the hash or HMAC_DRBG output.
//
// Note how taking the rightmost bits would have been as easy as masking the
// first byte, but we can't have nice things.
func rightShift(b []byte, shift int) ([]byte, error) <span class="cov0" title="0">{
        if shift &lt;= 0 || shift &gt;= 8 </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("shift can only be by 1 to 7 bits")
        }</span>
        <span class="cov0" title="0">b = bytes.Clone(b)
        for i := len(b) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                b[i] &gt;&gt;= shift
                if i &gt; 0 </span><span class="cov0" title="0">{
                        b[i] |= b[i-1] &lt;&lt; (8 - shift)
                }</span>
        }
        <span class="cov0" title="0">return b, nil</span>
}
</pre>
		
		<pre class="file" id="file299" style="display: none">package ecdsa

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// KeyGenerator generates ECDSA key pairs by sampling random scalars from the
// curve's scalar field and computing the corresponding public keys.
type KeyGenerator[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        curve       Curve[P, B, S]
        scalarField algebra.PrimeField[S]
}

// NewKeyGenerator creates a key generator for the specified elliptic curve.
func NewKeyGenerator[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](curve Curve[P, B, S]) *KeyGenerator[P, B, S] <span class="cov0" title="0">{
        scalarField := algebra.StructureMustBeAs[algebra.PrimeField[S]](curve.ScalarStructure())
        kg := &amp;KeyGenerator[P, B, S]{
                curve:       curve,
                scalarField: scalarField,
        }
        return kg
}</span>

// Generate creates a new ECDSA key pair using random bytes from the provided reader.
//
// The private key d is sampled uniformly from [1, n-1] where n is the curve order.
// The public key Q is computed as Q = d * G where G is the curve's generator.
//
// The prng must be a cryptographically secure random source (e.g., crypto/rand.Reader).
func (kg *KeyGenerator[P, B, S]) Generate(prng io.Reader) (*PrivateKey[P, B, S], *PublicKey[P, B, S], error) <span class="cov0" title="0">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov0" title="0">skRaw, err := kg.scalarField.Random(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample private key")
        }</span>
        <span class="cov0" title="0">pkRaw := kg.curve.ScalarBaseMul(skRaw)

        pk, err := NewPublicKey(pkRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create public key")
        }</span>
        <span class="cov0" title="0">sk, err := NewPrivateKey(skRaw.Clone(), pk.Clone())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create secret key")
        }</span>
        <span class="cov0" title="0">return sk, pk, nil</span>
}
</pre>
		
		<pre class="file" id="file300" style="display: none">package ecdsa

import (
        nativeEcdsa "crypto/ecdsa"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

// PublicKey represents an ECDSA public key as a point on an elliptic curve.
// The public key Q is computed as Q = d * G, where d is the private key scalar
// and G is the curve's generator point.
type PublicKey[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        pk P
}

type publicKeyDTO[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        PK P `cbor:"publicKey"`
}

// NewPublicKey creates a PublicKey from an elliptic curve point.
// The point must be a valid, non-zero point on a supported ECDSA curve.
func NewPublicKey[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](pk P) (*PublicKey[P, B, S], error) <span class="cov8" title="1">{
        if pk.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("public key is zero")
        }</span>
        <span class="cov8" title="1">if _, err := algebra.StructureAs[Curve[P, B, S]](pk.Structure()); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("curve structure is not supported")
        }</span>

        <span class="cov8" title="1">key := &amp;PublicKey[P, B, S]{
                pk: pk,
        }
        return key, nil</span>
}

// Value returns the underlying elliptic curve point.
func (pk *PublicKey[P, B, S]) Value() P <span class="cov8" title="1">{
        return pk.pk
}</span>

// Clone returns a deep copy of the public key.
func (pk *PublicKey[P, B, S]) Clone() *PublicKey[P, B, S] <span class="cov0" title="0">{
        if pk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">clone := &amp;PublicKey[P, B, S]{
                pk: pk.pk.Clone(),
        }
        return clone</span>
}

// Equal returns true if both public keys represent the same curve point.
func (pk *PublicKey[P, B, S]) Equal(rhs *PublicKey[P, B, S]) bool <span class="cov8" title="1">{
        if pk == nil || rhs == nil </span><span class="cov0" title="0">{
                return pk == rhs
        }</span>

        <span class="cov8" title="1">return pk.pk.Equal(rhs.pk)</span>
}

// HashCode returns a hash of the public key for use in hash-based data structures.
func (pk *PublicKey[P, B, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return pk.pk.HashCode()
}</span>

// ToElliptic converts the public key to Go's standard library ecdsa.PublicKey format.
// This enables interoperability with Go's crypto/ecdsa package.
func (pk *PublicKey[P, B, S]) ToElliptic() *nativeEcdsa.PublicKey <span class="cov8" title="1">{
        curve := algebra.StructureMustBeAs[Curve[P, B, S]](pk.pk.Structure())
        nativeCurve := curve.ToElliptic()
        nativeX := errs2.Must1(pk.Value().AffineX()).Cardinal().Big()
        nativeY := errs2.Must1(pk.Value().AffineY()).Cardinal().Big()
        nativePublicKey := &amp;nativeEcdsa.PublicKey{
                Curve: nativeCurve,
                X:     nativeX,
                Y:     nativeY,
        }
        return nativePublicKey
}</span>

// MarshalCBOR serialises the public key to CBOR format.
func (pk *PublicKey[P, B, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;publicKeyDTO[P, B, S]{
                PK: pk.pk,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal ECDSA PublicKey")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR deserializes a public key from CBOR format.
func (pk *PublicKey[P, B, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*publicKeyDTO[P, B, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">pk2, err := NewPublicKey(dto.PK)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*pk = *pk2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file301" style="display: none">package ecdsa

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
)

// Scheme represents a configured ECDSA signature scheme instance.
// It binds a cryptographic Suite with a random source and provides factory methods
// for creating key generators, signers, and verifiers.
type Scheme[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        suite *Suite[P, B, S]
        prng  io.Reader
}

// NewScheme creates a new ECDSA scheme from a suite and random source.
//
// For randomised ECDSA suites, prng must be a cryptographically secure random source
// (e.g., crypto/rand.Reader). For deterministic suites (RFC 6979), prng can be nil
// as the nonce is derived from the private key and message.
func NewScheme[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](suite *Suite[P, B, S], prng io.Reader) (*Scheme[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil || (!suite.IsDeterministic() &amp;&amp; prng == nil) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("suite or prng is nil")
        }</span>

        <span class="cov8" title="1">s := &amp;Scheme[P, B, S]{
                suite: suite,
                prng:  prng,
        }
        return s, nil</span>
}

// Name returns the signature scheme identifier ("ECDSA").
func (*Scheme[P, B, S]) Name() signatures.Name <span class="cov0" title="0">{
        return Name
}</span>

// Keygen creates a key generator for producing ECDSA key pairs.
func (s *Scheme[P, B, S]) Keygen(_ ...signatures.KeyGeneratorOption[*KeyGenerator[P, B, S], *PrivateKey[P, B, S], *PublicKey[P, B, S]]) (*KeyGenerator[P, B, S], error) <span class="cov0" title="0">{
        return NewKeyGenerator(s.suite.curve), nil
}</span>

// Signer creates a signer for producing ECDSA signatures with the given private key.
func (s *Scheme[P, B, S]) Signer(sk *PrivateKey[P, B, S], _ ...signatures.SignerOption[*Signer[P, B, S], []byte, *Signature[S]]) (*Signer[P, B, S], error) <span class="cov8" title="1">{
        sg, err := NewSigner(s.suite, sk, s.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("signer creation failed")
        }</span>
        <span class="cov8" title="1">return sg, nil</span>
}

// Verifier creates a verifier for validating ECDSA signatures.
func (s *Scheme[P, B, S]) Verifier(_ ...signatures.VerifierOption[*Verifier[P, B, S], *PublicKey[P, B, S], []byte, *Signature[S]]) (*Verifier[P, B, S], error) <span class="cov8" title="1">{
        vr, err := NewVerifier(s.suite)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("verifier creation failed")
        }</span>
        <span class="cov8" title="1">return vr, nil</span>
}

// Suite returns the cryptographic suite used by this scheme.
func (s *Scheme[P, B, S]) Suite() *Suite[P, B, S] <span class="cov0" title="0">{
        return s.suite
}</span>
</pre>
		
		<pre class="file" id="file302" style="display: none">package ecdsa

import (
        "math/big"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
)

// Signature represents an ECDSA signature consisting of two scalar values (r, s)
// and an optional recovery ID (v).
//
// The signature values are:
//   - r: the x-coordinate of the ephemeral public key R = k*G, reduced modulo n
//   - s: computed as s = k^(-1) * (z + r*d) mod n, where z is the message hash and d is the private key
//   - v: optional recovery ID (0-3) enabling public key recovery from the signature
//
// Reference: SEC 1 v2.0 Section 4.1: https://www.secg.org/sec1-v2.pdf
type Signature[S algebra.PrimeFieldElement[S]] struct {
        v *int
        r S
        s S
}

// NewSignature creates a Signature from r, s values and an optional recovery ID.
// Both r and s must be non-zero. If provided, v must be in the range [0, 3].
func NewSignature[S algebra.PrimeFieldElement[S]](r, s S, v *int) (*Signature[S], error) <span class="cov8" title="1">{
        if r.IsZero() || s.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("r/s cannot be zero")
        }</span>
        <span class="cov8" title="1">if v != nil &amp;&amp; (*v &lt; 0 || *v &gt; 3) </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("v must be 0/1/2/3")
        }</span>

        <span class="cov8" title="1">sig := &amp;Signature[S]{
                v,
                r,
                s,
        }
        return sig, nil</span>
}

// Clone returns a deep copy of the signature.
func (sig *Signature[S]) Clone() *Signature[S] <span class="cov0" title="0">{
        var v *int
        if sig.v != nil </span><span class="cov0" title="0">{
                v = new(int)
                *v = *sig.v
        }</span>
        <span class="cov0" title="0">clone := &amp;Signature[S]{
                v: v,
                r: sig.r.Clone(),
                s: sig.s.Clone(),
        }
        return clone</span>
}

// Equal returns true if both signatures have the same r and s values.
// Note: recovery ID (v) is not compared as it's metadata for key recovery.
func (sig *Signature[S]) Equal(rhs *Signature[S]) bool <span class="cov8" title="1">{
        if sig == nil || rhs == nil </span><span class="cov0" title="0">{
                return sig == rhs
        }</span>
        <span class="cov8" title="1">return sig.r.Equal(rhs.r) &amp;&amp; sig.s.Equal(rhs.s)</span>
}

// HashCode returns a hash of the signature for use in hash-based data structures.
func (sig *Signature[S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return sig.s.HashCode() ^ sig.r.HashCode()
}</span>

// R returns the r component of the signature (x-coordinate of ephemeral public key mod n).
func (sig *Signature[S]) R() S <span class="cov8" title="1">{
        return sig.r
}</span>

// S returns the s component of the signature.
func (sig *Signature[S]) S() S <span class="cov8" title="1">{
        return sig.s
}</span>

// V returns the recovery ID, or nil if not set.
// The recovery ID enables public key recovery from the signature.
func (sig *Signature[S]) V() *int <span class="cov0" title="0">{
        return sig.v
}</span>

// Normalise converts the signature to "low-S" canonical form.
//
// In ECDSA, both (r, s) and (r, n-s) are valid signatures for the same message.
// This malleability can cause issues in systems that use signature hashes as identifiers.
// Normalisation ensures s is in the lower half of its range [1, n/2], providing
// a unique canonical representation.
//
// This is required by Bitcoin (BIP-62) and Ethereum to prevent transaction malleability.
// The recovery ID is also adjusted when s is negated.
//
// Reference: BIP-62 https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki
func (sig *Signature[S]) Normalise() <span class="cov0" title="0">{
        if !sig.IsNormalized() </span><span class="cov0" title="0">{
                sig.s = sig.s.Neg()
                if sig.v != nil </span><span class="cov0" title="0">{
                        v := *sig.v ^ 1
                        sig.v = &amp;v
                }</span>
        }
}

// IsNormalized returns true if the signature is in low-S canonical form.
// A signature is normalised if s &lt;= n/2, where n is the curve order.
func (sig *Signature[S]) IsNormalized() bool <span class="cov0" title="0">{
        return sig.s.Cardinal().Big().Cmp(sig.s.Neg().Cardinal().Big()) &lt;= 0
}</span>

// ToElliptic returns the r and s values as big.Int for use with Go's crypto/ecdsa package.
func (sig *Signature[S]) ToElliptic() (r, s *big.Int) <span class="cov8" title="1">{
        nativeR := sig.r.Cardinal().Big()
        nativeS := sig.s.Cardinal().Big()
        return nativeR, nativeS
}</span>
</pre>
		
		<pre class="file" id="file303" style="display: none">package ecdsa

import (
        nativeEcdsa "crypto/ecdsa"
        "encoding/asn1"
        "io"
        "math/big"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

// Signer produces ECDSA signatures using a private key.
// It supports both randomised signing (with a PRNG) and deterministic signing (RFC 6979).
type Signer[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        suite *Suite[P, B, S]
        sk    *PrivateKey[P, B, S]
        prng  io.Reader
}

// NewSigner creates a signer with the given suite, private key, and random source.
// For randomised suites, prng must be a cryptographically secure random source.
// For deterministic suites (RFC 6979), prng can be nil.
func NewSigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](suite *Suite[P, B, S], sk *PrivateKey[P, B, S], prng io.Reader) (*Signer[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil || (prng == nil &amp;&amp; !suite.IsDeterministic()) || sk == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("suite or prng or secret key is nil")
        }</span>

        <span class="cov8" title="1">s := &amp;Signer[P, B, S]{
                suite: suite,
                sk:    sk,
                prng:  prng,
        }
        return s, nil</span>
}

// Sign creates an ECDSA signature on the given message.
//
// The signing process:
//  1. Hash the message using the suite's hash function
//  2. Generate ephemeral key k (random or deterministic per RFC 6979)
//  3. Compute R = k*G and set r = R.x mod n
//  4. Compute s = k^(-1) * (hash + r*d) mod n
//  5. Compute recovery ID v for public key recovery
//
// The returned signature includes r, s, and the recovery ID v.
func (s *Signer[P, B, S]) Sign(message []byte) (*Signature[S], error) <span class="cov8" title="1">{
        digest, err := hashing.Hash(s.suite.hashFunc, message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("hashing failed")
        }</span>
        <span class="cov8" title="1">nativeSk := s.sk.ToElliptic()

        var nativeR, nativeS *big.Int
        if s.suite.IsDeterministic() </span><span class="cov8" title="1">{
                asn1Sig, err := nativeSk.Sign(nil, digest, s.suite.hashID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("signing failed")
                }</span>

                // Parse ASN.1 DER-encoded signature to extract r and s
                <span class="cov8" title="1">var nativeEcdsaSig struct {
                        R, S *big.Int
                }
                _, err = asn1.Unmarshal(asn1Sig, &amp;nativeEcdsaSig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to parse ASN.1 signature")
                }</span>
                <span class="cov8" title="1">nativeR, nativeS = nativeEcdsaSig.R, nativeEcdsaSig.S</span>
        } else<span class="cov8" title="1"> {
                nativeR, nativeS, err = nativeEcdsa.Sign(s.prng, nativeSk, digest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("signing failed")
                }</span>
        }

        <span class="cov8" title="1">rr, err := s.suite.scalarField.FromWideBytes(nativeR.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert r")
        }</span>
        <span class="cov8" title="1">ss, err := s.suite.scalarField.FromWideBytes(nativeS.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert s")
        }</span>

        <span class="cov8" title="1">for i := range 5 </span><span class="cov8" title="1">{
                v := i
                signature, err := NewSignature(rr, ss, &amp;v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create signature")
                }</span>
                <span class="cov8" title="1">recoveredPk, err := RecoverPublicKey(s.suite, signature, message)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot recover public key")
                }</span>
                <span class="cov8" title="1">if recoveredPk.Equal(s.sk.pk) </span><span class="cov8" title="1">{
                        return signature, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, ErrVerificationFailed.WithMessage("cannot compute recovery id")</span>
}

// IsDeterministic returns true if this signer uses RFC 6979 deterministic nonce generation.
func (s *Signer[P, B, S]) IsDeterministic() bool <span class="cov0" title="0">{
        return s.suite.IsDeterministic()
}</span>
</pre>
		
		<pre class="file" id="file304" style="display: none">package ecdsa

import (
        nativeEcdsa "crypto/ecdsa"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// PrivateKey represents an ECDSA private key as a scalar value d in [1, n-1],
// where n is the order of the curve's base point. The corresponding public key
// Q = d * G is stored alongside for efficient access.
//
// Security: Private keys must be generated using a cryptographically secure
// random source and protected against disclosure.
type PrivateKey[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        sk S
        pk *PublicKey[P, B, S]
}

// NewPrivateKey creates a PrivateKey from a scalar value and its corresponding public key.
// The constructor validates that sk * G equals the provided public key to ensure consistency.
func NewPrivateKey[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](sk S, pk *PublicKey[P, B, S]) (*PrivateKey[P, B, S], error) <span class="cov8" title="1">{
        if pk == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key is nil")
        }</span>
        <span class="cov8" title="1">if sk.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("secret key is zero")
        }</span>
        <span class="cov8" title="1">curve, err := algebra.StructureAs[Curve[P, B, S]](pk.Value().Structure())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("curve structure is not supported")
        }</span>
        <span class="cov8" title="1">if !curve.ScalarBaseMul(sk).Equal(pk.Value()) </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("private key doesn't match public key")
        }</span>

        <span class="cov8" title="1">key := &amp;PrivateKey[P, B, S]{
                sk: sk,
                pk: pk,
        }
        return key, nil</span>
}

// Value returns the underlying scalar value of the private key.
func (sk *PrivateKey[P, B, S]) Value() S <span class="cov0" title="0">{
        return sk.sk
}</span>

// PublicKey returns the public key corresponding to this private key.
func (sk *PrivateKey[P, B, S]) PublicKey() *PublicKey[P, B, S] <span class="cov0" title="0">{
        return sk.pk
}</span>

// Equal returns true if both private keys have the same scalar value.
func (sk *PrivateKey[P, B, S]) Equal(rhs *PrivateKey[P, B, S]) bool <span class="cov0" title="0">{
        if sk == nil || rhs == nil </span><span class="cov0" title="0">{
                return sk == rhs
        }</span>
        <span class="cov0" title="0">return sk.sk.Equal(rhs.sk)</span>
}

// Clone returns a deep copy of the private key.
func (sk *PrivateKey[P, B, S]) Clone() *PrivateKey[P, B, S] <span class="cov0" title="0">{
        if sk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">clone := &amp;PrivateKey[P, B, S]{
                sk: sk.sk.Clone(),
                pk: sk.pk.Clone(),
        }
        return clone</span>
}

// ToElliptic converts the private key to Go's standard library ecdsa.PrivateKey format.
// This enables interoperability with Go's crypto/ecdsa package.
func (sk *PrivateKey[P, B, S]) ToElliptic() *nativeEcdsa.PrivateKey <span class="cov8" title="1">{
        nativeSk := &amp;nativeEcdsa.PrivateKey{
                PublicKey: *sk.pk.ToElliptic(),
                D:         sk.sk.Cardinal().Big(),
        }

        return nativeSk
}</span>
</pre>
		
		<pre class="file" id="file305" style="display: none">package ecdsa

import (
        "crypto"
        "hash"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

// Suite encapsulates the cryptographic parameters for an ECDSA instance.
// It binds together the elliptic curve, hash function, and signing mode (randomised
// or deterministic) to ensure consistent parameter usage across signing and verification.
type Suite[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        deterministic bool
        curve         Curve[P, B, S]
        baseField     algebra.PrimeField[B]
        scalarField   algebra.PrimeField[S]
        hashFunc      func() hash.Hash
        hashID        crypto.Hash
}

// NewSuite creates a new ECDSA suite for randomised signing.
// The hash function is used to compute message digests before signing.
//
// Common configurations:
//   - P-256 with SHA-256
//   - P-384 with SHA-384
//   - secp256k1 with SHA-256 (Bitcoin/Ethereum)
func NewSuite[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], H hash.Hash](curve Curve[P, B, S], hashFunc func() H) (*Suite[P, B, S], error) <span class="cov8" title="1">{
        if hashFunc == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("hash function is nil")
        }</span>
        <span class="cov8" title="1">scalarField := algebra.StructureMustBeAs[algebra.PrimeField[S]](curve.ScalarStructure())
        baseField := algebra.StructureMustBeAs[algebra.PrimeField[B]](curve.BaseStructure())

        s := &amp;Suite[P, B, S]{
                false,
                curve,
                baseField,
                scalarField,
                hashing.HashFuncTypeErase(hashFunc),
                0,
        }
        return s, nil</span>
}

// NewDeterministicSuite creates a new ECDSA suite for deterministic signing per RFC 6979.
//
// Deterministic ECDSA generates the nonce k from the private key and message hash using
// HMAC-DRBG, eliminating the need for a random source during signing. This prevents
// catastrophic nonce reuse vulnerabilities that have affected systems with poor entropy.
//
// The hash parameter must be a registered crypto.Hash that is available on the system.
//
// Reference: RFC 6979 - Deterministic Usage of DSA and ECDSA
func NewDeterministicSuite[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](curve Curve[P, B, S], h crypto.Hash) (*Suite[P, B, S], error) <span class="cov8" title="1">{
        if !h.Available() </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("hash function not available")
        }</span>
        <span class="cov8" title="1">scalarField := algebra.StructureMustBeAs[algebra.PrimeField[S]](curve.ScalarStructure())
        baseField := algebra.StructureMustBeAs[algebra.PrimeField[B]](curve.BaseStructure())

        s := &amp;Suite[P, B, S]{
                deterministic: true,
                curve:         curve,
                baseField:     baseField,
                scalarField:   scalarField,
                hashFunc:      h.New,
                hashID:        h,
        }
        return s, nil</span>
}

// IsDeterministic returns true if this suite uses RFC 6979 deterministic nonce generation.
func (s *Suite[P, B, S]) IsDeterministic() bool <span class="cov8" title="1">{
        return s.deterministic
}</span>

// Curve returns the elliptic curve used by this suite.
func (s *Suite[P, B, S]) Curve() Curve[P, B, S] <span class="cov0" title="0">{
        return s.curve
}</span>

// BaseField returns the prime field over which the curve is defined (coordinate field).
func (s *Suite[P, B, S]) BaseField() algebra.PrimeField[B] <span class="cov0" title="0">{
        return s.baseField
}</span>

// ScalarField returns the prime field of scalars (integers modulo the curve order).
func (s *Suite[P, B, S]) ScalarField() algebra.PrimeField[S] <span class="cov0" title="0">{
        return s.scalarField
}</span>

// HashFunc returns the hash function constructor used for message digests.
func (s *Suite[P, B, S]) HashFunc() func() hash.Hash <span class="cov0" title="0">{
        return s.hashFunc
}</span>

// HashID returns the crypto.Hash identifier for deterministic suites, or 0 for randomised suites.
func (s *Suite[P, B, S]) HashID() crypto.Hash <span class="cov0" title="0">{
        return s.hashID
}</span>
</pre>
		
		<pre class="file" id="file306" style="display: none">package ecdsa

import (
        nativeEcdsa "crypto/ecdsa"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

// Verifier validates ECDSA signatures against public keys.
// It uses the cryptographic parameters from the suite to ensure consistent
// hash function usage between signing and verification.
type Verifier[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        suite *Suite[P, B, S]
}

// NewVerifier creates a verifier with the given cryptographic suite.
// The suite defines the curve and hash function used for verification.
func NewVerifier[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](suite *Suite[P, B, S]) (*Verifier[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("suite is nil")
        }</span>

        <span class="cov8" title="1">v := &amp;Verifier[P, B, S]{
                suite: suite,
        }
        return v, nil</span>
}

// Verify checks that a signature is valid for a message under a public key.
//
// The verification process (per SEC 1 v2.0 Section 4.1.4):
//  1. Hash the message using the suite's hash function
//  2. Compute u1 = z * s^(-1) mod n and u2 = r * s^(-1) mod n
//  3. Compute R' = u1*G + u2*Q (where Q is the public key)
//  4. Accept if R'.x  r (mod n)
//
// If the signature includes a recovery ID (v), this method additionally verifies
// that the recovered public key matches the provided public key, providing an
// extra integrity check.
//
// Returns nil if the signature is valid, or an error describing the failure.
func (v *Verifier[P, B, S]) Verify(s *Signature[S], pk *PublicKey[P, B, S], m []byte) error <span class="cov8" title="1">{
        if s == nil || pk == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("signature &amp; public key cannot be nil")
        }</span>

        <span class="cov8" title="1">if s.v != nil </span><span class="cov8" title="1">{
                recoveredPublicKey, err := RecoverPublicKey(v.suite, s, m)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot recover public key")
                }</span>
                <span class="cov8" title="1">if !recoveredPublicKey.Equal(pk) </span><span class="cov0" title="0">{
                        return ErrVerificationFailed.WithMessage("recovered public key does not match")
                }</span>
        }

        <span class="cov8" title="1">digest, err := hashing.Hash(v.suite.hashFunc, m)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot hash message")
        }</span>

        <span class="cov8" title="1">nativePk := pk.ToElliptic()
        nativeR, nativeS := s.ToElliptic()
        ok := nativeEcdsa.Verify(nativePk, digest, nativeR, nativeS)
        if !ok </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("invalid signature")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file307" style="display: none">// Package bip340 implements BIP-340 Schnorr signatures for Bitcoin.
//
// BIP-340 defines a Schnorr signature scheme over the secp256k1 curve with
// specific design choices optimised for Bitcoin:
//
// # Key Features
//
//   - X-only public keys: Only the x-coordinate is used (32 bytes vs 33 compressed)
//   - Even y-coordinate constraint: R and P are implicitly lifted to have even y
//   - Tagged hashing: Domain-separated SHA-256 for aux, nonce, and challenge
//   - Deterministic nonce: k derived from private key, message, and auxiliary randomness
//
// # Signature Format
//
// A BIP-340 signature is 64 bytes: (R.x || s) where:
//   - R.x: 32-byte x-coordinate of the nonce commitment
//   - s: 32-byte response scalar
//
// # Security Properties
//
// The auxiliary randomness input protects against:
//   - Differential fault attacks
//   - Differential power analysis
//   - Nonce reuse with same message but different auxiliary data
//
// # Batch Verification
//
// BIP-340 supports efficient batch verification using random linear combinations,
// providing significant speedups when verifying multiple signatures.
//
// Reference: https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
package bip340

import (
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/k256"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
)

type (
        // Group is the secp256k1 elliptic curve used by BIP-340.
        Group = k256.Curve
        // GroupElement is a point on the secp256k1 curve.
        GroupElement = k256.Point
        // ScalarField is the field of integers modulo the secp256k1 group order.
        ScalarField = k256.ScalarField
        // Scalar is an element of the scalar field.
        Scalar = k256.Scalar

        // Message is a byte slice to be signed.
        Message = []byte
        // PublicKey is a BIP-340 public key (x-only, 32 bytes when serialised).
        PublicKey = schnorrlike.PublicKey[*GroupElement, *Scalar]
        // PrivateKey is a BIP-340 private key (32-byte scalar).
        PrivateKey = schnorrlike.PrivateKey[*GroupElement, *Scalar]
        // Signature is a BIP-340 signature (R.x || s, 64 bytes).
        Signature = schnorrlike.Signature[*GroupElement, *Scalar]
)

const (
        // AuxSizeBytes is the size of auxiliary randomness for nonce generation (32 bytes).
        // The aux data is XORed with the private key before hashing to derive the nonce.
        AuxSizeBytes int = 32
)

var (
        _ schnorrlike.Scheme[*Variant, *k256.Point, *k256.Scalar, Message, *KeyGenerator, *Signer, *Verifier] = (*Scheme)(nil)
        _ schnorrlike.Variant[*GroupElement, *Scalar, Message]                                                = (*Variant)(nil)
        _ schnorrlike.KeyGenerator[*GroupElement, *Scalar]                                                    = (*KeyGenerator)(nil)
        _ schnorrlike.Signer[*Variant, *GroupElement, *Scalar, Message]                                       = (*Signer)(nil)
        _ schnorrlike.Verifier[*Variant, *GroupElement, *Scalar, Message]

        _ tschnorr.MPCFriendlyScheme[*Variant, *GroupElement, *Scalar, Message, *KeyGenerator, *Signer, *Verifier] = (*Scheme)(nil)
        _ tschnorr.MPCFriendlyVariant[*GroupElement, *Scalar, Message]                                             = (*Variant)(nil)
)

// NewPublicKey creates a BIP-340 public key from a secp256k1 curve point.
// The point is validated to be non-identity and in the prime-order subgroup.
func NewPublicKey(point *GroupElement) (*PublicKey, error) <span class="cov8" title="1">{
        pk, err := schnorrlike.NewPublicKey(point)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BIP340 public key")
        }</span>
        <span class="cov8" title="1">return pk, nil</span>
}

// NewPrivateKey creates a BIP-340 private key from a scalar.
// The scalar must be non-zero. The corresponding public key P = xG is computed.
func NewPrivateKey(scalar *Scalar) (*PrivateKey, error) <span class="cov8" title="1">{
        if scalar == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("scalar is nil")
        }</span>
        <span class="cov8" title="1">if scalar.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("scalar is zero")
        }</span>
        <span class="cov8" title="1">pkv := k256.NewCurve().ScalarBaseMul(scalar)
        pk, err := schnorrlike.NewPublicKey(pkv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create public key")
        }</span>
        <span class="cov8" title="1">sk, err := schnorrlike.NewPrivateKey(scalar, pk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BIP340 private key")
        }</span>
        <span class="cov8" title="1">return sk, nil</span>
}

// NewSchemeWithAux creates a BIP-340 scheme with explicit auxiliary randomness.
// The aux data is used in nonce derivation: k = H(d XOR H(aux) || P || m).
// Use this when you need deterministic signatures with known aux data.
func NewSchemeWithAux(aux [AuxSizeBytes]byte) *Scheme <span class="cov8" title="1">{
        return &amp;Scheme{
                aux: aux,
        }
}</span>

// NewScheme creates a BIP-340 scheme with random auxiliary data.
// The aux data is sampled from prng and used for nonce derivation.
// This provides protection against side-channel attacks.
func NewScheme(prng io.Reader) (*Scheme, error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>

        <span class="cov8" title="1">aux := [AuxSizeBytes]byte{}
        _, err := io.ReadFull(prng, aux[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate nonce")
        }</span>
        <span class="cov8" title="1">return &amp;Scheme{
                aux: aux,
        }, nil</span>
}

// Scheme implements the BIP-340 Schnorr signature scheme.
// It provides key generation, signing, and verification following BIP-340.
type Scheme struct {
        aux [AuxSizeBytes]byte // Auxiliary randomness for nonce derivation
}

// Name returns the signature scheme identifier ("SchnorrLike").
func (Scheme) Name() signatures.Name <span class="cov0" title="0">{
        return schnorrlike.Name
}</span>

// Variant returns the BIP-340 variant configuration for this scheme.
func (s *Scheme) Variant() *Variant <span class="cov8" title="1">{
        return &amp;Variant{
                sk:         nil,
                Aux:        s.aux,
                msg:        nil,
                adjustedSk: nil,
        }
}</span>

// Keygen creates a key generator for BIP-340 key pairs.
func (*Scheme) Keygen(opts ...KeyGeneratorOption) (*KeyGenerator, error) <span class="cov0" title="0">{
        out := &amp;KeyGenerator{
                KeyGeneratorTrait: schnorrlike.KeyGeneratorTrait[*GroupElement, *Scalar]{
                        Grp: k256.NewCurve(),
                        SF:  k256.NewScalarField(),
                },
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(out); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("key generator option failed")
                }</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

// Signer creates a signer for producing BIP-340 signatures.
// The signer uses deterministic nonce derivation per BIP-340.
func (s *Scheme) Signer(privateKey *PrivateKey, opts ...SignerOption) (*Signer, error) <span class="cov8" title="1">{
        if privateKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("private key is nil")
        }</span>
        <span class="cov8" title="1">variant := &amp;Variant{
                sk:         privateKey,
                Aux:        s.aux,
                msg:        nil,
                adjustedSk: nil,
        }
        out := &amp;Signer{
                sg: schnorrlike.SignerTrait[*Variant, *GroupElement, *Scalar, Message]{
                        Sk: privateKey,
                        V:  variant,
                        Verifier: &amp;Verifier{
                                variant:            variant,
                                prng:               nil,
                                challengePublicKey: nil,
                        },
                },
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(out); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("signer option failed")
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// Verifier creates a verifier for validating BIP-340 signatures.
func (s *Scheme) Verifier(opts ...VerifierOption) (*Verifier, error) <span class="cov8" title="1">{
        out := &amp;Verifier{
                variant:            s.Variant(),
                prng:               nil,
                challengePublicKey: nil,
        }
        for _, opt := range opts </span><span class="cov8" title="1">{
                if err := opt(out); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("verifier option failed")
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// PartialSignatureVerifier creates a verifier for threshold/partial signatures.
// In MPC signing, each party produces a partial signature that must be verified
// against their individual public key share rather than the aggregate public key.
func (s *Scheme) PartialSignatureVerifier(
        publicKey *PublicKey,
        opts ...signatures.VerifierOption[*Verifier, *PublicKey, Message, *Signature],
) (schnorrlike.Verifier[*Variant, *GroupElement, *Scalar, Message], error) <span class="cov0" title="0">{
        if publicKey == nil || publicKey.Value() == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key is nil or invalid")
        }</span>
        <span class="cov0" title="0">verifier, err := s.Verifier(opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("verifier creation failed")
        }</span>
        <span class="cov0" title="0">verifier.challengePublicKey = publicKey
        return verifier, nil</span>
}

// NewSignatureFromBytes deserializes a BIP-340 signature from 64 bytes.
// The format is (R.x || s) where R.x is the 32-byte x-coordinate
// and s is the 32-byte response scalar.
func NewSignatureFromBytes(input []byte) (*Signature, error) <span class="cov8" title="1">{
        if len(input) != 64 </span><span class="cov0" title="0">{
                return nil, ErrSerialization.WithMessage("invalid length")
        }</span>

        <span class="cov8" title="1">r, err := decodePoint(input[:32])
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">s, err := k256.NewScalarField().FromBytes(input[32:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid signature")
        }</span>
        <span class="cov8" title="1">return &amp;Signature{
                E: nil,
                R: r,
                S: s,
        }, nil</span>
}

// KeyGeneratorOption configures key generation behaviour.
type KeyGeneratorOption = signatures.KeyGeneratorOption[*KeyGenerator, *PrivateKey, *PublicKey]

// KeyGenerator creates BIP-340 key pairs.
type KeyGenerator struct {
        schnorrlike.KeyGeneratorTrait[*GroupElement, *Scalar]
}

// SignerOption configures signing behaviour.
type SignerOption = signatures.SignerOption[*Signer, Message, *Signature]

// Signer produces BIP-340 signatures using deterministic nonce derivation.
type Signer struct {
        sg schnorrlike.SignerTrait[*Variant, *GroupElement, *Scalar, Message]
}

// Sign creates a BIP-340 signature on the message.
// The nonce is derived deterministically from the private key, message,
// and auxiliary randomness per BIP-340 specification.
func (s *Signer) Sign(message Message) (*Signature, error) <span class="cov8" title="1">{
        // ComputeNonceCommitment requires a message
        s.sg.V.msg = message
        sig, err := s.sg.Sign(message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to sign message")
        }</span>
        <span class="cov8" title="1">return sig, nil</span>
}

// Variant returns the BIP-340 variant used by this signer.
func (s *Signer) Variant() *Variant <span class="cov0" title="0">{
        return s.sg.V
}</span>

// VerifierOption configures verification behaviour.
type VerifierOption = signatures.VerifierOption[*Verifier, *PublicKey, Message, *Signature]

// VerifyWithPRNG configures the verifier with a PRNG for batch verification.
// The PRNG is used to generate random coefficients for the batch equation.
func VerifyWithPRNG(prng io.Reader) VerifierOption <span class="cov8" title="1">{
        return func(v *Verifier) error </span><span class="cov8" title="1">{
                if prng == nil </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("prng is nil")
                }</span>
                <span class="cov8" title="1">v.prng = prng
                return nil</span>
        }
}

// Verifier validates BIP-340 signatures.
type Verifier struct {
        variant            *Variant   // BIP-340 variant configuration
        prng               io.Reader  // PRNG for batch verification
        challengePublicKey *PublicKey // Override for partial signature verification
}

// Variant returns the BIP-340 variant used by this verifier.
func (v *Verifier) Variant() *Variant <span class="cov0" title="0">{
        return v.variant
}</span>

// Verify checks that a BIP-340 signature is valid for a message under a public key.
//
// The verification follows BIP-340 Section 4.2:
//  1. P = lift_x(pk) - lift public key to have even y
//  2. e = H(R.x || P || m) mod n - compute challenge
//  3. R' = sG - eP - compute expected nonce commitment
//  4. Verify R'.x = r and R' has even y
//
// Returns nil if valid, otherwise returns an error describing the failure.
func (v *Verifier) Verify(signature *Signature, publicKey *PublicKey, message Message) error <span class="cov8" title="1">{
        if publicKey == nil || publicKey.Value() == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("curve not supported")
        }</span>
        <span class="cov8" title="1">if signature == nil || signature.R == nil || signature.S == nil || signature.R.IsZero() || signature.S.IsZero() </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("some signature elements are nil/zero")
        }</span>
        <span class="cov8" title="1">if publicKey.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("public key is identity")
        }</span>
        <span class="cov8" title="1">if !publicKey.Value().IsTorsionFree() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("Public Key not in the prime subgroup")
        }</span>

        // For partial signature verification (when challengePublicKey is set), we should NOT
        // apply LiftX to the additive share P_i, as individual shares can have odd Y coordinates.
        // LiftX is only for standard BIP340 verification with x-only public keys.
        <span class="cov8" title="1">var bigP *GroupElement
        var challengePublicKeyValue *GroupElement
        if v.challengePublicKey != nil </span><span class="cov0" title="0">{
                // Partial signature verification mode: apply same parity correction to public key share
                // that was applied to private key shares during signing.
                correctedP, err := v.variant.CorrectPublicKeyShareParity(v.challengePublicKey, publicKey.Value())
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot correct public key share parity")
                }</span>
                <span class="cov0" title="0">bigP = correctedP
                challengePublicKeyValue = v.challengePublicKey.Value()</span>
        } else<span class="cov8" title="1"> {
                // Standard BIP340 verification
                // 1. Let P = lift_x(int(pk)).
                bigP = LiftX(publicKey.Value())
                challengePublicKeyValue = bigP
        }</span>

        // 2. (implicit) Let r = int(sig[0:32]); fail if r  p.
        // 3. (implicit) Let s = int(sig[32:64]); fail if s  n.

        // 4. Let e = int(hashBIP0340/challenge(bytes(r) || bytes(P) || m)) mod n.
        // For partial signature verification, use the pre-computed challenge from the signature
        // (which was computed from aggregate R), rather than recomputing from individual R_i.
        <span class="cov8" title="1">var e *Scalar
        if signature.E != nil </span><span class="cov8" title="1">{
                e = signature.E
        }</span> else<span class="cov8" title="1"> {
                var err error
                e, err = v.variant.ComputeChallenge(signature.R, challengePublicKeyValue, message)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot create challenge scalar")
                }</span>
        }

        // 5. Let R = sG - eP.
        <span class="cov8" title="1">bigR := k256.NewCurve().ScalarBaseMul(signature.S).Sub(bigP.ScalarMul(e))

        // 6. Fail if is_infinite(R).
        if bigR.IsZero() </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("signature is invalid")
        }</span>

        // For partial signature verification (when challengePublicKey is set), individual R_i values
        // may have odd Y coordinates. The even-Y constraint only applies to the aggregate signature.
        // We also need to compare the full point, not just x-coordinates.
        <span class="cov8" title="1">if v.challengePublicKey != nil </span><span class="cov0" title="0">{
                // Partial signature verification: check that computed R matches signature.R exactly
                if !bigR.Equal(signature.R) </span><span class="cov0" title="0">{
                        return ErrVerificationFailed.WithMessage("signature is invalid")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Standard BIP340 verification for aggregate signatures:

        // 7. Fail if not has_even_y(R).
        <span class="cov8" title="1">ry, err := bigR.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot compute y coordinate")
        }</span>
        <span class="cov8" title="1">if ry.IsOdd() </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("signature is invalid")
        }</span>

        // 8. Fail if x(R)  r.
        <span class="cov8" title="1">sigRx, err := signature.R.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot compute x coordinate")
        }</span>
        <span class="cov8" title="1">rx, err := bigR.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot compute x coordinate")
        }</span>
        <span class="cov8" title="1">if !sigRx.Equal(rx) </span><span class="cov8" title="1">{
                return ErrVerificationFailed.WithMessage("signature is invalid")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BatchVerify efficiently verifies multiple BIP-340 signatures using random linear combinations.
//
// The batch equation is: (s1 + a2s2 + ... + ausu)G = R1 + a2R2 + ... + auRu + e1P1 + (a2e2)P2 + ... + (aueu)Pu
//
// This is more efficient than individual verification when verifying many signatures,
// as it requires only one multi-scalar multiplication instead of u separate ones.
//
// The verifier must be initialised with a PRNG using VerifyWithPRNG option.
// The random coefficients a2...au prevent an attacker from constructing signatures
// that pass batch verification but fail individual verification.
func (v *Verifier) BatchVerify(sigs []*Signature, publicKeys []*PublicKey, messages []Message) error <span class="cov8" title="1">{
        if v.prng == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("batch verification requires a prng. Initialise the verifier with the prng option")
        }</span>
        <span class="cov8" title="1">if len(publicKeys) != len(sigs) || len(sigs) != len(messages) || len(sigs) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("length of publickeys, messages and signatures must be equal and greater than zero")
        }</span>
        <span class="cov8" title="1">if sliceutils.Any(publicKeys, func(pk *PublicKey) bool </span><span class="cov8" title="1">{
                return pk == nil || pk.Value() == nil || pk.Value().IsOpIdentity()
        }</span>) <span class="cov0" title="0">{

                return ErrInvalidArgument.WithMessage("some public keys are nil or identity")
        }</span>
        <span class="cov8" title="1">curve := k256.NewCurve()
        sf := k256.NewScalarField()
        var err error
        // 1. Generate u-1 random integers a2...u in the range 1...n-1.
        a := make([]*k256.Scalar, len(sigs))
        a[0] = sf.One()
        for i := 1; i &lt; len(sigs); i++ </span><span class="cov8" title="1">{
                a[i], err = algebrautils.RandomNonIdentity(sf, v.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("cannot generate random scalar for i=%d", i)
                }</span>
        }

        // For i = 1 .. u:
        <span class="cov8" title="1">left := sf.Zero()
        ae := make([]*k256.Scalar, len(sigs))
        bigR := make([]*k256.Point, len(sigs))
        bigP := make([]*k256.Point, len(sigs))
        for i, sig := range sigs </span><span class="cov8" title="1">{
                // 2. Let P_i = lift_x(int(pki))
                // 3. (implicit) Let r_i = int(sigi[0:32]); fail if ri  p.
                // 4. (implicit) Let s_i = int(sigi[32:64]); fail if si  n.
                bigP[i] = LiftX(publicKeys[i].Value())

                // 5. Let ei = int(hashBIP0340/challenge(bytes(r_i) || bytes(P_i) || mi)) mod n.
                e, err := v.variant.ComputeChallenge(sig.R, publicKeys[i].V, messages[i])
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("invalid signature")
                }</span>

                // 6. Let Ri = lift_x(ri); fail if lift_x(ri) fails.
                <span class="cov8" title="1">bigR[i] = LiftX(sigs[i].R)

                ae[i] = a[i].Mul(e)
                left = left.Add(a[i].Mul(sig.S))</span>
        }

        // 7. Fail if (s1 + a2s2 + ... + ausu)G  R1 + a2R2 + ... + auRu + e1P1 + (a2e2)P2 + ... + (aueu)Pu.
        <span class="cov8" title="1">rightA, err := curve.MultiScalarMul(a, bigR)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("failed to multiply scalars and points")
        }</span>
        <span class="cov8" title="1">rightB, err := curve.MultiScalarMul(ae, bigP)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("failed to multiply scalars and points")
        }</span>
        <span class="cov8" title="1">right := rightA.Add(rightB)
        if !curve.Generator().ScalarMul(left).Equal(right) </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("signature is invalid")
        }</span>

        // Return success iff no failure occurred before reaching this point.
        <span class="cov8" title="1">return nil</span>
}

// LiftX converts a point to have an even y-coordinate per BIP-340.
// If p.y is odd, returns -p (which has even y). Otherwise returns p unchanged.
// This is used to convert x-only public keys and R values to full curve points.
func LiftX(p *k256.Point) *k256.Point <span class="cov8" title="1">{
        if p.IsZero() </span><span class="cov0" title="0">{
                return p
        }</span>

        <span class="cov8" title="1">py, err := p.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                panic("this should never happen")</span>
        }
        <span class="cov8" title="1">if py.IsOdd() </span><span class="cov8" title="1">{
                return p.Neg()
        }</span>
        <span class="cov8" title="1">return p</span>
}

// SerializeSignature encodes a BIP-340 signature to 64 bytes: (R.x || s).
// The R point is encoded as its 32-byte x-coordinate (x-only encoding).
func SerializeSignature(signature *Signature) ([]byte, error) <span class="cov8" title="1">{
        if signature == nil || signature.R == nil || signature.S == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("signature is nil")
        }</span>
        <span class="cov8" title="1">return slices.Concat(signature.R.ToCompressed()[1:], signature.S.Bytes()), nil</span>
}

// NewPublicKeyFromBytes deserializes a BIP-340 public key from 32 bytes (x-only).
// The y-coordinate is implicitly even per the BIP-340 lift_x operation.
func NewPublicKeyFromBytes(input []byte) (*PublicKey, error) <span class="cov0" title="0">{
        p, err := decodePoint(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot decode point")
        }</span>
        <span class="cov0" title="0">pk, err := NewPublicKey(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create public key")
        }</span>
        <span class="cov0" title="0">return pk, nil</span>
}

// SerializePublicKey encodes a BIP-340 public key to 32 bytes (x-only).
// Only the x-coordinate is serialised; y is implicitly even.
func SerializePublicKey(publicKey *PublicKey) ([]byte, error) <span class="cov8" title="1">{
        if publicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key is nil")
        }</span>
        <span class="cov8" title="1">return publicKey.Value().ToCompressed()[1:], nil</span>
}

// encodePoint serialises a point to 32 bytes (x-coordinate only).
func encodePoint(p *k256.Point) []byte <span class="cov8" title="1">{
        return p.ToCompressed()[1:]
}</span>

// decodePoint deserializes a 32-byte x-coordinate to a curve point.
// The point is reconstructed with even y-coordinate (0x02 prefix).
func decodePoint(data []byte) (*k256.Point, error) <span class="cov8" title="1">{
        curve := k256.NewCurve()
        p, err := curve.FromCompressed(slices.Concat([]byte{0x02}, data))
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("cannot decode point")
        }</span>

        <span class="cov8" title="1">return p, nil</span>
}
</pre>
		
		<pre class="file" id="file308" style="display: none">package bip340

import (
        "crypto/subtle"
        "hash"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/k256"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/hashing/bip340"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/additive"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
)

// VariantType identifies this as the BIP-340 Schnorr variant.
const VariantType schnorrlike.VariantType = "bip340"

var (
        _ schnorrlike.Variant[*GroupElement, *Scalar, Message]         = (*Variant)(nil)
        _ tschnorr.MPCFriendlyVariant[*GroupElement, *Scalar, Message] = (*Variant)(nil)
)

// Variant implements BIP-340 specific signing behaviour.
// It handles the deterministic nonce derivation, even-y constraints,
// and tagged hashing required by BIP-340.
type Variant struct {
        sk         *PrivateKey        // Private key for deterministic nonce derivation
        Aux        [AuxSizeBytes]byte // Auxiliary randomness for nonce derivation
        msg        Message            // Message being signed (needed for nonce computation)
        adjustedSk *Scalar            // Private key d adjusted for P.y parity (negated if P.y is odd)
}

// Type returns the variant identifier "bip340".
func (*Variant) Type() schnorrlike.VariantType <span class="cov0" title="0">{
        return VariantType
}</span>

// HashFunc returns the BIP-340 tagged hash function for challenge computation.
// Uses SHA-256 with the tag "BIP0340/challenge" for domain separation.
func (*Variant) HashFunc() func() hash.Hash <span class="cov8" title="1">{
        return bip340.NewBip340HashChallenge
}</span>

// ComputeNonceCommitment implements BIP-340 deterministic nonce derivation.
//
// The nonce k is derived as:
//  1. t = d XOR H_aux(aux) where d is the (possibly negated) private key
//  2. rand = H_nonce(t || P || m)
//  3. k' = rand mod n
//  4. If R.y is odd, k = n - k' (to ensure R has even y)
//
// This deterministic derivation prevents nonce reuse vulnerabilities while
// the auxiliary randomness provides side-channel protection.
func (v *Variant) ComputeNonceCommitment() (R *GroupElement, k *Scalar, err error) <span class="cov8" title="1">{
        if v.sk == nil || v.msg == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("need both private key and message")
        }</span>
        <span class="cov8" title="1">g := k256.NewCurve().Generator()
        f := k256.NewScalarField()
        // 1. Let d' = int(sk)
        dPrime := v.sk.Value()
        // 2. Fail if d' = 0 or d'  n
        if dPrime.IsZero() </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("d' is invalid")
        }</span>
        // 3. Let P = d'G
        <span class="cov8" title="1">bigP := g.ScalarMul(v.sk.Value())
        // 4. Let d = d' if P.y even, otherwise let d = n - d'
        d := dPrime
        py, err := bigP.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute y")
        }</span>
        <span class="cov8" title="1">if py.IsOdd() </span><span class="cov8" title="1">{
                d = dPrime.Neg()
        }</span>
        // Store the adjusted private key for use in ComputeResponse
        <span class="cov8" title="1">v.adjustedSk = d
        // 5. Let t be the byte-wise xor of bytes(d) and hashBIP0340/aux(a).
        auxDigest, err := hashing.Hash(bip340.NewBip340HashAux, v.Aux[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("hash failed")
        }</span>
        <span class="cov8" title="1">t := make([]byte, len(auxDigest))
        if n := subtle.XORBytes(t, d.Bytes(), auxDigest); n != len(d.Bytes()) </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("invalid scalar bytes length")
        }</span>
        // 6. Let rand = hashBIP0340/nonce(t || bytes(P) || m).
        <span class="cov8" title="1">rand, err := hashing.Hash(
                bip340.NewBip340HashNonce, t, encodePoint(bigP), v.msg,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("hash failed")
        }</span>

        // 7. Let k' = int(rand) mod n.
        <span class="cov8" title="1">kPrime, err := f.FromWideBytes(rand)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot set k'")
        }</span>

        // 8. Fail if k' = 0
        <span class="cov8" title="1">if kPrime.IsZero() </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("k' is invalid")
        }</span>

        // 9. Let R = k'G.
        <span class="cov8" title="1">bigR := g.ScalarMul(kPrime)
        // 10. Let k = k' if R.y is even, otherwise let k = n - k', R = k  G
        k = kPrime
        ry, err := bigR.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute y")
        }</span>
        <span class="cov8" title="1">if ry.IsOdd() </span><span class="cov8" title="1">{
                k = kPrime.Neg()
                bigR = g.ScalarMul(k)
        }</span>
        <span class="cov8" title="1">return bigR, k, nil</span>
}

// ComputeChallenge computes the BIP-340 challenge using tagged hashing.
// e = H_challenge(R.x || P || m) mod n
//
// The challenge hash uses SHA-256 with the tag "BIP0340/challenge".
// R and P are encoded as 32-byte x-coordinates (x-only encoding).
func (v *Variant) ComputeChallenge(nonceCommitment, publicKeyValue *GroupElement, message Message) (*Scalar, error) <span class="cov8" title="1">{
        // 11. Let e = int(hashBIP0340/challenge(bytes(R) || bytes(P) || m)) mod n.
        roinput := slices.Concat(
                nonceCommitment.ToCompressed()[1:],
                publicKeyValue.ToCompressed()[1:],
                message,
        )

        e, err := schnorrlike.MakeGenericChallenge(k256.NewScalarField(), v.HashFunc(), false, roinput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("hash failed")
        }</span>
        <span class="cov8" title="1">return e, nil</span>
}

// ComputeResponse computes the BIP-340 signature response: s = k + ed mod n.
// Uses the adjusted private key d (negated if P.y was odd during nonce commitment).
func (v *Variant) ComputeResponse(privateKeyValue, nonce, challenge *Scalar) (*Scalar, error) <span class="cov8" title="1">{
        if privateKeyValue == nil || nonce == nil || challenge == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("arguments are nil")
        }</span>
        // Use the adjusted private key if available (from ComputeNonceCommitment)
        // This ensures we use d (not d') when P.y is odd
        <span class="cov8" title="1">adjustedPrivateKey := privateKeyValue
        if v.adjustedSk != nil </span><span class="cov8" title="1">{
                adjustedPrivateKey = v.adjustedSk
        }</span>
        <span class="cov8" title="1">s, err := schnorrlike.ComputeGenericResponse(adjustedPrivateKey, nonce, challenge, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compute BIP340 response")
        }</span>
        // 12. Let sig = (R, (k + ed) mod n)).
        <span class="cov8" title="1">return s, nil</span>
}

// SerializeSignature encodes the signature to 64 bytes: (R.x || s).
func (*Variant) SerializeSignature(signature *Signature) ([]byte, error) <span class="cov0" title="0">{
        return SerializeSignature(signature)
}</span>

// Clone creates a deep copy of the variant.
func (v *Variant) Clone() *Variant <span class="cov0" title="0">{
        out := &amp;Variant{
                sk:         nil,
                Aux:        v.Aux,
                msg:        nil,
                adjustedSk: nil,
        }
        if v.sk != nil </span><span class="cov0" title="0">{
                out.sk = v.sk.Clone()
        }</span>
        <span class="cov0" title="0">if v.msg != nil </span><span class="cov0" title="0">{
                copy(out.msg, v.msg)
        }</span>
        <span class="cov0" title="0">if v.adjustedSk != nil </span><span class="cov0" title="0">{
                out.adjustedSk = v.adjustedSk.Clone()
        }</span>
        <span class="cov0" title="0">return out</span>
}

// ============ MPC Methods ============.
//
// These methods support threshold/MPC Schnorr signing with BIP-340.
// BIP-340 requires R and P to have even y-coordinates, which requires
// special handling in distributed signing protocols.

var _ tschnorr.MPCFriendlyVariant[*k256.Point, *k256.Scalar, Message] = (*Variant)(nil)

// CorrectAdditiveSecretShareParity adjusts a secret share for BIP-340's even-y requirement.
//
// In threshold signing, each party holds a share of the private key x.
// If the aggregate public key P = xG has odd y, BIP-340 requires using -x instead.
// This method negates the share if P.y is odd, ensuring all parties use
// consistent (negated) shares when P.y is odd.
func (*Variant) CorrectAdditiveSecretShareParity(publicKey *PublicKey, share *additive.Share[*k256.Scalar]) (*additive.Share[*k256.Scalar], error) <span class="cov0" title="0">{
        if publicKey == nil || share == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key or secret share is nil")
        }</span>
        <span class="cov0" title="0">out := share.Clone()
        pky, err := publicKey.Value().AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute y")
        }</span>
        <span class="cov0" title="0">if pky.IsOdd() </span><span class="cov0" title="0">{
                // If the public key is odd, we need to negate the additive share
                // to ensure that the parity of the nonce commitment is correct.
                out, _ = additive.NewShare(share.ID(), share.Value().Neg(), nil)
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// CorrectPublicKeyShareParity applies the same parity correction to a public key share
// that CorrectAdditiveSecretShareParity applies to private key shares. This is needed
// for partial signature verification where the public key share must be corrected
// based on the aggregate public key's Y coordinate parity.
func (*Variant) CorrectPublicKeyShareParity(aggregatePublicKey *PublicKey, share *k256.Point) (*k256.Point, error) <span class="cov0" title="0">{
        if aggregatePublicKey == nil || share == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("aggregate public key or share is nil")
        }</span>
        <span class="cov0" title="0">pky, err := aggregatePublicKey.Value().AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute y")
        }</span>
        <span class="cov0" title="0">if pky.IsOdd() </span><span class="cov0" title="0">{
                // If the aggregate public key has odd Y, negate the share to match
                // the correction applied to private key shares during signing.
                return share.Neg(), nil
        }</span>
        <span class="cov0" title="0">return share, nil</span>
}

// CorrectPartialNonceParity adjusts a partial nonce for BIP-340's even-y requirement.
//
// In threshold signing, the aggregate nonce commitment R must have even y.
// After all parties contribute their nonce commitments and the aggregate R is known,
// if R.y is odd, each party must negate their partial nonce k_i.
// This ensures the aggregate response s = k_i + ex_i uses the correct nonces.
func (*Variant) CorrectPartialNonceParity(nonceCommitment *k256.Point, k *k256.Scalar) (*k256.Point, *k256.Scalar, error) <span class="cov0" title="0">{
        if nonceCommitment == nil || k == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("nonce commitment or k is nil")
        }</span>
        <span class="cov0" title="0">correctedK := k.Clone()
        y, err := nonceCommitment.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compute y")
        }</span>
        <span class="cov0" title="0">if y.IsOdd() </span><span class="cov0" title="0">{
                // If the nonce commitment is odd, we need to negate k to ensure that the parity is correct.
                correctedK = correctedK.Neg()
        }</span>
        <span class="cov0" title="0">correctedR := k256.NewCurve().ScalarBaseOp(correctedK)
        return correctedR, correctedK, nil</span>
}
</pre>
		
		<pre class="file" id="file309" style="display: none">package schnorrlike

import (
        "hash"
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
)

// ComputeGenericNonceCommitment generates a random nonce k and commitment R = kG.
// This is used by Schnorr variants that don't have deterministic nonce generation.
//
// The shouldNegateNonce callback allows variants to enforce parity constraints.
// For example, BIP-340 requires R to have an even y-coordinate, so if R.y is odd,
// the nonce k is negated to flip the parity of R.
//
// Returns the nonce commitment R and the nonce scalar k.
func ComputeGenericNonceCommitment[GE GroupElement[GE, S], S Scalar[S]](
        group Group[GE, S], prng io.Reader, shouldNegateNonce func(nonceCommitment GE) bool,
) (R GE, k S, err error) <span class="cov0" title="0">{
        if prng == nil </span><span class="cov0" title="0">{
                return *new(GE), *new(S), ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov0" title="0">sf, ok := group.ScalarStructure().(ScalarField[S])
        if !ok </span><span class="cov0" title="0">{
                return *new(GE), *new(S), ErrInvalidArgument.WithMessage("group type assertion failed")
        }</span>
        <span class="cov0" title="0">k, err = algebrautils.RandomNonIdentity(sf, prng)
        if err != nil </span><span class="cov0" title="0">{
                return *new(GE), *new(S), errs2.Wrap(err).WithMessage("scalar")
        }</span>
        <span class="cov0" title="0">if shouldNegateNonce != nil &amp;&amp; shouldNegateNonce(group.ScalarBaseOp(k)) </span><span class="cov0" title="0">{
                k = k.Neg()
        }</span>
        <span class="cov0" title="0">R = group.ScalarBaseOp(k)
        return R, k, nil</span>
}

// ComputeGenericResponse computes the Schnorr response scalar s = k  ex.
//
// The response equation is:
//   - s = k + ex when responseOperatorIsNegative is false (standard)
//   - s = k - ex when responseOperatorIsNegative is true
//
// Parameters:
//   - privateKeyValue: the private key scalar x
//   - nonce: the ephemeral nonce scalar k
//   - challenge: the Fiat-Shamir challenge e
//   - responseOperatorIsNegative: if true, subtracts ex instead of adding
func ComputeGenericResponse[S Scalar[S]](privateKeyValue, nonce, challenge S, responseOperatorIsNegative bool) (S, error) <span class="cov0" title="0">{
        if utils.IsNil(privateKeyValue) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("private key is nil")
        }</span>
        <span class="cov0" title="0">if utils.IsNil(nonce) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("nonce is nil")
        }</span>
        <span class="cov0" title="0">if utils.IsNil(challenge) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("challenge is nil")
        }</span>
        <span class="cov0" title="0">operand := challenge.Mul(privateKeyValue)
        if responseOperatorIsNegative </span><span class="cov0" title="0">{
                operand = operand.Neg()
        }</span>
        <span class="cov0" title="0">return nonce.Add(operand), nil</span>
}

// MakeGenericChallenge computes the Fiat-Shamir challenge by hashing inputs.
// This implements the transformation from interactive to non-interactive Schnorr:
// e = H(R || P || m) reduced modulo the scalar field order.
//
// The challengeElementsAreLittleEndian parameter controls byte ordering:
//   - false: inputs are treated as big-endian (standard for most curves)
//   - true: inputs are reversed to little-endian before hashing (used by some variants)
//
// The hash output is reduced modulo n using FromWideBytes to avoid bias.
func MakeGenericChallenge[S Scalar[S]](scalarField ScalarField[S], hashFunc func() hash.Hash, challengeElementsAreLittleEndian bool, xs ...[]byte) (S, error) <span class="cov0" title="0">{
        if scalarField == nil </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("scalar field is nil")
        }</span>
        <span class="cov0" title="0">for _, x := range xs </span><span class="cov0" title="0">{
                if x == nil </span><span class="cov0" title="0">{
                        return *new(S), ErrInvalidArgument.WithMessage("an input is nil")
                }</span>
        }
        <span class="cov0" title="0">digest, err := hashing.Hash(hashFunc, xs...)
        if err != nil </span><span class="cov0" title="0">{
                return *new(S), errs2.Wrap(err).WithMessage("could not compute fiat shamir hash")
        }</span>
        <span class="cov0" title="0">if challengeElementsAreLittleEndian </span><span class="cov0" title="0">{
                slices.Reverse(digest)
        }</span>
        <span class="cov0" title="0">challenge, err := scalarField.FromWideBytes(digest)
        if err != nil </span><span class="cov0" title="0">{
                return *new(S), errs2.Wrap(err).WithMessage("could not compute fiat shamir challenge")
        }</span>
        <span class="cov0" title="0">return challenge, nil</span>
}
</pre>
		
		<pre class="file" id="file310" style="display: none">package mina

import (
        "github.com/bronlabs/bron-crypto/pkg/base/base58"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// Base58Check version prefixes for Mina key and signature encoding.
// These prefixes ensure type safety and prevent accidental misuse of encoded data.
//
// Reference: https://github.com/MinaProtocol/mina/blob/develop/src/lib/base58_check/version_bytes.ml
const (
        // PrivateKeyBase58VersionPrefix (0x5A) identifies Base58-encoded private keys.
        PrivateKeyBase58VersionPrefix base58.VersionPrefix = 0x5A
        // NonZeroCurvePointCompressedBase58VersionPrefix (0xCB) identifies Base58-encoded public keys.
        NonZeroCurvePointCompressedBase58VersionPrefix base58.VersionPrefix = 0xCB
        // SignatureBase58VersionPrefix (0x9A) identifies Base58-encoded signatures.
        SignatureBase58VersionPrefix base58.VersionPrefix = 0x9A
)

// EncodePublicKey encodes a Mina public key to Base58Check format.
// The encoding uses version prefix 0xCB with additional bytes [0x01, 0x01],
// followed by the x-coordinate in little-endian and a y-parity byte.
// Format: Base58Check(0xCB || 0x01 || 0x01 || x_LE[32] || y_parity[1])
func EncodePublicKey(publicKey *PublicKey) (base58.Base58, error) <span class="cov8" title="1">{
        if publicKey == nil </span><span class="cov8" title="1">{
                return "", ErrInvalidArgument.WithMessage("public key is nil")
        }</span>
        // Mina uses a 3-byte version prefix: [0xCB, 0x01, 0x01]
        // Mina uses LITTLE-ENDIAN for field elements

        // Get x-coordinate and y-parity
        <span class="cov8" title="1">x, err := publicKey.V.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return "", errs2.Wrap(err).WithMessage("failed to get x coordinate")
        }</span>
        <span class="cov8" title="1">y, err := publicKey.V.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return "", errs2.Wrap(err).WithMessage("failed to get y coordinate")
        }</span>

        // Convert x from big-endian (internal) to little-endian (Mina format)
        <span class="cov8" title="1">xBytesBE := x.Bytes()
        xBytesLE := make([]byte, len(xBytesBE))
        for i := range xBytesBE </span><span class="cov8" title="1">{
                xBytesLE[i] = xBytesBE[len(xBytesBE)-1-i]
        }</span>

        <span class="cov8" title="1">yParity := byte(0)
        if y.IsOdd() </span><span class="cov8" title="1">{
                yParity = 1
        }</span>

        // Build payload: [0x01, 0x01] + x-coordinate (LE) + y-parity
        <span class="cov8" title="1">payload := make([]byte, 0, 2+32+1)
        payload = append(payload, 0x01, 0x01) // Additional version bytes
        payload = append(payload, xBytesLE...)
        payload = append(payload, yParity)

        return base58.CheckEncode(payload, NonZeroCurvePointCompressedBase58VersionPrefix), nil</span>
}

// DecodePublicKey decodes a Mina public key from Base58Check format.
// Validates the version prefix (0xCB) and additional bytes [0x01, 0x01],
// then reconstructs the curve point from x-coordinate and y-parity.
func DecodePublicKey(s base58.Base58) (*PublicKey, error) <span class="cov8" title="1">{
        data, v, err := base58.CheckDecode(s)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("failed to decode public key")
        }</span>
        <span class="cov8" title="1">if v != NonZeroCurvePointCompressedBase58VersionPrefix </span><span class="cov8" title="1">{
                return nil, ErrVerificationFailed.WithMessage("invalid version prefix for public key. got :%d, need :%d", v, NonZeroCurvePointCompressedBase58VersionPrefix)
        }</span>
        // Mina format: [0x01, 0x01] + x-coordinate (32 bytes, LE) + y-parity (1 byte) = 35 bytes
        <span class="cov8" title="1">if len(data) != 35 </span><span class="cov0" title="0">{
                return nil, ErrSerialization.WithMessage("decoded public key data. got :%d, need :%d", len(data), 35)
        }</span>
        // Verify additional version bytes
        <span class="cov8" title="1">if data[0] != 0x01 || data[1] != 0x01 </span><span class="cov0" title="0">{
                return nil, ErrVerificationFailed.WithMessage("invalid additional version bytes. got :[%02x, %02x], need :[0x01, 0x01]", data[0], data[1])
        }</span>

        // Extract x-coordinate and y-parity
        <span class="cov8" title="1">xBytesLE := data[2:34] // 32 bytes in little-endian
        yParity := data[34]    // 1 byte

        // Convert x from little-endian (Mina format) to big-endian (internal format)
        xBytesBE := make([]byte, len(xBytesLE))
        for i := range xBytesLE </span><span class="cov8" title="1">{
                xBytesBE[i] = xBytesLE[len(xBytesLE)-1-i]
        }</span>

        // Parse x-coordinate
        <span class="cov8" title="1">x, err := group.BaseField().FromBytes(xBytesBE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to parse x coordinate")
        }</span>

        // Reconstruct point from x and y-parity
        <span class="cov8" title="1">pkv, err := group.FromAffineX(x, yParity == 1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create public key from coordinates")
        }</span>
        <span class="cov8" title="1">publicKey, err := NewPublicKey(pkv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create public key")
        }</span>
        <span class="cov8" title="1">return publicKey, nil</span>
}

// EncodePrivateKey encodes a Mina private key to Base58Check format.
// The encoding uses version prefix 0x5A with additional byte 0x01,
// followed by the scalar value in little-endian.
// Format: Base58Check(0x5A || 0x01 || scalar_LE[32])
func EncodePrivateKey(privateKey *PrivateKey) (base58.Base58, error) <span class="cov8" title="1">{
        if privateKey == nil </span><span class="cov8" title="1">{
                return "", ErrInvalidArgument.WithMessage("private key is nil")
        }</span>
        // Mina uses a 2-byte version prefix for private keys: [0x5A, 0x01]
        // Mina uses LITTLE-ENDIAN for scalar bytes (contrary to our internal big-endian)
        <span class="cov8" title="1">scalarBytes := privateKey.V.Bytes()
        // Reverse to convert from big-endian (internal) to little-endian (Mina format)
        scalarBytesLE := make([]byte, len(scalarBytes))
        for i := range scalarBytes </span><span class="cov8" title="1">{
                scalarBytesLE[i] = scalarBytes[len(scalarBytes)-1-i]
        }</span>

        // Build payload: [0x01] + scalar (32 bytes, LE)
        <span class="cov8" title="1">payload := make([]byte, 0, 1+32)
        payload = append(payload, 0x01) // Additional version byte
        payload = append(payload, scalarBytesLE...)

        return base58.CheckEncode(payload, PrivateKeyBase58VersionPrefix), nil</span>
}

// DecodePrivateKey decodes a Mina private key from Base58Check format.
// Validates the version prefix (0x5A) and additional byte 0x01,
// then parses the scalar value from little-endian bytes.
func DecodePrivateKey(s base58.Base58) (*PrivateKey, error) <span class="cov8" title="1">{
        data, v, err := base58.CheckDecode(s)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("failed to decode private key")
        }</span>
        <span class="cov8" title="1">if v != PrivateKeyBase58VersionPrefix </span><span class="cov8" title="1">{
                return nil, ErrVerificationFailed.WithMessage("invalid version prefix for private key. got :%d, need :%d", v, PrivateKeyBase58VersionPrefix)
        }</span>
        // Mina format: [0x01] + scalar (32 bytes, LE) = 33 bytes
        <span class="cov8" title="1">if len(data) != 33 </span><span class="cov0" title="0">{
                return nil, ErrSerialization.WithMessage("decoded private key data. got :%d, need :%d", len(data), 33)
        }</span>
        // Verify additional version byte
        <span class="cov8" title="1">if data[0] != 0x01 </span><span class="cov0" title="0">{
                return nil, ErrVerificationFailed.WithMessage("invalid additional version byte. got :0x%02x, need :0x01", data[0])
        }</span>

        // Extract scalar bytes (skip first version byte)
        <span class="cov8" title="1">scalarBytesLE := data[1:] // 32 bytes in little-endian

        // Convert from little-endian (Mina format) to big-endian (internal format)
        scalarBytesBE := make([]byte, len(scalarBytesLE))
        for i := range scalarBytesLE </span><span class="cov8" title="1">{
                scalarBytesBE[i] = scalarBytesLE[len(scalarBytesLE)-1-i]
        }</span>

        <span class="cov8" title="1">skv, err := sf.FromBytes(scalarBytesBE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create scalar from bytes")
        }</span>
        <span class="cov8" title="1">privateKey, err := NewPrivateKey(skv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create private key")
        }</span>
        <span class="cov8" title="1">return privateKey, nil</span>
}

// EncodeSignature encodes a Mina signature to Base58Check format.
// The signature is first serialised to 64 bytes (R.x || s in little-endian),
// then encoded with version prefix 0x9A.
func EncodeSignature(signature *Signature) (base58.Base58, error) <span class="cov8" title="1">{
        if signature == nil </span><span class="cov8" title="1">{
                return "", ErrInvalidArgument.WithMessage("signature is nil")
        }</span>
        <span class="cov8" title="1">data, err := SerializeSignature(signature)
        if err != nil </span><span class="cov0" title="0">{
                return "", errs2.Wrap(err).WithMessage("failed to serialise signature")
        }</span>
        <span class="cov8" title="1">return base58.CheckEncode(data, SignatureBase58VersionPrefix), nil</span>
}

// DecodeSignature decodes a Mina signature from Base58Check format.
// Validates the version prefix (0x9A) and deserializes the 64-byte payload
// to reconstruct the signature (R point with even y, response scalar s).
func DecodeSignature(s base58.Base58) (*Signature, error) <span class="cov8" title="1">{
        data, v, err := base58.CheckDecode(s)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("failed to decode signature")
        }</span>
        <span class="cov8" title="1">if v != SignatureBase58VersionPrefix </span><span class="cov8" title="1">{
                return nil, ErrVerificationFailed.WithMessage("invalid version prefix for signature. got :%d, need :%d", v, SignatureBase58VersionPrefix)
        }</span>
        <span class="cov8" title="1">if len(data) != SignatureSize </span><span class="cov0" title="0">{
                return nil, ErrSerialization.WithMessage("decoded signature data. got :%d, need :%d", len(data), SignatureSize)
        }</span>
        <span class="cov8" title="1">sig, err := DeserializeSignature(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to deserialize signature")
        }</span>
        <span class="cov8" title="1">return sig, nil</span>
}
</pre>
		
		<pre class="file" id="file311" style="display: none">// Package mina implements Schnorr signatures for the Mina Protocol.
//
// Mina uses a Schnorr signature scheme over the Pallas curve (part of the Pasta
// curve cycle) with the Poseidon hash function for challenge computation.
// This signature scheme is used for transaction signing in the Mina blockchain.
//
// # Key Differences from Standard Schnorr
//
//   - Curve: Pallas (part of Pasta cycle, ~255-bit prime field)
//   - Hash: Poseidon algebraic hash over the base field
//   - Message format: ROInput (structured field elements and bits)
//   - Byte order: Little-endian for field elements
//   - Nonce derivation: Deterministic using Blake2b (legacy mode)
//   - R encoding: Only x-coordinate with implicit even y
//
// # Signature Format
//
// A Mina signature is 64 bytes: (R.x || s) in little-endian, where:
//   - R.x: 32-byte x-coordinate of the nonce commitment
//   - s: 32-byte response scalar
//
// The y-coordinate of R is always even (parity 0), enforced during signing.
//
// # Network IDs
//
// Mina uses network-specific prefixes for domain separation:
//   - MainNet: "MinaSignatureMainnet"
//   - TestNet: "CodaSignature*******"
//
// References:
//   - Mina Protocol: https://minaprotocol.com
//   - o1js implementation: https://github.com/o1-labs/o1js
package mina

import (
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing/poseidon"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
)

type (
        // Group is the Pallas elliptic curve used by Mina.
        Group = pasta.PallasCurve
        // GroupElement is a point on the Pallas curve.
        GroupElement = pasta.PallasPoint
        // ScalarField is the field of integers modulo the Pallas group order.
        ScalarField = pasta.PallasScalarField
        // Scalar is an element of the scalar field.
        Scalar = pasta.PallasScalar

        // Message is an ROInput containing structured field elements and bits.
        Message = ROInput
        // PublicKey is a Mina public key (Pallas curve point).
        PublicKey = schnorrlike.PublicKey[*GroupElement, *Scalar]
        // PrivateKey is a Mina private key (scalar).
        PrivateKey = schnorrlike.PrivateKey[*GroupElement, *Scalar]
        // Signature is a Mina signature (R.x || s, 64 bytes little-endian).
        Signature = schnorrlike.Signature[*GroupElement, *Scalar]
)

var (
        hashFunc = poseidon.NewLegacyHash
        group    = pasta.NewPallasCurve()
        sf       = pasta.NewPallasScalarField()

        // SignatureSize is the size of a serialised Mina signature (64 bytes).
        SignatureSize = group.ElementSize() + sf.ElementSize()
        // PublicKeySize is the size of a serialised Mina public key (32 bytes).
        PublicKeySize = group.ElementSize()
        // PrivateKeySize is the size of a Mina private key (32 bytes).
        PrivateKeySize = sf.ElementSize()

        _ schnorrlike.Scheme[*Variant, *GroupElement, *Scalar, *Message, *KeyGenerator, *Signer, *Verifier]         = (*Scheme)(nil)
        _ tschnorr.MPCFriendlyScheme[*Variant, *GroupElement, *Scalar, *Message, *KeyGenerator, *Signer, *Verifier] = (*Scheme)(nil)
)

// NewPublicKey creates a Mina public key from a Pallas curve point.
func NewPublicKey(point *GroupElement) (*PublicKey, error) <span class="cov8" title="1">{
        pk, err := schnorrlike.NewPublicKey(point)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create Mina public key")
        }</span>
        <span class="cov8" title="1">return pk, nil</span>
}

// NewPrivateKey creates a Mina private key from a scalar.
// The scalar must be non-zero. The corresponding public key P = xG is computed.
func NewPrivateKey(scalar *Scalar) (*PrivateKey, error) <span class="cov8" title="1">{
        if scalar == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("scalar is nil")
        }</span>
        <span class="cov8" title="1">if scalar.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("scalar is zero")
        }</span>
        <span class="cov8" title="1">pkv := group.ScalarBaseMul(scalar)
        pk, err := schnorrlike.NewPublicKey(pkv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create public key")
        }</span>
        <span class="cov8" title="1">sk, err := schnorrlike.NewPrivateKey(scalar, pk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create Mina private key")
        }</span>
        <span class="cov8" title="1">return sk, nil</span>
}

// NewScheme creates a Mina signature scheme with deterministic nonce derivation.
// The nonce is derived from the private key, public key, and network ID using
// Blake2b, following the legacy Mina/o1js implementation.
func NewScheme(nid NetworkID, privateKey *PrivateKey) (*Scheme, error) <span class="cov8" title="1">{
        vr, err := NewDeterministicVariant(nid, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create variant")
        }</span>
        <span class="cov8" title="1">return &amp;Scheme{
                vr: vr,
        }, nil</span>
}

// NewRandomisedScheme creates a Mina signature scheme with random nonce generation.
// This is typically used for MPC/threshold signing where nonces are generated
// collaboratively rather than deterministically.
func NewRandomisedScheme(nid NetworkID, prng io.Reader) (*Scheme, error) <span class="cov8" title="1">{
        vr, err := NewRandomisedVariant(nid, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create variant")
        }</span>
        <span class="cov8" title="1">return &amp;Scheme{
                vr: vr,
        }, nil</span>
}

// Scheme implements the Mina Schnorr signature scheme.
// It supports both deterministic and randomised nonce generation modes.
type Scheme struct {
        vr *Variant
}

// Name returns the signature scheme identifier ("SchnorrLike").
func (*Scheme) Name() signatures.Name <span class="cov0" title="0">{
        return schnorrlike.Name
}</span>

// Variant returns the Mina variant configuration for this scheme.
func (s *Scheme) Variant() *Variant <span class="cov0" title="0">{
        return s.vr
}</span>

// Keygen creates a key generator for Mina key pairs.
func (*Scheme) Keygen(opts ...KeyGeneratorOption) (*KeyGenerator, error) <span class="cov8" title="1">{
        kg := &amp;KeyGenerator{
                schnorrlike.KeyGeneratorTrait[*GroupElement, *Scalar]{
                        Grp: group,
                        SF:  sf,
                },
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(kg); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to apply key generator option")
                }</span>
        }
        <span class="cov8" title="1">return kg, nil</span>
}

// Signer creates a signer for producing Mina signatures.
func (s *Scheme) Signer(privateKey *PrivateKey, opts ...SignerOption) (*Signer, error) <span class="cov8" title="1">{
        if privateKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("private key is nil")
        }</span>
        <span class="cov8" title="1">verifier, err := s.Verifier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("verifier creation failed")
        }</span>
        <span class="cov8" title="1">signer := &amp;Signer{
                schnorrlike.SignerTrait[*Variant, *GroupElement, *Scalar, *Message]{
                        Sk:       privateKey,
                        V:        s.vr,
                        Verifier: verifier,
                },
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(signer); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to apply signer option")
                }</span>
        }
        <span class="cov8" title="1">return signer, nil</span>
}

// Verifier creates a verifier for validating Mina signatures.
func (s *Scheme) Verifier(opts ...VerifierOption) (*Verifier, error) <span class="cov8" title="1">{
        verifier := &amp;Verifier{
                VerifierTrait: schnorrlike.VerifierTrait[*Variant, *GroupElement, *Scalar, *Message]{
                        V:                          s.vr,
                        ResponseOperatorIsNegative: false,
                        ChallengePublicKey:         nil,
                },
                prng: nil,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(verifier); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to apply verifier option")
                }</span>
        }
        <span class="cov8" title="1">return verifier, nil</span>
}

// PartialSignatureVerifier creates a verifier for threshold/partial signatures.
func (s *Scheme) PartialSignatureVerifier(publicKey *PublicKey, opts ...signatures.VerifierOption[*Verifier, *PublicKey, *Message, *Signature]) (schnorrlike.Verifier[*Variant, *GroupElement, *Scalar, *Message], error) <span class="cov0" title="0">{
        if publicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key is nil")
        }</span>
        <span class="cov0" title="0">verifier, err := s.Verifier(opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("verifier creation failed")
        }</span>
        <span class="cov0" title="0">verifier.ChallengePublicKey = publicKey
        return verifier, nil</span>
}

// KeyGeneratorOption configures key generation behaviour.
type KeyGeneratorOption = signatures.KeyGeneratorOption[*KeyGenerator, *PrivateKey, *PublicKey]

// KeyGenerator creates Mina key pairs on the Pallas curve.
type KeyGenerator struct {
        schnorrlike.KeyGeneratorTrait[*GroupElement, *Scalar]
}

// SignerOption configures signing behaviour.
type SignerOption = signatures.SignerOption[*Signer, *Message, *Signature]

// Signer produces Mina signatures.
type Signer struct {
        schnorrlike.SignerTrait[*Variant, *GroupElement, *Scalar, *Message]
}

// Sign creates a Mina signature on the given message.
// The message is set on the variant before signing to enable deterministic
// nonce derivation that includes the message content.
func (s *Signer) Sign(message *Message) (*Signature, error) <span class="cov8" title="1">{
        // Set message on variant for deterministic nonce derivation
        s.V.msg = message
        sig, err := s.SignerTrait.Sign(message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to sign message")
        }</span>
        <span class="cov8" title="1">return sig, nil</span>
}

// VerifierOption configures verification behaviour.
type VerifierOption = signatures.VerifierOption[*Verifier, *PublicKey, *Message, *Signature]

// VerifyWithPRNG configures the verifier with a PRNG (for future batch verification).
func VerifyWithPRNG(prng io.Reader) VerifierOption <span class="cov0" title="0">{
        return func(v *Verifier) error </span><span class="cov0" title="0">{
                if prng == nil </span><span class="cov0" title="0">{
                        return ErrInvalidArgument.WithMessage("prng is nil")
                }</span>
                <span class="cov0" title="0">v.prng = prng
                return nil</span>
        }
}

// Verifier validates Mina signatures.
type Verifier struct {
        schnorrlike.VerifierTrait[*Variant, *GroupElement, *Scalar, *Message]

        prng io.Reader // PRNG for future batch verification support
}

// SerializeSignature encodes a Mina signature to 64 bytes in little-endian format.
// The format is (R.x || s) where both components are in little-endian byte order.
// This matches the Mina/o1js serialisation convention.
func SerializeSignature(signature *Signature) ([]byte, error) <span class="cov8" title="1">{
        if signature == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("signature is nil")
        }</span>
        // Mina uses LITTLE-ENDIAN for field elements
        <span class="cov8" title="1">rx, err := signature.R.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to serialise signature")
        }</span>

        // Convert R.x from big-endian to little-endian
        <span class="cov8" title="1">rxBytesBE := rx.Bytes()
        rxBytesLE := make([]byte, len(rxBytesBE))
        for i := range rxBytesBE </span><span class="cov8" title="1">{
                rxBytesLE[i] = rxBytesBE[len(rxBytesBE)-1-i]
        }</span>

        // Convert S from big-endian to little-endian
        <span class="cov8" title="1">sBytesBE := signature.S.Bytes()
        sBytesLE := make([]byte, len(sBytesBE))
        for i := range sBytesBE </span><span class="cov8" title="1">{
                sBytesLE[i] = sBytesBE[len(sBytesBE)-1-i]
        }</span>

        <span class="cov8" title="1">out := slices.Concat(rxBytesLE, sBytesLE)
        if len(out) != SignatureSize </span><span class="cov0" title="0">{
                return nil, ErrSerialization.WithMessage("invalid signature size. got :%d, need :%d", len(out), SignatureSize)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// DeserializeSignature parses a Mina signature from 64 bytes in little-endian format.
// The R point is reconstructed from its x-coordinate with even y-coordinate (parity 0).
// The challenge E is not stored and will be recomputed during verification.
func DeserializeSignature(input []byte) (*Signature, error) <span class="cov8" title="1">{
        if len(input) != SignatureSize </span><span class="cov8" title="1">{
                return nil, ErrSerialization.WithMessage("invalid signature size. got :%d, need :%d", len(input), SignatureSize)
        }</span>

        <span class="cov8" title="1">rxBytesLE := input[:group.ElementSize()]
        sBytesLE := input[group.ElementSize():]

        // Mina uses LITTLE-ENDIAN for field elements
        // Convert R.x from little-endian to big-endian
        rxBytesBE := make([]byte, len(rxBytesLE))
        for i := range rxBytesLE </span><span class="cov8" title="1">{
                rxBytesBE[i] = rxBytesLE[len(rxBytesLE)-1-i]
        }</span>

        // Parse R.x as a base field element
        <span class="cov8" title="1">rx, err := group.BaseField().FromBytes(rxBytesBE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to parse R.x")
        }</span>

        // Reconstruct R from x-coordinate
        // Mina signatures always have R with even y-coordinate (parity=0)
        <span class="cov8" title="1">R, err := group.FromAffineX(rx, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to reconstruct R from x-coordinate")
        }</span>

        // Convert S from little-endian to big-endian
        <span class="cov8" title="1">sBytesBE := make([]byte, len(sBytesLE))
        for i := range sBytesLE </span><span class="cov8" title="1">{
                sBytesBE[i] = sBytesLE[len(sBytesLE)-1-i]
        }</span>

        <span class="cov8" title="1">s, err := sf.FromBytes(sBytesBE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create scalar from bytes")
        }</span>

        <span class="cov8" title="1">return &amp;Signature{
                E: nil, // E is not stored in Mina signatures, it will be recomputed during verification
                R: R,
                S: s,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file312" style="display: none">package mina

import (
        "fmt"
        "math/big"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/hashing/poseidon"
)

// NetworkID identifies a Mina network for domain separation in signatures.
// Different networks use different prefixes to prevent signature replay attacks
// across networks.
type NetworkID string

const (
        // TestNet is the Mina test network, using the legacy "CodaSignature" prefix.
        // Reference: https://github.com/o1-labs/o1js-bindings/blob/df8c87ed6804465f79196fdff84e5147ae71e92d/crypto/constants.ts#L13
        TestNet NetworkID = "testnet"
        // MainNet is the Mina main network, using the "MinaSignatureMainnet" prefix.
        MainNet NetworkID = "mainnet"
)

var (
        // testNetHashInput is the network ID byte for TestNet (0x00) used in nonce derivation.
        testNetHashInput = new(big.Int).SetUint64(0x00)
        // mainNetHashInput is the network ID byte for MainNet (0x01) used in nonce derivation.
        mainNetHashInput = new(big.Int).SetUint64(0x01)
)

// Prefix is a domain separation string used in Mina's signature hashing.
// It is converted to a field element and included in the Poseidon hash input.
type Prefix []byte

// ToBaseFieldElement converts the prefix to a Pallas base field element.
// The prefix bytes are interpreted as a little-endian integer and converted
// to a field element for use in Poseidon hashing.
//
// Reference: https://github.com/o1-labs/o1js-bindings/blob/df8c87ed6804465f79196fdff84e5147ae71e92d/lib/binable.ts#L317
func (p Prefix) ToBaseFieldElement() (*pasta.PallasBaseFieldElement, error) <span class="cov8" title="1">{
        fieldSize := pasta.NewPallasBaseField().ElementSize() // TODO: ensure this is correct size
        if len(p) &gt; fieldSize </span><span class="cov8" title="1">{
                return nil, ErrSerialization.WithMessage("prefix too long")
        }</span>

        <span class="cov8" title="1">var feBytes [32]byte
        copy(feBytes[:], p)
        slices.Reverse(feBytes[:])
        out, err := pasta.NewPallasBaseField().FromBytes(feBytes[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("set bytes failed")
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// SignaturePrefix returns the domain separation prefix for signatures on the given network.
// MainNet uses "MinaSignatureMainnet" and TestNet uses "CodaSignature*******" (legacy).
// Custom network IDs generate a prefix by padding/truncating to exactly 20 characters.
//
// Reference: https://github.com/o1-labs/o1js/blob/885b50e60ead596cdcd8dc944df55fd3a4467a0a/src/mina-signer/src/signature.ts#L354
func SignaturePrefix(nid NetworkID) Prefix <span class="cov8" title="1">{
        switch nid </span>{
        case MainNet:<span class="cov8" title="1">
                return []byte("MinaSignatureMainnet")</span>
        case TestNet:<span class="cov8" title="1">
                return []byte("CodaSignature*******")</span>
        default:<span class="cov8" title="1">
                return createCustomPrefix(string(nid) + ("Signature"))</span>
        }
}

// createCustomPrefix creates a 20-character prefix from a custom network ID string.
// If the input is shorter than 20 characters, it is padded with '*' characters.
// If longer, it is truncated to 20 characters.
//
// Reference: https://github.com/o1-labs/o1js/blob/885b50e60ead596cdcd8dc944df55fd3a4467a0a/src/mina-signer/src/signature.ts#L354
func createCustomPrefix(input string) Prefix <span class="cov8" title="1">{
        maxLength := 20
        paddingChar := '*'
        length := len(input)
        if length &lt;= maxLength </span><span class="cov8" title="1">{
                diff := maxLength - length
                padding := make([]byte, diff)
                for i := range diff </span><span class="cov8" title="1">{
                        padding[i] = byte(paddingChar)
                }</span>
                <span class="cov8" title="1">return slices.Concat([]byte(input), padding)</span>
        } else<span class="cov8" title="1"> {
                return []byte(input[:maxLength])
        }</span>
}

// getNetworkIDHashInput returns the network ID as a big.Int and its bit length
// for inclusion in the nonce derivation hash. MainNet is 0x01 (8 bits),
// TestNet is 0x00 (8 bits), and custom networks encode the string as bits.
//
// Reference: https://github.com/o1-labs/o1js/blob/fdc94dd8d3735d01c232d7d7af49763e044b738b/src/mina-signer/src/signature.ts#L305
func getNetworkIDHashInput(nid NetworkID) (val *big.Int, bitLen int) <span class="cov8" title="1">{
        switch nid </span>{
        case MainNet:<span class="cov8" title="1">
                return mainNetHashInput, 8</span>
        case TestNet:<span class="cov8" title="1">
                return testNetHashInput, 8</span>
        default:<span class="cov8" title="1">
                return networkIDOfString(string(nid))</span>
        }
}

// numberToBytePadded formats a byte as an 8-character binary string, zero-padded.
// Equivalent to JS: (b: number) =&gt; b.toString(2).padStart(8, '0')
//
// Reference: https://github.com/o1-labs/o1js/blob/fdc94dd8d3735d01c232d7d7af49763e044b738b/src/mina-signer/src/signature.ts#L292
func numberToBytePadded(b byte) string <span class="cov8" title="1">{
        return fmt.Sprintf("%08b", b)
}</span>

// networkIDOfString converts a custom network ID string to a big.Int and bit length.
// The string is encoded as reversed binary digits (each character as 8-bit MSB-first),
// then interpreted as an integer. Returns the value and total bit count.
//
// Reference: https://github.com/o1-labs/o1js/blob/fdc94dd8d3735d01c232d7d7af49763e044b738b/src/mina-signer/src/signature.ts#L294
func networkIDOfString(n string) (val *big.Int, bitLen int) <span class="cov8" title="1">{
        acc := ""
        for i := len(n) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                b := n[i]
                padded := numberToBytePadded(b)
                acc += padded
        }</span>
        <span class="cov8" title="1">val = new(big.Int)
        val.SetString(acc, 2)
        return val, len(acc)</span>
}

// bytesToBits converts a byte slice to a bit slice in LSB-first order per byte.
// Each byte is expanded to 8 bits, with the least significant bit first.
// This matches the o1js binable encoding.
//
// Reference: https://github.com/o1-labs/o1js/blob/fdc94dd8d3735d01c232d7d7af49763e044b738b/src/bindings/lib/binable.ts#L315
func bytesToBits(bytes []byte) []bool <span class="cov8" title="1">{
        bits := make([]bool, 0, len(bytes)*8)
        for _, b := range bytes </span><span class="cov8" title="1">{
                for range 8 </span><span class="cov8" title="1">{
                        bits = append(bits, b&amp;1 == 1)
                        b &gt;&gt;= 1
                }</span>
        }
        <span class="cov8" title="1">return bits</span>
}

// reversedBytes returns a new byte slice with elements in reversed order.
// Used to convert between big-endian and little-endian byte representations.
func reversedBytes(b []byte) []byte <span class="cov8" title="1">{
        result := make([]byte, len(b))
        for i := range b </span><span class="cov8" title="1">{
                result[i] = b[len(b)-1-i]
        }</span>
        <span class="cov8" title="1">return result</span>
}

// hashWithPrefix computes a Poseidon hash with domain separation.
// The prefix is converted to a field element and prepended to the inputs,
// then hashed using Poseidon Legacy. The result is returned as a scalar
// for use as a Fiat-Shamir challenge in signature computation.
//
// Reference: https://github.com/o1-labs/o1js/blob/885b50e60ead596cdcd8dc944df55fd3a4467a0a/src/lib/provable/crypto/hash-generic.ts#L23
func hashWithPrefix(prefix Prefix, inputs ...*pasta.PallasBaseFieldElement) (*Scalar, error) <span class="cov8" title="1">{
        h := poseidon.NewLegacy()

        // salt
        pfe, err := prefix.ToBaseFieldElement()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not convert prefix to base field element")
        }</span>
        <span class="cov8" title="1">h.Update(pfe)

        // hashWithPrefix itself
        h.Update(inputs...)

        digest := h.Digest()
        s, err := sf.FromBytes(digest.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot deserialize scalar")
        }</span>

        <span class="cov8" title="1">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file313" style="display: none">package mina

import (
        "encoding/hex"
        "encoding/json"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/bitvec"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

var (
        _ json.Marshaler = (*ROInput)(nil)
)

// ROInput (Random Oracle Input) is the message format for Mina signatures.
// It accumulates field elements and bits that are packed into Pallas base field
// elements for hashing with Poseidon.
//
// The ROInput format allows efficient representation of structured data for
// signing, where different parts of a transaction (amounts, addresses, etc.)
// can be added as field elements or packed bits.
//
// References:
//   - https://github.com/o1-labs/proof-systems/blob/43cf0ea4a66c3cccf40d29f13f36ba638e38ed4a/hasher/src/roinput.rs#L62
//   - https://github.com/o1-labs/o1js/blob/fdc94dd8d3735d01c232d7d7af49763e044b738b/src/mina-signer/src/poseidon-bigint.ts#L68
type ROInput struct {
        fields []*pasta.PallasBaseFieldElement // Field elements added directly
        bits   *bitvec.BitVector               // Bits to be packed into field elements
}

// MarshalJSON serialises the ROInput to JSON as an array of hex-encoded field elements.
func (r *ROInput) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        packed := r.PackToFields()
        fields := make([]string, len(packed))
        for i, p := range packed </span><span class="cov8" title="1">{
                fields[i] = hex.EncodeToString(p.Bytes())
        }</span>

        <span class="cov8" title="1">b, err := json.Marshal(fields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot serialise input")
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

// Init initialises an empty ROInput. Must be called before use.
func (r *ROInput) Init() *ROInput <span class="cov8" title="1">{
        r.fields = make([]*pasta.PallasBaseFieldElement, 0)
        r.bits = bitvec.NewBitVector(make([]byte, 0), 0)
        return r
}</span>

// Clone creates a deep copy of the ROInput.
func (r *ROInput) Clone() *ROInput <span class="cov8" title="1">{
        t := new(ROInput)
        t.fields = make([]*pasta.PallasBaseFieldElement, len(r.fields))
        for i, f := range r.fields </span><span class="cov8" title="1">{
                t.fields[i] = f.Clone()
        }</span>
        <span class="cov8" title="1">buffer := r.bits.Bytes()
        data := make([]byte, len(buffer))
        copy(data, buffer)
        t.bits = bitvec.NewBitVector(data, r.bits.Length())
        return t</span>
}

// AddFields appends field elements directly to the ROInput.
// These will appear first when packed for hashing.
func (r *ROInput) AddFields(fieldElements ...*pasta.PallasBaseFieldElement) <span class="cov8" title="1">{
        r.fields = append(r.fields, fieldElements...)
}</span>

// AddString appends a string as bits (MSB first per byte).
func (r *ROInput) AddString(input string) <span class="cov8" title="1">{
        for _, b := range []byte(input) </span><span class="cov8" title="1">{
                for i := range 8 </span><span class="cov8" title="1">{
                        bitIdx := 7 - i
                        r.bits.Append((b &gt;&gt; bitIdx) &amp; 1)
                }</span>
        }
}

// AddBits appends individual bits to the ROInput.
func (r *ROInput) AddBits(bits ...bool) <span class="cov8" title="1">{
        for _, b := range bits </span><span class="cov8" title="1">{
                if b </span><span class="cov8" title="1">{
                        r.bits.Append(1)
                }</span> else<span class="cov8" title="1"> {
                        r.bits.Append(0)
                }</span>
        }
}

// PackToFields converts the ROInput to field elements for Poseidon hashing.
// Field elements are included directly, while accumulated bits are packed
// into 254-bit chunks (the maximum that fits in a Pallas field element).
func (r *ROInput) PackToFields() []*pasta.PallasBaseFieldElement <span class="cov8" title="1">{
        const maxChunkSize = 254
        fields := make([]*pasta.PallasBaseFieldElement, 0, len(r.fields)+((r.bits.Length()+maxChunkSize-1)/maxChunkSize))
        for _, f := range r.fields </span><span class="cov8" title="1">{
                fields = append(fields, f.Clone())
        }</span>

        <span class="cov8" title="1">idx := 0
        for idx &lt; r.bits.Length() </span><span class="cov8" title="1">{
                var chunk [32]byte
                for i := 0; i &lt; maxChunkSize &amp;&amp; idx &lt; r.bits.Length(); i++ </span><span class="cov8" title="1">{
                        offset := idx % maxChunkSize
                        byteIdx := offset / 8
                        bitIdx := offset % 8
                        chunk[byteIdx] |= r.bits.Element(idx) &lt;&lt; bitIdx
                        idx++
                }</span>
                <span class="cov8" title="1">slices.Reverse(chunk[:])
                field, _ := pasta.NewPallasBaseField().FromBytes(chunk[:])
                fields = append(fields, field)</span>
        }

        <span class="cov8" title="1">return fields</span>
}

// Fields returns a copy of the field elements stored in the ROInput.
func (r *ROInput) Fields() []*pasta.PallasBaseFieldElement <span class="cov8" title="1">{
        result := make([]*pasta.PallasBaseFieldElement, len(r.fields))
        for i, f := range r.fields </span><span class="cov8" title="1">{
                result[i] = f.Clone()
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Bits returns all bits as a boolean slice.
func (r *ROInput) Bits() []bool <span class="cov8" title="1">{
        if r.bits == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">result := make([]bool, r.bits.Length())
        for i := range r.bits.Length() </span><span class="cov8" title="1">{
                result[i] = r.bits.Element(i) == 1
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file314" style="display: none">package mina

import "github.com/bronlabs/bron-crypto/pkg/base/errs2"

// Helper functions to create payment and delegation messages
// Reference: https://github.com/o1-labs/o1js/blob/188cf3faf6442e1e1ca8e4b3212a459b917c4ed4/src/mina-signer/src/sign-legacy.ts#L96
func NewPaymentMessage(source, receiver *PublicKey, amount, fee uint64, nonce, validUntil uint32, memo string) (*ROInput, error) <span class="cov8" title="1">{
        msg := new(ROInput).Init()

        // ===== COMMON SECTION =====
        // Reference: commonToInputLegacy in sign-legacy.ts
        // Order: fee, legacyTokenID, feePayer, nonce, validUntil, memo

        // 1. Fee (64 bits, LSB-first)
        msg.AddBits(uint64ToBits(fee)...)

        // 2. Legacy token ID (64 bits: [true, false*63])
        msg.AddBits(legacyTokenID()...)

        // 3. Fee payer public key (x as field, isOdd as 1 bit)
        // In payments, the fee payer is the source
        if err := addPublicKeyToInput(msg, source); err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>

        // 4. Nonce (32 bits, LSB-first)
        <span class="cov8" title="1">msg.AddBits(uint32ToBits(nonce)...)

        // 5. Valid until (32 bits, LSB-first)
        msg.AddBits(uint32ToBits(validUntil)...)

        // 6. Memo (272 bits = 34 bytes * 8)
        msg.AddBits(memoToBits(memo)...)

        // ===== BODY SECTION =====
        // Reference: bodyToInputLegacy in sign-legacy.ts
        // Order: tag, source, receiver, legacyTokenID, amount, tokenLocked

        // 1. Tag (3 bits: Payment=0 -&gt; [false, false, false])
        msg.AddBits(tagToBits(0)...)

        // 2. Source public key
        if err := addPublicKeyToInput(msg, source); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>

        // 3. Receiver public key
        <span class="cov8" title="1">if err := addPublicKeyToInput(msg, receiver); err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>

        // 4. Legacy token ID again
        <span class="cov8" title="1">msg.AddBits(legacyTokenID()...)

        // 5. Amount (64 bits, LSB-first)
        msg.AddBits(uint64ToBits(amount)...)

        // 6. Token locked flag (1 bit: false)
        msg.AddBits(false)

        return msg, nil</span>
}

func NewDelegationMessage(source, newDelegate *PublicKey, fee uint64, nonce, validUntil uint32, memo string) (*ROInput, error) <span class="cov8" title="1">{
        msg := new(ROInput).Init()

        // ===== COMMON SECTION =====
        // Reference: commonToInputLegacy in sign-legacy.ts
        // Order: fee, legacyTokenID, feePayer, nonce, validUntil, memo

        // 1. Fee (64 bits, LSB-first)
        msg.AddBits(uint64ToBits(fee)...)

        // 2. Legacy token ID (64 bits: [true, false*63])
        msg.AddBits(legacyTokenID()...)

        // 3. Fee payer public key (x as field, isOdd as 1 bit)
        if err := addPublicKeyToInput(msg, source); err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>

        // 4. Nonce (32 bits, LSB-first)
        <span class="cov8" title="1">msg.AddBits(uint32ToBits(nonce)...)

        // 5. Valid until (32 bits, LSB-first)
        msg.AddBits(uint32ToBits(validUntil)...)

        // 6. Memo (272 bits = 34 bytes * 8)
        msg.AddBits(memoToBits(memo)...)

        // ===== BODY SECTION =====
        // Reference: bodyToInputLegacy in sign-legacy.ts
        // Order: tag, source, receiver (delegate), legacyTokenID, amount, tokenLocked

        // 1. Tag (3 bits: StakeDelegation=1 -&gt; [false, false, true])
        msg.AddBits(tagToBits(1)...)

        // 2. Source public key
        if err := addPublicKeyToInput(msg, source); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        // 3. Receiver public key (the delegate)
        <span class="cov8" title="1">if err := addPublicKeyToInput(msg, newDelegate); err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err)
        }</span>

        // 4. Legacy token ID again
        <span class="cov8" title="1">msg.AddBits(legacyTokenID()...)

        // 5. Amount (64 bits, LSB-first) - 0 for delegation
        msg.AddBits(uint64ToBits(0)...)

        // 6. Token locked flag (1 bit: false)
        msg.AddBits(false)

        return msg, nil</span>
}

// legacyTokenID is [true, false, false, ..., false] (64 bits total).
// Reference: https://github.com/o1-labs/o1js/blob/main/src/mina-signer/src/sign-legacy.ts
func legacyTokenID() []bool <span class="cov8" title="1">{
        bits := make([]bool, 64)
        bits[0] = true
        return bits
}</span>

// uint64ToBits converts a uint64 to 64 bits in LSB-first order per byte.
// Reference: https://github.com/o1-labs/o1js/blob/main/src/bindings/lib/binable.ts
func uint64ToBits(v uint64) []bool <span class="cov8" title="1">{
        bits := make([]bool, 64)
        for i := range 64 </span><span class="cov8" title="1">{
                bits[i] = (v&gt;&gt;i)&amp;1 == 1
        }</span>
        <span class="cov8" title="1">return bits</span>
}

// uint32ToBits converts a uint32 to 32 bits in LSB-first order.
func uint32ToBits(v uint32) []bool <span class="cov8" title="1">{
        bits := make([]bool, 32)
        for i := range 32 </span><span class="cov8" title="1">{
                bits[i] = (v&gt;&gt;i)&amp;1 == 1
        }</span>
        <span class="cov8" title="1">return bits</span>
}

// memoToBits converts a memo string to 272 bits (34 bytes * 8).
// The memo is encoded as: [1 byte type tag (0x01)] + [1 byte length] + [up to 32 bytes UTF-8].
// Reference: https://github.com/o1-labs/o1js/blob/main/src/mina-signer/src/memo.ts
func memoToBits(memo string) []bool <span class="cov8" title="1">{
        const memoSize = 34
        bytes := make([]byte, memoSize)
        memoBytes := []byte(memo)

        if len(memoBytes) &gt; 32 </span><span class="cov8" title="1">{
                memoBytes = memoBytes[:32]
        }</span>

        // Byte 0: memo type tag (0x01 = user memo)
        <span class="cov8" title="1">bytes[0] = 0x01
        // Byte 1: length of the actual memo content
        bytes[1] = byte(len(memoBytes))
        // Bytes 2+: memo content (up to 32 bytes)
        copy(bytes[2:], memoBytes)

        // Convert to bits (LSB-first per byte)
        bits := make([]bool, memoSize*8)
        for i, b := range bytes </span><span class="cov8" title="1">{
                for j := range 8 </span><span class="cov8" title="1">{
                        bits[i*8+j] = (b&gt;&gt;j)&amp;1 == 1
                }</span>
        }
        <span class="cov8" title="1">return bits</span>
}

// tagToBits converts a transaction tag (0=Payment, 1=Delegation) to 3 bits.
// Reference: https://github.com/o1-labs/o1js/blob/main/src/mina-signer/src/sign-legacy.ts
func tagToBits(tag int) []bool <span class="cov8" title="1">{
        return []bool{
                tag&amp;4 != 0,
                tag&amp;2 != 0,
                tag&amp;1 != 0,
        }
}</span>

// addPublicKeyToInput adds a public key to ROInput in legacy format:
// x coordinate as field element, isOdd as 1 bit.
// Reference: https://github.com/o1-labs/o1js/blob/main/src/mina-signer/src/curve-bigint.ts
func addPublicKeyToInput(msg *ROInput, pk *PublicKey) error <span class="cov8" title="1">{
        if pk == nil </span><span class="cov8" title="1">{
                return errs2.New("public key is nil")
        }</span>
        <span class="cov8" title="1">x, err := pk.V.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">y, err := pk.V.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov8" title="1">msg.AddFields(x)
        msg.AddBits(y.IsOdd())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file315" style="display: none">package mina

import (
        "hash"
        "io"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/additive"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
)

// VariantType identifies this as the Mina Schnorr variant.
const VariantType schnorrlike.VariantType = "mina"

var (
        _ schnorrlike.Variant[*GroupElement, *Scalar, *Message]         = (*Variant)(nil)
        _ tschnorr.MPCFriendlyVariant[*GroupElement, *Scalar, *Message] = (*Variant)(nil)
)

// NewDeterministicVariant creates a Mina variant with deterministic nonce derivation.
// The nonce is derived from the private key, public key, and network ID using Blake2b,
// following the legacy Mina/o1js implementation.
func NewDeterministicVariant(nid NetworkID, privateKey *PrivateKey) (*Variant, error) <span class="cov8" title="1">{
        if privateKey == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("private key is nil")
        }</span>
        <span class="cov8" title="1">return &amp;Variant{
                nid:  nid,
                sk:   privateKey,
                prng: nil,
                msg:  nil,
        }, nil</span>
}

// NewRandomisedVariant creates a Mina variant with random nonce generation.
// This is used for MPC/threshold signing where nonces are collaboratively generated.
func NewRandomisedVariant(nid NetworkID, prng io.Reader) (*Variant, error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">return &amp;Variant{
                nid:  nid,
                sk:   nil,
                prng: prng,
                msg:  nil,
        }, nil</span>
}

// Variant implements Mina-specific signing behaviour.
// It handles deterministic or random nonce generation, Poseidon-based challenge
// computation, and the even-y constraint on the nonce commitment.
type Variant struct {
        nid  NetworkID   // Network ID for domain separation (MainNet, TestNet, or custom)
        sk   *PrivateKey // Private key for deterministic nonce derivation (nil for random)
        prng io.Reader   // PRNG for random nonce generation (nil for deterministic)
        msg  *Message    // Message being signed (needed for deterministic nonce derivation)
}

// Type returns the variant identifier "mina".
func (*Variant) Type() schnorrlike.VariantType <span class="cov8" title="1">{
        return VariantType
}</span>

// HashFunc returns the Poseidon hash function constructor for challenge computation.
func (*Variant) HashFunc() func() hash.Hash <span class="cov8" title="1">{
        return hashFunc
}</span>

// IsDeterministic returns true if this variant uses deterministic nonce derivation.
func (v *Variant) IsDeterministic() bool <span class="cov8" title="1">{
        return v.sk != nil
}</span>

// fieldTo255Bits converts a field element to 255 bits in LSB-first order.
// This matches o1js's Field.toBits() which returns 255 bits.
//
// IMPORTANT: o1js uses little-endian byte order for field elements,
// so we need to reverse the byte order from our big-endian representation.
func fieldTo255Bits(field *pasta.PallasBaseFieldElement) []bool <span class="cov8" title="1">{
        bytesLE := reversedBytes(field.Bytes()) // Convert big-endian to little-endian
        bits := make([]bool, 255)
        // o1js bytesToBits: extracts LSB-first per byte, starting from bytes[0]
        for i := range 255 </span><span class="cov8" title="1">{
                byteIdx := i / 8
                bitIdx := i % 8
                bits[i] = (bytesLE[byteIdx]&gt;&gt;bitIdx)&amp;1 == 1
        }</span>
        <span class="cov8" title="1">return bits</span>
}

// bitsToBytes converts a slice of bits to bytes using LSB-first ordering per byte.
// This matches o1js's bitsToBytes function.
func bitsToBytes(bits []bool) []byte <span class="cov8" title="1">{
        numBytes := (len(bits) + 7) / 8
        bytes := make([]byte, numBytes)
        for i, bit := range bits </span><span class="cov8" title="1">{
                if bit </span><span class="cov8" title="1">{
                        byteIdx := i / 8
                        bitIdx := i % 8
                        bytes[byteIdx] |= 1 &lt;&lt; bitIdx
                }</span>
        }
        <span class="cov8" title="1">return bytes</span>
}

// deriveNonceLegacy computes a deterministic nonce using the legacy Mina/o1js algorithm.
// The nonce is derived as:
//  1. Build HashInputLegacy with message fields + [pk.x, pk.y], and bits + scalarBits + idBits
//  2. Convert to bits using inputToBitsLegacy: fields255 bits each, then raw bits
//  3. Convert bits to bytes (LSB-first per byte)
//  4. Hash with Blake2b-256
//  5. Clear top 2 bits of last byte (to ensure result &lt; field modulus)
//
// Reference: https://github.com/o1-labs/o1js/blob/fdc94dd8d3735d01c232d7d7af49763e044b738b/src/mina-signer/src/signature.ts#L249
func (v *Variant) deriveNonceLegacy() (*Scalar, error) <span class="cov8" title="1">{
        if v.msg == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("message is nil for deterministic nonce derivation")
        }</span>

        <span class="cov8" title="1">pkx, err := v.sk.PublicKey().V.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to get public key X coordinate")
        }</span>
        <span class="cov8" title="1">pky, err := v.sk.PublicKey().V.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to get public key Y coordinate")
        }</span>

        // Convert private key to bits using Scalar.toBits()
        // In o1js: let scalarBits = Scalar.toBits(privateKey)
        <span class="cov8" title="1">scalarBits := scalarTo255Bits(v.sk.Value())

        // Get network ID as bits
        // In o1js: let idBits = bytesToBits([Number(id)])
        // For mainnet id=1, testnet id=0, converted to 8 bits LSB-first
        id, _ := getNetworkIDHashInput(v.nid)
        idByte := byte(id.Uint64())
        idBits := make([]bool, 8)
        for i := range 8 </span><span class="cov8" title="1">{
                idBits[i] = (idByte&gt;&gt;i)&amp;1 == 1
        }</span>

        // Get message fields and bits separately
        // o1js: let input = HashInputLegacy.append(message, { fields: [x, y], bits: [...scalarBits, ...idBits] })
        <span class="cov8" title="1">msgFields := v.msg.Fields()
        msgBits := v.msg.Bits()

        // Build all bits using inputToBitsLegacy logic:
        // fields.flatMap(f =&gt; f.toBits()) ++ bits
        var allBits []bool

        // 1. Convert message fields to 255 bits each
        for _, field := range msgFields </span><span class="cov8" title="1">{
                allBits = append(allBits, fieldTo255Bits(field)...)
        }</span>

        // 2. Convert additional fields [pk.x, pk.y] to 255 bits each
        <span class="cov8" title="1">allBits = append(allBits, fieldTo255Bits(pkx)...)
        allBits = append(allBits, fieldTo255Bits(pky)...)

        // 3. Append raw message bits
        allBits = append(allBits, msgBits...)

        // 4. Append scalar bits (private key)
        allBits = append(allBits, scalarBits...)

        // 5. Append network ID bits
        allBits = append(allBits, idBits...)

        // Convert bits to bytes (LSB-first per byte)
        // This matches: bitsToBytes(inputBits)
        inputBytes := bitsToBytes(allBits)

        digest := blake2b.Sum256(inputBytes)

        // Drop top two bits of last byte
        // Reference: bytes[bytes.length - 1] &amp;= 0x3f in o1js
        digest[len(digest)-1] &amp;= 0x3f

        // Scalar.fromBytes interprets bytes as little-endian in o1js
        // Our sf.FromBytes expects big-endian, so we need to reverse
        digestBE := reversedBytes(digest[:])
        k, err := sf.FromBytes(digestBE)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create scalar from bytes")
        }</span>
        <span class="cov8" title="1">return k, nil</span>
}

// scalarTo255Bits converts a scalar to 255 bits in LSB-first order.
// This matches o1js's Scalar.toBits() which returns 255 bits.
func scalarTo255Bits(scalar *Scalar) []bool <span class="cov8" title="1">{
        bytesLE := reversedBytes(scalar.Bytes()) // Convert big-endian to little-endian
        bits := make([]bool, 255)
        for i := range 255 </span><span class="cov8" title="1">{
                byteIdx := i / 8
                bitIdx := i % 8
                bits[i] = (bytesLE[byteIdx]&gt;&gt;bitIdx)&amp;1 == 1
        }</span>
        <span class="cov8" title="1">return bits</span>
}

// ComputeNonceCommitment generates the nonce k and commitment R = kG.
// Uses deterministic derivation if a private key was provided, otherwise uses PRNG.
// The nonce is adjusted to ensure R has an even y-coordinate.
func (v *Variant) ComputeNonceCommitment() (R *GroupElement, k *Scalar, err error) <span class="cov8" title="1">{
        if v.IsDeterministic() </span><span class="cov8" title="1">{
                k, err = v.deriveNonceLegacy()
        }</span> else<span class="cov8" title="1"> {
                k, err = algebrautils.RandomNonIdentity(sf, v.prng)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err).WithMessage("failed to create scalar from bytes")
        }</span>
        <span class="cov8" title="1">R = group.ScalarBaseMul(k)

        // Ensure R has an even y-coordinate (same as BIP340)
        ry, err := R.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot get y coordinate")
        }</span>
        <span class="cov8" title="1">if ry.IsOdd() </span><span class="cov8" title="1">{
                // Negate k to flip the y-coordinate parity
                k = k.Neg()
                R = group.ScalarBaseMul(k)
        }</span>

        <span class="cov8" title="1">return R, k, nil</span>
}

// ComputeChallenge computes the Mina Fiat-Shamir challenge using Poseidon hashing.
// The challenge is: e = Poseidon(prefix || message || pk.x || pk.y || R.x)
// where prefix is the network-specific signature prefix.
//
// Reference: https://github.com/o1-labs/o1js/blob/885b50e60ead596cdcd8dc944df55fd3a4467a0a/src/mina-signer/src/signature.ts#L242
func (v *Variant) ComputeChallenge(nonceCommitment, publicKeyValue *GroupElement, message *Message) (*Scalar, error) <span class="cov8" title="1">{
        if nonceCommitment == nil || publicKeyValue == nil || message == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("nonceCommitment, publicKeyValue and message must not be nil")
        }</span>
        <span class="cov8" title="1">input := message.Clone()
        pkx, err := publicKeyValue.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get x")
        }</span>
        <span class="cov8" title="1">pky, err := publicKeyValue.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get y")
        }</span>
        <span class="cov8" title="1">ncx, err := nonceCommitment.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get x")
        }</span>
        <span class="cov8" title="1">input.AddFields(pkx, pky, ncx)
        prefix := SignaturePrefix(v.nid)
        e, err := hashWithPrefix(prefix, input.PackToFields()...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compute challenge")
        }</span>
        <span class="cov8" title="1">return e, nil</span>
}

// ComputeResponse computes the Mina signature response: s = k + ex mod n.
func (*Variant) ComputeResponse(privateKeyValue, nonce, challenge *Scalar) (*Scalar, error) <span class="cov8" title="1">{
        if privateKeyValue == nil || nonce == nil || challenge == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("privateKeyValue, nonce and challenge must not be nil")
        }</span>
        <span class="cov8" title="1">return nonce.Add(challenge.Mul(privateKeyValue)), nil</span>
}

// SerializeSignature encodes the signature to 64 bytes in Mina's little-endian format.
func (*Variant) SerializeSignature(signature *Signature) ([]byte, error) <span class="cov8" title="1">{
        return SerializeSignature(signature)
}</span>

// ============ MPC Methods ============.
//
// These methods support threshold/MPC Schnorr signing with Mina.
// Mina requires R to have an even y-coordinate, similar to BIP-340.

// CorrectAdditiveSecretShareParity is a no-op for Mina since no parity correction
// is needed for secret shares (only for nonce commitments).
func (*Variant) CorrectAdditiveSecretShareParity(publicKey *PublicKey, share *additive.Share[*Scalar]) (*additive.Share[*Scalar], error) <span class="cov8" title="1">{
        // no changes needed
        return share, nil
}</span>

// CorrectPartialNonceParity adjusts a partial nonce for Mina's even-y requirement.
// If the aggregate nonce commitment R has odd y, each party must negate their
// partial nonce k_i to ensure the final signature is valid.
func (*Variant) CorrectPartialNonceParity(aggregatedNonceCommitments *GroupElement, localNonce *Scalar) (correctedR *GroupElement, correctedK *Scalar, err error) <span class="cov8" title="1">{
        if aggregatedNonceCommitments == nil || localNonce == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrInvalidArgument.WithMessage("nonce commitment or k is nil")
        }</span>
        <span class="cov8" title="1">correctedK = localNonce.Clone()
        ancy, err := aggregatedNonceCommitments.AffineY()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot get y")
        }</span>
        <span class="cov8" title="1">if ancy.IsOdd() </span><span class="cov8" title="1">{
                // If the nonce commitment is odd, we need to negate k to ensure that the parity is correct.
                correctedK = correctedK.Neg()
        }</span>
        <span class="cov8" title="1">correctedR = group.ScalarBaseOp(correctedK)
        return correctedR, correctedK, nil</span>
}
</pre>
		
		<pre class="file" id="file316" style="display: none">// Package vanilla provides a configurable generic Schnorr signature implementation.
//
// Unlike BIP-340 or Mina which have fixed parameter choices, this package allows
// customization of all aspects of the Schnorr signature scheme:
//   - Elliptic curve group (any prime-order group)
//   - Hash function (SHA-256, SHA-3, BLAKE2, etc.)
//   - Response equation sign (s = k + ex or s = k - ex)
//   - Byte ordering (big-endian or little-endian)
//   - Nonce parity constraints (optional even-y requirement)
//
// This flexibility makes it suitable for implementing custom Schnorr variants
// or for use with non-standard curves.
//
// # Example Usage
//
//        scheme, _ := vanilla.NewScheme(
//            secp256k1.NewCurve(),           // Curve
//            sha256.New,                      // Hash function
//            false,                           // Response operator not negative
//            false,                           // Big-endian challenge elements
//            nil,                             // No nonce parity constraint
//            rand.Reader,                     // Random nonce generation
//        )
//        signer, _ := scheme.Signer(privateKey)
//        signature, _ := signer.Sign(message)
package vanilla

import (
        "hash"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/additive"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
)

type (
        // PublicKey is a generic Schnorr public key parameterized by curve and scalar types.
        PublicKey[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = schnorrlike.PublicKey[GE, S]
        // PrivateKey is a generic Schnorr private key parameterized by curve and scalar types.
        PrivateKey[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = schnorrlike.PrivateKey[GE, S]
        // Signature is a generic Schnorr signature parameterized by curve and scalar types.
        Signature[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = schnorrlike.Signature[GE, S]
        // Message is a byte slice to be signed.
        Message = []byte
)

// VariantType identifies this as the vanilla Schnorr variant.
const VariantType schnorrlike.VariantType = "Schnorr"

// NewPublicKey creates a Schnorr public key from a curve point.
func NewPublicKey[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]](point GE) (*PublicKey[GE, S], error) <span class="cov0" title="0">{
        pk, err := schnorrlike.NewPublicKey(point)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create Schnorr public key")
        }</span>
        <span class="cov0" title="0">return pk, nil</span>
}

// NewPrivateKey creates a Schnorr private key from a scalar and its public key.
func NewPrivateKey[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]](scalar S, pk *PublicKey[GE, S]) (*PrivateKey[GE, S], error) <span class="cov0" title="0">{
        sk, err := schnorrlike.NewPrivateKey(scalar, pk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create Schnorr private key")
        }</span>
        <span class="cov0" title="0">return sk, nil</span>
}

// NewScheme creates a configurable Schnorr signature scheme.
//
// Parameters:
//   - group: The elliptic curve group (must be prime-order)
//   - f: Hash function constructor for challenge computation
//   - responseOperatorIsNegative: If true, uses s = k - ex instead of s = k + ex
//   - challengeElementsAreLittleEndian: If true, reverses bytes before hashing
//   - shouldNegateNonce: Optional callback to enforce nonce parity (e.g., even y)
//   - prng: Random source for nonce generation
func NewScheme[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]](
        group algebra.PrimeGroup[GE, S],
        f func() hash.Hash,
        responseOperatorIsNegative bool,
        challengeElementsAreLittleEndian bool,
        shouldNegateNonce func(nonceCommitment GE) bool,
        prng io.Reader,
) (*Scheme[GE, S], error) <span class="cov8" title="1">{
        if group == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("group is nil")
        }</span>
        <span class="cov8" title="1">if f == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("hash function is nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">sf, ok := group.ScalarStructure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("group type assertion failed")
        }</span>
        <span class="cov8" title="1">return &amp;Scheme[GE, S]{
                vr: &amp;Variant[GE, S]{
                        g:                                group,
                        sf:                               sf,
                        h:                                f,
                        prng:                             prng,
                        shouldNegateNonce:                shouldNegateNonce,
                        responseOperatorIsNegative:       responseOperatorIsNegative,
                        challengeElementsAreLittleEndian: challengeElementsAreLittleEndian,
                },
        }, nil</span>
}

// Scheme is a configurable generic Schnorr signature scheme.
// It can be parameterized with any prime-order elliptic curve group.
type Scheme[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] struct {
        vr *Variant[GE, S]
}

// Name returns the signature scheme identifier ("SchnorrLike").
func (*Scheme[GE, S]) Name() signatures.Name <span class="cov0" title="0">{
        return schnorrlike.Name
}</span>

// Variant returns the Schnorr variant configuration for this scheme.
func (s *Scheme[GE, S]) Variant() *Variant[GE, S] <span class="cov8" title="1">{
        return s.vr
}</span>

// Keygen creates a key generator for this Schnorr scheme.
func (s *Scheme[GE, S]) Keygen(opts ...KeyGeneratorOption[GE, S]) (*KeyGenerator[GE, S], error) <span class="cov8" title="1">{
        out := &amp;KeyGenerator[GE, S]{
                KeyGeneratorTrait: schnorrlike.KeyGeneratorTrait[GE, S]{
                        Grp: s.vr.g,
                        SF:  s.vr.sf,
                },
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(out); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("key generator option failed")
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// Signer creates a signer for producing Schnorr signatures.
func (s *Scheme[GE, S]) Signer(privateKey *PrivateKey[GE, S], opts ...SignerOption[GE, S]) (*Signer[GE, S], error) <span class="cov8" title="1">{
        if privateKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("private key is nil")
        }</span>
        <span class="cov8" title="1">verifier, err := s.Verifier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("verifier creation failed")
        }</span>
        <span class="cov8" title="1">out := &amp;Signer[GE, S]{
                schnorrlike.SignerTrait[*Variant[GE, S], GE, S, Message]{
                        Sk:       privateKey,
                        V:        s.vr,
                        Verifier: verifier,
                },
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(out); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("signer option failed")
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// Verifier creates a verifier for validating Schnorr signatures.
func (s *Scheme[GE, S]) Verifier(opts ...VerifierOption[GE, S]) (*Verifier[GE, S], error) <span class="cov8" title="1">{
        out := &amp;Verifier[GE, S]{
                VerifierTrait: schnorrlike.VerifierTrait[*Variant[GE, S], GE, S, Message]{
                        V:                          s.vr,
                        ResponseOperatorIsNegative: s.vr.responseOperatorIsNegative,
                        ChallengePublicKey:         nil,
                },
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if err := opt(out); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("verifier option failed")
                }</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// PartialSignatureVerifier creates a verifier for threshold/partial signatures.
func (s *Scheme[GE, S]) PartialSignatureVerifier(
        publicKey *PublicKey[GE, S],
        opts ...signatures.VerifierOption[*Verifier[GE, S], *PublicKey[GE, S], Message, *Signature[GE, S]],
) (schnorrlike.Verifier[*Variant[GE, S], GE, S, Message], error) <span class="cov0" title="0">{
        if publicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key is nil or invalid")
        }</span>
        <span class="cov0" title="0">verifier, err := s.Verifier(opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("verifier creation failed")
        }</span>
        <span class="cov0" title="0">verifier.ChallengePublicKey = publicKey
        return verifier, nil</span>
}

// KeyGeneratorOption configures key generation behaviour.
type KeyGeneratorOption[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = signatures.KeyGeneratorOption[*KeyGenerator[GE, S], *PrivateKey[GE, S], *PublicKey[GE, S]]

// KeyGenerator creates Schnorr key pairs for the configured curve.
type KeyGenerator[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] struct {
        schnorrlike.KeyGeneratorTrait[GE, S]
}

// SignerOption configures signing behaviour.
type SignerOption[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = signatures.SignerOption[*Signer[GE, S], Message, *Signature[GE, S]]

// Signer produces Schnorr signatures using random nonce generation.
type Signer[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] struct {
        schnorrlike.SignerTrait[*Variant[GE, S], GE, S, Message]
}

// Variant returns the Schnorr variant used by this signer.
func (sg *Signer[GE, S]) Variant() *Variant[GE, S] <span class="cov0" title="0">{
        if sg == nil </span><span class="cov0" title="0">{
                panic(ErrInvalidArgument.WithMessage("signer is nil"))</span>
        }
        <span class="cov0" title="0">return sg.V</span>
}

// VerifierOption configures verification behaviour.
type VerifierOption[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = signatures.VerifierOption[*Verifier[GE, S], *PublicKey[GE, S], Message, *Signature[GE, S]]

// Verifier validates Schnorr signatures.
type Verifier[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] struct {
        schnorrlike.VerifierTrait[*Variant[GE, S], GE, S, Message]
}

// Variant returns the Schnorr variant used by this verifier.
func (v *Verifier[GE, S]) Variant() *Variant[GE, S] <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                panic(ErrInvalidArgument.WithMessage("verifier is nil"))</span>
        }
        <span class="cov0" title="0">return v.V</span>
}

// Variant implements variant-specific behaviour for vanilla Schnorr.
// It stores all configurable parameters for the signature scheme.
type Variant[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] struct {
        g                                algebra.PrimeGroup[GE, S]     // underlying group
        sf                               algebra.PrimeField[S]         // Scalar field of the underlying group
        h                                func() hash.Hash              // Hash function for challenges
        prng                             io.Reader                     // Random source for nonces
        responseOperatorIsNegative       bool                          // Use s = k - ex instead of s = k + ex
        challengeElementsAreLittleEndian bool                          // Reverse byte order before hashing
        shouldNegateNonce                func(nonceCommitment GE) bool // Optional parity constraint callback
}

// Type returns the variant identifier "Schnorr".
func (*Variant[GE, S]) Type() schnorrlike.VariantType <span class="cov8" title="1">{
        return VariantType
}</span>

// HashFunc returns the configured hash function constructor.
func (v *Variant[GE, S]) HashFunc() func() hash.Hash <span class="cov8" title="1">{
        if v.h == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return v.h</span>
}

// ComputeNonceCommitment generates a random nonce k and commitment R = kG.
// If shouldNegateNonce was configured, applies parity correction to k.
func (v *Variant[GE, S]) ComputeNonceCommitment() (R GE, k S, err error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return *new(GE), *new(S), ErrInvalidArgument.WithMessage("variant is nil")
        }</span>
        <span class="cov8" title="1">ge, s, err := schnorrlike.ComputeGenericNonceCommitment(v.g, v.prng, v.shouldNegateNonce)
        if err != nil </span><span class="cov0" title="0">{
                return *new(GE), *new(S), errs2.Wrap(err).WithMessage("failed to compute nonce commitment")
        }</span>
        <span class="cov8" title="1">return ge, s, nil</span>
}

// ComputeChallenge computes the Fiat-Shamir challenge: e = H(R || P || m) mod n.
// Uses the configured hash function and byte ordering.
func (v *Variant[GE, S]) ComputeChallenge(nonceCommitment, publicKeyValue GE, message Message) (S, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("variant is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(nonceCommitment) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("nonce commitment is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(publicKeyValue) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("public key value is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(message) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("message is nil")
        }</span>
        <span class="cov8" title="1">challenge, err := schnorrlike.MakeGenericChallenge(v.sf, v.h, v.challengeElementsAreLittleEndian, nonceCommitment.Bytes(), publicKeyValue.Bytes(), message)
        if err != nil </span><span class="cov0" title="0">{
                return *new(S), errs2.Wrap(err).WithMessage("failed to compute Schnorr challenge")
        }</span>
        <span class="cov8" title="1">return challenge, nil</span>
}

// ComputeResponse computes the signature response: s = k  ex mod n.
// The sign depends on the responseOperatorIsNegative configuration.
func (v *Variant[GE, S]) ComputeResponse(privateKeyValue, nonce, challenge S) (S, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("variant is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(privateKeyValue) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("private key value is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(nonce) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("nonce is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(challenge) </span><span class="cov0" title="0">{
                return *new(S), ErrInvalidArgument.WithMessage("challenge is nil")
        }</span>
        <span class="cov8" title="1">response, err := schnorrlike.ComputeGenericResponse(privateKeyValue, nonce, challenge, v.responseOperatorIsNegative)
        if err != nil </span><span class="cov0" title="0">{
                return *new(S), errs2.Wrap(err).WithMessage("failed to compute Schnorr response")
        }</span>
        <span class="cov8" title="1">return response, nil</span>
}

// SerializeSignature encodes the signature as (R || s) in native byte format.
func (v *Variant[GE, S]) SerializeSignature(signature *Signature[GE, S]) ([]byte, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("variant is nil")
        }</span>
        <span class="cov8" title="1">if signature == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("signature is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(signature.R) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("signature.R is nil")
        }</span>
        <span class="cov8" title="1">if utils.IsNil(signature.S) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("signature.S is nil")
        }</span>
        // Vanilla Schnorr signature format: (R, s)
        // Note: E (challenge) can be recomputed during verification
        <span class="cov8" title="1">out := append(signature.R.Bytes(), signature.S.Bytes()...)
        return out, nil</span>
}

// NonceIsFunctionOfMessage returns false since vanilla Schnorr uses random nonces.
func (*Variant[GE, S]) NonceIsFunctionOfMessage() bool <span class="cov8" title="1">{
        return false
}</span>

// CorrectPartialNonceParity is a no-op for vanilla Schnorr (no parity constraints).
// Returns the nonce and its commitment unchanged.
func (*Variant[GE, S]) CorrectPartialNonceParity(aggregatedNonceCommitment GE, nonce S) (R GE, correctedNonce S, err error) <span class="cov0" title="0">{
        if utils.IsNil(aggregatedNonceCommitment) </span><span class="cov0" title="0">{
                return *new(GE), *new(S), ErrInvalidArgument.WithMessage("aggregated nonce commitment is nil")
        }</span>
        <span class="cov0" title="0">if utils.IsNil(nonce) </span><span class="cov0" title="0">{
                return *new(GE), *new(S), ErrInvalidArgument.WithMessage("nonce is nil")
        }</span>
        // No change in MPC context
        <span class="cov0" title="0">group, ok := aggregatedNonceCommitment.Structure().(algebra.PrimeGroup[GE, S])
        if !ok </span><span class="cov0" title="0">{
                return *new(GE), *new(S), ErrInvalidArgument.WithMessage("aggregated nonce commitment type assertion failed")
        }</span>
        <span class="cov0" title="0">R = group.ScalarBaseOp(nonce)
        return R, nonce, nil</span>
}

// CorrectAdditiveSecretShareParity is a no-op for vanilla Schnorr (no parity constraints).
// Returns a clone of the share unchanged.
func (*Variant[GE, S]) CorrectAdditiveSecretShareParity(publicKey *schnorrlike.PublicKey[GE, S], share *additive.Share[S]) (*additive.Share[S], error) <span class="cov0" title="0">{
        if publicKey == nil || share == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key or secret share is nil")
        }</span>
        // No change in MPC context
        <span class="cov0" title="0">return share.Clone(), nil</span>
}

func _[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]]() {
        var (
                _ schnorrlike.Variant[GE, S, Message]         = (*Variant[GE, S])(nil)
                _ tschnorr.MPCFriendlyVariant[GE, S, Message] = (*Variant[GE, S])(nil)
        )
}
</pre>
		
		<pre class="file" id="file317" style="display: none">// Package schnorrlike provides a generic framework for Schnorr-like signature schemes.
//
// Schnorr signatures are digital signatures based on the discrete logarithm problem,
// originally proposed by Claus-Peter Schnorr in 1989. They convert an interactive
// identification protocol into a non-interactive signature scheme using the
// Fiat-Shamir heuristic.
//
// # Protocol Overview
//
// A Schnorr signature on message m with private key x and public key P = xG consists of:
//  1. Generate random nonce k and compute commitment R = kG
//  2. Compute challenge e = H(R || P || m)
//  3. Compute response s = k + ex (or s = k - ex depending on variant)
//
// The signature is (R, s) or (e, s) depending on the variant.
//
// Verification checks: sG = R + eP (or sG = R - eP for negative response variants)
//
// # Variants
//
// This package supports multiple Schnorr variants through the Variant interface:
//   - BIP-340: Bitcoin's Schnorr with x-only public keys and tagged hashing
//   - Mina: Schnorr on Pallas curve with Poseidon hashing
//   - Vanilla: Configurable generic Schnorr implementation
//
// Each variant can customise nonce generation, challenge computation, and response
// calculation while sharing common verification logic.
//
// # Threshold Signatures
//
// The framework supports threshold/MPC-friendly signatures through additional
// interfaces that handle parity corrections required by variants like BIP-340.
//
// References:
//   - Schnorr, C.P. (1991). Efficient signature generation by smart cards.
//     Journal of Cryptology, 4(3), 161-174.
//   - Fiat, A., &amp; Shamir, A. (1987). How to prove yourself: Practical solutions
//     to identification and signature problems.
package schnorrlike

import (
        "hash"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
)

// Name is the signature scheme identifier for Schnorr-like signatures.
const Name signatures.Name = "SchnorrLike"

type (
        // VariantType identifies a specific Schnorr variant (e.g., "bip340", "mina", "Schnorr").
        VariantType string

        // Group represents an elliptic curve group suitable for Schnorr signatures.
        // It must be a prime-order group where the discrete logarithm problem is hard.
        Group[GE GroupElement[GE, S], S Scalar[S]] algebra.PrimeGroup[GE, S]

        // GroupElement represents a point on the elliptic curve.
        // Public keys and nonce commitments are group elements.
        GroupElement[GE algebra.PrimeGroupElement[GE, S], S Scalar[S]] algebra.PrimeGroupElement[GE, S]

        // ScalarField represents the field of scalars (integers modulo the group order).
        ScalarField[S Scalar[S]] algebra.PrimeField[S]

        // Scalar represents an element of the scalar field.
        // Private keys, nonces, challenges, and responses are scalars.
        Scalar[S algebra.PrimeFieldElement[S]] algebra.PrimeFieldElement[S]

        // KeyGenerator creates Schnorr key pairs.
        KeyGenerator[GE GroupElement[GE, S], S Scalar[S]] = signatures.KeyGenerator[*PrivateKey[GE, S], *PublicKey[GE, S]]

        // Signer creates Schnorr signatures using a private key.
        // It embeds the base Signer interface and provides access to the variant.
        Signer[VR Variant[GE, S, M], GE GroupElement[GE, S], S Scalar[S], M Message] interface {
                signatures.Signer[M, *Signature[GE, S]]
                Variant() VR
        }

        // Verifier validates Schnorr signatures against public keys.
        // It embeds the base Verifier interface and provides access to the variant.
        Verifier[VR Variant[GE, S, M], GE GroupElement[GE, S], S Scalar[S], M Message] interface {
                signatures.Verifier[*PublicKey[GE, S], M, *Signature[GE, S]]
                Variant() VR
        }

        // Scheme is the complete Schnorr signature scheme combining key generation,
        // signing, and verification. Different variants implement this interface
        // to provide variant-specific behaviour while maintaining a consistent API.
        Scheme[
                VR Variant[GE, S, M], GE GroupElement[GE, S], S Scalar[S], M Message,
                KG KeyGenerator[GE, S], SG Signer[VR, GE, S, M], VF Verifier[VR, GE, S, M],
        ] interface {
                signatures.Scheme[*PrivateKey[GE, S], *PublicKey[GE, S], M, *Signature[GE, S], KG, SG, VF]
                Variant() VR
        }
)

// Variant defines variant-specific behaviour for a Schnorr signature scheme.
// Different variants (BIP-340, Mina, etc.) implement this interface to customise:
//   - Nonce generation (deterministic vs random, parity constraints)
//   - Challenge computation (hash function, input ordering, domain separation)
//   - Response calculation (s = k + ex vs s = k - ex)
//   - Signature serialisation format
type Variant[GE GroupElement[GE, S], S Scalar[S], M Message] interface {
        // Type returns the variant identifier (e.g., "bip340", "mina").
        Type() VariantType

        // HashFunc returns the hash function constructor used for challenge computation.
        HashFunc() func() hash.Hash

        // ComputeNonceCommitment generates the nonce k and commitment R = kG.
        // The implementation may use deterministic derivation (BIP-340, Mina)
        // or random sampling, and may enforce parity constraints on R.
        ComputeNonceCommitment() (GE, S, error)

        // ComputeChallenge computes the Fiat-Shamir challenge e = H(R || P || m).
        // The exact hash function, input ordering, and domain separation vary by variant.
        ComputeChallenge(nonceCommitment GE, publicKeyValue GE, message M) (S, error)

        // ComputeResponse computes the signature response s from the private key,
        // nonce, and challenge. Typically s = k + ex or s = k - ex.
        ComputeResponse(privateKeyValue, nonce, challenge S) (S, error)

        // SerializeSignature encodes the signature to bytes in variant-specific format.
        SerializeSignature(signature *Signature[GE, S]) ([]byte, error)
}

// Message is the type constraint for messages that can be signed.
type Message signatures.Message

// NewPublicKey creates a Schnorr public key from an elliptic curve point.
// The point must be non-nil, not the identity element, and torsion-free
// (in the prime-order subgroup) to be valid.
func NewPublicKey[PKV GroupElement[PKV, S], S Scalar[S]](value PKV) (*PublicKey[PKV, S], error) <span class="cov0" title="0">{
        if utils.IsNil(value) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("value is nil")
        }</span>
        <span class="cov0" title="0">if value.IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("value is identity")
        }</span>
        <span class="cov0" title="0">if !value.IsTorsionFree() </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("value is not torsion free")
        }</span>
        <span class="cov0" title="0">return &amp;PublicKey[PKV, S]{
                PublicKeyTrait: signatures.PublicKeyTrait[PKV, S]{
                        V: value,
                },
        }, nil</span>
}

// PublicKey represents a Schnorr public key as an elliptic curve point P = xG,
// where x is the corresponding private key and G is the group generator.
type PublicKey[PKV GroupElement[PKV, S], S Scalar[S]] struct {
        signatures.PublicKeyTrait[PKV, S]
}

// publicKeyDTO is the CBOR serialisation format for public keys.
type publicKeyDTO[PKV GroupElement[PKV, S], S Scalar[S]] struct {
        PK PKV `cbor:"publicKey"`
}

// Equal returns true if two public keys represent the same curve point.
func (pk *PublicKey[PKV, S]) Equal(other *PublicKey[PKV, S]) bool <span class="cov0" title="0">{
        if pk == nil || other == nil </span><span class="cov0" title="0">{
                return pk == other
        }</span>
        <span class="cov0" title="0">return pk.PublicKeyTrait.Equal(&amp;other.PublicKeyTrait)</span>
}

// Clone returns a deep copy of the public key.
func (pk *PublicKey[PKV, S]) Clone() *PublicKey[PKV, S] <span class="cov0" title="0">{
        if pk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PublicKey[PKV, S]{PublicKeyTrait: *pk.PublicKeyTrait.Clone()}</span>
}

// MarshalCBOR serialises the public key to CBOR format.
func (pk *PublicKey[PKV, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;publicKeyDTO[PKV, S]{
                PK: pk.V,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal schnorrlike PublicKey")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR deserializes a public key from CBOR format.
func (pk *PublicKey[PKV, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*publicKeyDTO[PKV, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">pk2, err := NewPublicKey(dto.PK)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*pk = *pk2
        return nil</span>
}

// NewPrivateKey creates a Schnorr private key from a scalar value.
// The scalar must be non-zero and the corresponding public key must be provided.
// The public key should satisfy P = xG where x is the private key scalar.
func NewPrivateKey[PKV GroupElement[PKV, SKV], SKV Scalar[SKV]](value SKV, publicKey *PublicKey[PKV, SKV]) (*PrivateKey[PKV, SKV], error) <span class="cov0" title="0">{
        if utils.IsNil(value) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("value is nil")
        }</span>
        <span class="cov0" title="0">if value.IsOpIdentity() </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("value is identity")
        }</span>
        <span class="cov0" title="0">if publicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("publicKey is nil")
        }</span>
        <span class="cov0" title="0">return &amp;PrivateKey[PKV, SKV]{
                PrivateKeyTrait: signatures.PrivateKeyTrait[PKV, SKV]{
                        V:              value,
                        PublicKeyTrait: publicKey.PublicKeyTrait,
                },
        }, nil</span>
}

// PrivateKey represents a Schnorr private key as a scalar x in [1, n-1],
// where n is the group order. The corresponding public key is P = xG.
type PrivateKey[PKV GroupElement[PKV, SKV], SKV Scalar[SKV]] struct {
        signatures.PrivateKeyTrait[PKV, SKV]
}

// PublicKey returns the public key corresponding to this private key.
func (sk *PrivateKey[PKV, SKV]) PublicKey() *PublicKey[PKV, SKV] <span class="cov0" title="0">{
        return &amp;PublicKey[PKV, SKV]{PublicKeyTrait: sk.PublicKeyTrait}
}</span>

// Name returns the signature scheme name ("SchnorrLike").
func (*PrivateKey[PKV, SKV]) Name() signatures.Name <span class="cov0" title="0">{
        return Name
}</span>

// Equal returns true if two private keys have the same scalar value.
func (sk *PrivateKey[PKV, SKV]) Equal(other *PrivateKey[PKV, SKV]) bool <span class="cov0" title="0">{
        if sk == nil || other == nil </span><span class="cov0" title="0">{
                return sk == other
        }</span>
        <span class="cov0" title="0">return sk.Name() == other.Name() &amp;&amp; sk.PrivateKeyTrait.Equal(&amp;other.PrivateKeyTrait)</span>
}

// Clone returns a deep copy of the private key.
func (sk *PrivateKey[PKV, SKV]) Clone() *PrivateKey[PKV, SKV] <span class="cov0" title="0">{
        if sk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PrivateKey[PKV, SKV]{
                PrivateKeyTrait: *sk.PrivateKeyTrait.Clone(),
        }</span>
}

// NewSignature creates a Schnorr signature from its components.
// A signature consists of:
//   - e: the challenge scalar (may be nil for some variants like Mina)
//   - r: the nonce commitment point R = kG
//   - s: the response scalar s = k  ex
//
// At least one of e or r must be provided, as both are needed for verification
// (e can be recomputed from R, P, and m).
func NewSignature[GE GroupElement[GE, S], S Scalar[S]](e S, r GE, s S) (*Signature[GE, S], error) <span class="cov0" title="0">{
        if utils.IsNil(s) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("s is nil")
        }</span>
        <span class="cov0" title="0">if utils.IsNil(r) &amp;&amp; utils.IsNil(e) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("r and e can't both be nil")
        }</span>
        <span class="cov0" title="0">return &amp;Signature[GE, S]{
                E: e,
                R: r,
                S: s,
        }, nil</span>
}

// Signature represents a Schnorr signature with three components:
//   - E: the Fiat-Shamir challenge e = H(R || P || m)
//   - R: the nonce commitment R = kG
//   - S: the response s = k + ex (or k - ex for some variants)
//
// Some variants (like Mina) don't store E explicitly as it can be recomputed.
// The serialised format varies by variant (typically just R.x and S).
type Signature[GE GroupElement[GE, S], S Scalar[S]] struct {
        E S
        R GE
        S S
}

// Equal returns true if two signatures have identical E, R, and S values.
func (sig *Signature[GE, S]) Equal(other *Signature[GE, S]) bool <span class="cov0" title="0">{
        if sig == nil || other == nil </span><span class="cov0" title="0">{
                return sig == other
        }</span>
        <span class="cov0" title="0">return sig.E.Equal(other.E) &amp;&amp; sig.R.Equal(other.R) &amp;&amp; sig.S.Equal(other.S)</span>
}

// Clone returns a deep copy of the signature.
func (sig *Signature[GE, S]) Clone() *Signature[GE, S] <span class="cov0" title="0">{
        if sig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;Signature[GE, S]{
                E: sig.E.Clone(),
                R: sig.R.Clone(),
                S: sig.S.Clone(),
        }</span>
}

// HashCode returns a hash code for the signature, useful for hash-based collections.
func (sig *Signature[GE, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return sig.E.HashCode() ^ sig.R.HashCode() ^ sig.S.HashCode()
}</span>

// KeyGeneratorTrait provides common key generation logic for Schnorr schemes.
// It generates key pairs by sampling a random non-zero scalar x and computing P = xG.
type KeyGeneratorTrait[GE GroupElement[GE, S], S Scalar[S]] struct {
        Grp Group[GE, S]   // The elliptic curve group
        SF  ScalarField[S] // The scalar field (integers mod group order)
}

// Generate creates a new Schnorr key pair using randomness from prng.
// The private key is a random scalar x in [1, n-1], and the public key is P = xG.
func (kg *KeyGeneratorTrait[GE, S]) Generate(prng io.Reader) (*PrivateKey[GE, S], *PublicKey[GE, S], error) <span class="cov0" title="0">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov0" title="0">sc, err := algebrautils.RandomNonIdentity(kg.SF, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("scalar")
        }</span>
        <span class="cov0" title="0">pkv := kg.Grp.ScalarBaseOp(sc)
        pk, err := NewPublicKey(pkv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("public key")
        }</span>
        <span class="cov0" title="0">sk, err := NewPrivateKey(sc, pk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("private key")
        }</span>
        <span class="cov0" title="0">return sk, pk, nil</span>
}

// SignerTrait provides common signing logic for Schnorr schemes.
// It implements the standard Schnorr signing algorithm using variant-specific
// nonce generation, challenge computation, and response calculation.
type SignerTrait[VR Variant[GE, S, M], GE GroupElement[GE, S], S Scalar[S], M Message] struct {
        Sk       *PrivateKey[GE, S]                                           // The signing private key
        V        VR                                                           // The Schnorr variant for algorithm customization
        Verifier signatures.Verifier[*PublicKey[GE, S], M, *Signature[GE, S]] // Verifier for signature self-check
}

// Sign creates a Schnorr signature on the given message.
// The signing process:
//  1. Generate nonce k and commitment R = kG (via variant)
//  2. Compute challenge e = H(R || P || m) (via variant)
//  3. Compute response s = k + ex (via variant)
//  4. Verify the signature before returning (defence in depth)
//
// The signature verification step protects against fault attacks that might
// produce invalid signatures leaking information about the private key.
func (sg *SignerTrait[VR, GE, S, M]) Sign(message M) (*Signature[GE, S], error) <span class="cov0" title="0">{
        R, k, err := sg.V.ComputeNonceCommitment()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("R")
        }</span>
        <span class="cov0" title="0">e, err := sg.V.ComputeChallenge(R, sg.Sk.PublicKey().Value(), message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("e")
        }</span>
        <span class="cov0" title="0">s, err := sg.V.ComputeResponse(sg.Sk.Value(), k, e)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not compute response")
        }</span>
        <span class="cov0" title="0">sigma := &amp;Signature[GE, S]{
                E: e,
                R: R,
                S: s,
        }

        if err := sg.Verifier.Verify(sigma, sg.Sk.PublicKey(), message); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("signature verification failed")
        }</span>
        <span class="cov0" title="0">return sigma, nil</span>
}

// Variant returns the Schnorr variant used by this signer.
func (sg *SignerTrait[VR, GE, S, M]) Variant() VR <span class="cov0" title="0">{
        return sg.V
}</span>

// VerifierTrait provides common verification logic for Schnorr schemes.
// It implements signature verification using the standard Schnorr equation:
// sG = R + eP (or sG = R - eP when ResponseOperatorIsNegative is true).
type VerifierTrait[VR Variant[GE, S, M], GE GroupElement[GE, S], S Scalar[S], M Message] struct {
        V                          VR                // The Schnorr variant for challenge computation
        ChallengePublicKey         *PublicKey[GE, S] // Optional override for partial signature verification
        ResponseOperatorIsNegative bool              // If true, uses sG = R - eP instead of sG = R + eP
}

// Variant returns the Schnorr variant used by this verifier.
func (v *VerifierTrait[VR, GE, S, M]) Variant() VR <span class="cov0" title="0">{
        return v.V
}</span>

// Verify checks that a signature is valid for a message under a public key.
// The verification equation is: sG = R + eP (or R - eP if ResponseOperatorIsNegative).
//
// For threshold/partial signatures, ChallengePublicKey can be set to use a
// different public key for challenge computation than for the verification equation.
func (v *VerifierTrait[VR, GE, S, M]) Verify(sigma *Signature[GE, S], publicKey *PublicKey[GE, S], message M) error <span class="cov0" title="0">{
        if publicKey == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("publicKey is nil")
        }</span>
        <span class="cov0" title="0">if publicKey.Value().IsOpIdentity() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("publicKey is identity")
        }</span>
        // For partial signature verification (when ChallengePublicKey is set), use the pre-computed
        // challenge from sigma.E (which was computed from aggregate R), rather than recomputing
        // from individual R_i. For normal verification, always recompute e from the message to
        // ensure tampered messages are rejected.
        <span class="cov0" title="0">var e S
        if v.ChallengePublicKey != nil &amp;&amp; !utils.IsNil(sigma.E) </span><span class="cov0" title="0">{
                // Partial signature verification mode: use stored challenge
                e = sigma.E
        }</span> else<span class="cov0" title="0"> {
                // Normal verification: compute challenge from signature and message
                challengePublicKey := publicKey
                if v.ChallengePublicKey != nil </span><span class="cov0" title="0">{
                        challengePublicKey = v.ChallengePublicKey
                }</span>
                <span class="cov0" title="0">var err error
                e, err = v.V.ComputeChallenge(sigma.R, challengePublicKey.V, message)
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("e")
                }</span>
        }
        <span class="cov0" title="0">generator := publicKey.Group().Generator()
        rhsOperand := publicKey.Value().ScalarOp(e)
        if v.ResponseOperatorIsNegative </span><span class="cov0" title="0">{
                rhsOperand = rhsOperand.OpInv()
        }</span>
        <span class="cov0" title="0">right := sigma.R.Op(rhsOperand)
        left := generator.ScalarOp(sigma.S)
        if !left.Equal(right) </span><span class="cov0" title="0">{
                return ErrVerificationFailed.WithMessage("signature verification failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// BatchVerify verifies multiple signatures in sequence.
// This is a naive implementation that verifies each signature individually.
// Some variants (like BIP-340) provide optimised batch verification.
func (v *VerifierTrait[VR, GE, S, M]) BatchVerify(sigs []*Signature[GE, S], publicKeys []*PublicKey[GE, S], messages []M) error <span class="cov0" title="0">{
        if len(sigs) != len(publicKeys) || len(sigs) != len(messages) </span><span class="cov0" title="0">{
                return ErrFailed.WithMessage("mismatched lengths")
        }</span>
        <span class="cov0" title="0">for i := range sigs </span><span class="cov0" title="0">{
                if err := v.Verify(sigs[i], publicKeys[i], messages[i]); err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("batch verification failed")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func _[GE GroupElement[GE, S], S Scalar[S]]() {
        var (
                _ signatures.PublicKey[*PublicKey[GE, S]]   = (*PublicKey[GE, S])(nil)
                _ signatures.PrivateKey[*PrivateKey[GE, S]] = (*PrivateKey[GE, S])(nil)
                _ signatures.Signature[*Signature[GE, S]]   = (*Signature[GE, S])(nil)
        )
}
</pre>
		
		<pre class="file" id="file318" style="display: none">package signatures

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
)

type PublicKeyTrait[PKV algebra.PrimeGroupElement[PKV, S], S algebra.PrimeFieldElement[S]] struct {
        V PKV
}

func (pk *PublicKeyTrait[PKV, S]) Group() algebra.PrimeGroup[PKV, S] <span class="cov0" title="0">{
        group, ok := pk.V.Structure().(algebra.PrimeGroup[PKV, S])
        if !ok </span><span class="cov0" title="0">{
                panic("PublicKeyTrait must be based on a PrimeGroupElement")</span>
        }
        <span class="cov0" title="0">return group</span>
}

func (pk *PublicKeyTrait[PKV, S]) String() string <span class="cov0" title="0">{
        if pk == nil </span><span class="cov0" title="0">{
                return "&lt;nil&gt;"
        }</span>
        <span class="cov0" title="0">return pk.V.String()</span>
}

func (pk *PublicKeyTrait[PKV, S]) Value() PKV <span class="cov0" title="0">{
        return pk.V
}</span>

func (pk *PublicKeyTrait[PKV, S]) Equal(other *PublicKeyTrait[PKV, S]) bool <span class="cov0" title="0">{
        if pk == nil || other == nil </span><span class="cov0" title="0">{
                return pk == other
        }</span>
        <span class="cov0" title="0">return pk.V.Equal(other.V)</span>
}

func (pk *PublicKeyTrait[PKV, S]) Clone() *PublicKeyTrait[PKV, S] <span class="cov0" title="0">{
        if pk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PublicKeyTrait[PKV, S]{V: pk.V.Clone()}</span>
}

func (pk *PublicKeyTrait[PKV, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return pk.V.HashCode()
}</span>

type PrivateKeyTrait[PKV algebra.PrimeGroupElement[PKV, S], S algebra.PrimeFieldElement[S]] struct {
        PublicKeyTrait[PKV, S]

        V S
}

func (sk *PrivateKeyTrait[PKV, S]) ScalarField() algebra.PrimeField[S] <span class="cov0" title="0">{
        return algebra.StructureMustBeAs[algebra.PrimeField[S]](sk.V.Structure())
}</span>

func (sk *PrivateKeyTrait[PKV, S]) Value() S <span class="cov0" title="0">{
        return sk.V
}</span>

func (sk *PrivateKeyTrait[PKV, S]) Equal(other *PrivateKeyTrait[PKV, S]) bool <span class="cov0" title="0">{
        if sk == nil || other == nil </span><span class="cov0" title="0">{
                return sk == other
        }</span>
        <span class="cov0" title="0">return sk.V.Equal(other.V) &amp;&amp; sk.PublicKeyTrait.Equal(&amp;other.PublicKeyTrait)</span>
}

func (sk *PrivateKeyTrait[PKV, S]) Clone() *PrivateKeyTrait[PKV, S] <span class="cov0" title="0">{
        if sk == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PrivateKeyTrait[PKV, S]{
                V:              sk.V.Clone(),
                PublicKeyTrait: *sk.PublicKeyTrait.Clone(),
        }</span>
}
</pre>
		
		<pre class="file" id="file319" style="display: none">package aor

import (
        "encoding/binary"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel    = "BRON_CRYPTO_AOR-"
        sizeLabel          = "BRON_CRYPTO_AOR_SIZE-"
        commitmentKeyLabel = "BRON_CRYPTO_AOR_COMMITMENT_KEY-"
        commitmentLabel    = "BRON_CRYPTO_AOR_COMMITMENT-"
)

// Participant runs the Agree-on-Random protocol for a single party.
type Participant struct {
        id               sharing.ID
        size             int
        quorum           network.Quorum
        round            network.Round
        tape             transcripts.Transcript
        commitmentScheme *hash_comm.Scheme
        prng             io.Reader
        state            State
}

type State struct {
        r            []byte
        rWitness     hash_comm.Witness
        rCommitments map[sharing.ID]hash_comm.Commitment
}

// NewParticipant initialises an AOR participant with transcript binding and randomness.
func NewParticipant(id sharing.ID, quorum network.Quorum, size int, tape transcripts.Transcript, prng io.Reader) (*Participant, error) <span class="cov8" title="1">{
        if size &lt;= 0 || tape == nil || prng == nil || quorum == nil || !quorum.Contains(id) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid arguments")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(transcriptLabel)
        tape.AppendBytes(sizeLabel, binary.LittleEndian.AppendUint64(nil, uint64(size)))
        keyBytes, err := tape.ExtractBytes(commitmentKeyLabel, hash_comm.KeySize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot extract commitment key")
        }</span>
        <span class="cov8" title="1">var key hash_comm.Key
        copy(key[:], keyBytes)
        commitmentScheme, err := hash_comm.NewScheme(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create commitment scheme")
        }</span>

        <span class="cov8" title="1">return &amp;Participant{
                id:               id,
                size:             size,
                quorum:           quorum,
                round:            1,
                tape:             tape,
                commitmentScheme: commitmentScheme,
                prng:             prng,
                state:            State{}, //nolint:exhaustruct // initially empty state
        }, nil</span>
}

func (p *Participant) SharingID() sharing.ID <span class="cov8" title="1">{
        return p.id
}</span>
</pre>
		
		<pre class="file" id="file320" style="display: none">package aor

import (
        "crypto/subtle"
        "encoding/binary"
        "io"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// Round1 samples a random value, commits to it, and broadcasts the commitment.
func (p *Participant) Round1() (*Round1Broadcast, error) <span class="cov8" title="1">{
        // validation
        if p.round != 1 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("expected round 1, got %d", p.round)
        }</span>

        // step 1.1: sample a random message
        <span class="cov8" title="1">p.state.r = make([]byte, p.size)
        _, err := io.ReadFull(p.prng, p.state.r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not sample random message")
        }</span>

        // step 1.2: commit your sample
        <span class="cov8" title="1">p.state.rCommitments = make(map[sharing.ID]hash_comm.Commitment)
        p.state.rCommitments[p.id], p.state.rWitness, err = p.commitmentScheme.Committer().Commit(p.state.r, p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not commit to the seed")
        }</span>

        // step 1.3: broadcast your commitment
        <span class="cov8" title="1">p.round++
        return &amp;Round1Broadcast{
                Commitment: p.state.rCommitments[p.id],
        }, nil</span>
}

// Round2 records all commitments and broadcasts the local opening (message, witness).
func (p *Participant) Round2(r1 network.RoundMessages[*Round1Broadcast]) (*Round2Broadcast, error) <span class="cov8" title="1">{
        // validation
        incomingMessages, err := validateIncomingBroadcastMessages(p, 2, r1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid incoming messages or round mismatch")
        }</span>

        // step 2.0: store all commitments
        <span class="cov8" title="1">for id, m := range incomingMessages </span><span class="cov8" title="1">{
                p.state.rCommitments[id] = m.Commitment
        }</span>
        <span class="cov8" title="1">p.writeCommitmentsToTranscript()

        // step 2.1: broadcast your witness and your sample r_i
        p.round++
        return &amp;Round2Broadcast{
                Message: p.state.r,
                Witness: p.state.rWitness,
        }, nil</span>
}

// Round3 verifies all openings and aggregates the agreed random output.
func (p *Participant) Round3(r2 network.RoundMessages[*Round2Broadcast]) ([]byte, error) <span class="cov8" title="1">{
        // validation
        incomingMessages, err := validateIncomingBroadcastMessages(p, 3, r2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid incoming messages or round mismatch")
        }</span>

        <span class="cov8" title="1">r := p.state.r
        for id, m := range incomingMessages </span><span class="cov8" title="1">{
                if err := p.commitmentScheme.Verifier().Verify(p.state.rCommitments[id], m.Message, m.Witness); err != nil </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("could not verify commitment")
                }</span>
                <span class="cov8" title="1">subtle.XORBytes(r, r, m.Message)</span>
        }

        <span class="cov8" title="1">p.round++
        return r, nil</span>
}

func (p *Participant) writeCommitmentsToTranscript() <span class="cov8" title="1">{
        for _, id := range slices.Sorted(p.quorum.Iter()) </span><span class="cov8" title="1">{
                p.tape.AppendBytes(commitmentLabel, binary.LittleEndian.AppendUint64(nil, uint64(id)), p.state.rCommitments[id].Bytes())
        }</span>
}
</pre>
		
		<pre class="file" id="file321" style="display: none">package aor

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/network/exchange"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// NewAgreeOnRandomRunner constructs a runner that executes the Agree-on-Random protocol.
func NewAgreeOnRandomRunner(id sharing.ID, quorum network.Quorum, sampleSize int, tape transcripts.Transcript, prng io.Reader) (network.Runner[[]byte], error) <span class="cov8" title="1">{
        party, err := NewParticipant(id, quorum, sampleSize, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create participant")
        }</span>

        <span class="cov8" title="1">return &amp;agreeOnRandomRunner{participant: party}, nil</span>
}

type agreeOnRandomRunner struct {
        participant *Participant
}

// Run executes the three-round Agree-on-Random protocol over the provided message router.
func (r *agreeOnRandomRunner) Run(rt *network.Router) ([]byte, error) <span class="cov8" title="1">{
        // r1
        r1Out, err := r.participant.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 1")
        }</span>
        <span class="cov8" title="1">r2In, err := exchange.Broadcast(rt, "AgreeOnRandomRound1Broadcast", r1Out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot exchange broadcast")
        }</span>

        // r2
        <span class="cov8" title="1">r2Out, err := r.participant.Round2(r2In)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 2")
        }</span>
        <span class="cov8" title="1">r3In, err := exchange.Broadcast(rt, "AgreeOnRandomRound2Broadcast", r2Out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot exchange broadcast")
        }</span>

        // r3
        <span class="cov8" title="1">sample, err := r.participant.Round3(r3In)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 3")
        }</span>

        <span class="cov8" title="1">return sample, nil</span>
}
</pre>
		
		<pre class="file" id="file322" style="display: none">package testutils

import (
        crand "crypto/rand"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/aor"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/stretchr/testify/require"
)

func MakeAgreeOnRandomParticipants(tb testing.TB, quorum network.Quorum, tapes map[sharing.ID]transcripts.Transcript, sampleSize int) map[sharing.ID]*aor.Participant <span class="cov0" title="0">{
        tb.Helper()

        participants := map[sharing.ID]*aor.Participant{}
        for id := range quorum.Iter() </span><span class="cov0" title="0">{
                p, err := aor.NewParticipant(id, quorum, sampleSize, tapes[id], crand.Reader)
                require.NoError(tb, err)
                participants[id] = p
        }</span>
        <span class="cov0" title="0">return participants</span>
}

func MakeAgreeOnRandomRunners(tb testing.TB, quorum network.Quorum, tapes map[sharing.ID]transcripts.Transcript, sampleSize int) map[sharing.ID]network.Runner[[]byte] <span class="cov0" title="0">{
        tb.Helper()

        runners := map[sharing.ID]network.Runner[[]byte]{}
        for id := range quorum.Iter() </span><span class="cov0" title="0">{
                runner, err := aor.NewAgreeOnRandomRunner(id, quorum, sampleSize, tapes[id], crand.Reader)
                require.NoError(tb, err)
                runners[id] = runner
        }</span>

        <span class="cov0" title="0">return runners</span>
}
</pre>
		
		<pre class="file" id="file323" style="display: none">package aor

import (
        "iter"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

func validateIncomingBroadcastMessages[MB network.Message](p *Participant, rIn network.Round, uIn network.RoundMessages[MB]) (iter.Seq2[sharing.ID, MB], error) <span class="cov8" title="1">{
        if rIn != p.round </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">incomingParties := uIn.Keys()
        for id := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if id == p.id </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !slices.Contains(incomingParties, id) </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing broadcast message from %d", id)
                }</span>
        }

        <span class="cov8" title="1">return func(yield func(p sharing.ID, m MB) bool) </span><span class="cov8" title="1">{
                for id := range p.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == p.id </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">u, ok := uIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing broadcast message")</span>
                        }
                        <span class="cov8" title="1">if !yield(id, u) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }, nil
}
</pre>
		
		<pre class="file" id="file324" style="display: none">package gennaro

import (
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        pedcom "github.com/bronlabs/bron-crypto/pkg/commitments/pedersen"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/pedersen"
        ts "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

type (
        ScalarField[S Scalar[S]]               = algebra.PrimeField[S]
        Scalar[S algebra.PrimeFieldElement[S]] = algebra.PrimeFieldElement[S]

        // Group is an alias for the prime-order group used throughout the protocol.
        Group[E GroupElement[E, S], S Scalar[S]]                     = algebra.PrimeGroup[E, S]
        GroupElement[E algebra.PrimeGroupElement[E, S], S Scalar[S]] = algebra.PrimeGroupElement[E, S]

        // DKGOutput contains both public material and the participant's private share.
        DKGOutput[
                E GroupElement[E, S], S Scalar[S],
        ] struct {
                DKGPublicOutput[E, S]

                share *feldman.Share[S]
        }

        // DKGPublicOutput collects the public artefacts from the Gennaro DKG execution.
        DKGPublicOutput[
                E GroupElement[E, S], S Scalar[S],
        ] struct {
                publicKeyValue         E
                partialPublicKeyValues ds.Map[sharing.ID, E]
                fv                     feldman.VerificationVector[E, S]
                accessStructure        *sharing.ThresholdAccessStructure
        }
)

const (
        transcriptLabel              = "BRON_CRYPTO_DKG_GENNARO-"
        proverIDLabel                = "BRON_CRYPTO_DKG_GENNARO_PROVER_ID-"
        secondPedersenGeneratorLabel = "second generator of pedersen key"
)

// Participant orchestrates the Gennaro DKG protocol for one party.
type Participant[E GroupElement[E, S], S Scalar[S]] struct {
        sid            network.SID
        ac             *sharing.ThresholdAccessStructure
        id             sharing.ID
        niCompilerName compiler.Name
        tape           ts.Transcript
        prng           io.Reader
        state          *State[E, S]
        round          network.Round
}

// SharingID returns the participant's identifier within the sharing scheme.
func (p *Participant[E, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return p.id
}</span>

// AccessStructure returns the access structure enforced by the DKG.
func (p *Participant[E, S]) AccessStructure() *sharing.ThresholdAccessStructure <span class="cov8" title="1">{
        return p.ac
}</span>

type State[E GroupElement[E, S], S Scalar[S]] struct {
        key         *pedcom.Key[E, S]
        pedersenVSS *pedersen.Scheme[E, S]
        feldmanVSS  *feldman.Scheme[E, S]

        receivedPedersenVerificationVectors ds.MutableMap[sharing.ID, pedersen.VerificationVector[E, S]]
        receivedFeldmanVerificationVectors  ds.MutableMap[sharing.ID, feldman.VerificationVector[E, S]]

        localPedersenDealerOutput      *pedersen.DealerOutput[E, S]
        pedersenDealerFunc             *pedersen.DealerFunc[S]
        localFeldmanVerificationVector feldman.VerificationVector[E, S]
        localSecret                    *pedersen.Secret[S]
        localShare                     *pedersen.Share[S]
}

// NewParticipant constructs a participant for the Gennaro DKG protocol.
func NewParticipant[E GroupElement[E, S], S Scalar[S]](
        sid network.SID,
        group Group[E, S],
        myID sharing.ID,
        ac *sharing.ThresholdAccessStructure,
        niCompilerName compiler.Name,
        tape ts.Transcript,
        prng io.Reader,
) (*Participant[E, S], error) <span class="cov8" title="1">{
        if group == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("group is nil")
        }</span>
        <span class="cov8" title="1">if tape == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("tape is nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">if ac == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("access structure is nil")
        }</span>
        <span class="cov8" title="1">if !ac.Shareholders().Contains(myID) </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("myID is not a shareholder in the access structure")
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d-%s", transcriptLabel, sid, group.Name())
        tape.AppendDomainSeparator(dst)

        h, err := ts.Extract(tape, secondPedersenGeneratorLabel, group)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to extract second generator for pedersen key")
        }</span>
        <span class="cov8" title="1">key, err := pedcom.NewCommitmentKey(group.Generator(), h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create pedersen key")
        }</span>
        <span class="cov8" title="1">pedersenVSS, err := pedersen.NewScheme(key, ac.Threshold(), ac.Shareholders())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create pedersen VSS scheme")
        }</span>
        <span class="cov8" title="1">feldmanVSS, err := feldman.NewScheme(key.G(), ac.Threshold(), ac.Shareholders())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create feldman VSS scheme")
        }</span>
        <span class="cov8" title="1">return &amp;Participant[E, S]{
                sid:            sid,
                tape:           tape,
                prng:           prng,
                id:             myID,
                ac:             ac,
                niCompilerName: niCompilerName,
                //nolint:exhaustruct // initially partially empty state
                state: &amp;State[E, S]{
                        key:                                 key,
                        pedersenVSS:                         pedersenVSS,
                        feldmanVSS:                          feldmanVSS,
                        receivedPedersenVerificationVectors: hashmap.NewComparable[sharing.ID, pedersen.VerificationVector[E, S]](),
                        receivedFeldmanVerificationVectors:  hashmap.NewComparable[sharing.ID, feldman.VerificationVector[E, S]](),
                },
                round: 1,
        }, nil</span>
}

// NewDKGOutput builds an output wrapper from a verified Feldman share and verification vector.
func NewDKGOutput[E GroupElement[E, S], S Scalar[S]](
        share *feldman.Share[S],
        vector feldman.VerificationVector[E, S],
        accessStructure *sharing.ThresholdAccessStructure,
) (*DKGOutput[E, S], error) <span class="cov8" title="1">{
        if share == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("share is nil")
        }</span>
        <span class="cov8" title="1">if vector == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("verification vector is nil")
        }</span>
        <span class="cov8" title="1">if accessStructure == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("accessStructure is nil")
        }</span>
        <span class="cov8" title="1">sf, ok := share.Value().Structure().(ScalarField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("share value structure is not a scalar field")
        }</span>
        <span class="cov8" title="1">publicKeyValue := vector.Eval(sf.Zero())
        partialPublicKeys, err := ComputePartialPublicKey(sf, share, vector, accessStructure)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compute partial public keys from share")
        }</span>
        <span class="cov8" title="1">return &amp;DKGOutput[E, S]{
                share: share,
                DKGPublicOutput: DKGPublicOutput[E, S]{
                        publicKeyValue:         publicKeyValue,
                        partialPublicKeyValues: partialPublicKeys,
                        fv:                     vector,
                        accessStructure:        accessStructure,
                },
        }, nil</span>
}

// Share returns the private Feldman share produced by the DKG.
func (o *DKGOutput[E, S]) Share() *feldman.Share[S] <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return o.share</span>
}

// PublicMaterial returns a copy of the public output material.
func (o *DKGOutput[E, S]) PublicMaterial() *DKGPublicOutput[E, S] <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;DKGPublicOutput[E, S]{
                publicKeyValue:         o.publicKeyValue,
                partialPublicKeyValues: o.partialPublicKeyValues,
                fv:                     o.fv,
                accessStructure:        o.accessStructure,
        }</span>
}

// PublicKeyValue returns the joint public key value derived from the verification vector.
func (o *DKGPublicOutput[E, S]) PublicKeyValue() E <span class="cov8" title="1">{
        return o.publicKeyValue
}</span>

// PartialPublicKeyValues returns the map of per-party public key contributions.
func (o *DKGPublicOutput[E, S]) PartialPublicKeyValues() ds.Map[sharing.ID, E] <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return o.partialPublicKeyValues</span>
}

// AccessStructure returns the access structure associated with the DKG output.
func (o *DKGPublicOutput[E, S]) AccessStructure() *sharing.ThresholdAccessStructure <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return o.accessStructure</span>
}

// VerificationVector returns the Feldman verification vector committed during the protocol.
func (o *DKGPublicOutput[E, S]) VerificationVector() feldman.VerificationVector[E, S] <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return o.fv</span>
}
</pre>
		
		<pre class="file" id="file325" style="display: none">package gennaro

import (
        "encoding/binary"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/batch_schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
)

// Round1 runs the dealer step and broadcasts the Pedersen verification vector.
func (p *Participant[E, S]) Round1() (*Round1Broadcast[E, S], error) <span class="cov8" title="1">{
        if p.round != 1 </span><span class="cov8" title="1">{
                return nil, ErrRound.WithMessage("expected round 1, got %d", p.round)
        }</span>
        <span class="cov8" title="1">var err error
        p.state.localPedersenDealerOutput, p.state.localSecret, p.state.pedersenDealerFunc, err = p.state.pedersenVSS.DealRandomAndRevealDealerFunc(p.prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("failed to deal random and reveal dealer function")
        }</span>
        <span class="cov8" title="1">var ok bool
        p.state.localShare, ok = p.state.localPedersenDealerOutput.Shares().Get(p.id)
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("failed to get my pedersen share")
        }</span>
        <span class="cov8" title="1">p.round++
        return &amp;Round1Broadcast[E, S]{
                PedersenVerificationVector: p.state.localPedersenDealerOutput.VerificationVector(),
        }, nil</span>
}

// Round2 shares Pedersen openings privately and proves correctness of Feldman vector.
func (p *Participant[E, S]) Round2(r2bin network.RoundMessages[*Round1Broadcast[E, S]]) (*Round2Broadcast[E, S], network.OutgoingUnicasts[*Round2Unicast[E, S]], error) <span class="cov8" title="1">{
        if p.round != 2 </span><span class="cov8" title="1">{
                return nil, nil, ErrRound.WithMessage("expected round 2, got %d", p.round)
        }</span>
        <span class="cov8" title="1">var err error
        r2uo := hashmap.NewComparable[sharing.ID, *Round2Unicast[E, S]]()
        for pid := range p.ac.Shareholders().Iter() </span><span class="cov8" title="1">{
                if pid == p.id </span><span class="cov8" title="1">{
                        continue</span> // skip myself
                }
                <span class="cov8" title="1">inB, _ := r2bin.Get(pid)
                p.state.receivedPedersenVerificationVectors.Put(pid, inB.PedersenVerificationVector)

                shareForThisParty, exists := p.state.localPedersenDealerOutput.Shares().Get(pid)
                if !exists </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing pedersen share for party %d", pid)
                }</span>
                <span class="cov8" title="1">r2uo.Put(pid, &amp;Round2Unicast[E, S]{
                        Share: shareForThisParty,
                })</span>
        }
        <span class="cov8" title="1">p.state.localFeldmanVerificationVector, err = polynomials.LiftPolynomial(p.state.pedersenDealerFunc.G, p.state.key.G())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("failed to lift pedersen dealer function to exponent")
        }</span>

        <span class="cov8" title="1">batchSchnorrProtocol, err := batch_schnorr.NewProtocol(int(p.AccessStructure().Threshold()), p.state.key.Group(), p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create batch schnorr protocol")
        }</span>
        <span class="cov8" title="1">niBatchSchnorr, err := compiler.Compile(p.niCompilerName, batchSchnorrProtocol, p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot compile protocol to non interactive")
        }</span>
        <span class="cov8" title="1">proverTape := p.tape.Clone()
        proverTape.AppendBytes(proverIDLabel, binary.LittleEndian.AppendUint64(nil, uint64(p.id)))
        prover, err := niBatchSchnorr.NewProver(p.sid, proverTape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create batch schnorr prover")
        }</span>

        <span class="cov8" title="1">witness := batch_schnorr.NewWitness(p.state.pedersenDealerFunc.G.Coefficients()...)
        statement := batch_schnorr.NewStatement(p.state.key.G(), p.state.localFeldmanVerificationVector.Coefficients()...)
        proof, err := prover.Prove(statement, witness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot prove batch schnorr statement")
        }</span>

        <span class="cov8" title="1">p.round++
        return &amp;Round2Broadcast[E, S]{
                FeldmanVerificationVector: p.state.localFeldmanVerificationVector,
                Proof:                     proof,
        }, r2uo.Freeze(), nil</span>
}

// Round3 verifies all incoming shares and proofs and outputs the joint key material.
func (p *Participant[E, S]) Round3(r3bi network.RoundMessages[*Round2Broadcast[E, S]], r3ui network.RoundMessages[*Round2Unicast[E, S]]) (*DKGOutput[E, S], error) <span class="cov8" title="1">{
        if p.round != 3 </span><span class="cov8" title="1">{
                return nil, ErrRound.WithMessage("expected round 3, got %d", p.round)
        }</span>

        <span class="cov8" title="1">batchSchnorrProtocol, err := batch_schnorr.NewProtocol(int(p.AccessStructure().Threshold()), p.state.key.Group(), p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create batch schnorr protocol")
        }</span>
        <span class="cov8" title="1">niBatchSchnorr, err := compiler.Compile(p.niCompilerName, batchSchnorrProtocol, p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compile protocol to non interactive")
        }</span>

        <span class="cov8" title="1">summedShareValue := p.state.localShare.Value()
        summedFeldmanVerificationVector := p.state.localFeldmanVerificationVector
        for pid := range p.ac.Shareholders().Iter() </span><span class="cov8" title="1">{
                if pid == p.id </span><span class="cov8" title="1">{
                        continue</span> // skip myself
                }

                <span class="cov8" title="1">inB, _ := r3bi.Get(pid)
                verifierTape := p.tape.Clone()
                verifierTape.AppendBytes(proverIDLabel, binary.LittleEndian.AppendUint64(nil, uint64(pid)))
                verifier, err := niBatchSchnorr.NewVerifier(p.sid, verifierTape)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create batch schnorr prover")
                }</span>
                <span class="cov8" title="1">statement := batch_schnorr.NewStatement(p.state.key.G(), inB.FeldmanVerificationVector.Coefficients()...)
                err = verifier.Verify(statement, inB.Proof)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pid).WithMessage("failed to verify feldman verification vector")
                }</span>
                <span class="cov8" title="1">p.state.receivedFeldmanVerificationVectors.Put(pid, inB.FeldmanVerificationVector)

                inU, _ := r3ui.Get(pid)
                feldmanShare, _ := feldman.NewShare(inU.Share.ID(), inU.Share.Value(), nil)
                if err := p.state.feldmanVSS.Verify(feldmanShare, inB.FeldmanVerificationVector); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pid).WithMessage("failed to verify feldman share from party %d", pid)
                }</span>
                <span class="cov8" title="1">referencePedersenVector, _ := p.state.receivedPedersenVerificationVectors.Get(pid)
                if err := p.state.pedersenVSS.Verify(inU.Share, referencePedersenVector); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pid).WithMessage("failed to verify pedersen share from party %d", pid)
                }</span>
                <span class="cov8" title="1">summedShareValue = summedShareValue.Add(inU.Share.Value())
                summedFeldmanVerificationVector = summedFeldmanVerificationVector.Op(inB.FeldmanVerificationVector)</span>
        }
        <span class="cov8" title="1">outputShare, err := feldman.NewShare(p.id, summedShareValue, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create output feldman share")
        }</span>
        <span class="cov8" title="1">out, err := NewDKGOutput(outputShare, summedFeldmanVerificationVector, p.ac)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create DKG output")
        }</span>
        <span class="cov8" title="1">p.round++
        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file326" style="display: none">package gennaro

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/network/exchange"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        ts "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

type gennaroDkgRunner[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        party *Participant[G, S]
}

// NewGennaroDKGRunner constructs a network runner that drives the three DKG rounds.
func NewGennaroDKGRunner[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](group algebra.PrimeGroup[G, S], sessionID network.SID, sharingID sharing.ID, accessStructure *sharing.ThresholdAccessStructure, niCompilerName compiler.Name, tape ts.Transcript, prng io.Reader) (network.Runner[*DKGOutput[G, S]], error) <span class="cov8" title="1">{
        party, err := NewParticipant(sessionID, group, sharingID, accessStructure, niCompilerName, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create participant")
        }</span>
        <span class="cov8" title="1">return &amp;gennaroDkgRunner[G, S]{party}, nil</span>
}

// Run executes the DKG rounds using the provided router and returns the final output.
func (r *gennaroDkgRunner[G, S]) Run(rt *network.Router) (*DKGOutput[G, S], error) <span class="cov8" title="1">{
        // r1
        r1OutB, err := r.party.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 1")
        }</span>
        <span class="cov8" title="1">r2InB, err := exchange.Broadcast(rt, "GennaroDKGRound1", r1OutB)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot exchange broadcast")
        }</span>

        // r2
        <span class="cov8" title="1">r2OutB, r2OutU, err := r.party.Round2(r2InB)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 2")
        }</span>
        <span class="cov8" title="1">r3InB, r3InU, err := exchange.Exchange(rt, "GennaroDKGRound2", r2OutB, r2OutU)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot exchange broadcast")
        }</span>

        // r3
        <span class="cov8" title="1">dkgOutput, err := r.party.Round3(r3InB, r3InU)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 3")
        }</span>

        <span class="cov8" title="1">return dkgOutput, nil</span>
}
</pre>
		
		<pre class="file" id="file327" style="display: none">package testutils

import (
        crand "crypto/rand"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        ntu "github.com/bronlabs/bron-crypto/pkg/network/testutils"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/stretchr/testify/require"
)

func MakeGennaroDKGRunners[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](tb testing.TB, sessionID network.SID, accessStructure *sharing.ThresholdAccessStructure, niCompiler compiler.Name, group algebra.PrimeGroup[G, S], tapes map[sharing.ID]transcripts.Transcript) map[sharing.ID]network.Runner[*gennaro.DKGOutput[G, S]] <span class="cov0" title="0">{
        tb.Helper()

        runners := make(map[sharing.ID]network.Runner[*gennaro.DKGOutput[G, S]])
        for id := range accessStructure.Shareholders().Iter() </span><span class="cov0" title="0">{
                runner, err := gennaro.NewGennaroDKGRunner(group, sessionID, id, accessStructure, niCompiler, tapes[id], crand.Reader)
                require.NoError(tb, err)
                runners[id] = runner
        }</span>

        <span class="cov0" title="0">return runners</span>
}

func DoGennaroRound1[
        E gennaro.GroupElement[E, S], S gennaro.Scalar[S],
](
        participants []*gennaro.Participant[E, S],
) (
        r1bo map[sharing.ID]*gennaro.Round1Broadcast[E, S], err error,
) <span class="cov0" title="0">{
        r1bo = make(map[sharing.ID]*gennaro.Round1Broadcast[E, S], len(participants))
        for _, pi := range participants </span><span class="cov0" title="0">{
                r1bo[pi.SharingID()], err = pi.Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("%d could not run Gennaro round 1", pi.SharingID())
                }</span>
        }

        <span class="cov0" title="0">return r1bo, nil</span>
}

func DoGennaroRound2[
        E gennaro.GroupElement[E, S], S gennaro.Scalar[S],
](
        participants []*gennaro.Participant[E, S], r2bi map[sharing.ID]network.RoundMessages[*gennaro.Round1Broadcast[E, S]],
) (
        r2bo map[sharing.ID]*gennaro.Round2Broadcast[E, S], r2uo map[sharing.ID]network.RoundMessages[*gennaro.Round2Unicast[E, S]], err error,
) <span class="cov0" title="0">{
        r2bo = make(map[sharing.ID]*gennaro.Round2Broadcast[E, S], len(participants))
        r2uo = make(map[sharing.ID]network.RoundMessages[*gennaro.Round2Unicast[E, S]], len(participants))
        for _, pi := range participants </span><span class="cov0" title="0">{
                r2bo[pi.SharingID()], r2uo[pi.SharingID()], err = pi.Round2(r2bi[pi.SharingID()])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("%d could not run Gennaro round 2", pi.SharingID())
                }</span>
        }
        <span class="cov0" title="0">return r2bo, r2uo, nil</span>
}

func DoGennaroRound3[
        E gennaro.GroupElement[E, S], S gennaro.Scalar[S],
](
        participants []*gennaro.Participant[E, S], r3bi map[sharing.ID]network.RoundMessages[*gennaro.Round2Broadcast[E, S]], r3ui map[sharing.ID]network.RoundMessages[*gennaro.Round2Unicast[E, S]],
) (
        dkgOutput ds.MutableMap[sharing.ID, *gennaro.DKGOutput[E, S]], err error,
) <span class="cov0" title="0">{
        dkgOutput = hashmap.NewComparable[sharing.ID, *gennaro.DKGOutput[E, S]]()
        for _, pi := range participants </span><span class="cov0" title="0">{
                v, err := pi.Round3(r3bi[pi.SharingID()], r3ui[pi.SharingID()])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("%d could not run Gennaro round 3", pi.SharingID())
                }</span>
                <span class="cov0" title="0">dkgOutput.Put(pi.SharingID(), v)</span>
        }
        <span class="cov0" title="0">return dkgOutput, nil</span>
}

func DoGennaroDKG[
        E gennaro.GroupElement[E, S], S gennaro.Scalar[S],
](
        tb testing.TB, participants []*gennaro.Participant[E, S],
) (
        dkgOutput ds.MutableMap[sharing.ID, *gennaro.DKGOutput[E, S]], err error,
) <span class="cov0" title="0">{
        tb.Helper()
        r1bo, err := DoGennaroRound1(participants)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not run Gennaro round 1")
        }</span>

        <span class="cov0" title="0">r2bi := ntu.MapBroadcastO2I(tb, participants, r1bo)

        r2bo, r2uo, err := DoGennaroRound2(participants, r2bi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not run Gennaro round 2")
        }</span>

        <span class="cov0" title="0">r3bi := ntu.MapBroadcastO2I(tb, participants, r2bo)
        r3ui := ntu.MapUnicastO2I(tb, participants, r2uo)

        dkgOutput, err = DoGennaroRound3(participants, r3bi, r3ui)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not run Gennaro round 3")
        }</span>

        <span class="cov0" title="0">return dkgOutput, nil</span>
}
</pre>
		
		<pre class="file" id="file328" style="display: none">package gennaro

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir"
)

// ComputePartialPublicKey derives each participant's partial public key from a share and verification vector.
func ComputePartialPublicKey[E GroupElement[E, S], S Scalar[S]](
        sf algebra.PrimeField[S],
        share *feldman.Share[S],
        vector feldman.VerificationVector[E, S],
        ac sharing.AccessStructure,
) (ds.Map[sharing.ID, E], error) <span class="cov8" title="1">{
        if share == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil share")
        }</span>
        <span class="cov8" title="1">if ac == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil access structure")
        }</span>
        <span class="cov8" title="1">if sf.Name() != share.Value().Structure().Name() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("field mismatch: %s != %s", sf.Name(), share.Value().Structure().Name())
        }</span>
        <span class="cov8" title="1">out := hashmap.NewComparable[sharing.ID, E]()
        for id := range ac.Shareholders().Iter() </span><span class="cov8" title="1">{
                out.Put(
                        id,
                        vector.Eval(shamir.SharingIDToLagrangeNode(sf, id)),
                )
        }</span>
        <span class="cov8" title="1">return out.Freeze(), nil</span>
}
</pre>
		
		<pre class="file" id="file329" style="display: none">package recovery

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
)

// Mislayer represents the party whose share is being reconstructed.
type Mislayer[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        sharingID sharing.ID
        field     algebra.PrimeField[S]
        scheme    *feldman.Scheme[G, S]
        quorum    network.Quorum
}

// NewMislayer constructs a mislayer helper used to validate and interpolate recovered shares.
func NewMislayer[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](id sharing.ID, quorum network.Quorum, as *sharing.ThresholdAccessStructure, group algebra.PrimeGroup[G, S]) (*Mislayer[G, S], error) <span class="cov8" title="1">{
        if quorum == nil || as == nil || group == nil || !quorum.Contains(id) || !quorum.IsSubSet(as.Shareholders()) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid arguments")
        }</span>

        <span class="cov8" title="1">field := algebra.StructureMustBeAs[algebra.PrimeField[S]](group.ScalarStructure())
        scheme, err := feldman.NewScheme(group.Generator(), as.Threshold(), as.Shareholders())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create feldman scheme")
        }</span>

        <span class="cov8" title="1">m := &amp;Mislayer[G, S]{
                sharingID: id,
                field:     field,
                scheme:    scheme,
                quorum:    quorum,
        }
        return m, nil</span>
}

// SharingID returns the identifier of the share being recovered.
func (m *Mislayer[G, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return m.sharingID
}</span>
</pre>
		
		<pre class="file" id="file330" style="display: none">package recovery

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig"
)

// Recoverer orchestrates recovery of a missing party's share.
type Recoverer[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        shard      *tsig.BaseShard[G, S]
        scheme     *feldman.Scheme[G, S]
        group      algebra.PrimeGroup[G, S]
        field      algebra.PrimeField[S]
        mislayerID sharing.ID
        quorum     ds.Set[sharing.ID]
        prng       io.Reader
        state      RecovererState[G, S]
}

// RecovererState stores per-session randomness and blinded share data.
type RecovererState[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        blindShare *feldman.Share[S]
}

// NewRecoverer creates a recoverer that helps reconstruct the mislayer's share.
func NewRecoverer[
        G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S],
](mislayerID sharing.ID, quorum network.Quorum, shard *tsig.BaseShard[G, S], prng io.Reader) (*Recoverer[G, S], error) <span class="cov8" title="1">{
        if quorum == nil || shard == nil || !quorum.Contains(shard.Share().ID()) || !quorum.Contains(mislayerID) || !quorum.IsSubSet(shard.AccessStructure().Shareholders()) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid arguments")
        }</span>

        <span class="cov8" title="1">group := algebra.StructureMustBeAs[algebra.PrimeGroup[G, S]](shard.VerificationVector().Coefficients()[0].Structure())
        field := algebra.StructureMustBeAs[algebra.PrimeField[S]](shard.Share().Value().Structure())
        scheme, err := feldman.NewScheme(group.Generator(), shard.AccessStructure().Threshold(), shard.AccessStructure().Shareholders())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create feldman scheme")
        }</span>

        <span class="cov8" title="1">r := &amp;Recoverer[G, S]{
                shard:      shard,
                scheme:     scheme,
                group:      group,
                field:      field,
                mislayerID: mislayerID,
                quorum:     quorum,
                prng:       prng,
                state:      RecovererState[G, S]{blindShare: nil},
        }
        return r, nil</span>
}

// SharingID returns the identifier of the share being recovered.
func (r *Recoverer[G, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return r.shard.Share().ID()
}</span>
</pre>
		
		<pre class="file" id="file331" style="display: none">package recovery

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials/interpolation/lagrange"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
)

// Round1 blinds the dealer polynomial and distributes blinded shares.
func (r *Recoverer[G, S]) Round1() (*Round1Broadcast[G, S], network.OutgoingUnicasts[*Round1P2P[G, S]], error) <span class="cov8" title="1">{
        blindOutput, _, err := r.scheme.DealRandom(r.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot deal blind")
        }</span>

        <span class="cov8" title="1">shift, ok := blindOutput.Shares().Get(r.mislayerID)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("cannot find mislayer share")
        }</span>
        <span class="cov8" title="1">blindShares := make(map[sharing.ID]*feldman.Share[S])
        for id, s := range blindOutput.Shares().Iter() </span><span class="cov8" title="1">{
                blindShares[id] = s.SubPlain(shift.Value())
                if id == r.SharingID() </span><span class="cov8" title="1">{
                        r.state.blindShare = blindShares[id]
                }</span>
        }
        <span class="cov8" title="1">blindVerification := blindOutput.VerificationMaterial().OpElement(r.group.Generator().ScalarOp(shift.Value()).OpInv())

        r1b := &amp;Round1Broadcast[G, S]{
                BlindVerificationVector: blindVerification,
        }
        r1u := hashmap.NewComparable[sharing.ID, *Round1P2P[G, S]]()
        for id := range r.quorum.Iter() </span><span class="cov8" title="1">{
                if id == r.mislayerID || id == r.SharingID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">s, ok := blindShares[id]
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing share")
                }</span>
                <span class="cov8" title="1">r1u.Put(id, &amp;Round1P2P[G, S]{
                        BlindShare: s,
                })</span>
        }

        <span class="cov8" title="1">return r1b, r1u.Freeze(), nil</span>
}

// Round2 aggregates blinded shares and publishes the original verification vector.
func (r *Recoverer[G, S]) Round2(r1b network.RoundMessages[*Round1Broadcast[G, S]], r1u network.RoundMessages[*Round1P2P[G, S]]) (*Round2Broadcast[G, S], network.OutgoingUnicasts[*Round2P2P[G, S]], error) <span class="cov8" title="1">{
        // TODO add share verification

        blindedShare := r.state.blindShare.Add(r.shard.Share())
        for id := range r.quorum.Iter() </span><span class="cov8" title="1">{
                if id == r.mislayerID || id == r.SharingID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">u, ok := r1u.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing share")
                }</span>
                <span class="cov8" title="1">b, ok := r1b.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing verification vector")
                }</span>

                <span class="cov8" title="1">verificationVector := b.BlindVerificationVector
                if !verificationVector.Eval(r.field.FromUint64(uint64(r.mislayerID))).IsOpIdentity() </span><span class="cov0" title="0">{
                        return nil, nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("invalid share")
                }</span>

                <span class="cov8" title="1">share := u.BlindShare
                err := r.scheme.Verify(share, verificationVector)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("cannot verify share")
                }</span>

                <span class="cov8" title="1">blindedShare = blindedShare.Add(share)</span>
        }

        <span class="cov8" title="1">r2b := &amp;Round2Broadcast[G, S]{
                VerificationVector: r.shard.VerificationVector(),
        }
        r2u := hashmap.NewComparable[sharing.ID, *Round2P2P[G, S]]()
        r2u.Put(r.mislayerID, &amp;Round2P2P[G, S]{
                BlindedShare: blindedShare,
        })

        return r2b, r2u.Freeze(), nil</span>
}

// Round3 interpolates the blinded shares to reconstruct the missing share.
func (m *Mislayer[G, S]) Round3(r2b network.RoundMessages[*Round2Broadcast[G, S]], r2u network.RoundMessages[*Round2P2P[G, S]]) (share *feldman.Share[S], verification feldman.VerificationVector[G, S], err error) <span class="cov8" title="1">{
        xs := []S{}
        ys := []S{}

        var verificationVector feldman.VerificationVector[G, S]
        for id := range m.quorum.Iter() </span><span class="cov8" title="1">{
                if id == m.sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">b, ok := r2b.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing message")
                }</span>
                <span class="cov8" title="1">if verificationVector == nil </span><span class="cov8" title="1">{
                        verificationVector = b.VerificationVector
                }</span> else<span class="cov8" title="1"> if !verificationVector.Equal(b.VerificationVector) </span><span class="cov0" title="0">{
                        return nil, nil, base.ErrAbort.WithMessage("mislayer verification vector does not match")
                }</span>

                <span class="cov8" title="1">u, ok := r2u.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing message")
                }</span>
                <span class="cov8" title="1">xs = append(xs, m.field.FromUint64(uint64(id)))
                ys = append(ys, u.BlindedShare.Value())</span>
        }

        <span class="cov8" title="1">shareValue, err := lagrange.InterpolateAt(xs, ys, m.field.FromUint64(uint64(m.sharingID)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, base.ErrAbort.WithMessage("cannot interpolate")
        }</span>
        <span class="cov8" title="1">share, err = feldman.NewShare(m.sharingID, shareValue, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("cannot create share")
        }</span>
        <span class="cov8" title="1">err = m.scheme.Verify(share, verificationVector)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, base.ErrAbort.WithMessage("cannot verify share")
        }</span>

        <span class="cov8" title="1">return share, verificationVector, nil</span>
}
</pre>
		
		<pre class="file" id="file332" style="display: none">package refresh

import (
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/hjky"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel = "BRON_CRYPTO_REFRESH-"
)

// Participant orchestrates share refresh using a zero-sum offset.
type Participant[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        shard           *tsig.BaseShard[G, S]
        zeroParticipant *hjky.Participant[G, S]
}

// NewParticipant constructs a shard refresher using the HjKy zero-sharing subprotocol.
func NewParticipant[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](sid network.SID, shard *tsig.BaseShard[G, S], tape transcripts.Transcript, prng io.Reader) (*Participant[G, S], error) <span class="cov8" title="1">{
        if shard == nil || tape == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("argument is nil")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s%s", transcriptLabel, hex.EncodeToString(sid[:])))
        group := algebra.StructureMustBeAs[algebra.PrimeGroup[G, S]](shard.VerificationVector().Coefficients()[0].Structure())
        zeroParticipant, err := hjky.NewParticipant(sid, shard.Share().ID(), shard.AccessStructure(), group, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create zero participant")
        }</span>

        <span class="cov8" title="1">p := &amp;Participant[G, S]{
                shard:           shard,
                zeroParticipant: zeroParticipant,
        }

        return p, nil</span>
}

// SharingID returns the identifier of the refreshed shard.
func (p *Participant[G, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return p.shard.Share().ID()
}</span>
</pre>
		
		<pre class="file" id="file333" style="display: none">package refresh

import (
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
)

// Round1 runs the zero-sharing subprotocol to derive a refresh offset.
func (p *Participant[G, S]) Round1() (broadcast *Round1Broadcast[G, S], unicasts network.OutgoingUnicasts[*Round1P2P[G, S]], err error) <span class="cov8" title="1">{
        bc, uu, err := p.zeroParticipant.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("failed to execute zero sharing Round1")
        }</span>
        <span class="cov8" title="1">return bc, uu, nil</span>
}

// Round2 finishes the refresh by adding the zero-share to the existing shard.
func (p *Participant[G, S]) Round2(r2b network.RoundMessages[*Round1Broadcast[G, S]], r2u network.RoundMessages[*Round1P2P[G, S]]) (share *feldman.Share[S], verification feldman.VerificationVector[G, S], err error) <span class="cov8" title="1">{
        share, verification, err = p.zeroParticipant.Round2(r2b, r2u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("failed to run round 2 of zero participant")
        }</span>

        <span class="cov8" title="1">share = share.Add(p.shard.Share())
        verification = verification.Op(p.shard.VerificationVector())

        return share, verification, nil</span>
}
</pre>
		
		<pre class="file" id="file334" style="display: none">package rvole_bbot

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
)

// Suite bundles protocol parameters and primitives.
type Suite[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        l     int
        group algebra.PrimeGroup[G, S]
        field algebra.PrimeField[S]
}

// NewSuite returns a new protocol suite.
func NewSuite[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](l int, group algebra.PrimeGroup[G, S]) (*Suite[G, S], error) <span class="cov8" title="1">{
        if group == nil || l &lt;= 0 </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("invalid arguments")
        }</span>
        <span class="cov8" title="1">field, ok := group.ScalarStructure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidType.WithMessage("invalid group scalar structure")
        }</span>

        <span class="cov8" title="1">s := &amp;Suite[G, S]{
                l:     l,
                group: group,
                field: field,
        }
        return s, nil</span>
}

// Group returns the underlying group.
func (s *Suite[G, S]) Group() algebra.PrimeGroup[G, S] <span class="cov8" title="1">{
        return s.group
}</span>

// Field returns the underlying field.
func (s *Suite[G, S]) Field() algebra.PrimeField[S] <span class="cov0" title="0">{
        return s.field
}</span>
</pre>
		
		<pre class="file" id="file335" style="display: none">package rvole_bbot

import (
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel = "BRON_CRYPTO_BBOT_MULTIPLY-"
        gadgetLabel     = "BRON_CRYPTO_BBOT_MULTIPLY-G-"
        aTildeLabel     = "BRON_CRYPTO_BBOT_MULTIPLY-A_TILDE-"
        thetaLabel      = "BRON_CRYPTO_BBOT_MULTIPLY-THETA-"
        muVectorLabel   = "BRON_CRYPTO_BBOT_MULTIPLY-MU_VECTOR-"
        muLabel         = "BRON_CRYPTO_BBOT_MULTIPLY-MU-"
)

type participant[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        sessionID network.SID
        suite     *Suite[G, S]
        xi, rho   int
        tape      transcripts.Transcript
        prng      io.Reader
        round     int
}

// Alice represents the sender party.
type Alice[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        participant[G, S] // Base Participant

        sender *ecbbot.Sender[G, S]
        g      []S
        alpha  [][2][]S
}

// Bob represents the receiver party.
type Bob[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        participant[G, S] // Base Participant

        receiver *ecbbot.Receiver[G, S]
        g        []S
        beta     []byte
        gamma    [][]S
}

func newParticipant[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[G, S], prng io.Reader, tape transcripts.Transcript, initialRound int) (*participant[G, S], error) <span class="cov8" title="1">{
        if suite == nil || prng == nil || tape == nil || initialRound &lt; 1 </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("argument")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        kappa := suite.group.ScalarStructure().ElementSize() * 8
        xi := kappa + 2*base.StatisticalSecurityBits
        rho := mathutils.CeilDiv(kappa, base.ComputationalSecurityBits)

        return &amp;participant[G, S]{
                prng:      prng,
                round:     initialRound,
                sessionID: sessionID,
                suite:     suite,
                tape:      tape,
                xi:        xi,
                rho:       rho,
        }, nil</span>
}

// NewAlice returns a new Alice participant.
func NewAlice[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[G, S], prng io.Reader, tape transcripts.Transcript) (*Alice[G, S], error) <span class="cov8" title="1">{
        p, err := newParticipant(sessionID, suite, prng, tape, 2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create participant / gadget vector")
        }</span>
        <span class="cov8" title="1">otSuite, err := ecbbot.NewSuite(p.xi, p.suite.l+p.rho, p.suite.Group())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create ecbbot suite")
        }</span>
        <span class="cov8" title="1">sender, err := ecbbot.NewSender(p.sessionID, otSuite, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create sender")
        }</span>
        <span class="cov8" title="1">gadget, err := p.generateGadgetVector()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create gadget vector")
        }</span>

        //nolint:exhaustruct // lazy initialisation
        <span class="cov8" title="1">alice := &amp;Alice[G, S]{
                participant: *p,
                sender:      sender,
                g:           gadget,
        }
        alice.round = 1
        return alice, nil</span>
}

// NewBob returns a new Bob participant.
func NewBob[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[G, S], prng io.Reader, tape transcripts.Transcript) (*Bob[G, S], error) <span class="cov8" title="1">{
        p, err := newParticipant(sessionID, suite, prng, tape, 1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create participant / gadget vector")
        }</span>
        <span class="cov8" title="1">otSuite, err := ecbbot.NewSuite(p.xi, p.suite.l+p.rho, p.suite.group)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create ecbbot suite")
        }</span>
        <span class="cov8" title="1">receiver, err := ecbbot.NewReceiver(p.sessionID, otSuite, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create receiver")
        }</span>
        <span class="cov8" title="1">gadget, err := p.generateGadgetVector()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create gadget vector")
        }</span>

        //nolint:exhaustruct // lazy initialisation
        <span class="cov8" title="1">bob := &amp;Bob[G, S]{
                participant: *p,
                receiver:    receiver,
                g:           gadget,
        }
        bob.round = 2
        return bob, nil</span>
}

func (p *participant[G, S]) generateGadgetVector() ([]S, error) <span class="cov8" title="1">{
        gadget := make([]S, p.xi)
        for i := range gadget </span><span class="cov8" title="1">{
                bytes, err := p.tape.ExtractBytes(gadgetLabel, uint(p.suite.field.WideElementSize()))
                if err != nil </span><span class="cov0" title="0">{
                        return gadget, errs2.Wrap(err).WithMessage("extracting bytes from transcript")
                }</span>
                <span class="cov8" title="1">gadget[i], err = p.suite.field.FromWideBytes(bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return gadget, errs2.Wrap(err).WithMessage("creating gadget scalar from bytes")
                }</span>
        }
        <span class="cov8" title="1">return gadget, nil</span>
}
</pre>
		
		<pre class="file" id="file336" style="display: none">package rvole_bbot

import (
        "bytes"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// Round1 executes protocol round 1.
func (alice *Alice[G, S]) Round1() (r1Out *Round1P2P[G, S], err error) <span class="cov8" title="1">{
        if alice.round != 1 </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">r1Out, err = alice.sender.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to call OT round 1")
        }</span>

        <span class="cov8" title="1">alice.round += 2
        return r1Out, nil</span>
}

// Round2 executes protocol round 2.
func (bob *Bob[G, S]) Round2(r1Out *Round1P2P[G, S]) (r2Out *Round2P2P[G, S], b S, err error) <span class="cov8" title="1">{
        var nilSE S
        if bob.round != 2 </span><span class="cov0" title="0">{
                return nil, nilSE, ErrValidation.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">beta := make([]byte, bob.xi/8)
        if _, err := io.ReadFull(bob.prng, beta); err != nil </span><span class="cov0" title="0">{
                return nil, nilSE, errs2.Wrap(err).WithMessage("cannot sample choices")
        }</span>

        <span class="cov8" title="1">r2Out, receiverOutput, err := bob.receiver.Round2(r1Out, beta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nilSE, errs2.Wrap(err).WithMessage("cannot run round 2 of receiver")
        }</span>
        <span class="cov8" title="1">bob.beta = receiverOutput.Choices
        bob.gamma = receiverOutput.Messages

        b = bob.suite.field.Zero()
        for j := range bob.xi </span><span class="cov8" title="1">{
                betaJ := bob.suite.field.Zero()
                ci := (bob.beta[j/8] &gt;&gt; (j % 8)) &amp; 0b1
                if ci != 0 </span><span class="cov8" title="1">{
                        betaJ = bob.suite.field.One()
                }</span>
                <span class="cov8" title="1">b = b.Add(betaJ.Mul(bob.g[j]))</span>
        }

        <span class="cov8" title="1">bob.round += 2
        return r2Out, b, nil</span>
}

// Round3 executes protocol round 3.
func (alice *Alice[G, S]) Round3(r2Out *Round2P2P[G, S], a []S) (r3Out *Round3P2P[S], c []S, err error) <span class="cov8" title="1">{
        if alice.round != 3 </span><span class="cov0" title="0">{
                return nil, nil, ErrValidation.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">senderOutput, err := alice.sender.Round3(r2Out)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot send round 3 of receiver")
        }</span>
        <span class="cov8" title="1">alice.alpha = senderOutput.Messages

        c = make([]S, alice.suite.l)
        for i := range alice.suite.l </span><span class="cov8" title="1">{
                c[i] = alice.suite.field.Zero()
                for j := range alice.xi </span><span class="cov8" title="1">{
                        c[i] = c[i].Sub(alice.g[j].Mul(alice.alpha[j][0][i]))
                }</span>
        }

        <span class="cov8" title="1">aHat := make([]S, alice.rho)
        for i := range alice.rho </span><span class="cov8" title="1">{
                aHat[i], err = alice.suite.field.Random(alice.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot get random scalar")
                }</span>
        }

        <span class="cov8" title="1">aTilde := make([][]S, alice.xi)
        for j := range alice.xi </span><span class="cov8" title="1">{
                aTilde[j] = make([]S, alice.suite.l+alice.rho)
                for i := range alice.suite.l </span><span class="cov8" title="1">{
                        aTilde[j][i] = alice.alpha[j][0][i].Sub(alice.alpha[j][1][i]).Add(a[i])
                }</span>
                <span class="cov8" title="1">for k := range alice.rho </span><span class="cov8" title="1">{
                        aTilde[j][alice.suite.l+k] = alice.alpha[j][0][alice.suite.l+k].Sub(alice.alpha[j][1][alice.suite.l+k]).Add(aHat[k])
                }</span>
        }

        <span class="cov8" title="1">theta, err := alice.roTheta(aTilde)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot get theta")
        }</span>

        <span class="cov8" title="1">eta := make([]S, alice.rho)
        for k := range alice.rho </span><span class="cov8" title="1">{
                eta[k] = aHat[k]
                for i := range alice.suite.l </span><span class="cov8" title="1">{
                        eta[k] = eta[k].Add(theta[i][k].Mul(a[i]))
                }</span>
        }

        <span class="cov8" title="1">muBold := make([][]S, alice.xi)
        for j := range alice.xi </span><span class="cov8" title="1">{
                muBold[j] = make([]S, alice.rho)
                for k := range alice.rho </span><span class="cov8" title="1">{
                        muBold[j][k] = alice.alpha[j][0][alice.suite.l+k]
                        for i := range alice.suite.l </span><span class="cov8" title="1">{
                                muBold[j][k] = muBold[j][k].Add(theta[i][k].Mul(alice.alpha[j][0][i]))
                        }</span>
                }
        }

        <span class="cov8" title="1">mu, err := alice.roMu(muBold)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot get mu")
        }</span>

        <span class="cov8" title="1">r3Out = &amp;Round3P2P[S]{
                ATilde: aTilde,
                Eta:    eta,
                Mu:     mu,
        }
        alice.round += 2
        return r3Out, c, nil</span>
}

// Round4 executes protocol round 4.
func (bob *Bob[G, S]) Round4(r3Out *Round3P2P[S]) (d []S, err error) <span class="cov8" title="1">{
        if bob.round != 4 </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("invalid round")
        }</span>
        // if err := r3Out.Validate(bob.Protocol); err != nil {
        //        return nil, errs2.Wrap(err).WithMessage("invalid message")
        //}

        <span class="cov8" title="1">theta, err := bob.roTheta(r3Out.ATilde)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get theta")
        }</span>

        <span class="cov8" title="1">dDot := make([][]S, bob.xi)
        for j := range bob.xi </span><span class="cov8" title="1">{
                dDot[j] = make([]S, bob.suite.l)
                betaJ := bob.suite.field.Zero()
                ci := (bob.beta[j/8] &gt;&gt; (j % 8)) &amp; 0b1
                if ci != 0 </span><span class="cov8" title="1">{
                        betaJ = bob.suite.field.One()
                }</span>
                <span class="cov8" title="1">for i := range bob.suite.l </span><span class="cov8" title="1">{
                        dDot[j][i] = bob.gamma[j][i].Add(betaJ.Mul(r3Out.ATilde[j][i]))
                }</span>
        }

        <span class="cov8" title="1">dHat := make([][]S, bob.xi)
        for j := range bob.xi </span><span class="cov8" title="1">{
                dHat[j] = make([]S, bob.rho)
                betaJ := bob.suite.field.Zero()
                ci := (bob.beta[j/8] &gt;&gt; (j % 8)) &amp; 0b1
                if ci != 0 </span><span class="cov8" title="1">{
                        betaJ = bob.suite.field.One()
                }</span>
                <span class="cov8" title="1">for k := range bob.rho </span><span class="cov8" title="1">{
                        dHat[j][k] = bob.gamma[j][bob.suite.l+k].Add(betaJ.Mul(r3Out.ATilde[j][bob.suite.l+k]))
                }</span>
        }

        <span class="cov8" title="1">muPrimeBold := make([][]S, bob.xi)
        for j := range bob.xi </span><span class="cov8" title="1">{
                muPrimeBold[j] = make([]S, bob.rho)
                betaJ := bob.suite.field.Zero()
                ci := (bob.beta[j/8] &gt;&gt; (j % 8)) &amp; 0b1
                if ci != 0 </span><span class="cov8" title="1">{
                        betaJ = bob.suite.field.One()
                }</span>
                <span class="cov8" title="1">for k := range bob.rho </span><span class="cov8" title="1">{
                        muPrimeBold[j][k] = dHat[j][k].Sub(betaJ.Mul(r3Out.Eta[k]))
                        for i := range bob.suite.l </span><span class="cov8" title="1">{
                                muPrimeBold[j][k] = muPrimeBold[j][k].Add(theta[i][k].Mul(dDot[j][i]))
                        }</span>
                }
        }

        <span class="cov8" title="1">mu, err := bob.roMu(muPrimeBold)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get mu")
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(r3Out.Mu, mu) </span><span class="cov0" title="0">{
                return nil, base.ErrAbort.WithMessage("consistency check failed")
        }</span>

        <span class="cov8" title="1">d = make([]S, bob.suite.l)
        for i := range bob.suite.l </span><span class="cov8" title="1">{
                d[i] = bob.suite.field.Zero()
                for j := range bob.xi </span><span class="cov8" title="1">{
                        d[i] = d[i].Add(bob.g[j].Mul(dDot[j][i]))
                }</span>
        }

        <span class="cov8" title="1">bob.round += 2
        return d, nil</span>
}

func (p *participant[G, S]) roTheta(aTilde [][]S) (theta [][]S, err error) <span class="cov8" title="1">{
        for _, aTildeJ := range aTilde </span><span class="cov8" title="1">{
                for _, aj := range aTildeJ </span><span class="cov8" title="1">{
                        p.tape.AppendBytes(aTildeLabel, aj.Bytes())
                }</span>
        }

        <span class="cov8" title="1">theta = make([][]S, p.suite.l)
        for i := range theta </span><span class="cov8" title="1">{
                theta[i] = make([]S, p.rho)
                for j := range theta[i] </span><span class="cov8" title="1">{
                        thetaBytes, err := p.tape.ExtractBytes(thetaLabel, uint(p.suite.field.WideElementSize()))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot extract theta")
                        }</span>
                        <span class="cov8" title="1">theta[i][j], err = p.suite.field.FromWideBytes(thetaBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot set theta")
                        }</span>
                }
        }

        <span class="cov8" title="1">return theta, nil</span>
}

func (p *participant[G, S]) roMu(muBold [][]S) (mu []byte, err error) <span class="cov8" title="1">{
        for _, muJ := range muBold </span><span class="cov8" title="1">{
                for _, e := range muJ </span><span class="cov8" title="1">{
                        p.tape.AppendBytes(muVectorLabel, e.Bytes())
                }</span>
        }
        <span class="cov8" title="1">mu, err = p.tape.ExtractBytes(muLabel, uint(base.CollisionResistanceBytesCeil))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot extract mu")
        }</span>
        <span class="cov8" title="1">return mu, nil</span>
}
</pre>
		
		<pre class="file" id="file337" style="display: none">package rvole_softspoken

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken"
)

// Round1P2P carries round 1 peer-to-peer messages.
type Round1P2P = softspoken.Round1P2P

// Round2P2P carries round 2 peer-to-peer messages.
type Round2P2P[S algebra.PrimeFieldElement[S]] struct {
        ATilde [][]S
        Eta    []S
        Mu     []byte
}

// Validate validates the message payload.
func (r2 *Round2P2P[S]) Validate(xi, l, rho int) error <span class="cov8" title="1">{
        if r2 == nil </span><span class="cov0" title="0">{
                return ErrValidation.WithMessage("missing message")
        }</span>
        <span class="cov8" title="1">if len(r2.ATilde) != xi </span><span class="cov0" title="0">{
                return ErrValidation.WithMessage("invalid message")
        }</span>
        <span class="cov8" title="1">for _, a := range r2.ATilde </span><span class="cov8" title="1">{
                if len(a) != (l + rho) </span><span class="cov0" title="0">{
                        return ErrValidation.WithMessage("invalid message")
                }</span>
                <span class="cov8" title="1">for _, aa := range a </span><span class="cov8" title="1">{
                        if aa.IsZero() </span><span class="cov0" title="0">{
                                return ErrValidation.WithMessage("invalid message")
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(r2.Eta) != rho </span><span class="cov0" title="0">{
                return ErrValidation.WithMessage("invalid message")
        }</span>
        <span class="cov8" title="1">for _, e := range r2.Eta </span><span class="cov8" title="1">{
                if e.IsZero() </span><span class="cov0" title="0">{
                        return ErrValidation.WithMessage("invalid message")
                }</span>
        }

        <span class="cov8" title="1">if len(r2.Mu) != (base.CollisionResistanceBytesCeil) </span><span class="cov0" title="0">{
                return ErrValidation.WithMessage("invalid message")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file338" style="display: none">package rvole_softspoken

import (
        "hash"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
)

// Suite bundles protocol parameters and primitives.
type Suite[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        l        int
        curve    curves.Curve[P, B, S]
        field    algebra.PrimeField[S]
        hashFunc func() hash.Hash
}

// NewSuite returns a new protocol suite.
func NewSuite[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]](l int, curve curves.Curve[P, B, S], hashFunc func() hash.Hash) (*Suite[P, B, S], error) <span class="cov8" title="1">{
        if curve == nil || hashFunc == nil || l &lt;= 0 </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("invalid arguments")
        }</span>
        <span class="cov8" title="1">field, ok := curve.ScalarStructure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid curve scalar structure")
        }</span>

        <span class="cov8" title="1">s := &amp;Suite[P, B, S]{
                l:        l,
                curve:    curve,
                field:    field,
                hashFunc: hashFunc,
        }
        return s, nil</span>
}
</pre>
		
		<pre class="file" id="file339" style="display: none">package rvole_softspoken

import (
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/mathutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
        "github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel = "BRON_CRYPTO_SOFTSPOKEN_OT_MULTIPLY-"
        gadgetLabel     = "BRON_CRYPTO_SOFTSPOKEN_OT_MULTIPLY-G-"
        aTildeLabel     = "BRON_CRYPTO_SOFTSPOKEN_OT_MULTIPLY-A_TILDE-"
        thetaLabel      = "BRON_CRYPTO_SOFTSPOKEN_OT_MULTIPLY-THETA-"
        muVectorLabel   = "BRON_CRYPTO_SOFTSPOKEN_OT_MULTIPLY-MU_VECTOR-"
        muLabel         = "BRON_CRYPTO_SOFTSPOKEN_OT_MULTIPLY-MU-"
)

type participant[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        sessionID network.SID
        suite     *Suite[P, B, S]
        xi        int
        rho       int
        tape      transcripts.Transcript
        prng      io.Reader
        round     int
}

// Alice represents the sender party.
type Alice[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        participant[P, B, S]

        sender *softspoken.Sender
        g      []S
        alpha  [][2][]S
}

// Bob represents the receiver party.
type Bob[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        participant[P, B, S]

        receiver *softspoken.Receiver
        g        []S
        beta     []byte
        gamma    [][]S
}

func newParticipant[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[P, B, S], prng io.Reader, tape transcripts.Transcript, initialRound int) (*participant[P, B, S], error) <span class="cov8" title="1">{
        if suite == nil || prng == nil || tape == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("argument")
        }</span>

        <span class="cov8" title="1">kappa := suite.field.ElementSize() * 8
        xi := kappa + base.CollisionResistance // normally this should be statistical security, but then xi is an invalid parameter for softspoken
        rho := mathutils.CeilDiv(kappa, base.ComputationalSecurityBits)

        tape.AppendDomainSeparator(fmt.Sprintf("%s-%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        return &amp;participant[P, B, S]{
                sessionID: sessionID,
                suite:     suite,
                xi:        xi,
                rho:       rho,
                tape:      tape,
                prng:      prng,
                round:     initialRound,
        }, nil</span>
}

// NewAlice returns a new Alice participant.
func NewAlice[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[P, B, S], seeds *vsot.ReceiverOutput, prng io.Reader, tape transcripts.Transcript) (*Alice[P, B, S], error) <span class="cov8" title="1">{
        p, err := newParticipant(sessionID, suite, prng, tape, 2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create participant / gadget vector")
        }</span>
        <span class="cov8" title="1">softspokenSuite, err := softspoken.NewSuite(p.xi, suite.l+p.rho, suite.hashFunc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create softspoken suite")
        }</span>

        <span class="cov8" title="1">sender, err := softspoken.NewSender(sessionID, seeds, softspokenSuite, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create sender")
        }</span>
        <span class="cov8" title="1">gadget, err := p.generateGadgetVector()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create gadget vector")
        }</span>

        //nolint:exhaustruct // lazy initialisation
        <span class="cov8" title="1">alice := &amp;Alice[P, B, S]{
                participant: *p,
                sender:      sender,
                g:           gadget,
        }
        return alice, nil</span>
}

// NewBob returns a new Bob participant.
func NewBob[P curves.Point[P, B, S], B algebra.FieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *Suite[P, B, S], seeds *vsot.SenderOutput, prng io.Reader, tape transcripts.Transcript) (*Bob[P, B, S], error) <span class="cov8" title="1">{
        p, err := newParticipant(sessionID, suite, prng, tape, 1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create participant / gadget vector")
        }</span>
        <span class="cov8" title="1">softspokenSuite, err := softspoken.NewSuite(p.xi, suite.l+p.rho, suite.hashFunc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create softspoken suite")
        }</span>

        <span class="cov8" title="1">receiver, err := softspoken.NewReceiver(sessionID, seeds, softspokenSuite, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create receiver")
        }</span>
        <span class="cov8" title="1">gadget, err := p.generateGadgetVector()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create gadget vector")
        }</span>

        //nolint:exhaustruct // lazy initialisation
        <span class="cov8" title="1">bob := &amp;Bob[P, B, S]{
                participant: *p,
                receiver:    receiver,
                g:           gadget,
        }
        return bob, nil</span>
}

func (p *participant[P, B, S]) generateGadgetVector() ([]S, error) <span class="cov8" title="1">{
        gadget := make([]S, p.xi)
        for i := range gadget </span><span class="cov8" title="1">{
                bytes, err := p.tape.ExtractBytes(gadgetLabel, uint(p.suite.field.WideElementSize()))
                if err != nil </span><span class="cov0" title="0">{
                        return gadget, errs2.Wrap(err).WithMessage("extracting bytes from transcript")
                }</span>
                <span class="cov8" title="1">gadget[i], err = p.suite.field.FromWideBytes(bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return gadget, errs2.Wrap(err).WithMessage("creating gadget scalar from bytes")
                }</span>
        }
        <span class="cov8" title="1">return gadget, nil</span>
}
</pre>
		
		<pre class="file" id="file340" style="display: none">package rvole_softspoken

import (
        "bytes"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// Round1 executes protocol round 1.
func (bob *Bob[P, B, S]) Round1() (r1 *Round1P2P, b S, err error) <span class="cov8" title="1">{
        var nilS S
        if bob.round != 1 </span><span class="cov0" title="0">{
                return nil, nilS, ErrValidation.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">beta := make([]byte, bob.xi/8)
        if _, err := io.ReadFull(bob.prng, beta); err != nil </span><span class="cov0" title="0">{
                return nil, nilS, errs2.Wrap(err).WithMessage("cannot sample choices")
        }</span>

        <span class="cov8" title="1">r1, receiverOutput, err := bob.receiver.Round1(beta)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nilS, errs2.Wrap(err).WithMessage("cannot run round 2 of receiver")
        }</span>
        <span class="cov8" title="1">bob.beta = receiverOutput.Choices
        bob.gamma = make([][]S, len(receiverOutput.Messages))
        for xi, messages := range receiverOutput.Messages </span><span class="cov8" title="1">{
                bob.gamma[xi] = make([]S, len(messages))
                for l, message := range messages </span><span class="cov8" title="1">{
                        bob.gamma[xi][l], err = bob.suite.field.Hash(message)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nilS, errs2.Wrap(err).WithMessage("cannot hash to curve message")
                        }</span>
                }
        }

        <span class="cov8" title="1">b = bob.suite.field.Zero()
        for j := range bob.xi </span><span class="cov8" title="1">{
                betaJ := bob.suite.field.Zero()
                ci := (bob.beta[j/8] &gt;&gt; (j % 8)) &amp; 0b1
                if ci != 0 </span><span class="cov8" title="1">{
                        betaJ = bob.suite.field.One()
                }</span>
                <span class="cov8" title="1">b = b.Add(betaJ.Mul(bob.g[j]))</span>
        }

        <span class="cov8" title="1">bob.round += 2
        return r1, b, nil</span>
}

// Round2 executes protocol round 2.
func (alice *Alice[P, B, S]) Round2(r1 *Round1P2P, a []S) (*Round2P2P[S], []S, error) <span class="cov8" title="1">{
        if alice.round != 2 </span><span class="cov0" title="0">{
                return nil, nil, ErrValidation.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">senderOutput, err := alice.sender.Round2(r1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run round 2 of receiver")
        }</span>
        <span class="cov8" title="1">alice.alpha = make([][2][]S, len(senderOutput.Messages))
        for xi, messages := range senderOutput.Messages </span><span class="cov8" title="1">{
                alice.alpha[xi][0] = make([]S, len(messages[0]))
                alice.alpha[xi][1] = make([]S, len(messages[1]))
                for l, message := range messages[0] </span><span class="cov8" title="1">{
                        alice.alpha[xi][0][l], err = alice.suite.field.Hash(message)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash to field message")
                        }</span>
                }
                <span class="cov8" title="1">for l, message := range messages[1] </span><span class="cov8" title="1">{
                        alice.alpha[xi][1][l], err = alice.suite.field.Hash(message)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot hash to field message")
                        }</span>
                }
        }

        <span class="cov8" title="1">c := make([]S, alice.suite.l)
        for i := range alice.suite.l </span><span class="cov8" title="1">{
                c[i] = alice.suite.field.Zero()
                for j := range alice.xi </span><span class="cov8" title="1">{
                        c[i] = c[i].Sub(alice.g[j].Mul(alice.alpha[j][0][i]))
                }</span>
        }

        <span class="cov8" title="1">aHat := make([]S, alice.rho)
        for i := range alice.rho </span><span class="cov8" title="1">{
                aHat[i], err = alice.suite.field.Random(alice.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot get random scalar")
                }</span>
        }

        <span class="cov8" title="1">aTilde := make([][]S, alice.xi)
        for j := range alice.xi </span><span class="cov8" title="1">{
                aTilde[j] = make([]S, alice.suite.l+alice.rho)
                for i := range alice.suite.l </span><span class="cov8" title="1">{
                        aTilde[j][i] = alice.alpha[j][0][i].Sub(alice.alpha[j][1][i]).Add(a[i])
                }</span>
                <span class="cov8" title="1">for k := range alice.rho </span><span class="cov8" title="1">{
                        aTilde[j][alice.suite.l+k] = alice.alpha[j][0][alice.suite.l+k].Sub(alice.alpha[j][1][alice.suite.l+k]).Add(aHat[k])
                }</span>
        }

        <span class="cov8" title="1">theta, err := alice.roTheta(aTilde)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot get theta")
        }</span>

        <span class="cov8" title="1">eta := make([]S, alice.rho)
        for k := range alice.rho </span><span class="cov8" title="1">{
                eta[k] = aHat[k]
                for i := range alice.suite.l </span><span class="cov8" title="1">{
                        eta[k] = eta[k].Add(theta[i][k].Mul(a[i]))
                }</span>
        }

        <span class="cov8" title="1">muBold := make([][]S, alice.xi)
        for j := range alice.xi </span><span class="cov8" title="1">{
                muBold[j] = make([]S, alice.rho)
                for k := range alice.rho </span><span class="cov8" title="1">{
                        muBold[j][k] = alice.alpha[j][0][alice.suite.l+k]
                        for i := range alice.suite.l </span><span class="cov8" title="1">{
                                muBold[j][k] = muBold[j][k].Add(theta[i][k].Mul(alice.alpha[j][0][i]))
                        }</span>
                }
        }

        <span class="cov8" title="1">mu, err := alice.roMu(muBold)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot get mu")
        }</span>

        <span class="cov8" title="1">r2 := &amp;Round2P2P[S]{
                ATilde: aTilde,
                Eta:    eta,
                Mu:     mu,
        }
        alice.round += 2
        return r2, c, nil</span>
}

// Round3 executes protocol round 3.
func (bob *Bob[P, B, S]) Round3(r2 *Round2P2P[S]) (d []S, err error) <span class="cov8" title="1">{
        if bob.round != 3 </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("invalid round")
        }</span>
        <span class="cov8" title="1">if err := r2.Validate(bob.xi, bob.suite.l, bob.rho); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid message")
        }</span>

        <span class="cov8" title="1">theta, err := bob.roTheta(r2.ATilde)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get theta")
        }</span>

        <span class="cov8" title="1">dDot := make([][]S, bob.xi)
        for j := range bob.xi </span><span class="cov8" title="1">{
                dDot[j] = make([]S, bob.suite.l)
                betaJ := bob.suite.field.Zero()
                ci := (bob.beta[j/8] &gt;&gt; (j % 8)) &amp; 0b1
                if ci != 0 </span><span class="cov8" title="1">{
                        betaJ = bob.suite.field.One()
                }</span>
                <span class="cov8" title="1">for i := range bob.suite.l </span><span class="cov8" title="1">{
                        dDot[j][i] = bob.gamma[j][i].Add(betaJ.Mul(r2.ATilde[j][i]))
                }</span>
        }

        <span class="cov8" title="1">dHat := make([][]S, bob.xi)
        for j := range bob.xi </span><span class="cov8" title="1">{
                dHat[j] = make([]S, bob.rho)
                betaJ := bob.suite.field.Zero()
                ci := (bob.beta[j/8] &gt;&gt; (j % 8)) &amp; 0b1
                if ci != 0 </span><span class="cov8" title="1">{
                        betaJ = bob.suite.field.One()
                }</span>
                <span class="cov8" title="1">for k := range bob.rho </span><span class="cov8" title="1">{
                        dHat[j][k] = bob.gamma[j][bob.suite.l+k].Add(betaJ.Mul(r2.ATilde[j][bob.suite.l+k]))
                }</span>
        }

        <span class="cov8" title="1">muPrimeBold := make([][]S, bob.xi)
        for j := range bob.xi </span><span class="cov8" title="1">{
                muPrimeBold[j] = make([]S, bob.rho)
                betaJ := bob.suite.field.Zero()
                ci := (bob.beta[j/8] &gt;&gt; (j % 8)) &amp; 0b1
                if ci != 0 </span><span class="cov8" title="1">{
                        betaJ = bob.suite.field.One()
                }</span>
                <span class="cov8" title="1">for k := range bob.rho </span><span class="cov8" title="1">{
                        muPrimeBold[j][k] = dHat[j][k].Sub(betaJ.Mul(r2.Eta[k]))
                        for i := range bob.suite.l </span><span class="cov8" title="1">{
                                muPrimeBold[j][k] = muPrimeBold[j][k].Add(theta[i][k].Mul(dDot[j][i]))
                        }</span>
                }
        }

        <span class="cov8" title="1">mu, err := bob.roMu(muPrimeBold)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get mu")
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(r2.Mu, mu) </span><span class="cov0" title="0">{
                return nil, base.ErrAbort.WithMessage("consistency check failed")
        }</span>

        <span class="cov8" title="1">d = make([]S, bob.suite.l)
        for i := range bob.suite.l </span><span class="cov8" title="1">{
                d[i] = bob.suite.field.Zero()
                for j := range bob.xi </span><span class="cov8" title="1">{
                        d[i] = d[i].Add(bob.g[j].Mul(dDot[j][i]))
                }</span>
        }

        <span class="cov8" title="1">bob.round += 2
        return d, nil</span>
}

func (p *participant[P, B, S]) roTheta(aTilde [][]S) (theta [][]S, err error) <span class="cov8" title="1">{
        for _, aTildeJ := range aTilde </span><span class="cov8" title="1">{
                for _, aj := range aTildeJ </span><span class="cov8" title="1">{
                        p.tape.AppendBytes(aTildeLabel, aj.Bytes())
                }</span>
        }

        <span class="cov8" title="1">theta = make([][]S, p.suite.l)
        for i := range theta </span><span class="cov8" title="1">{
                theta[i] = make([]S, p.rho)
                for j := range theta[i] </span><span class="cov8" title="1">{
                        thetaBytes, err := p.tape.ExtractBytes(thetaLabel, uint(p.suite.field.WideElementSize()))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot extract theta")
                        }</span>
                        <span class="cov8" title="1">theta[i][j], err = p.suite.field.FromWideBytes(thetaBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("cannot set theta")
                        }</span>
                }
        }

        <span class="cov8" title="1">return theta, nil</span>
}

func (p *participant[P, B, S]) roMu(muBold [][]S) (mu []byte, err error) <span class="cov8" title="1">{
        for _, muJ := range muBold </span><span class="cov8" title="1">{
                for _, e := range muJ </span><span class="cov8" title="1">{
                        p.tape.AppendBytes(muVectorLabel, e.Bytes())
                }</span>
        }
        <span class="cov8" title="1">mu, err = p.tape.ExtractBytes(muLabel, base.CollisionResistanceBytesCeil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot extract mu")
        }</span>
        <span class="cov8" title="1">return mu, nil</span>
}
</pre>
		
		<pre class="file" id="file341" style="display: none">// Package additive implements additive secret sharing over arbitrary groups.
//
// In additive secret sharing, a secret s is split into n shares s_1, ..., s_n
// such that s = s_1 + s_2 + ... + s_n (using the group operation). This is an
// n-of-n scheme: all shares are required to reconstruct the secret.
//
// Additive sharing is information-theoretically secure: any proper subset of
// shares reveals no information about the secret. It is commonly used as a
// building block in MPC protocols and as the target representation when
// converting Shamir shares via Lagrange coefficients.
package additive

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

type (
        // Group is a finite group over which additive sharing can be performed.
        Group[E GroupElement[E]] algebra.FiniteGroup[E]
        // GroupElement is an element of a group that supports the group operation.
        GroupElement[E algebra.GroupElement[E]] algebra.GroupElement[E]
)

// Name is the canonical name of this secret sharing scheme.
const Name sharing.Name = "Additive Secret Sharing Scheme"

// NewScheme creates a new additive secret sharing scheme.
//
// Parameters:
//   - g: The group over which sharing is performed
//   - shareholders: Set of shareholder IDs who will receive shares (all required for reconstruction)
func NewScheme[E GroupElement[E]](g Group[E], shareholders ds.Set[sharing.ID]) (*Scheme[E], error) <span class="cov8" title="1">{
        if shareholders == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithMessage("identities is nil")
        }</span>
        <span class="cov8" title="1">if g == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithMessage("group is nil")
        }</span>
        <span class="cov8" title="1">accessStructure, err := sharing.NewMinimalQualifiedAccessStructure(shareholders)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not create access structure")
        }</span>
        <span class="cov8" title="1">return &amp;Scheme[E]{
                g:  g,
                ac: accessStructure,
        }, nil</span>
}

// Scheme implements additive secret sharing over a finite group.
type Scheme[E GroupElement[E]] struct {
        g  Group[E]
        ac *sharing.MinimalQualifiedAccessStructure
}

// Name returns the canonical name of this scheme.
func (*Scheme[E]) Name() sharing.Name <span class="cov0" title="0">{
        return Name
}</span>

// AccessStructure returns the access structure (all shareholders required).
func (d *Scheme[E]) AccessStructure() *sharing.MinimalQualifiedAccessStructure <span class="cov8" title="1">{
        return d.ac
}</span>

// DealRandom generates shares for a randomly sampled secret.
func (d *Scheme[E]) DealRandom(prng io.Reader) (*DealerOutput[E], *Secret[E], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrIsNil.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">value, err := d.g.Random(prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not sample group element")
        }</span>
        <span class="cov8" title="1">secret := NewSecret(value)
        shares, err := d.Deal(secret, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not create shares")
        }</span>
        <span class="cov8" title="1">return shares, secret, nil</span>
}

// Deal creates shares for the given secret. All but one share are sampled randomly,
// and the final share is computed to ensure s_1 + s_2 + ... + s_n = s.
func (d *Scheme[E]) Deal(secret *Secret[E], prng io.Reader) (*DealerOutput[E], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">if secret == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithMessage("secret is nil")
        }</span>
        <span class="cov8" title="1">participantsList := d.ac.Shareholders().List()
        shares := hashmap.NewComparable[sharing.ID, *Share[E]]()

        partialSum := d.g.OpIdentity()
        for _, id := range participantsList[1:] </span><span class="cov8" title="1">{
                v, err := d.g.Random(prng)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, errs2.Wrap(err).WithMessage("could not sample group element")
                }</span>
                <span class="cov8" title="1">partialSum = partialSum.Op(v)
                shares.Put(id, &amp;Share[E]{
                        id: id,
                        v:  v,
                })</span>
        }
        <span class="cov8" title="1">final := secret.Value().Op(partialSum.OpInv())
        shares.Put(participantsList[0], &amp;Share[E]{
                id: participantsList[0],
                v:  final,
        })
        return &amp;DealerOutput[E]{
                shares: shares.Freeze(),
        }, nil</span>
}

// Reconstruct recovers the secret by summing all shares: s = s_1 + s_2 + ... + s_n.
// All shareholders must provide their shares for reconstruction to succeed.
func (d *Scheme[E]) Reconstruct(shares ...*Share[E]) (*Secret[E], error) <span class="cov8" title="1">{
        // First check for nil shares before creating hashset
        ids, err := sharing.CollectIDs(shares...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not collect IDs from shares")
        }</span>

        // Filter out nil shares
        <span class="cov8" title="1">validShares := make([]*Share[E], 0, len(shares))
        for _, share := range shares </span><span class="cov8" title="1">{
                if share != nil </span><span class="cov8" title="1">{
                        validShares = append(validShares, share)
                }</span>
        }

        // Create set from valid shares only
        <span class="cov8" title="1">sharesSet := hashset.NewHashable(validShares...).List()

        if !d.ac.IsAuthorized(ids...) </span><span class="cov8" title="1">{
                return nil, ErrFailed.WithMessage("not authorized to reconstruct secret with IDs %v", ids)
        }</span>
        <span class="cov8" title="1">reconstructed := algebrautils.Sum(sharesSet[0], sharesSet[1:]...)
        return &amp;Secret[E]{v: reconstructed.v}, nil</span>
}

// NewShare creates a new additive share with the given ID and value.
// If an access structure is provided, validates that the ID is a valid shareholder.
func NewShare[E GroupElement[E]](id sharing.ID, v E, ac *sharing.MinimalQualifiedAccessStructure) (*Share[E], error) <span class="cov8" title="1">{
        if ac != nil &amp;&amp; !ac.Shareholders().Contains(id) </span><span class="cov8" title="1">{
                return nil, ErrMembership.WithMessage("share ID %d is not a valid shareholder", id)
        }</span>
        <span class="cov8" title="1">return &amp;Share[E]{
                id: id,
                v:  v,
        }, nil</span>
}

// Share represents an additive secret share consisting of a shareholder ID
// and a group element value.
type Share[E GroupElement[E]] struct {
        id sharing.ID
        v  E
}

// ID returns the shareholder identifier for this share.
func (s *Share[E]) ID() sharing.ID <span class="cov8" title="1">{
        return s.id
}</span>

// Value returns the group element value of this share.
func (s *Share[E]) Value() E <span class="cov8" title="1">{
        return s.v
}</span>

// Equal returns true if two shares have the same ID and value.
func (s *Share[E]) Equal(other *Share[E]) bool <span class="cov8" title="1">{
        if s == nil || other == nil </span><span class="cov8" title="1">{
                return s == other
        }</span>
        <span class="cov8" title="1">return s.id == other.id &amp;&amp; s.v.Equal(other.v)</span>
}

// Op is an alias for Add, implementing the group element interface.
func (s *Share[E]) Op(other *Share[E]) *Share[E] <span class="cov8" title="1">{
        return s.Add(other)
}</span>

// Add returns a new share that is the component-wise sum of two shares.
// Both shares must have the same ID.
func (s *Share[E]) Add(other *Share[E]) *Share[E] <span class="cov8" title="1">{
        return &amp;Share[E]{
                id: s.id,
                v:  s.v.Op(other.v),
        }
}</span>

// Clone returns a deep copy of this share.
func (s *Share[E]) Clone() *Share[E] <span class="cov8" title="1">{
        return &amp;Share[E]{
                id: s.id,
                v:  s.v.Clone(),
        }
}</span>

// HashCode returns a hash code for this share, for use in hash-based collections.
func (s *Share[E]) HashCode() base.HashCode <span class="cov8" title="1">{
        return base.HashCode(s.id) ^ s.v.HashCode()
}</span>

// SchemeName returns the name of the secret sharing scheme.
func (*Share[E]) SchemeName() sharing.Name <span class="cov0" title="0">{
        return Name
}</span>

// NewSecret creates a new secret from a group element.
func NewSecret[E GroupElement[E]](v E) *Secret[E] <span class="cov8" title="1">{
        return &amp;Secret[E]{v: v}
}</span>

// Secret wraps a group element that is being shared.
type Secret[E GroupElement[E]] struct {
        v E
}

// Value returns the underlying group element.
func (s *Secret[E]) Value() E <span class="cov8" title="1">{
        return s.v
}</span>

// Equal returns true if two secrets have the same value.
func (s *Secret[E]) Equal(other *Secret[E]) bool <span class="cov8" title="1">{
        if s == nil || other == nil </span><span class="cov8" title="1">{
                return s == other
        }</span>
        <span class="cov8" title="1">return s.v.Equal(other.v)</span>
}

// Clone returns a deep copy of this secret.
func (s *Secret[E]) Clone() *Secret[E] <span class="cov8" title="1">{
        return &amp;Secret[E]{
                v: s.v.Clone(),
        }
}</span>

// DealerOutput contains the result of an additive dealing operation:
// a map from shareholder IDs to their corresponding shares.
type DealerOutput[E GroupElement[E]] struct {
        shares ds.Map[sharing.ID, *Share[E]]
}

// Shares returns the map of shareholder IDs to their corresponding shares.
func (d *DealerOutput[E]) Shares() ds.Map[sharing.ID, *Share[E]] <span class="cov8" title="1">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return d.shares</span>
}
</pre>
		
		<pre class="file" id="file342" style="display: none">package feldman

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// DealerOutput contains the result of a Feldman VSS dealing operation:
// a map of shares and the verification vector for share verification.
type DealerOutput[E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]] struct {
        shares ds.Map[sharing.ID, *Share[FE]]
        v      VerificationVector[E, FE]
}

// Shares returns the map of shareholder IDs to their corresponding shares.
func (d *DealerOutput[E, FE]) Shares() ds.Map[sharing.ID, *Share[FE]] <span class="cov8" title="1">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return d.shares</span>
}

// VerificationMaterial returns the verification vector V = (g^{a_0}, g^{a_1}, ..., g^{a_{t-1}})
// which allows shareholders to verify their shares without revealing the secret.
func (d *DealerOutput[E, FE]) VerificationMaterial() VerificationVector[E, FE] <span class="cov8" title="1">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return d.v</span>
}
</pre>
		
		<pre class="file" id="file343" style="display: none">package feldman

import (
        "io"
        "maps"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir"
)

// Scheme implements Feldman's verifiable secret sharing.
type Scheme[E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]] struct {
        basePoint E
        shamirSSS *shamir.Scheme[FE]
}

// NewScheme creates a new Feldman VSS scheme.
//
// Parameters:
//   - basePoint: Generator g of the group used for verification commitments
//   - threshold: Minimum shares required for reconstruction (must be  2)
//   - shareholders: Set of shareholder IDs
func NewScheme[E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]](basePoint E, threshold uint, shareholders ds.Set[sharing.ID]) (*Scheme[E, FE], error) <span class="cov8" title="1">{
        if utils.IsNil(basePoint) </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("base point is nil")
        }</span>

        <span class="cov8" title="1">group := algebra.StructureMustBeAs[algebra.PrimeGroup[E, FE]](basePoint.Structure())
        f := algebra.StructureMustBeAs[algebra.PrimeField[FE]](group.ScalarStructure())
        shamirScheme, err := shamir.NewScheme(f, threshold, shareholders)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not create shamir scheme")
        }</span>
        <span class="cov8" title="1">return &amp;Scheme[E, FE]{
                basePoint: basePoint,
                shamirSSS: shamirScheme,
        }, nil</span>
}

// Name returns the canonical name of this scheme.
func (*Scheme[E, FE]) Name() sharing.Name <span class="cov0" title="0">{
        return Name
}</span>

// AccessStructure returns the threshold access structure.
func (d *Scheme[E, FE]) AccessStructure() *sharing.ThresholdAccessStructure <span class="cov8" title="1">{
        return d.shamirSSS.AccessStructure()
}</span>

// DealRandom generates shares for a randomly sampled secret.
func (d *Scheme[E, FE]) DealRandom(prng io.Reader) (*DealerOutput[E, FE], *Secret[FE], error) <span class="cov8" title="1">{
        out, secret, _, err := d.DealRandomAndRevealDealerFunc(prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not deal random shares")
        }</span>
        <span class="cov8" title="1">return out, secret, nil</span>
}

// DealRandomAndRevealDealerFunc generates shares for a random secret and returns
// the dealing polynomial.
func (d *Scheme[E, FE]) DealRandomAndRevealDealerFunc(prng io.Reader) (output *DealerOutput[E, FE], secret *Secret[FE], dealerFunc DealerFunc[FE], err error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, nil, ErrIsNil.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">value, err := d.shamirSSS.Field().Random(prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, errs2.Wrap(err).WithMessage("could not sample field element")
        }</span>
        <span class="cov8" title="1">secret = NewSecret(value)
        out, poly, err := d.DealAndRevealDealerFunc(secret, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, errs2.Wrap(err).WithMessage("could not create shares")
        }</span>
        <span class="cov8" title="1">return out, secret, poly, nil</span>
}

// Deal creates shares for the given secret along with a verification vector.
func (d *Scheme[E, FE]) Deal(secret *Secret[FE], prng io.Reader) (*DealerOutput[E, FE], error) <span class="cov8" title="1">{
        out, _, err := d.DealAndRevealDealerFunc(secret, prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not deal shares")
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// DealAndRevealDealerFunc creates shares and returns the dealing polynomial.
// The verification vector is computed as g^{f(x)} where f is the polynomial.
func (d *Scheme[E, FE]) DealAndRevealDealerFunc(secret *Secret[FE], prng io.Reader) (*DealerOutput[E, FE], DealerFunc[FE], error) <span class="cov8" title="1">{
        shamirShares, poly, err := d.shamirSSS.DealAndRevealDealerFunc(secret, prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not create shamir shares")
        }</span>
        <span class="cov8" title="1">verificationVector, err := polynomials.LiftPolynomial(poly, d.basePoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not lift polynomial to exponent")
        }</span>
        <span class="cov8" title="1">shares := hashmap.NewComparableFromNativeLike(maps.Collect(shamirShares.Shares().Iter())).Freeze()
        return &amp;DealerOutput[E, FE]{
                shares: shares,
                v:      verificationVector,
        }, poly, nil</span>
}

// Reconstruct recovers the secret from a set of shares using Lagrange interpolation.
func (d *Scheme[E, FE]) Reconstruct(shares ...*Share[FE]) (*Secret[FE], error) <span class="cov8" title="1">{
        secret, err := d.shamirSSS.Reconstruct(shares...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not reconstruct secret from shares")
        }</span>
        <span class="cov8" title="1">return secret, nil</span>
}

// ReconstructAndVerify recovers the secret and verifies each share against
// the verification vector before reconstruction.
func (d *Scheme[E, FE]) ReconstructAndVerify(reference VerificationVector[E, FE], shares ...*Share[FE]) (*Secret[FE], error) <span class="cov8" title="1">{
        reconstructed, err := d.Reconstruct(shares...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not reconstruct secret without verification")
        }</span>
        <span class="cov8" title="1">for i, share := range shares </span><span class="cov8" title="1">{
                if err := d.Verify(share, reference); err != nil </span><span class="cov8" title="1">{
                        return nil, errs2.Wrap(err).WithMessage("verification failed for share %d", i)
                }</span>
        }
        <span class="cov8" title="1">return reconstructed, nil</span>
}

// Verify checks that a share is consistent with the verification vector.
// Returns nil if g^{share} equals the evaluation of the verification vector at the share's ID.
func (d *Scheme[E, FE]) Verify(share *Share[FE], reference VerificationVector[E, FE]) error <span class="cov8" title="1">{
        if reference == nil </span><span class="cov0" title="0">{
                return ErrIsNil.WithMessage("verification vector is nil")
        }</span>
        <span class="cov8" title="1">if reference.Degree()+1 != int(d.shamirSSS.AccessStructure().Threshold()) </span><span class="cov0" title="0">{
                return ErrVerification.WithMessage("verification vector degree %d does not match expected degree %d", reference.Degree(), d.shamirSSS.AccessStructure().Threshold()-1)
        }</span>
        <span class="cov8" title="1">x := d.shamirSSS.SharingIDToLagrangeNode(share.ID())
        yInExponent := reference.Eval(x)
        shareInExponent := d.basePoint.ScalarOp(share.Value())
        if !yInExponent.Equal(shareInExponent) </span><span class="cov8" title="1">{
                return ErrVerification.WithMessage("verification vector does not match share in exponent")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file344" style="display: none">package feldman

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir"
)

// NewSecret creates a new secret from a field element.
func NewSecret[FE algebra.PrimeFieldElement[FE]](value FE) *Secret[FE] <span class="cov8" title="1">{
        return shamir.NewSecret(value)
}</span>

// Secret is a Feldman VSS secret, which is identical to a Shamir secret.
// This is the value s = f(0) that is shared among the shareholders.
type Secret[FE algebra.PrimeFieldElement[FE]] = shamir.Secret[FE]
</pre>
		
		<pre class="file" id="file345" style="display: none">package feldman

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/additive"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir"
)

// Share is a Feldman VSS share, which is identical to a Shamir share.
// The share value is f(i) where f is the dealing polynomial and i is the shareholder ID.
type Share[FE algebra.PrimeFieldElement[FE]] = shamir.Share[FE]

// NewShare creates a new Feldman share with the given ID and value.
// If an access structure is provided, validates that the ID is a valid shareholder.
func NewShare[FE algebra.PrimeFieldElement[FE]](id sharing.ID, v FE, ac *sharing.ThresholdAccessStructure) (*Share[FE], error) <span class="cov8" title="1">{
        s, err := shamir.NewShare(id, v, ac)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create Feldman share")
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

// LiftedShare represents a share lifted to the exponent: g^{f(i)} where f(i) is
// the underlying Shamir share value. This is used when shares need to be verified
// or combined in the group rather than the field.
type LiftedShare[E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]] struct {
        id sharing.ID
        v  E
}

type liftedShareDTO[E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]] struct {
        ID sharing.ID `cbor:"sharingID"`
        V  E          `cbor:"value"`
}

// NewLiftedShare creates a new lifted share with the given ID and group element value.
func NewLiftedShare[E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]](id sharing.ID, v E) (*LiftedShare[E, FE], error) <span class="cov8" title="1">{
        if utils.IsNil(v) </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("value is nil")
        }</span>

        <span class="cov8" title="1">return &amp;LiftedShare[E, FE]{
                id: id,
                v:  v,
        }, nil</span>
}

// ID returns the shareholder identifier for this lifted share.
func (s *LiftedShare[E, FE]) ID() sharing.ID <span class="cov8" title="1">{
        return s.id
}</span>

// Value returns the group element value g^{f(i)} of this lifted share.
func (s *LiftedShare[E, FE]) Value() E <span class="cov0" title="0">{
        return s.v
}</span>

// ToAdditive converts this lifted share to an additive share by exponentiating
// with the appropriate Lagrange coefficient. For shareholder i in qualified set S,
// the result is g^{_i  f(i)} where _i is the Lagrange coefficient.
// The resulting additive shares can be multiplied together to reconstruct g^s.
func (s *LiftedShare[E, FE]) ToAdditive(qualifiedSet *sharing.MinimalQualifiedAccessStructure) (*additive.Share[E], error) <span class="cov8" title="1">{
        if qualifiedSet == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("qualified set is nil")
        }</span>
        <span class="cov8" title="1">if !qualifiedSet.Shareholders().Contains(s.id) </span><span class="cov0" title="0">{
                return nil, ErrMembership.WithMessage("share ID %d is not a valid shareholder", s.id)
        }</span>
        <span class="cov8" title="1">group := algebra.StructureMustBeAs[algebra.PrimeGroup[E, FE]](s.v.Structure())
        sf := algebra.StructureMustBeAs[algebra.PrimeField[FE]](group.ScalarStructure())
        lambdas, err := shamir.LagrangeCoefficients(sf, qualifiedSet.Shareholders().List()...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not compute Lagrange coefficients")
        }</span>
        <span class="cov8" title="1">lambdaI, exists := lambdas.Get(s.id)
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrMembership.WithMessage("share ID %d is not a valid shareholder", s.id)
        }</span>
        <span class="cov8" title="1">converted := s.v.ScalarOp(lambdaI)
        additiveShare, err := additive.NewShare(s.id, converted, qualifiedSet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert Feldman share to additive")
        }</span>
        <span class="cov8" title="1">return additiveShare, nil</span>
}

func (s *LiftedShare[E, FE]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;liftedShareDTO[E, FE]{
                ID: s.id,
                V:  s.v,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Feldman LiftedShare")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (s *LiftedShare[E, FE]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*liftedShareDTO[E, FE]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s2, err := NewLiftedShare(dto.ID, dto.V)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*s = *s2
        return nil</span>
}

// SharesInExponent is a collection of lifted shares that can be used to
// reconstruct the secret in the exponent (i.e., g^s) without revealing s.
type SharesInExponent[E algebra.PrimeGroupElement[E, FE], FE algebra.PrimeFieldElement[FE]] []*LiftedShare[E, FE]

// ReconstructAsAdditive reconstructs g^s from a set of lifted shares using
// Lagrange interpolation in the exponent. Each share g^{f(i)} is raised to
// its Lagrange coefficient _i, and the results are multiplied together:
// g^s = _i (g^{f(i)})^{_i} = g^{_i _if(i)} = g^{f(0)} = g^s.
func (s SharesInExponent[E, FE]) ReconstructAsAdditive() (E, error) <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return *new(E), ErrArgument.WithMessage("no shares provided for reconstruction")
        }</span>

        <span class="cov8" title="1">group := algebra.StructureMustBeAs[algebra.PrimeGroup[E, FE]](s[0].v.Structure())
        sf := algebra.StructureMustBeAs[algebra.PrimeField[FE]](group.ScalarStructure())
        qualifiedSet, err := sharing.NewMinimalQualifiedAccessStructure(
                hashset.NewComparable(
                        slices.Collect(
                                iterutils.Map(
                                        slices.Values(s),
                                        func(share *LiftedShare[E, FE]) sharing.ID </span><span class="cov8" title="1">{ return share.ID() }</span>,
                                ),
                        )...,
                ).Freeze(),
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return *new(E), errs2.Wrap(err).WithMessage("could not create qualified set from shares")
        }</span>
        <span class="cov8" title="1">lambdas, err := shamir.LagrangeCoefficients(sf, qualifiedSet.Shareholders().List()...)
        if err != nil </span><span class="cov0" title="0">{
                return *new(E), errs2.Wrap(err).WithMessage("could not compute Lagrange coefficients")
        }</span>
        <span class="cov8" title="1">converted := make([]*additive.Share[E], 0, len(s))
        for _, share := range s </span><span class="cov8" title="1">{
                lambdaI, exists := lambdas.Get(share.ID())
                if !exists </span><span class="cov0" title="0">{
                        return *new(E), ErrMembership.WithMessage("share ID %d is not a valid shareholder", share.ID())
                }</span>
                <span class="cov8" title="1">si, err := additive.NewShare(share.ID(), share.v.ScalarOp(lambdaI), nil)
                if err != nil </span><span class="cov0" title="0">{
                        return *new(E), errs2.Wrap(err).WithMessage("could not create additive share from share in exponent")
                }</span>
                <span class="cov8" title="1">converted = append(converted, si)</span>
        }
        <span class="cov8" title="1">additiveScheme, err := additive.NewScheme(group, qualifiedSet.Shareholders())
        if err != nil </span><span class="cov0" title="0">{
                return *new(E), errs2.Wrap(err).WithMessage("could not create additive scheme")
        }</span>
        <span class="cov8" title="1">reconstructed, err := additiveScheme.Reconstruct(converted...)
        if err != nil </span><span class="cov0" title="0">{
                return *new(E), errs2.Wrap(err).WithMessage("could not reconstruct additive share")
        }</span>
        <span class="cov8" title="1">return reconstructed.Value(), nil</span>
}
</pre>
		
		<pre class="file" id="file346" style="display: none">package sharing

import (
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

// MinimalQualifiedAccessStructure represents an n-of-n access structure where
// all shareholders must participate to reconstruct the secret. This is the
// access structure for additive secret sharing.
type MinimalQualifiedAccessStructure struct {
        ps ds.Set[ID]
}

type minimalQualifiedAccessStructureDTO struct {
        Ps map[ID]bool `cbor:"shareholders"`
}

// NewMinimalQualifiedAccessStructure creates a new n-of-n access structure.
//
// Parameters:
//   - shareholders: The set of shareholder IDs (must have at least 2 members)
//
// Returns an error if shareholders is nil or has fewer than 2 members.
func NewMinimalQualifiedAccessStructure(shareholders ds.Set[ID]) (*MinimalQualifiedAccessStructure, error) <span class="cov0" title="0">{
        if shareholders == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("ids cannot be nil")
        }</span>
        <span class="cov0" title="0">if shareholders.Size() &lt; 2 </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("ids must have at least 2 shareholders")
        }</span>
        <span class="cov0" title="0">return &amp;MinimalQualifiedAccessStructure{
                ps: shareholders,
        }, nil</span>
}

// Shareholders returns the set of all shareholder IDs.
func (a *MinimalQualifiedAccessStructure) Shareholders() ds.Set[ID] <span class="cov0" title="0">{
        return a.ps
}</span>

// IsAuthorized returns true only if the given IDs exactly match all shareholders.
// Unlike threshold access structures, partial subsets are never authorized.
func (a *MinimalQualifiedAccessStructure) IsAuthorized(ids ...ID) bool <span class="cov0" title="0">{
        return a.ps.Size() == len(ids) &amp;&amp; a.ps.Equal(hashset.NewComparable(ids...).Freeze())
}</span>

func (a *MinimalQualifiedAccessStructure) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := minimalQualifiedAccessStructureDTO{
                Ps: make(map[ID]bool),
        }
        for id := range a.ps.Iter() </span><span class="cov0" title="0">{
                dto.Ps[id] = true
        }</span>
        <span class="cov0" title="0">data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (a *MinimalQualifiedAccessStructure) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[minimalQualifiedAccessStructureDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err)
        }</span>
        <span class="cov0" title="0">ps := hashset.NewComparable[ID]()
        for id := range dto.Ps </span><span class="cov0" title="0">{
                ps.Add(id)
        }</span>
        <span class="cov0" title="0">a.ps = ps.Freeze()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file347" style="display: none">package pedersen

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials"
)

// DealerFunc represents the pair of polynomials (f, r) used for Pedersen VSS.
// f(x) is the secret polynomial with f(0) = s, and r(x) is the blinding polynomial.
type DealerFunc[S algebra.PrimeFieldElement[S]] struct {
        G *polynomials.Polynomial[S]
        H *polynomials.Polynomial[S]
}

// NewDealerFunc creates a new dealer function from the secret and blinding polynomials.
func NewDealerFunc[S algebra.PrimeFieldElement[S]](g, h *polynomials.Polynomial[S]) *DealerFunc[S] <span class="cov8" title="1">{
        return &amp;DealerFunc[S]{G: g, H: h}
}</span>

// LiftedDealerFunc represents the dealer polynomials lifted to the exponent:
// (g^{f(x)}, h^{r(x)}). Used internally to compute the verification vector.
type LiftedDealerFunc[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        G *polynomials.ModuleValuedPolynomial[G, S]
        H *polynomials.ModuleValuedPolynomial[G, S]
}

// VerificationVector computes the verification vector by multiplying the lifted
// polynomials coefficient-wise: V_j = g^{a_j}h^{b_j}.
func (df *LiftedDealerFunc[G, S]) VerificationVector() VerificationVector[G, S] <span class="cov8" title="1">{
        return df.G.Op(df.H)
}</span>

func liftDealerFuncToExp[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](dealerFunc *DealerFunc[S], baseG, baseH G) (*LiftedDealerFunc[G, S], error) <span class="cov8" title="1">{
        gg, err := polynomials.LiftPolynomial(dealerFunc.G, baseG)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot lift polynomial")
        }</span>
        <span class="cov8" title="1">hh, err := polynomials.LiftPolynomial(dealerFunc.H, baseH)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot lift polynomial")
        }</span>

        <span class="cov8" title="1">return &amp;LiftedDealerFunc[G, S]{
                G: gg,
                H: hh,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file348" style="display: none">package pedersen

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// DealerOutput contains the result of a Pedersen VSS dealing operation:
// a map of shares (each with secret and blinding components) and the verification vector.
type DealerOutput[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        shares ds.Map[sharing.ID, *Share[S]]
        v      VerificationVector[E, S]
}

// Shares returns the map of shareholder IDs to their corresponding shares.
func (d *DealerOutput[E, S]) Shares() ds.Map[sharing.ID, *Share[S]] <span class="cov8" title="1">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return d.shares</span>
}

// VerificationVector returns the verification vector V = (g^{a_0}h^{b_0}, ..., g^{a_{t-1}}h^{b_{t-1}})
// which allows shareholders to verify their shares without revealing the secret.
func (d *DealerOutput[E, S]) VerificationVector() VerificationVector[E, S] <span class="cov8" title="1">{
        if d == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return d.v</span>
}
</pre>
		
		<pre class="file" id="file349" style="display: none">package pedersen

import (
        "io"
        "maps"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/commitments"
        pedcom "github.com/bronlabs/bron-crypto/pkg/commitments/pedersen"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir"
)

// NewScheme creates a new Pedersen VSS scheme.
//
// Parameters:
//   - key: Pedersen commitment key containing generators g and h
//   - threshold: Minimum shares required for reconstruction (must be  2)
//   - shareholders: Set of shareholder IDs who will receive shares
func NewScheme[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]](key *pedcom.Key[E, S], threshold uint, shareholders ds.Set[sharing.ID]) (*Scheme[E, S], error) <span class="cov8" title="1">{
        pedcomScheme, err := pedcom.NewScheme(key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not create pedersen scheme")
        }</span>
        <span class="cov8" title="1">module := algebra.StructureMustBeAs[algebra.Module[E, S]](key.G().Structure())
        field := algebra.StructureMustBeAs[algebra.PrimeField[S]](module.ScalarStructure())
        shamirSSS, err := shamir.NewScheme(field, threshold, shareholders)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not create shamir scheme")
        }</span>
        <span class="cov8" title="1">return &amp;Scheme[E, S]{
                key:              key,
                commitmentScheme: pedcomScheme,
                shamirSSS:        shamirSSS,
        }, nil</span>
}

// Scheme implements Pedersen's verifiable secret sharing with information-theoretic hiding.
type Scheme[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        key              *pedcom.Key[E, S]
        commitmentScheme commitments.Scheme[*pedcom.Key[E, S], *pedcom.Witness[S], *pedcom.Message[S], *pedcom.Commitment[E, S], *pedcom.Committer[E, S], *pedcom.Verifier[E, S]]
        shamirSSS        *shamir.Scheme[S]
}

// Name returns the canonical name of this scheme.
func (*Scheme[E, S]) Name() sharing.Name <span class="cov0" title="0">{
        return Name
}</span>

// AccessStructure returns the threshold access structure.
func (s *Scheme[E, S]) AccessStructure() *sharing.ThresholdAccessStructure <span class="cov8" title="1">{
        return s.shamirSSS.AccessStructure()
}</span>

func (s *Scheme[E, S]) dealAllNonZeroShares(secret *Secret[S], prng io.Reader) (*shamir.DealerOutput[S], *shamir.Secret[S], shamir.DealerFunc[S], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, nil, nil, ErrIsNil.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">var shamirShares *shamir.DealerOutput[S]
        var secretPoly shamir.DealerFunc[S]
        var err error
        for shamirShares == nil || sliceutils.Any(
                shamirShares.Shares().Values(), func(share *shamir.Share[S]) bool </span><span class="cov8" title="1">{ return share.Value().IsZero() }</span>,
        ) <span class="cov8" title="1">{
                if secret != nil </span><span class="cov0" title="0">{
                        shamirShares, secretPoly, err = s.shamirSSS.DealAndRevealDealerFunc(secret, prng)
                }</span> else<span class="cov8" title="1"> {
                        shamirShares, secret, secretPoly, err = s.shamirSSS.DealRandomAndRevealDealerFunc(prng)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, errs2.Wrap(err).WithMessage("could not deal shares")
                }</span>
        }
        <span class="cov8" title="1">return shamirShares, secret, secretPoly, nil</span>
}

// DealAndRevealDealerFunc creates shares for the given secret and returns the dealing
// polynomials. Uses two polynomials: f(x) for the secret and r(x) for blinding.
// The verification vector contains Pedersen commitments g^{a_j}h^{b_j}.
func (s *Scheme[E, S]) DealAndRevealDealerFunc(secret *Secret[S], prng io.Reader) (*DealerOutput[E, S], *DealerFunc[S], error) <span class="cov8" title="1">{
        if secret == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrIsNil.WithMessage("secret is nil")
        }</span>
        // Deal secret shares (can be zero)
        <span class="cov8" title="1">shamirShares, secretPoly, err := s.shamirSSS.DealAndRevealDealerFunc(secret, prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not deal secret shares")
        }</span>
        // Deal blinding shares (must be non-zero for witness creation)
        <span class="cov8" title="1">blindingShares, _, blindingPoly, err := s.dealAllNonZeroShares(nil, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not deal blinding shares")
        }</span>
        <span class="cov8" title="1">dealerFunc := NewDealerFunc(secretPoly, blindingPoly)
        dealerFuncInTheExponent, err := liftDealerFuncToExp(dealerFunc, s.key.G(), s.key.H())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not lift direct sum of polynomials to exponent")
        }</span>
        <span class="cov8" title="1">verificationVector := dealerFuncInTheExponent.VerificationVector()
        shares := hashmap.NewComparableFromNativeLike(
                maps.Collect(
                        iterutils.Map2(
                                shamirShares.Shares().Iter(),
                                func(id sharing.ID, shamirShare *shamir.Share[S]) (sharing.ID, *Share[S]) </span><span class="cov8" title="1">{
                                        blindingShare, _ := blindingShares.Shares().Get(id)
                                        message := pedcom.NewMessage(shamirShare.Value())
                                        witness, _ := pedcom.NewWitness(blindingShare.Value())
                                        share, _ := NewShare(id, message, witness, nil)
                                        return id, share
                                }</span>,
                        ),
                ),
        )
        <span class="cov8" title="1">return &amp;DealerOutput[E, S]{
                shares: shares.Freeze(),
                v:      verificationVector,
        }, dealerFunc, nil</span>
}

// Deal creates shares for the given secret along with a verification vector.
func (s *Scheme[E, S]) Deal(secret *Secret[S], prng io.Reader) (*DealerOutput[E, S], error) <span class="cov8" title="1">{
        shares, _, err := s.DealAndRevealDealerFunc(secret, prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not deal shares")
        }</span>
        <span class="cov8" title="1">return shares, nil</span>
}

// DealRandomAndRevealDealerFunc generates shares for a random secret and returns
// the dealing polynomials.
func (s *Scheme[E, S]) DealRandomAndRevealDealerFunc(prng io.Reader) (*DealerOutput[E, S], *Secret[S], *DealerFunc[S], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, nil, ErrIsNil.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">value, err := s.shamirSSS.Field().Random(prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, errs2.Wrap(err).WithMessage("could not sample random field element")
        }</span>
        <span class="cov8" title="1">secret := NewSecret(value)
        shares, poly, err := s.DealAndRevealDealerFunc(secret, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, errs2.Wrap(err).WithMessage("could not create shares")
        }</span>
        <span class="cov8" title="1">return shares, secret, poly, nil</span>
}

// DealRandom generates shares for a randomly sampled secret.
func (s *Scheme[E, S]) DealRandom(prng io.Reader) (*DealerOutput[E, S], *Secret[S], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrIsNil.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">shares, secret, _, err := s.DealRandomAndRevealDealerFunc(prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not deal random shares")
        }</span>
        <span class="cov8" title="1">return shares, secret, nil</span>
}

// Reconstruct recovers the secret from a set of shares using Lagrange interpolation.
// Only the secret component f(i) of each share is used; blinding factors are discarded.
func (s *Scheme[E, S]) Reconstruct(shares ...*Share[S]) (*Secret[S], error) <span class="cov8" title="1">{
        shamirShares, _ := sliceutils.MapOrError(shares, func(sh *Share[S]) (*shamir.Share[S], error) </span><span class="cov8" title="1">{ return shamir.NewShare(sh.ID(), sh.secret.Value(), nil) }</span>)
        <span class="cov8" title="1">secret, err := s.shamirSSS.Reconstruct(shamirShares...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not reconstruct secret from shares")
        }</span>
        <span class="cov8" title="1">return secret, nil</span>
}

// ReconstructAndVerify recovers the secret and verifies each share against
// the verification vector before reconstruction.
func (s *Scheme[E, S]) ReconstructAndVerify(vector VerificationVector[E, S], shares ...*Share[S]) (*Secret[S], error) <span class="cov8" title="1">{
        reconstructed, err := s.Reconstruct(shares...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for i, share := range shares </span><span class="cov8" title="1">{
                if err := s.Verify(share, vector); err != nil </span><span class="cov8" title="1">{
                        return nil, errs2.Wrap(err).WithMessage("verification failed for share %d", i)
                }</span>
        }
        <span class="cov8" title="1">return reconstructed, nil</span>
}

// Verify checks that a share (s_i, t_i) is consistent with the verification vector.
// Returns nil if g^{s_i}h^{t_i} equals the evaluation of the verification vector at the share's ID.
func (s *Scheme[E, S]) Verify(share *Share[S], vector VerificationVector[E, S]) error <span class="cov8" title="1">{
        if vector == nil </span><span class="cov8" title="1">{
                return ErrIsNil.WithMessage("verification vector is nil")
        }</span>
        <span class="cov8" title="1">if uint(vector.Degree()+1) != s.AccessStructure().Threshold() </span><span class="cov0" title="0">{
                return ErrVerification.WithMessage("verification vector degree does not match threshold")
        }</span>
        <span class="cov8" title="1">commitment, err := pedcom.NewCommitment(vector.Eval(s.shamirSSS.SharingIDToLagrangeNode(share.ID())))
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("could not create commitment from recomputed value")
        }</span>
        <span class="cov8" title="1">verifier := s.commitmentScheme.Verifier()
        if err := verifier.Verify(commitment, share.secret, share.blinding); err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("could not verify commitment")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file350" style="display: none">package pedersen

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir"
)

// Secret is a Pedersen VSS secret, which is identical to a Shamir secret.
// This is the value s = f(0) that is shared among the shareholders.
type Secret[S algebra.PrimeFieldElement[S]] = shamir.Secret[S]

// NewSecret creates a new secret from a field element.
func NewSecret[S algebra.PrimeFieldElement[S]](value S) *Secret[S] <span class="cov8" title="1">{
        return shamir.NewSecret(value)
}</span>
</pre>
		
		<pre class="file" id="file351" style="display: none">package pedersen

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        pedcom "github.com/bronlabs/bron-crypto/pkg/commitments/pedersen"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/additive"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir"
)

// Share represents a Pedersen VSS share consisting of a secret component f(i)
// and a blinding component r(i), where f and r are the dealing polynomials.
type Share[S algebra.PrimeFieldElement[S]] struct {
        id       sharing.ID
        secret   *pedcom.Message[S]
        blinding *pedcom.Witness[S]
}

type shareDTO[S algebra.PrimeFieldElement[S]] struct {
        ID       sharing.ID         `cbor:"sharingID"`
        Secret_  *pedcom.Message[S] `cbor:"secret"`
        Blinding *pedcom.Witness[S] `cbor:"blinding"`
}

// NewShare creates a new Pedersen share with the given ID, secret, and blinding value.
// If an access structure is provided, validates that the ID is a valid shareholder.
func NewShare[S algebra.PrimeFieldElement[S]](id sharing.ID, secret *pedcom.Message[S], blinding *pedcom.Witness[S], ac *sharing.ThresholdAccessStructure) (*Share[S], error) <span class="cov8" title="1">{
        if secret == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithMessage("secret cannot be nil")
        }</span>
        <span class="cov8" title="1">if blinding == nil </span><span class="cov8" title="1">{
                return nil, ErrIsNil.WithMessage("blinding cannot be nil")
        }</span>
        <span class="cov8" title="1">if ac != nil &amp;&amp; !ac.Shareholders().Contains(id) </span><span class="cov8" title="1">{
                return nil, ErrMembership.WithMessage("share ID %d is not a valid shareholder", id)
        }</span>
        <span class="cov8" title="1">return &amp;Share[S]{
                id:       id,
                secret:   secret,
                blinding: blinding,
        }, nil</span>
}

// ID returns the shareholder identifier for this share.
func (s *Share[S]) ID() sharing.ID <span class="cov8" title="1">{
        return s.id
}</span>

// Value returns the secret component f(i) of this share.
func (s *Share[S]) Value() S <span class="cov8" title="1">{
        return s.secret.Value()
}</span>

// Blinding returns the blinding component r(i) of this share.
func (s *Share[S]) Blinding() *pedcom.Witness[S] <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.blinding</span>
}

// Secret returns the secret component as a Pedersen message.
func (s *Share[S]) Secret() *pedcom.Message[S] <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.secret</span>
}

// Op is an alias for Add, implementing the group element interface.
func (s *Share[S]) Op(other *Share[S]) *Share[S] <span class="cov8" title="1">{
        if s.id != other.id </span><span class="cov0" title="0">{
                panic("cannot add shares with different IDs")</span>
        }
        <span class="cov8" title="1">return &amp;Share[S]{
                id:       s.id,
                secret:   s.secret.Op(other.secret),
                blinding: s.blinding.Op(other.blinding),
        }</span>
}

// Add returns a new share that is the component-wise sum of two shares.
// Both the secret and blinding components are added separately.
func (s *Share[S]) Add(other *Share[S]) *Share[S] <span class="cov8" title="1">{
        return s.Op(other)
}</span>

// ScalarOp is an alias for ScalarMul.
// Panics if scalar is zero since Pedersen requires non-zero blinding factors.
func (s *Share[S]) ScalarOp(scalar S) *Share[S] <span class="cov8" title="1">{
        // Special case: multiplying by zero is not supported in Pedersen VSS
        // because it would require a zero blinding factor, which is not allowed
        if scalar.IsZero() </span><span class="cov8" title="1">{
                panic(ErrIsZero.WithMessage("cannot multiply Pedersen share by zero - zero blinding factors are not allowed"))</span>
        }

        <span class="cov8" title="1">w2, err := pedcom.NewWitness(scalar)
        if err != nil </span><span class="cov0" title="0">{
                panic(ErrFailed.WithMessage("could not create witness from scalar: %v", err))</span>
        }
        <span class="cov8" title="1">m2 := pedcom.NewMessage(scalar)
        return &amp;Share[S]{
                id:       s.id,
                secret:   s.secret.Mul(m2),
                blinding: s.blinding.Mul(w2),
        }</span>
}

// ScalarMul returns a new share with both components multiplied by a scalar.
func (s *Share[S]) ScalarMul(scalar S) *Share[S] <span class="cov8" title="1">{
        return s.ScalarOp(scalar)
}</span>

// HashCode returns a hash code for this share, for use in hash-based collections.
func (s *Share[S]) HashCode() base.HashCode <span class="cov8" title="1">{
        return s.secret.HashCode() ^ s.blinding.HashCode()
}</span>

// Equal returns true if two shares have the same secret and blinding components.
func (s *Share[S]) Equal(other *Share[S]) bool <span class="cov8" title="1">{
        if s == nil || other == nil </span><span class="cov8" title="1">{
                return s == other
        }</span>
        <span class="cov8" title="1">return s.id == other.id &amp;&amp; s.secret.Equal(other.secret) &amp;&amp; s.blinding.Equal(other.blinding)</span>
}

// Bytes returns the canonical byte representation of this share.
func (s *Share[S]) Bytes() []byte <span class="cov0" title="0">{
        return slices.Concat(
                s.secret.Value().Bytes(),
                s.blinding.Value().Bytes(),
        )
}</span>

// ToAdditive converts this Pedersen share to an additive share by multiplying
// the secret component by the appropriate Lagrange coefficient. The blinding
// component is discarded. The resulting additive shares can be summed to
// reconstruct the secret.
func (s *Share[S]) ToAdditive(qualifiedSet *sharing.MinimalQualifiedAccessStructure) (*additive.Share[S], error) <span class="cov8" title="1">{
        ss, err := shamir.NewShare(s.id, s.secret.Value(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create shamir share from share")
        }</span>
        <span class="cov8" title="1">additiveShare, err := ss.ToAdditive(qualifiedSet)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert Pedersen share to additive")
        }</span>
        <span class="cov8" title="1">return additiveShare, nil</span>
}

func (s *Share[S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := shareDTO[S]{
                ID:       s.id,
                Secret_:  s.secret,
                Blinding: s.blinding,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Pedersen Share")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (s *Share[S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*shareDTO[S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s2, err := NewShare(dto.ID, dto.Secret_, dto.Blinding, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*s = *s2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file352" style="display: none">package shamir

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// DealerOutput contains the result of a dealing operation: a map from
// shareholder IDs to their corresponding shares.
type DealerOutput[FE algebra.PrimeFieldElement[FE]] struct {
        shares ds.Map[sharing.ID, *Share[FE]]
}

// Shares returns the map of shareholder IDs to shares.
func (d *DealerOutput[FE]) Shares() ds.Map[sharing.ID, *Share[FE]] <span class="cov8" title="1">{
        return d.shares
}</span>
</pre>
		
		<pre class="file" id="file353" style="display: none">package shamir

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials/interpolation/lagrange"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// Scheme implements Shamir's (t,n) threshold secret sharing over a prime field.
type Scheme[FE algebra.PrimeFieldElement[FE]] struct {
        f        algebra.PrimeField[FE]
        polyRing *polynomials.PolynomialRing[FE]
        ac       *sharing.ThresholdAccessStructure
}

// NewScheme creates a new Shamir secret sharing scheme.
//
// Parameters:
//   - f: The prime field over which sharing is performed
//   - threshold: Minimum number of shares required for reconstruction (must be  2)
//   - shareholders: Set of shareholder IDs who will receive shares
//
// The threshold must not exceed the number of shareholders.
func NewScheme[FE algebra.PrimeFieldElement[FE]](f algebra.PrimeField[FE], threshold uint, shareholders ds.Set[sharing.ID]) (*Scheme[FE], error) <span class="cov8" title="1">{
        if f == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("invalid field")
        }</span>
        <span class="cov8" title="1">if shareholders == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("shareholders is nil")
        }</span>
        <span class="cov8" title="1">if threshold &lt; 2 </span><span class="cov8" title="1">{
                return nil, ErrValue.WithMessage("threshold cannot be less than 2")
        }</span>
        <span class="cov8" title="1">if threshold &gt; uint(shareholders.Size()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("threshold cannot be greater than total number of shareholders")
        }</span>
        <span class="cov8" title="1">ac, err := sharing.NewThresholdAccessStructure(threshold, shareholders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create access structure")
        }</span>
        <span class="cov8" title="1">ring, err := polynomials.NewPolynomialRing(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create polynomial ring")
        }</span>

        <span class="cov8" title="1">return &amp;Scheme[FE]{
                f:        f,
                polyRing: ring,
                ac:       ac,
        }, nil</span>
}

// Name returns the canonical name of this scheme.
func (*Scheme[FE]) Name() sharing.Name <span class="cov0" title="0">{
        return Name
}</span>

// SharingIDToLagrangeNode converts a shareholder ID to its field element representation.
func (d *Scheme[FE]) SharingIDToLagrangeNode(id sharing.ID) FE <span class="cov8" title="1">{
        return SharingIDToLagrangeNode(d.f, id)
}</span>

// AccessStructure returns the threshold access structure for this scheme.
func (d *Scheme[FE]) AccessStructure() *sharing.ThresholdAccessStructure <span class="cov8" title="1">{
        return d.ac
}</span>

// PolynomialRing returns the polynomial ring used for share generation.
func (d *Scheme[FE]) PolynomialRing() *polynomials.PolynomialRing[FE] <span class="cov0" title="0">{
        return d.polyRing
}</span>

// DealRandomAndRevealDealerFunc generates shares for a random secret and returns
// the dealing polynomial. This is useful for protocols that need the polynomial
// for verification or further computation.
func (d *Scheme[FE]) DealRandomAndRevealDealerFunc(prng io.Reader) (*DealerOutput[FE], *Secret[FE], DealerFunc[FE], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, nil, ErrIsNil.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">value, err := d.f.Random(prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, nil, errs2.Wrap(err).WithMessage("could not sample field element")
        }</span>
        <span class="cov8" title="1">secret := NewSecret(value)
        shares, dealerFunc, err := d.DealAndRevealDealerFunc(secret, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, errs2.Wrap(err).WithMessage("could not create shares")
        }</span>
        <span class="cov8" title="1">return shares, secret, dealerFunc, nil</span>
}

// DealRandom generates shares for a randomly sampled secret.
func (d *Scheme[FE]) DealRandom(prng io.Reader) (*DealerOutput[FE], *Secret[FE], error) <span class="cov8" title="1">{
        shares, secret, _, err := d.DealRandomAndRevealDealerFunc(prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not deal random shares")
        }</span>
        <span class="cov8" title="1">return shares, secret, nil</span>
}

// DealAndRevealDealerFunc creates shares for the given secret and returns the
// dealing polynomial f(x) where f(0) = secret.
func (d *Scheme[FE]) DealAndRevealDealerFunc(secret *Secret[FE], prng io.Reader) (*DealerOutput[FE], DealerFunc[FE], error) <span class="cov8" title="1">{
        if secret == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrIsNil.WithMessage("secret is nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov8" title="1">{
                return nil, nil, ErrIsNil.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">poly, err := d.polyRing.RandomPolynomialWithConstantTerm(int(d.ac.Threshold()-1), secret.v, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not generate random polynomial")
        }</span>
        <span class="cov8" title="1">shares := hashmap.NewComparable[sharing.ID, *Share[FE]]()
        for id := range d.ac.Shareholders().Iter() </span><span class="cov8" title="1">{
                node := d.SharingIDToLagrangeNode(id)
                shares.Put(id, &amp;Share[FE]{
                        id: id,
                        v:  poly.Eval(node),
                })
        }</span>
        <span class="cov8" title="1">return &amp;DealerOutput[FE]{shares: shares.Freeze()}, poly, nil</span>
}

// Deal creates shares for the given secret.
func (d *Scheme[FE]) Deal(secret *Secret[FE], prng io.Reader) (*DealerOutput[FE], error) <span class="cov8" title="1">{
        out, _, err := d.DealAndRevealDealerFunc(secret, prng)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs2.Wrap(err).WithMessage("could not deal shares")
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// Reconstruct recovers the secret from a set of shares using Lagrange interpolation.
// At least threshold shares must be provided, and all shares must belong to authorized
// shareholders in the access structure.
func (d *Scheme[FE]) Reconstruct(shares ...*Share[FE]) (*Secret[FE], error) <span class="cov8" title="1">{
        sharesSet := hashset.NewHashable(shares...)
        ids, err := sharing.CollectIDs(sharesSet.List()...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not collect IDs from shares")
        }</span>
        <span class="cov8" title="1">if !d.ac.IsAuthorized(ids...) </span><span class="cov8" title="1">{
                return nil, ErrFailed.WithMessage("shares are not authorized by the access structure")
        }</span>
        <span class="cov8" title="1">nodes := make([]FE, sharesSet.Size())
        values := make([]FE, sharesSet.Size())
        for i, share := range sharesSet.Iter2() </span><span class="cov8" title="1">{
                nodes[i] = d.SharingIDToLagrangeNode(share.ID())
                values[i] = share.Value()
        }</span>
        <span class="cov8" title="1">reconstructed, err := lagrange.InterpolateAt(nodes, values, d.f.Zero())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not interpolate polynomial")
        }</span>
        <span class="cov8" title="1">return &amp;Secret[FE]{reconstructed}, nil</span>
}

// Field returns the prime field over which this scheme operates.
func (d *Scheme[FE]) Field() algebra.PrimeField[FE] <span class="cov0" title="0">{
        return d.f
}</span>
</pre>
		
		<pre class="file" id="file354" style="display: none">package shamir

import "github.com/bronlabs/bron-crypto/pkg/base/algebra"

// Secret wraps a prime field element that is being shared.
type Secret[FE algebra.PrimeFieldElement[FE]] struct {
        v FE
}

// NewSecret creates a new secret from a field element.
func NewSecret[FE algebra.PrimeFieldElement[FE]](value FE) *Secret[FE] <span class="cov8" title="1">{
        return &amp;Secret[FE]{v: value}
}</span>

// Value returns the underlying field element.
func (s *Secret[FE]) Value() FE <span class="cov8" title="1">{
        return s.v
}</span>

// Equal returns true if two secrets have the same value.
func (s *Secret[FE]) Equal(other *Secret[FE]) bool <span class="cov8" title="1">{
        if s == nil || other == nil </span><span class="cov0" title="0">{
                return s == other
        }</span>
        <span class="cov8" title="1">return s.v.Equal(other.v)</span>
}

// Clone returns a deep copy of this secret.
func (s *Secret[FE]) Clone() *Secret[FE] <span class="cov0" title="0">{
        return &amp;Secret[FE]{
                v: s.v.Clone(),
        }
}</span>
</pre>
		
		<pre class="file" id="file355" style="display: none">// Package shamir implements Shamir's (t,n) threshold secret sharing scheme.
//
// In Shamir's scheme, a secret s is encoded as the constant term of a random
// polynomial f(x) of degree t-1. Each share is a point (i, f(i)) on the polynomial.
// Any t shares can reconstruct s via Lagrange interpolation, while t-1 or fewer
// shares reveal no information about s (information-theoretic security).
package shamir

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials"
        "github.com/bronlabs/bron-crypto/pkg/base/polynomials/interpolation/lagrange"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// DealerFunc is the polynomial used by the dealer to generate shares.
// The secret is f(0) and each share i is f(i).
type (
        DealerFunc[FE algebra.PrimeFieldElement[FE]] = *polynomials.Polynomial[FE]
)

// Name is the canonical name of this secret sharing scheme.
const Name sharing.Name = "Shamir's Secret Sharing"

// SharingIDToLagrangeNode converts a shareholder ID to the corresponding
// evaluation point on the polynomial (the x-coordinate for interpolation).
func SharingIDToLagrangeNode[FE algebra.PrimeFieldElement[FE]](f algebra.PrimeField[FE], id sharing.ID) FE <span class="cov8" title="1">{
        return f.FromUint64(uint64(id))
}</span>

// LagrangeCoefficients computes the Lagrange basis polynomial values at x=0
// for the given set of shareholder IDs. These coefficients are used to
// convert Shamir shares to additive shares or to perform reconstruction.
//
// For shareholder i in set S, the coefficient _i = _{jS,ji} j/(j-i).
func LagrangeCoefficients[FE algebra.PrimeFieldElement[FE]](field algebra.PrimeField[FE], sharingIDs ...sharing.ID) (ds.Map[sharing.ID, FE], error) <span class="cov8" title="1">{
        if hashset.NewComparable(sharingIDs...).Size() != len(sharingIDs) </span><span class="cov0" title="0">{
                return nil, ErrMembership.WithMessage("invalid sharing id hash set")
        }</span>

        <span class="cov8" title="1">sharingIDsScalar := make([]FE, len(sharingIDs))
        for i, id := range sharingIDs </span><span class="cov8" title="1">{
                sharingIDsScalar[i] = SharingIDToLagrangeNode(field, id)
        }</span>

        <span class="cov8" title="1">basisPolynomialAtZero, err := lagrange.BasisAt(sharingIDsScalar, field.Zero())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not compute all basis polynomials at x=0")
        }</span>

        <span class="cov8" title="1">result := hashmap.NewComparable[sharing.ID, FE]()
        for i, li := range basisPolynomialAtZero.Coefficients() </span><span class="cov8" title="1">{
                result.Put(sharingIDs[i], li)
        }</span>

        <span class="cov8" title="1">return result.Freeze(), nil</span>
}
</pre>
		
		<pre class="file" id="file356" style="display: none">package shamir

import (
        "encoding/binary"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/additive"
)

// Share represents a Shamir secret share, consisting of an evaluation point (ID)
// and the polynomial value at that point.
type Share[FE algebra.PrimeFieldElement[FE]] struct {
        id sharing.ID
        v  FE
}

type shareDTO[FE algebra.PrimeFieldElement[FE]] struct {
        ID sharing.ID `cbor:"sharingID"`
        V  FE         `cbor:"value"`
}

// NewShare creates a new Shamir share with the given ID and value.
// If an access structure is provided, validates that the ID is a valid shareholder.
func NewShare[FE algebra.PrimeFieldElement[FE]](id sharing.ID, value FE, ac *sharing.ThresholdAccessStructure) (*Share[FE], error) <span class="cov8" title="1">{
        if ac != nil &amp;&amp; !ac.Shareholders().Contains(id) </span><span class="cov0" title="0">{
                return nil, ErrMembership.WithMessage("share ID %d is not a valid shareholder", id)
        }</span>
        <span class="cov8" title="1">return &amp;Share[FE]{
                id: id,
                v:  value,
        }, nil</span>
}

// ToAdditive converts this Shamir share to an additive share by multiplying
// by the appropriate Lagrange coefficient. The resulting additive shares can
// be summed to reconstruct the secret.
func (s *Share[FE]) ToAdditive(qualifiedSet *sharing.MinimalQualifiedAccessStructure) (*additive.Share[FE], error) <span class="cov8" title="1">{
        field, ok := s.v.Structure().(algebra.PrimeField[FE])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrType.WithMessage("share value does not implement Field interface")
        }</span>
        <span class="cov8" title="1">lambdas, err := LagrangeCoefficients(field, qualifiedSet.Shareholders().List()...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not compute Lagrange coefficients")
        }</span>
        <span class="cov8" title="1">lambdaI, exists := lambdas.Get(s.id)
        if !exists </span><span class="cov8" title="1">{
                return nil, ErrMembership.WithMessage("share ID %d is not a valid shareholder", s.id)
        }</span>
        <span class="cov8" title="1">converted := lambdaI.Mul(s.v)
        additiveShare, err := additive.NewShare(s.id, converted, qualifiedSet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert Shamir share to additive")
        }</span>
        <span class="cov8" title="1">return additiveShare, nil</span>
}

// ID returns the shareholder identifier for this share.
func (s *Share[_]) ID() sharing.ID <span class="cov8" title="1">{
        return s.id
}</span>

// Value returns the share value (the polynomial evaluation at ID).
func (s *Share[FE]) Value() FE <span class="cov8" title="1">{
        return s.v
}</span>

// Equal returns true if two shares have the same ID and value.
func (s *Share[FE]) Equal(other *Share[FE]) bool <span class="cov8" title="1">{
        if s == nil || other == nil </span><span class="cov8" title="1">{
                return s == other
        }</span>
        <span class="cov8" title="1">return s.id == other.id &amp;&amp; s.v.Equal(other.v)</span>
}

// Op is an alias for Add, implementing the group element interface.
func (s *Share[FE]) Op(other *Share[FE]) *Share[FE] <span class="cov8" title="1">{
        return s.Add(other)
}</span>

// Add returns a new share that is the component-wise sum of two shares.
// Both shares must have the same ID.
func (s *Share[FE]) Add(other *Share[FE]) *Share[FE] <span class="cov8" title="1">{
        if s.id != other.id </span><span class="cov0" title="0">{
                panic("cannot add shares with different IDs")</span>
        }
        <span class="cov8" title="1">return &amp;Share[FE]{
                id: s.id,
                v:  s.v.Add(other.v),
        }</span>
}

// SubPlain subtracts a plaintext value from this share.
func (s *Share[FE]) SubPlain(other FE) *Share[FE] <span class="cov0" title="0">{
        return &amp;Share[FE]{
                id: s.id,
                v:  s.v.Sub(other),
        }
}</span>

// ScalarOp is an alias for ScalarMul.
func (s *Share[FE]) ScalarOp(scalar FE) *Share[FE] <span class="cov8" title="1">{
        return s.ScalarMul(scalar)
}</span>

// ScalarMul returns a new share with the value multiplied by a scalar.
func (s *Share[FE]) ScalarMul(scalar FE) *Share[FE] <span class="cov8" title="1">{
        return &amp;Share[FE]{
                id: s.id,
                v:  s.v.Mul(scalar),
        }
}</span>

// Clone returns a deep copy of this share.
func (s *Share[FE]) Clone() *Share[FE] <span class="cov8" title="1">{
        return &amp;Share[FE]{
                id: s.id,
                v:  s.v.Clone(),
        }
}</span>

// HashCode returns a hash code for this share, for use in hash-based collections.
func (s *Share[FE]) HashCode() base.HashCode <span class="cov8" title="1">{
        return base.HashCode(s.id) ^ s.v.HashCode()
}</span>

// Bytes returns the canonical byte representation of this share.
func (s *Share[FE]) Bytes() []byte <span class="cov0" title="0">{
        buf := s.Value().Bytes()
        binary.BigEndian.AppendUint64(buf, uint64(s.ID()))
        return buf
}</span>

func (s *Share[FE]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;shareDTO[FE]{
                ID: s.id,
                V:  s.v,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal Shamir Share")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (s *Share[FE]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*shareDTO[FE]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s2, err := NewShare(dto.ID, dto.V, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*s = *s2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file357" style="display: none">package sharing

import (
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
)

// ThresholdAccessStructure represents a (t,n) threshold access structure where
// any subset of at least t shareholders (out of n total) is authorized to
// reconstruct the secret.
type ThresholdAccessStructure struct {
        t  uint
        ps ds.Set[ID]
}

type thresholdAccessStructureDTO struct {
        T  uint        `cbor:"threshold"`
        Ps map[ID]bool `cbor:"shareholders"`
}

// NewThresholdAccessStructure creates a new threshold access structure.
//
// Parameters:
//   - t: The threshold (minimum shares required), must be at least 2
//   - ps: The set of shareholder IDs, must not contain 0
//
// Returns an error if t &lt; 2, t &gt; |ps|, ps is nil, or ps contains 0.
func NewThresholdAccessStructure(t uint, ps ds.Set[ID]) (*ThresholdAccessStructure, error) <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("party set is nil")
        }</span>
        <span class="cov0" title="0">if ps.Contains(0) </span><span class="cov0" title="0">{
                return nil, ErrMembership.WithMessage("party set cannot contain 0")
        }</span>
        <span class="cov0" title="0">if t &lt; 2 </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("threshold cannot be less than 2")
        }</span>
        <span class="cov0" title="0">if t &gt; uint(ps.Size()) </span><span class="cov0" title="0">{
                return nil, ErrValue.WithMessage("total cannot be less than threshold")
        }</span>
        <span class="cov0" title="0">return &amp;ThresholdAccessStructure{
                t:  t,
                ps: ps,
        }, nil</span>
}

// Threshold returns the minimum number of shares required for reconstruction.
func (a *ThresholdAccessStructure) Threshold() uint <span class="cov0" title="0">{
        return a.t
}</span>

// Shareholders returns the set of all valid shareholder IDs.
func (a *ThresholdAccessStructure) Shareholders() ds.Set[ID] <span class="cov0" title="0">{
        return a.ps
}</span>

// IsAuthorized returns true if the given set of shareholder IDs forms an
// authorized subset (i.e., has at least t members, all from the shareholder set).
func (a *ThresholdAccessStructure) IsAuthorized(ids ...ID) bool <span class="cov0" title="0">{
        idsSet := hashset.NewComparable(ids...)
        return idsSet.Size() &gt;= int(a.t) &amp;&amp;
                idsSet.Size() &lt;= a.ps.Size() &amp;&amp;
                idsSet.Freeze().IsSubSet(a.ps)
}</span>

// Equal returns true if two access structures have the same threshold and shareholders.
func (a *ThresholdAccessStructure) Equal(other *ThresholdAccessStructure) bool <span class="cov0" title="0">{
        if a == nil || other == nil </span><span class="cov0" title="0">{
                return a == other
        }</span>
        <span class="cov0" title="0">if a.t != other.t </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if a.ps.Size() != other.ps.Size() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return a.ps.Equal(other.ps)</span>
}

// Clone returns a deep copy of this access structure.
func (a *ThresholdAccessStructure) Clone() *ThresholdAccessStructure <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;ThresholdAccessStructure{
                t:  a.t,
                ps: a.ps.Clone(),
        }</span>
}

func (a *ThresholdAccessStructure) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;thresholdAccessStructureDTO{
                T:  a.t,
                Ps: make(map[ID]bool),
        }
        for p := range a.ps.Iter() </span><span class="cov0" title="0">{
                dto.Ps[p] = true
        }</span>

        <span class="cov0" title="0">data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal AccessStructure")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

func (a *ThresholdAccessStructure) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*thresholdAccessStructureDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ps := hashset.NewComparable[ID]()
        for k, v := range dto.Ps </span><span class="cov0" title="0">{
                if v </span><span class="cov0" title="0">{
                        ps.Add(k)
                }</span>
        }
        <span class="cov0" title="0">a2, err := NewThresholdAccessStructure(dto.T, ps.Freeze())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*a = *a2
        return nil</span>
}
</pre>
		
		<pre class="file" id="file358" style="display: none">package sharing

import (
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
)

// NewOrdinalShareholderSet creates a set of shareholder IDs {1, 2, ..., count}.
// This is a convenience function for creating standard shareholder sets where
// IDs are sequential integers starting from 1.
func NewOrdinalShareholderSet(count uint) ds.Set[ID] <span class="cov0" title="0">{
        out := hashset.NewComparable[ID]()
        for i := range count </span><span class="cov0" title="0">{
                out.Add(ID(i + 1))
        }</span>
        <span class="cov0" title="0">return out.Freeze()</span>
}

// CollectIDs extracts the shareholder IDs from a slice of shares.
// Returns an error if any share is nil.
func CollectIDs[S Share[S]](shares ...S) ([]ID, error) <span class="cov0" title="0">{
        ids, err := sliceutils.MapOrError(shares, func(s S) (ID, error) </span><span class="cov0" title="0">{
                if utils.IsNil(s) </span><span class="cov0" title="0">{
                        return 0, ErrIsNil.WithMessage("share cannot be nil")
                }</span>
                <span class="cov0" title="0">return s.ID(), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to collect share IDs")
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}
</pre>
		
		<pre class="file" id="file359" style="display: none">package hjky

import (
        "encoding/hex"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel  = "BRON_CRYPTO_HJKY-"
        coefficientLabel = "BRON_CRYPTO_HJKY_COEFFICIENT-"
)

// Participant executes the HJKY zero-sharing protocol.
type Participant[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        sessionID       network.SID
        sharingID       sharing.ID
        accessStructure *sharing.ThresholdAccessStructure
        group           algebra.PrimeGroup[G, S]
        field           algebra.PrimeField[S]
        scheme          *feldman.Scheme[G, S]
        round           network.Round
        prng            io.Reader
        tape            transcripts.Transcript
        state           State[G, S]
}

type State[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]] struct {
        verificationVectors map[sharing.ID]feldman.VerificationVector[G, S]
        share               *feldman.Share[S]
}

// NewParticipant creates a zero-sharing participant bound to the given session and access structure.
func NewParticipant[G algebra.PrimeGroupElement[G, S], S algebra.PrimeFieldElement[S]](sid network.SID, id sharing.ID, as *sharing.ThresholdAccessStructure, g algebra.PrimeGroup[G, S], tape transcripts.Transcript, prng io.Reader) (*Participant[G, S], error) <span class="cov8" title="1">{
        if tape == nil || prng == nil || !as.Shareholders().Contains(id) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid arguments")
        }</span>

        <span class="cov8" title="1">field := algebra.StructureMustBeAs[algebra.PrimeField[S]](g.ScalarStructure())
        scheme, err := feldman.NewScheme(g.Generator(), as.Threshold(), as.Shareholders())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create feldman scheme")
        }</span>
        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s%s", transcriptLabel, hex.EncodeToString(sid[:])))

        return &amp;Participant[G, S]{
                sessionID:       sid,
                sharingID:       id,
                accessStructure: as,
                group:           g,
                field:           field,
                scheme:          scheme,
                round:           1,
                prng:            prng,
                tape:            tape,
                state: State[G, S]{
                        verificationVectors: nil,
                        share:               nil,
                },
        }, nil</span>
}

// SharingID returns the identifier for this participant within the access structure.
func (p *Participant[G, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return p.sharingID
}</span>
</pre>
		
		<pre class="file" id="file360" style="display: none">package hjky

import (
        "maps"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
)

// Round1 deals a zero-sharing and distributes shares and verification vectors.
func (p *Participant[G, S]) Round1() (*Round1Broadcast[G, S], network.OutgoingUnicasts[*Round1P2P[G, S]], error) <span class="cov8" title="1">{
        if p.round != 1 </span><span class="cov0" title="0">{
                return nil, nil, ErrRound.WithMessage("expected round 1")
        }</span>

        <span class="cov8" title="1">dealerOut, err := p.scheme.Deal(feldman.NewSecret(p.field.Zero()), p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not deal shares")
        }</span>
        <span class="cov8" title="1">p.state.verificationVectors = make(map[sharing.ID]feldman.VerificationVector[G, S])
        p.state.verificationVectors[p.sharingID] = dealerOut.VerificationMaterial()

        var ok bool
        p.state.share, ok = dealerOut.Shares().Get(p.sharingID)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("missing share")
        }</span>

        <span class="cov8" title="1">r1b := &amp;Round1Broadcast[G, S]{
                VerificationVector: p.state.verificationVectors[p.sharingID],
        }
        r1u := hashmap.NewComparable[sharing.ID, *Round1P2P[G, S]]()
        for id := range p.accessStructure.Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">share, ok := dealerOut.Shares().Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing share")
                }</span>
                <span class="cov8" title="1">r1u.Put(id, &amp;Round1P2P[G, S]{
                        ZeroShare: share,
                })</span>
        }

        <span class="cov8" title="1">p.round++
        return r1b, r1u.Freeze(), nil</span>
}

// Round2 verifies all zero-shares and aggregates them into a single zero-share and verification vector.
func (p *Participant[G, S]) Round2(r1b network.RoundMessages[*Round1Broadcast[G, S]], r1u network.RoundMessages[*Round1P2P[G, S]]) (share *feldman.Share[S], verification feldman.VerificationVector[G, S], err error) <span class="cov8" title="1">{
        if p.round != 2 </span><span class="cov0" title="0">{
                return nil, nil, ErrRound.WithMessage("expected round 2")
        }</span>

        <span class="cov8" title="1">share = p.state.share
        verificationVector := p.state.verificationVectors[p.sharingID]
        for id := range p.accessStructure.Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">b, ok := r1b.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing message")
                }</span>
                <span class="cov8" title="1">u, ok := r1u.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing message")
                }</span>

                <span class="cov8" title="1">if !b.VerificationVector.Coefficients()[0].Equal(p.group.OpIdentity()) || p.scheme.Verify(u.ZeroShare, b.VerificationVector) != nil </span><span class="cov0" title="0">{
                        return nil, nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("invalid share")
                }</span>
                <span class="cov8" title="1">share = share.Add(u.ZeroShare)
                verificationVector = verificationVector.Op(b.VerificationVector)
                p.state.verificationVectors[id] = b.VerificationVector</span>
        }
        <span class="cov8" title="1">p.writeVerificationVectorToTranscript()

        p.round++
        return share, verificationVector, nil</span>
}

func (p *Participant[G, S]) writeVerificationVectorToTranscript() <span class="cov8" title="1">{
        for _, id := range slices.Sorted(maps.Keys(p.state.verificationVectors)) </span><span class="cov8" title="1">{
                v := p.state.verificationVectors[id]
                for _, c := range v.Coefficients() </span><span class="cov8" title="1">{
                        p.tape.AppendBytes(coefficientLabel, c.Bytes())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file361" style="display: none">package przs

import (
        "io"
        "math/rand/v2"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// Sampler deterministically derives zero-sharing scalars from pairwise seeds.
type Sampler[FE algebra.PrimeFieldElement[FE]] struct {
        field       algebra.PrimeField[FE]
        mySharingID sharing.ID
        seededPrngs ds.Map[sharing.ID, io.Reader]
}

// NewSampler builds a sampler from per-party seeds agreed during setup.
func NewSampler[FE algebra.PrimeFieldElement[FE]](sharingID sharing.ID, quorum network.Quorum, seeds Seeds, field algebra.PrimeField[FE]) (*Sampler[FE], error) <span class="cov8" title="1">{
        prngs := hashmap.NewComparable[sharing.ID, io.Reader]()
        for id := range quorum.Iter() </span><span class="cov8" title="1">{
                if id == sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seed, ok := seeds.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrInvalidArgument.WithMessage("missing seed for %d", id)
                }</span>

                <span class="cov8" title="1">prng := rand.NewChaCha8(seed)
                prngs.Put(id, prng)</span>
        }
        <span class="cov8" title="1">p := &amp;Sampler[FE]{
                field:       field,
                mySharingID: sharingID,
                seededPrngs: prngs.Freeze(),
        }

        return p, nil</span>
}

// Sample draws a zero-share using pairwise PRNGs; the sum across parties is zero.
func (s *Sampler[FE]) Sample() (FE, error) <span class="cov8" title="1">{
        var nilFE FE
        share := s.field.Zero()

        for id, prng := range s.seededPrngs.Iter() </span><span class="cov8" title="1">{
                sample, err := s.field.Random(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilFE, errs2.Wrap(err).WithMessage("could not sample scalar")
                }</span>

                <span class="cov8" title="1">if id &lt; s.mySharingID </span><span class="cov8" title="1">{
                        share = share.Add(sample)
                }</span> else<span class="cov8" title="1"> {
                        share = share.Add(sample.Neg())
                }</span>
        }

        <span class="cov8" title="1">if share.IsZero() </span><span class="cov0" title="0">{
                return nilFE, ErrFailed.WithMessage("could not sample a zero share")
        }</span>
        <span class="cov8" title="1">return share, nil</span>
}
</pre>
		
		<pre class="file" id="file362" style="display: none">package przssetup

import (
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
)

type Round1Broadcast struct {
        Commitments map[sharing.ID]hash_comm.Commitment `cbor:"commitments"`
}

func (*Round1Broadcast) Bytes() []byte <span class="cov0" title="0">{
        panic("not used")</span>
}

type Round2P2P struct {
        SeedContribution [przs.SeedLength]byte `cbor:"seedContribution"`
        Witness          hash_comm.Witness     `cbor:"witness"`
}

func (*Round2P2P) Bytes() []byte <span class="cov0" title="0">{
        panic("not used")</span>
}
</pre>
		
		<pre class="file" id="file363" style="display: none">package przssetup

import (
        "io"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        ts "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        domainSeparator = "BRON_CRYPTO_PRZS_SETUP_SID-"
)

// Participant runs the PRZS seed-setup protocol.
type Participant struct {
        mySharingID sharing.ID
        quorum      network.Quorum
        tape        ts.Transcript
        prng        io.Reader
        state       State
}

// State stores commitments and seed material across rounds.
type State struct {
        commitmentScheme *hash_comm.Scheme

        seedContributions ds.Map[sharing.ID, [przs.SeedLength]byte]
        witnesses         ds.Map[sharing.ID, hash_comm.Witness]
        commitments       ds.MutableMap[sharing.ID, ds.Map[sharing.ID, hash_comm.Commitment]]
}

// NewParticipant initialises the seed setup for a given session.
func NewParticipant(sessionID network.SID, mySharingID sharing.ID, quorum network.Quorum, tape ts.Transcript, prng io.Reader) (*Participant, error) <span class="cov8" title="1">{
        // TODO: add validation
        p := &amp;Participant{
                mySharingID: mySharingID,
                quorum:      quorum,
                tape:        tape,
                prng:        prng,
                state: State{
                        commitmentScheme:  nil,
                        seedContributions: nil,
                        witnesses:         nil,
                        commitments:       nil,
                },
        }
        p.tape.AppendBytes(domainSeparator, sessionID[:])

        var ck hash_comm.Key
        ckBytes, err := p.tape.ExtractBytes("ck", uint(len(ck)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to extract commitment key")
        }</span>
        <span class="cov8" title="1">copy(ck[:], ckBytes)
        p.state.commitmentScheme, err = hash_comm.NewScheme(ck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create commitment scheme")
        }</span>

        <span class="cov8" title="1">return p, nil</span>
}

// SharingID returns the participant identifier.
func (p *Participant) SharingID() sharing.ID <span class="cov8" title="1">{
        return p.mySharingID
}</span>
</pre>
		
		<pre class="file" id="file364" style="display: none">package przssetup

import (
        "crypto/subtle"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
)

// Round1 samples pairwise seed contributions and commits to them.
func (p *Participant) Round1() (*Round1Broadcast, error) <span class="cov8" title="1">{
        seedContributions := hashmap.NewComparable[sharing.ID, [przs.SeedLength]byte]()
        commitments := hashmap.NewComparable[sharing.ID, hash_comm.Commitment]()
        witnesses := hashmap.NewComparable[sharing.ID, hash_comm.Witness]()
        for sharingID := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if sharingID == p.mySharingID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">var seedContribution [przs.SeedLength]byte
                if _, err := io.ReadFull(p.prng, seedContribution[:]); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot sample seed contribution")
                }</span>

                <span class="cov8" title="1">seedContributionCommitment, seedContributionWitness, err := p.state.commitmentScheme.Committer().Commit(seedContribution[:], p.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot commit seed contribution")
                }</span>

                <span class="cov8" title="1">seedContributions.Put(sharingID, seedContribution)
                commitments.Put(sharingID, seedContributionCommitment)
                witnesses.Put(sharingID, seedContributionWitness)</span>
        }

        <span class="cov8" title="1">p.state.seedContributions = seedContributions.Freeze()
        p.state.witnesses = witnesses.Freeze()
        p.state.commitments = hashmap.NewComparable[sharing.ID, ds.Map[sharing.ID, hash_comm.Commitment]]()
        p.state.commitments.Put(p.mySharingID, commitments.Freeze())
        r1bo := &amp;Round1Broadcast{Commitments: commitments.ToNative()}
        return r1bo, nil</span>
}

// Round2 opens committed seed contributions to each counterparty.
func (p *Participant) Round2(r1bo network.RoundMessages[*Round1Broadcast]) (network.RoundMessages[*Round2P2P], error) <span class="cov8" title="1">{
        for sharingID := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if sharingID == p.mySharingID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">msg, ok := r1bo.Get(sharingID)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing message from %d", sharingID)
                }</span>
                <span class="cov8" title="1">p.state.commitments.Put(sharingID, hashmap.NewImmutableComparableFromNativeLike(msg.Commitments))</span>
        }

        <span class="cov8" title="1">r2uo := hashmap.NewComparable[sharing.ID, *Round2P2P]()
        for sharingID := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if sharingID == p.mySharingID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">seedContribution, ok := p.state.seedContributions.Get(sharingID)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing seed contribution to %d", sharingID)
                }</span>

                <span class="cov8" title="1">witness, ok := p.state.witnesses.Get(sharingID)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing seed witness to %d", sharingID)
                }</span>

                <span class="cov8" title="1">r2uo.Put(sharingID, &amp;Round2P2P{
                        SeedContribution: seedContribution,
                        Witness:          witness,
                })</span>
        }

        <span class="cov8" title="1">return r2uo.Freeze(), nil</span>
}

// Round3 verifies peers' openings and derives pairwise seeds.
func (p *Participant) Round3(r2uo network.RoundMessages[*Round2P2P]) (przs.Seeds, error) <span class="cov8" title="1">{
        commonSeeds := hashmap.NewComparable[sharing.ID, [przs.SeedLength]byte]()
        for sharingID := range p.quorum.Iter() </span><span class="cov8" title="1">{
                if sharingID == p.mySharingID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">msg, ok := r2uo.Get(sharingID)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing message from %d", sharingID)
                }</span>
                <span class="cov8" title="1">theirSeedContribution := msg.SeedContribution
                theirWitness := msg.Witness
                theirCommitments, ok := p.state.commitments.Get(sharingID)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing commitments from %d", sharingID)
                }</span>
                <span class="cov8" title="1">theirCommitment, ok := theirCommitments.Get(p.mySharingID)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing commitment for %d", sharingID)
                }</span>
                <span class="cov8" title="1">if p.state.commitmentScheme.Verifier().Verify(theirCommitment, theirSeedContribution[:], theirWitness) != nil </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, sharingID).WithMessage("invalid seed contribution")
                }</span>
                <span class="cov8" title="1">mySeedContribution, ok := p.state.seedContributions.Get(sharingID)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("missing seed for %d", sharingID)
                }</span>
                <span class="cov8" title="1">var seed [przs.SeedLength]byte
                subtle.XORBytes(seed[:], theirSeedContribution[:], mySeedContribution[:])
                commonSeeds.Put(sharingID, seed)</span>
        }

        <span class="cov8" title="1">return commonSeeds.Freeze(), nil</span>
}
</pre>
		
		<pre class="file" id="file365" style="display: none">package tsig

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
)

// BasePublicMaterial contains the public information for threshold signature verification,
// including the access structure, verification vector, and partial public keys for each party.
type BasePublicMaterial[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        accessStructure   *sharing.ThresholdAccessStructure
        fv                feldman.VerificationVector[E, S]
        partialPublicKeys ds.Map[sharing.ID, *schnorrlike.PublicKey[E, S]]
}

type basePublicMaterialDTO[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        AccessStructure   *sharing.ThresholdAccessStructure           `cbor:"accessStructure"`
        FV                feldman.VerificationVector[E, S]            `cbor:"verificationVector"`
        PartialPublicKeys map[sharing.ID]*schnorrlike.PublicKey[E, S] `cbor:"partialPublicKeys"`
}

// AccessStructure returns the threshold access structure defining authorized quorums.
func (spm *BasePublicMaterial[E, S]) AccessStructure() *sharing.ThresholdAccessStructure <span class="cov0" title="0">{
        if spm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return spm.accessStructure</span>
}

// PublicKey returns the threshold public key (first coefficient of the verification vector).
func (spm *BasePublicMaterial[E, S]) PublicKey() E <span class="cov0" title="0">{
        return spm.fv.Coefficients()[0]
}</span>

// PartialPublicKeys returns the map of party IDs to their partial public keys.
func (spm *BasePublicMaterial[E, S]) PartialPublicKeys() ds.Map[sharing.ID, *schnorrlike.PublicKey[E, S]] <span class="cov0" title="0">{
        if spm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return spm.partialPublicKeys</span>
}

// VerificationVector returns the Feldman verification vector for the shared secret.
func (spm *BasePublicMaterial[E, S]) VerificationVector() feldman.VerificationVector[E, S] <span class="cov0" title="0">{
        if spm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return spm.fv</span>
}

// Equal returns true if this public material equals another.
func (spm *BasePublicMaterial[E, S]) Equal(other *BasePublicMaterial[E, S]) bool <span class="cov0" title="0">{
        if spm == nil || other == nil </span><span class="cov0" title="0">{
                return spm == other
        }</span>
        <span class="cov0" title="0">if !spm.accessStructure.Equal(other.accessStructure) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !spm.fv.Equal(other.fv) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if spm.partialPublicKeys.Size() != other.partialPublicKeys.Size() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for id, pk := range spm.partialPublicKeys.Iter() </span><span class="cov0" title="0">{
                otherPk, exists := other.partialPublicKeys.Get(id)
                if !exists || !pk.Equal(otherPk) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// HashCode returns a hash code for this public material.
func (spm *BasePublicMaterial[E, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        return spm.fv.HashCode()
}</span>

// MarshalCBOR serialises the public material to CBOR format.
func (spm *BasePublicMaterial[E, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        ppk := make(map[sharing.ID]*schnorrlike.PublicKey[E, S])
        for k, v := range spm.partialPublicKeys.Iter() </span><span class="cov0" title="0">{
                ppk[k] = v
        }</span>

        <span class="cov0" title="0">dto := &amp;basePublicMaterialDTO[E, S]{
                AccessStructure:   spm.accessStructure,
                FV:                spm.fv,
                PartialPublicKeys: ppk,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal tSchnorr BasePublicMaterial")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR deserializes the public material from CBOR format.
func (spm *BasePublicMaterial[E, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*basePublicMaterialDTO[E, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ppk := hashmap.NewImmutableComparableFromNativeLike(dto.PartialPublicKeys)
        spm2 := &amp;BasePublicMaterial[E, S]{
                accessStructure:   dto.AccessStructure,
                fv:                dto.FV,
                partialPublicKeys: ppk,
        }
        *spm = *spm2
        return nil</span>
}

// BaseShard contains a party's secret share and the associated public material for threshold signing.
type BaseShard[
        E algebra.PrimeGroupElement[E, S],
        S algebra.PrimeFieldElement[S],
] struct {
        BasePublicMaterial[E, S]

        share *feldman.Share[S]
}

type baseShardDTO[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        Share *feldman.Share[S]        `cbor:"share"`
        PM    BasePublicMaterial[E, S] `cbor:"publicMaterial"`
}

// Share returns the party's Feldman secret share.
func (sh *BaseShard[E, S]) Share() *feldman.Share[S] <span class="cov0" title="0">{
        if sh == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return sh.share</span>
}

// Equal returns true if this shard equals another.
func (sh *BaseShard[E, S]) Equal(other *BaseShard[E, S]) bool <span class="cov0" title="0">{
        if sh == nil || other == nil </span><span class="cov0" title="0">{
                return sh == other
        }</span>
        <span class="cov0" title="0">return sh.share.Equal(other.share) &amp;&amp;
                sh.BasePublicMaterial.Equal(&amp;other.BasePublicMaterial)</span>
}

// HashCode returns a hash code for this shard.
func (sh *BaseShard[E, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        if sh == nil </span><span class="cov0" title="0">{
                return base.HashCode(0)
        }</span>
        <span class="cov0" title="0">return sh.BasePublicMaterial.HashCode()</span>
}

// MarshalCBOR serialises the shard to CBOR format.
func (sh *BaseShard[E, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;baseShardDTO[E, S]{
                Share: sh.share,
                PM:    sh.BasePublicMaterial,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal tSchnorr BaseShard")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR deserializes the shard from CBOR format.
func (sh *BaseShard[E, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*baseShardDTO[E, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">sh2, err := NewBaseShard(dto.Share, dto.PM.VerificationVector(), dto.PM.AccessStructure())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*sh = *sh2
        return nil</span>
}

// NewBaseShard creates a new base shard from a Feldman share, verification vector, and access structure.
// It computes the partial public keys for all parties in the access structure.
func NewBaseShard[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]](
        share *feldman.Share[S],
        fv feldman.VerificationVector[E, S],
        accessStructure *sharing.ThresholdAccessStructure,
) (*BaseShard[E, S], error) <span class="cov0" title="0">{
        if share == nil || fv == nil || accessStructure == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil input parameters")
        }</span>
        <span class="cov0" title="0">sf, ok := share.Value().Structure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("share value structure is not a prime field")
        }</span>
        <span class="cov0" title="0">partialPublicKeyValues, err := gennaro.ComputePartialPublicKey(sf, share, fv, accessStructure)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compute partial public keys from share")
        }</span>
        <span class="cov0" title="0">partialPublicKeys := hashmap.NewComparable[sharing.ID, *schnorrlike.PublicKey[E, S]]()
        for id, value := range partialPublicKeyValues.Iter() </span><span class="cov0" title="0">{
                pk, err := schnorrlike.NewPublicKey(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create public key for party %d", id)
                }</span>
                <span class="cov0" title="0">partialPublicKeys.Put(id, pk)</span>
        }

        <span class="cov0" title="0">return &amp;BaseShard[E, S]{
                share: share,
                BasePublicMaterial: BasePublicMaterial[E, S]{
                        accessStructure:   accessStructure,
                        fv:                fv,
                        partialPublicKeys: partialPublicKeys.Freeze(),
                },
        }, nil</span>
}

var (
        // ErrInvalidArgument is returned when a function receives an invalid argument.
        ErrInvalidArgument = errs2.New("invalid argument")
)
</pre>
		
		<pre class="file" id="file366" style="display: none">package boldyreva02

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/signatures/bls"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls"
)

// PartialSignature represents a partial BLS signature produced by a single party
// in the Boldyreva threshold BLS scheme. It contains the partial signature on
// the message (SigmaI) and optionally a proof-of-possession signature (SigmaPopI)
// when using the POP rogue key prevention algorithm.
type PartialSignature[
        Sig curves.PairingFriendlyPoint[Sig, SigFE, PK, PKFE, E, S], SigFE algebra.FieldElement[SigFE],
        PK curves.PairingFriendlyPoint[PK, PKFE, Sig, SigFE, E, S], PKFE algebra.FieldElement[PKFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        // SigmaI is the partial signature on the message.
        SigmaI *bls.Signature[Sig, SigFE, PK, PKFE, E, S]
        // SigmaPopI is the proof-of-possession signature, present only when using POP algorithm.
        SigmaPopI *bls.Signature[Sig, SigFE, PK, PKFE, E, S]
}

// Equal returns true if two PartialSignature instances are equal.
// Two partial signatures are equal if both their message signatures and POP signatures match.
func (ps *PartialSignature[Sig, SigFE, PK, PKFE, E, S]) Equal(other *PartialSignature[Sig, SigFE, PK, PKFE, E, S]) bool <span class="cov0" title="0">{
        if ps == nil || other == nil </span><span class="cov0" title="0">{
                return ps == other
        }</span>
        <span class="cov0" title="0">return ps.SigmaI.Equal(other.SigmaI) &amp;&amp; ps.SigmaPopI.Equal(other.SigmaPopI)</span>
}

// Bytes returns the byte representation of the partial signature.
// It concatenates the message signature bytes with the POP signature bytes (if present).
func (ps *PartialSignature[Sig, SigFE, PK, PKFE, E, S]) Bytes() []byte <span class="cov0" title="0">{
        buf := ps.SigmaI.Bytes()
        if ps.SigmaPopI != nil </span><span class="cov0" title="0">{
                buf = append(buf, ps.SigmaPopI.Bytes()...)
        }</span>
        <span class="cov0" title="0">return buf</span>
}

type (
        // Shard is an alias for tbls.Shard, representing a party's secret share
        // in the Boldyreva threshold BLS signature scheme.
        Shard[
                PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
                SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
                E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
        ] = tbls.Shard[PK, PKFE, SG, SGFE, E, S]

        // PublicMaterial is an alias for tbls.PublicMaterial, containing the public
        // cryptographic material for the Boldyreva threshold BLS scheme.
        PublicMaterial[
                PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
                SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
                E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
        ] = tbls.PublicMaterial[PK, PKFE, SG, SGFE, E, S]
)
</pre>
		
		<pre class="file" id="file367" style="display: none">package keygen

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/signatures/bls"
        "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls"
)

// DKGOutput is an alias for gennaro.DKGOutput, representing the output of a
// distributed key generation protocol suitable for creating Boldyreva threshold BLS shards.
type DKGOutput[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] = gennaro.DKGOutput[PK, S]

// NewShortKeyShard creates a threshold BLS shard for the short key variant from DKG output.
// In the short key variant, public keys are in G1 (smaller) and signatures are in G2 (larger).
// Returns an error if the DKG output is invalid or shard creation fails.
func NewShortKeyShard[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        output *gennaro.DKGOutput[PK, S],
) (*tbls.Shard[PK, PKFE, SG, SGFE, E, S], error) <span class="cov0" title="0">{
        pk, err := bls.NewPublicKey(output.PublicKeyValue())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BLS public key")
        }</span>
        <span class="cov0" title="0">shard, err := tbls.NewShortKeyShard(output.Share(), pk, output.VerificationVector(), output.AccessStructure())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create tBLS short key shard")
        }</span>
        <span class="cov0" title="0">return shard, nil</span>
}

// NewLongKeyShard creates a threshold BLS shard for the long key variant from DKG output.
// In the long key variant, public keys are in G2 (larger) and signatures are in G1 (smaller).
// Returns an error if the DKG output is invalid or shard creation fails.
func NewLongKeyShard[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        output *gennaro.DKGOutput[PK, S],
) (*tbls.Shard[PK, PKFE, SG, SGFE, E, S], error) <span class="cov0" title="0">{
        pk, err := bls.NewPublicKey(output.PublicKeyValue())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BLS public key")
        }</span>
        <span class="cov0" title="0">shard, err := tbls.NewLongKeyShard(output.Share(), pk, output.VerificationVector(), output.AccessStructure())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create tBLS long key shard")
        }</span>
        <span class="cov0" title="0">return shard, nil</span>
}
</pre>
		
		<pre class="file" id="file368" style="display: none">package signing

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/signatures/bls"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02"
)

// Aggregator collects and combines partial BLS signatures from multiple cosigners
// into a single threshold signature. It verifies each partial signature before aggregation.
type Aggregator[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        publicMaterial    *boldyreva02.PublicMaterial[PK, PKFE, SG, SGFE, E, S]
        targetRogueKeyAlg bls.RogueKeyPreventionAlgorithm
        targetDst         string
        scheme            *bls.Scheme[PK, PKFE, SG, SGFE, E, S]
}

// PublicKeyMaterial returns the public cryptographic material used for verification.
// Returns nil if the receiver is nil.
func (A *Aggregator[PK, PKFE, SG, SGFE, E, S]) PublicKeyMaterial() *boldyreva02.PublicMaterial[PK, PKFE, SG, SGFE, E, S] <span class="cov0" title="0">{
        if A == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return A.publicMaterial</span>
}

// NewShortKeyAggregator creates a new Aggregator for the short key variant of BLS signatures.
// In this variant, public keys are in G1 (smaller) and signatures are in G2 (larger).
//
// Parameters:
//   - curveFamily: The pairing-friendly curve family to use
//   - publicMaterial: The public cryptographic material for the threshold scheme
//   - rogueKeyAlg: The rogue key prevention algorithm (Basic, MessageAugmentation, or POP)
//
// Returns an error if any parameter is invalid.
func NewShortKeyAggregator[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        curveFamily curves.PairingFriendlyFamily[P1, FE1, P2, FE2, E, S],
        publicMaterial *boldyreva02.PublicMaterial[P1, FE1, P2, FE2, E, S],
        rogueKeyAlg bls.RogueKeyPreventionAlgorithm,
) (*Aggregator[P1, FE1, P2, FE2, E, S], error) <span class="cov8" title="1">{
        if curveFamily == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("curveFamily is nil")
        }</span>
        <span class="cov8" title="1">if !bls.RogueKeyPreventionAlgorithmIsSupported(rogueKeyAlg) </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("rogue key prevention algorithm %d is not supported", rogueKeyAlg)
        }</span>
        <span class="cov8" title="1">scheme, err := bls.NewShortKeyScheme(curveFamily, bls.POP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BLS short key scheme")
        }</span>
        <span class="cov8" title="1">blsDst, err := scheme.CipherSuite().GetDst(rogueKeyAlg, bls.ShortKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to get BLS destination for rogue key prevention algorithm")
        }</span>
        <span class="cov8" title="1">return &amp;Aggregator[P1, FE1, P2, FE2, E, S]{
                scheme:            scheme,
                targetRogueKeyAlg: rogueKeyAlg,
                targetDst:         blsDst,
                publicMaterial:    publicMaterial,
        }, nil</span>
}

// NewLongKeyAggregator creates a new Aggregator for the long key variant of BLS signatures.
// In this variant, public keys are in G2 (larger) and signatures are in G1 (smaller).
//
// Parameters:
//   - curveFamily: The pairing-friendly curve family to use
//   - publicMaterial: The public cryptographic material for the threshold scheme
//   - rogueKeyAlg: The rogue key prevention algorithm (Basic, MessageAugmentation, or POP)
//
// Returns an error if any parameter is invalid.
func NewLongKeyAggregator[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        curveFamily curves.PairingFriendlyFamily[P1, FE1, P2, FE2, E, S],
        publicMaterial *boldyreva02.PublicMaterial[P2, FE2, P1, FE1, E, S],
        rogueKeyAlg bls.RogueKeyPreventionAlgorithm,
) (*Aggregator[P2, FE2, P1, FE1, E, S], error) <span class="cov8" title="1">{
        if curveFamily == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("curveFamily is nil")
        }</span>
        <span class="cov8" title="1">if !bls.RogueKeyPreventionAlgorithmIsSupported(rogueKeyAlg) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("rogue key prevention algorithm %d is not supported", rogueKeyAlg)
        }</span>
        <span class="cov8" title="1">scheme, err := bls.NewLongKeyScheme(curveFamily, bls.POP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BLS long key scheme")
        }</span>
        <span class="cov8" title="1">blsDst, err := scheme.CipherSuite().GetDst(rogueKeyAlg, bls.LongKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to get BLS destination for rogue key prevention algorithm")
        }</span>
        <span class="cov8" title="1">return &amp;Aggregator[P2, FE2, P1, FE1, E, S]{
                scheme:            scheme,
                targetRogueKeyAlg: rogueKeyAlg,
                targetDst:         blsDst,
                publicMaterial:    publicMaterial,
        }, nil</span>
}

// Aggregate combines partial signatures from multiple cosigners into a single threshold signature.
// It verifies each partial signature against the corresponding partial public key before aggregation.
// For POP algorithm, it also verifies the proof-of-possession signatures.
//
// Parameters:
//   - partialSigs: The collection of partial signatures from cosigners
//   - message: The original message that was signed
//
// Returns the aggregated BLS signature, or an error if verification fails or
// the partial signatures are not from an authorized quorum.
func (A *Aggregator[PK, PKFE, SG, SGFE, E, S]) Aggregate(
        partialSigs network.RoundMessages[*boldyreva02.PartialSignature[SG, SGFE, PK, PKFE, E, S]],
        message []byte,
) (*bls.Signature[SG, SGFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if partialSigs == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("partialSigs is nil")
        }</span>
        <span class="cov8" title="1">if len(message) == 0 </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("message cannot be empty")
        }</span>
        <span class="cov8" title="1">if !A.publicMaterial.AccessStructure().IsAuthorized(partialSigs.Keys()...) </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("partial signatures are not authorized in the access structure")
        }</span>
        <span class="cov8" title="1">partialSignatureVerifier, err := A.scheme.Verifier(bls.VerifyWithCustomDST[PK](A.targetDst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create verifier for partial signature")
        }</span>
        <span class="cov8" title="1">sigShares := feldman.SharesInExponent[SG, S]{}
        popShares := feldman.SharesInExponent[SG, S]{}
        for sender, psig := range partialSigs.Iter() </span><span class="cov8" title="1">{
                partialPublicKey, exists := A.publicMaterial.PartialPublicKeys().Get(sender)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrInvalidArgument.WithMessage("partial public key for sender %d does not exist in public material", sender)
                }</span>
                <span class="cov8" title="1">var err error
                var internalMessage []byte
                switch A.targetRogueKeyAlg </span>{
                case bls.Basic:<span class="cov8" title="1">
                        internalMessage = message</span>
                case bls.MessageAugmentation:<span class="cov8" title="1">
                        internalMessage, err = bls.AugmentMessage(message, A.publicMaterial.PublicKey().Value())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("failed to augment message for sender %d", sender)
                        }</span>
                case bls.POP:<span class="cov8" title="1">
                        internalMessage = message
                        internalPopMessage := A.publicMaterial.PublicKey().Bytes()
                        popDst := A.scheme.CipherSuite().GetPopDst(A.scheme.Variant())
                        popVerifier, err := A.scheme.Verifier(bls.VerifyWithCustomDST[PK](popDst))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("failed to create verifier for POP")
                        }</span>
                        <span class="cov8" title="1">if err := popVerifier.Verify(psig.SigmaPopI, partialPublicKey, internalPopMessage); err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, sender).WithMessage("failed to verify POP signature")
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, ErrInvalidArgument.WithMessage("unsupported rogue key prevention algorithm: %d", A.scheme.RogueKeyPreventionAlgorithm())</span>
                }
                <span class="cov8" title="1">if err := partialSignatureVerifier.Verify(psig.SigmaI, partialPublicKey, internalMessage); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, sender).WithMessage("failed to verify partial signature")
                }</span>
                <span class="cov8" title="1">shareInExponent, err := feldman.NewLiftedShare(sender, psig.SigmaI.Value())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create additive share for sender %d", sender)
                }</span>
                <span class="cov8" title="1">sigShares = append(sigShares, shareInExponent)
                if A.targetRogueKeyAlg == bls.POP </span><span class="cov8" title="1">{
                        popShareInExponent, err := feldman.NewLiftedShare(sender, psig.SigmaPopI.Value())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithMessage("failed to create additive share for POP signature for sender %d", sender)
                        }</span>
                        <span class="cov8" title="1">popShares = append(popShares, popShareInExponent)</span>
                }
        }

        <span class="cov8" title="1">reconstructedSignatureValue, err := sigShares.ReconstructAsAdditive()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to reconstruct signature value from shares")
        }</span>
        <span class="cov8" title="1">var pop *bls.ProofOfPossession[SG, SGFE, PK, PKFE, E, S]
        if A.targetRogueKeyAlg == bls.POP </span><span class="cov8" title="1">{
                reconstructedPopValue, err := popShares.ReconstructAsAdditive()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to reconstruct POP value from shares")
                }</span>
                <span class="cov8" title="1">pop, err = bls.NewProofOfPossession(reconstructedPopValue)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create POP from reconstructed value")
                }</span>
        }
        <span class="cov8" title="1">aggregatedSignature, err := bls.NewSignature(reconstructedSignatureValue, pop)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create signature from reconstructed value")
        }</span>
        <span class="cov8" title="1">return aggregatedSignature, nil</span>
}
</pre>
		
		<pre class="file" id="file369" style="display: none">package signing

import (
        "fmt"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/signatures/bls"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02"
        ts "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const transcriptLabel = "BRON_CRYPTO_TBLS_BOLDYREVA-"

// Cosigner represents a participant in the Boldyreva threshold BLS signing protocol.
// Each cosigner holds a shard of the secret key and can produce partial signatures
// that are later aggregated into a full threshold signature.
type Cosigner[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        sid               network.SID
        shard             *boldyreva02.Shard[PK, PKFE, SG, SGFE, E, S]
        quorum            network.Quorum
        tape              ts.Transcript
        round             network.Round
        targetRogueKeyAlg bls.RogueKeyPreventionAlgorithm
        targetDst         string
        shareAsPrivateKey *bls.PrivateKey[PK, PKFE, SG, SGFE, E, S]
        scheme            *bls.Scheme[PK, PKFE, SG, SGFE, E, S]
}

// SharingID returns the sharing identifier for this cosigner's share.
func (c *Cosigner[PK, PKFE, SG, SGFE, E, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return c.shard.Share().ID()
}</span>

// Quorum returns the set of parties participating in this signing session.
// Returns nil if the receiver is nil.
func (c *Cosigner[PK, PKFE, SG, SGFE, E, S]) Quorum() network.Quorum <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return c.quorum</span>
}

// Shard returns the cosigner's secret shard used for producing partial signatures.
// Returns nil if the receiver is nil.
func (c *Cosigner[PK, PKFE, SG, SGFE, E, S]) Shard() *boldyreva02.Shard[PK, PKFE, SG, SGFE, E, S] <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return c.shard</span>
}

// Variant returns the BLS variant (short key or long key) used by this cosigner.
func (c *Cosigner[PK, PKFE, SG, SGFE, E, S]) Variant() bls.Variant <span class="cov8" title="1">{
        return c.scheme.Variant()
}</span>

// TargetRogueKeyPreventionAlgorithm returns the rogue key prevention algorithm
// (Basic, MessageAugmentation, or POP) used by this cosigner.
func (c *Cosigner[PK, PKFE, SG, SGFE, E, S]) TargetRogueKeyPreventionAlgorithm() bls.RogueKeyPreventionAlgorithm <span class="cov8" title="1">{
        return c.targetRogueKeyAlg
}</span>

// NewShortKeyCosigner creates a new Cosigner for the short key variant of BLS signatures.
// In this variant, public keys are in G1 (smaller) and signatures are in G2 (larger).
//
// Parameters:
//   - sid: Unique session identifier
//   - curveFamily: The pairing-friendly curve family to use
//   - shard: The party's secret shard
//   - quorum: The set of parties participating in signing
//   - rogueKeyAlg: The rogue key prevention algorithm (Basic, MessageAugmentation, or POP)
//   - tape: The transcript for domain separation
//
// Returns an error if any parameter is invalid or the quorum is not authorized.
func NewShortKeyCosigner[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        sid network.SID,
        curveFamily curves.PairingFriendlyFamily[P1, FE1, P2, FE2, E, S],
        shard *boldyreva02.Shard[P1, FE1, P2, FE2, E, S],
        quorum network.Quorum,
        rogueKeyAlg bls.RogueKeyPreventionAlgorithm,
        tape ts.Transcript,
) (*Cosigner[P1, FE1, P2, FE2, E, S], error) <span class="cov8" title="1">{
        if curveFamily == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("curveFamily is nil")
        }</span>
        <span class="cov8" title="1">if tape == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("transcript is nil")
        }</span>
        <span class="cov8" title="1">if shard == nil </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("shard is nil")
        }</span>
        <span class="cov8" title="1">if quorum == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("quorum is nil")
        }</span>
        <span class="cov8" title="1">if !bls.RogueKeyPreventionAlgorithmIsSupported(rogueKeyAlg) </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("rogue key prevention algorithm %d is not supported", rogueKeyAlg)
        }</span>
        <span class="cov8" title="1">if !shard.AccessStructure().IsAuthorized(quorum.List()...) </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("quorum is not authorized in the access structure")
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d-%s-%d-%d", transcriptLabel, sid, curveFamily.Name(), bls.ShortKey, rogueKeyAlg)
        tape.AppendDomainSeparator(dst)
        scheme, err := bls.NewShortKeyScheme(curveFamily, bls.POP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BLS short key scheme")
        }</span>
        <span class="cov8" title="1">shareAsPrivateKey, err := shard.AsBLSPrivateKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert shard to BLS private key")
        }</span>
        <span class="cov8" title="1">blsDst, err := scheme.CipherSuite().GetDst(rogueKeyAlg, bls.ShortKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to get BLS destination for rogue key prevention algorithm")
        }</span>
        <span class="cov8" title="1">return &amp;Cosigner[P1, FE1, P2, FE2, E, S]{
                sid:               sid,
                shard:             shard,
                quorum:            quorum,
                tape:              tape,
                scheme:            scheme,
                targetRogueKeyAlg: rogueKeyAlg,
                targetDst:         blsDst,
                shareAsPrivateKey: shareAsPrivateKey,
                round:             1,
        }, nil</span>
}

// NewLongKeyCosigner creates a new Cosigner for the long key variant of BLS signatures.
// In this variant, public keys are in G2 (larger) and signatures are in G1 (smaller).
//
// Parameters:
//   - sid: Unique session identifier
//   - curveFamily: The pairing-friendly curve family to use
//   - shard: The party's secret shard
//   - quorum: The set of parties participating in signing
//   - rogueKeyAlg: The rogue key prevention algorithm (Basic, MessageAugmentation, or POP)
//   - tape: The transcript for domain separation
//
// Returns an error if any parameter is invalid or the quorum is not authorized.
func NewLongKeyCosigner[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        sid network.SID,
        curveFamily curves.PairingFriendlyFamily[P1, FE1, P2, FE2, E, S],
        shard *boldyreva02.Shard[P2, FE2, P1, FE1, E, S],
        quorum network.Quorum,
        rogueKeyAlg bls.RogueKeyPreventionAlgorithm,
        tape ts.Transcript,
) (*Cosigner[P2, FE2, P1, FE1, E, S], error) <span class="cov8" title="1">{
        if curveFamily == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("curveFamily is nil")
        }</span>
        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("transcript is nil")
        }</span>
        <span class="cov8" title="1">if !shard.AccessStructure().IsAuthorized(quorum.List()...) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("quorum is not authorized in the access structure")
        }</span>
        <span class="cov8" title="1">if !bls.RogueKeyPreventionAlgorithmIsSupported(rogueKeyAlg) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("rogue key prevention algorithm %d is not supported", rogueKeyAlg)
        }</span>
        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d-%s-%d-%d", transcriptLabel, sid, curveFamily.Name(), bls.LongKey, rogueKeyAlg)
        tape.AppendDomainSeparator(dst)
        scheme, err := bls.NewLongKeyScheme(curveFamily, bls.POP)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BLS long key scheme")
        }</span>
        <span class="cov8" title="1">shareAsPrivateKey, err := shard.AsBLSPrivateKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to convert shard to BLS private key")
        }</span>
        <span class="cov8" title="1">blsDst, err := scheme.CipherSuite().GetDst(rogueKeyAlg, bls.LongKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to get BLS destination for rogue key prevention algorithm")
        }</span>
        <span class="cov8" title="1">return &amp;Cosigner[P2, FE2, P1, FE1, E, S]{
                sid:               sid,
                shard:             shard,
                quorum:            quorum,
                tape:              tape,
                scheme:            scheme,
                shareAsPrivateKey: shareAsPrivateKey,
                targetRogueKeyAlg: rogueKeyAlg,
                targetDst:         blsDst,
                round:             1,
        }, nil</span>
}

// ProducePartialSignature generates a partial BLS signature on the given message.
// This method can only be called once per signing session (in round 1).
// The partial signature includes a proof-of-possession if using the POP algorithm.
// Returns an error if called in the wrong round or if signing fails.
func (c *Cosigner[PK, PKFE, SG, SGFE, E, S]) ProducePartialSignature(message []byte) (*boldyreva02.PartialSignature[SG, SGFE, PK, PKFE, E, S], error) <span class="cov8" title="1">{
        if c.round != 1 </span><span class="cov8" title="1">{
                return nil, ErrRound.WithMessage("ProducePartialSignature can only be called in round 1, current round: %d", c.round)
        }</span>
        <span class="cov8" title="1">if len(message) == 0 </span><span class="cov8" title="1">{
                return nil, ErrInvalidArgument.WithMessage("message cannot be empty")
        }</span>
        <span class="cov8" title="1">var err error
        var sigmaPopI *bls.Signature[SG, SGFE, PK, PKFE, E, S]
        switch c.targetRogueKeyAlg </span>{
        case bls.Basic:<span class="cov8" title="1"></span>
        case bls.MessageAugmentation:<span class="cov8" title="1">
                message, err = bls.AugmentMessage(message, c.shard.PublicKey().Value())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to augment message")
                }</span>
        case bls.POP:<span class="cov8" title="1">
                popMsg := c.Shard().PublicKey().Bytes()
                popDst := c.scheme.CipherSuite().GetPopDst(c.Variant())
                popSigner, err := c.scheme.Signer(c.shareAsPrivateKey, bls.SignWithCustomDST[PK](popDst))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create signer for POP")
                }</span>
                <span class="cov8" title="1">sigmaPopI, err = popSigner.Sign(popMsg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to sign POP message")
                }</span>
        default:<span class="cov0" title="0">
                return nil, ErrInvalidArgument.WithMessage("unsupported rogue key prevention algorithm: %d", c.targetRogueKeyAlg)</span>
        }
        <span class="cov8" title="1">signer, err := c.scheme.Signer(c.shareAsPrivateKey, bls.SignWithCustomDST[PK](c.targetDst))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create signer")
        }</span>
        <span class="cov8" title="1">sigmaI, err := signer.Sign(message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to sign message")
        }</span>
        <span class="cov8" title="1">c.round++
        return &amp;boldyreva02.PartialSignature[SG, SGFE, PK, PKFE, E, S]{
                SigmaI:    sigmaI,
                SigmaPopI: sigmaPopI,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file370" style="display: none">package testutils

import (
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/curves/pairable/bls12381"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/signatures/bls"
        "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro"
        gentu "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro/testutils"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02/keygen"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tbls/boldyreva02/signing"
)

// Type aliases for convenience.
type ShortKeyShard = boldyreva02.Shard[*bls12381.PointG1, *bls12381.BaseFieldElementG1, *bls12381.PointG2, *bls12381.BaseFieldElementG2, *bls12381.GtElement, *bls12381.Scalar]
type LongKeyShard = boldyreva02.Shard[*bls12381.PointG2, *bls12381.BaseFieldElementG2, *bls12381.PointG1, *bls12381.BaseFieldElementG1, *bls12381.GtElement, *bls12381.Scalar]

// DoBoldyrevaDKG runs the complete DKG process for Boldyreva02 threshold BLS
// It uses Gennaro DKG under the hood and converts the output to BLS shards.
func DoBoldyrevaDKG[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        tb testing.TB, participants []*gennaro.Participant[PK, S], shortKey bool,
) (
        shards ds.MutableMap[sharing.ID, *tbls.Shard[PK, PKFE, SG, SGFE, E, S]], err error,
) <span class="cov0" title="0">{
        tb.Helper()

        // Run Gennaro DKG
        dkgOutputs, err := gentu.DoGennaroDKG(tb, participants)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to run Gennaro DKG")
        }</span>

        // Convert DKG outputs to BLS shards
        <span class="cov0" title="0">shards = hashmap.NewComparable[sharing.ID, *tbls.Shard[PK, PKFE, SG, SGFE, E, S]]()
        for id, output := range dkgOutputs.Iter() </span><span class="cov0" title="0">{
                var shard *tbls.Shard[PK, PKFE, SG, SGFE, E, S]
                if shortKey </span><span class="cov0" title="0">{
                        shard, err = keygen.NewShortKeyShard(output)
                }</span> else<span class="cov0" title="0"> {
                        shard, err = keygen.NewLongKeyShard(output)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create shard for participant %d", id)
                }</span>
                <span class="cov0" title="0">shards.Put(id, shard)</span>
        }

        <span class="cov0" title="0">return shards, nil</span>
}

// ProducePartialSignatures produces partial signatures from all cosigners.
func ProducePartialSignatures[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        cosigners []*signing.Cosigner[PK, PKFE, SG, SGFE, E, S], message []byte,
) (
        partialSigs map[sharing.ID]*boldyreva02.PartialSignature[SG, SGFE, PK, PKFE, E, S], err error,
) <span class="cov0" title="0">{
        partialSigs = make(map[sharing.ID]*boldyreva02.PartialSignature[SG, SGFE, PK, PKFE, E, S], len(cosigners))
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                partialSigs[cosigner.SharingID()], err = cosigner.ProducePartialSignature(message)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("%d could not produce partial signature", cosigner.SharingID())
                }</span>
        }
        <span class="cov0" title="0">return partialSigs, nil</span>
}

// DoThresholdSign performs the complete threshold signing process.
func DoThresholdSign[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        tb testing.TB,
        cosigners []*signing.Cosigner[PK, PKFE, SG, SGFE, E, S],
        scheme *bls.Scheme[PK, PKFE, SG, SGFE, E, S],
        message []byte,
        aggregator *signing.Aggregator[PK, PKFE, SG, SGFE, E, S],
) (
        signature *bls.Signature[SG, SGFE, PK, PKFE, E, S], err error,
) <span class="cov0" title="0">{
        tb.Helper()

        // Produce partial signatures
        partialSigs, err := ProducePartialSignatures(cosigners, message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not produce partial signatures")
        }</span>

        // Convert map to RoundMessages
        <span class="cov0" title="0">partialSigsMap := hashmap.NewComparable[sharing.ID, *boldyreva02.PartialSignature[SG, SGFE, PK, PKFE, E, S]]()
        for id, psig := range partialSigs </span><span class="cov0" title="0">{
                partialSigsMap.Put(id, psig)
        }</span>
        <span class="cov0" title="0">roundMessages := partialSigsMap.Freeze()

        // Aggregate partial signatures using the provided aggregator
        signature, err = aggregator.Aggregate(roundMessages, message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not aggregate partial signatures")
        }</span>

        <span class="cov0" title="0">return signature, nil</span>
}

// VerifyPartialSignatures verifies all partial signatures.
func VerifyPartialSignatures[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        tb testing.TB,
        partialSigs map[sharing.ID]*boldyreva02.PartialSignature[SG, SGFE, PK, PKFE, E, S],
        publicMaterial *tbls.PublicMaterial[PK, PKFE, SG, SGFE, E, S],
        scheme *bls.Scheme[PK, PKFE, SG, SGFE, E, S],
        message []byte,
) error <span class="cov0" title="0">{
        tb.Helper()

        for id, psig := range partialSigs </span><span class="cov0" title="0">{
                partialPK, exists := publicMaterial.PartialPublicKeys().Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return errs2.New("partial public key for participant %d", id)
                }</span>

                // Determine the message to verify based on rogue key prevention algorithm
                <span class="cov0" title="0">var verifyMessage []byte
                var err error
                switch scheme.RogueKeyPreventionAlgorithm() </span>{
                case bls.Basic:<span class="cov0" title="0">
                        verifyMessage = message</span>
                case bls.MessageAugmentation:<span class="cov0" title="0">
                        verifyMessage, err = bls.AugmentMessage(message, publicMaterial.PublicKey().Value())
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("failed to augment message for participant %d", id)
                        }</span>
                case bls.POP:<span class="cov0" title="0">
                        verifyMessage = message</span>
                }

                // Create verifier
                <span class="cov0" title="0">verifier, err := scheme.Verifier()
                if err != nil </span><span class="cov0" title="0">{
                        return errs2.Wrap(err).WithMessage("failed to create verifier")
                }</span>

                // Verify the partial signature
                <span class="cov0" title="0">if psig.SigmaI != nil </span><span class="cov0" title="0">{
                        if err := verifier.Verify(psig.SigmaI, partialPK, verifyMessage); err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("failed to verify partial signature from participant %d", id)
                        }</span>
                }

                // Verify the proof of possession if present
                <span class="cov0" title="0">if scheme.RogueKeyPreventionAlgorithm() == bls.POP &amp;&amp; psig.SigmaPopI != nil </span><span class="cov0" title="0">{
                        popMessage := partialPK.Bytes()
                        popDst := scheme.CipherSuite().GetPopDst(scheme.Variant())
                        popVerifier, err := scheme.Verifier(bls.VerifyWithCustomDST[PK](popDst))
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("failed to create POP verifier")
                        }</span>
                        <span class="cov0" title="0">if err := popVerifier.Verify(psig.SigmaPopI, partialPK, popMessage); err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("failed to verify proof of possession from participant %d", id)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file371" style="display: none">package tbls

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/signatures/bls"
        "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
)

// PublicMaterial contains the public cryptographic material for a threshold BLS signature scheme.
// It holds the combined public key, the access structure defining the threshold parameters,
// the Feldman verification vector, and the partial public keys for each party.
// The type parameters support pairing-friendly curves where PK is the public key group
// and SG is the signature group.
type PublicMaterial[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        publicKey         *bls.PublicKey[PK, PKFE, SG, SGFE, E, S]
        accessStructure   *sharing.ThresholdAccessStructure
        fv                *feldman.VerificationVector[PK, S]
        partialPublicKeys ds.Map[sharing.ID, *bls.PublicKey[PK, PKFE, SG, SGFE, E, S]]
}

// PublicKey returns the combined BLS public key for the threshold scheme.
// Returns nil if the receiver is nil.
func (spm *PublicMaterial[PK, PKFE, SG, SGFE, E, S]) PublicKey() *bls.PublicKey[PK, PKFE, SG, SGFE, E, S] <span class="cov0" title="0">{
        if spm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return spm.publicKey</span>
}

// AccessStructure returns the threshold access structure defining which subsets of parties
// are authorized to produce valid signatures. Returns nil if the receiver is nil.
func (spm *PublicMaterial[PK, PKFE, SG, SGFE, E, S]) AccessStructure() *sharing.ThresholdAccessStructure <span class="cov0" title="0">{
        if spm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return spm.accessStructure</span>
}

// PartialPublicKeys returns the map of partial public keys indexed by party ID.
// Each partial public key can be used to verify partial signatures from the corresponding party.
// Returns nil if the receiver is nil.
func (spm *PublicMaterial[PK, PKFE, SG, SGFE, E, S]) PartialPublicKeys() ds.Map[sharing.ID, *bls.PublicKey[PK, PKFE, SG, SGFE, E, S]] <span class="cov0" title="0">{
        if spm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return spm.partialPublicKeys</span>
}

// VerificationVector returns the Feldman verification vector used to verify
// that parties hold valid shares of the secret key. Returns nil if the receiver is nil.
func (spm *PublicMaterial[PK, PKFE, SG, SGFE, E, S]) VerificationVector() *feldman.VerificationVector[PK, S] <span class="cov0" title="0">{
        if spm == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return spm.fv</span>
}

// Equal returns true if two PublicMaterial instances are equal.
// Two instances are equal if they have the same access structure, public key,
// and identical partial public keys for all parties.
func (spm *PublicMaterial[PK, PKFE, SG, SGFE, E, S]) Equal(other *PublicMaterial[PK, PKFE, SG, SGFE, E, S]) bool <span class="cov0" title="0">{
        if spm == nil || other == nil </span><span class="cov0" title="0">{
                return spm == other
        }</span>
        <span class="cov0" title="0">if !spm.accessStructure.Equal(other.accessStructure) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !spm.publicKey.Equal(other.publicKey) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if spm.partialPublicKeys.Size() != other.partialPublicKeys.Size() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for id, pk := range spm.partialPublicKeys.Iter() </span><span class="cov0" title="0">{
                otherPk, exists := other.partialPublicKeys.Get(id)
                if !exists || !pk.Equal(otherPk) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// HashCode returns a hash code for the public material, derived from the public key.
// Returns 0 if the receiver is nil.
func (spm *PublicMaterial[PK, PKFE, SG, SGFE, E, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        if spm == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return spm.publicKey.HashCode()</span>
}

// Shard represents a party's secret share in a threshold BLS signature scheme.
// It embeds PublicMaterial and additionally contains the party's private Feldman share,
// which is used to produce partial signatures. Shards should be kept secret by their owners.
type Shard[
        PK curves.PairingFriendlyPoint[PK, PKFE, SG, SGFE, E, S], PKFE algebra.FieldElement[PKFE],
        SG curves.PairingFriendlyPoint[SG, SGFE, PK, PKFE, E, S], SGFE algebra.FieldElement[SGFE],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
] struct {
        PublicMaterial[PK, PKFE, SG, SGFE, E, S]

        share *feldman.Share[S]
}

// Share returns the party's Feldman share of the secret key.
// This share is used to compute partial signatures. Returns nil if the receiver is nil.
func (s *Shard[PK, PKFE, SG, SGFE, E, S]) Share() *feldman.Share[S] <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s.share</span>
}

// Equal returns true if two Shard instances are equal.
// Two shards are equal if they have the same share and public material.
func (s *Shard[PK, PKFE, SG, SGFE, E, S]) Equal(other *Shard[PK, PKFE, SG, SGFE, E, S]) bool <span class="cov0" title="0">{
        if s == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return s == other
        }</span>
        <span class="cov0" title="0">return (s.share.Equal(other.share) &amp;&amp;
                s.PublicMaterial.Equal(&amp;other.PublicMaterial))</span>
}

// PublicKeyMaterial extracts and returns a copy of the public material from the shard.
// The returned PublicMaterial can be safely shared with other parties.
// Returns nil if the receiver is nil.
func (s *Shard[PK, PKFE, SG, SGFE, E, S]) PublicKeyMaterial() *PublicMaterial[PK, PKFE, SG, SGFE, E, S] <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;PublicMaterial[PK, PKFE, SG, SGFE, E, S]{
                publicKey:         s.publicKey.Clone(),
                accessStructure:   s.accessStructure.Clone(),
                fv:                s.fv,
                partialPublicKeys: s.partialPublicKeys.Clone(),
        }</span>
}

// HashCode returns a hash code for the shard, derived from both the share and public key.
// Returns 0 if the receiver is nil.
func (s *Shard[PK, PKFE, SG, SGFE, E, S]) HashCode() base.HashCode <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return s.share.HashCode() ^ s.publicKey.HashCode()</span>
}

// AsBLSPrivateKey converts the shard to a BLS private key.
// This is useful for signing operations where the shard holder can produce partial signatures.
// Returns an error if the shard is nil or if the private key creation fails.
func (s *Shard[PK, PKFE, SG, SGFE, E, S]) AsBLSPrivateKey() (*bls.PrivateKey[PK, PKFE, SG, SGFE, E, S], error) <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("Shard is nil")
        }</span>
        <span class="cov0" title="0">out, err := bls.NewPrivateKey(s.publicKey.Group(), s.share.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create BLS private key from shard")
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// NewShortKeyShard creates a new Shard for the short key variant of BLS signatures.
// In the short key variant, public keys are in G1 (shorter) and signatures are in G2 (longer).
// This provides smaller public keys at the cost of larger signatures.
//
// Parameters:
//   - share: The party's Feldman share of the secret key
//   - publicKey: The combined BLS public key (must be a short key variant)
//   - vector: The Feldman verification vector
//   - accessStructure: The threshold access structure
//
// Returns an error if any parameter is nil, if the public key is not a short variant,
// or if partial public key computation fails.
func NewShortKeyShard[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](

        share *feldman.Share[S],
        publicKey *bls.PublicKey[P1, FE1, P2, FE2, E, S],
        vector feldman.VerificationVector[P1, S],
        accessStructure *sharing.ThresholdAccessStructure,
) (*Shard[P1, FE1, P2, FE2, E, S], error) <span class="cov0" title="0">{
        if share == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("share")
        }</span>
        <span class="cov0" title="0">if publicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("publicKey")
        }</span>
        <span class="cov0" title="0">if accessStructure == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("accessStructure")
        }</span>
        <span class="cov0" title="0">if vector == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("verification vector")
        }</span>
        <span class="cov0" title="0">if !publicKey.IsShort() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key is not a short key variant")
        }</span>
        <span class="cov0" title="0">sf, ok := share.Value().Structure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("share value structure is not a prime field")
        }</span>
        <span class="cov0" title="0">partialPublicKeyValues, err := gennaro.ComputePartialPublicKey(sf, share, vector, accessStructure)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compute partial public keys from share")
        }</span>
        <span class="cov0" title="0">partialPublicKeys := hashmap.NewComparable[sharing.ID, *bls.PublicKey[P1, FE1, P2, FE2, E, S]]()
        for id, value := range partialPublicKeyValues.Iter() </span><span class="cov0" title="0">{
                pk, err := bls.NewPublicKey(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create public key for party %d", id)
                }</span>
                <span class="cov0" title="0">partialPublicKeys.Put(id, pk)</span>
        }
        <span class="cov0" title="0">return &amp;Shard[P1, FE1, P2, FE2, E, S]{
                share: share,
                PublicMaterial: PublicMaterial[P1, FE1, P2, FE2, E, S]{
                        publicKey:         publicKey,
                        accessStructure:   accessStructure,
                        fv:                &amp;vector,
                        partialPublicKeys: partialPublicKeys.Freeze(),
                },
        }, nil</span>
}

// NewLongKeyShard creates a new Shard for the long key variant of BLS signatures.
// In the long key variant, public keys are in G2 (longer) and signatures are in G1 (shorter).
// This provides smaller signatures at the cost of larger public keys.
//
// Parameters:
//   - share: The party's Feldman share of the secret key
//   - publicKey: The combined BLS public key (must be a long key variant)
//   - vector: The Feldman verification vector
//   - accessStructure: The threshold access structure
//
// Returns an error if any parameter is nil, if the public key is not a long variant,
// or if partial public key computation fails.
func NewLongKeyShard[
        P1 curves.PairingFriendlyPoint[P1, FE1, P2, FE2, E, S], FE1 algebra.FieldElement[FE1],
        P2 curves.PairingFriendlyPoint[P2, FE2, P1, FE1, E, S], FE2 algebra.FieldElement[FE2],
        E algebra.MultiplicativeGroupElement[E], S algebra.PrimeFieldElement[S],
](
        share *feldman.Share[S],
        publicKey *bls.PublicKey[P2, FE2, P1, FE1, E, S],
        vector feldman.VerificationVector[P2, S],
        accessStructure *sharing.ThresholdAccessStructure,
) (*Shard[P2, FE2, P1, FE1, E, S], error) <span class="cov0" title="0">{
        if share == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("share")
        }</span>
        <span class="cov0" title="0">if publicKey == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("publicKey")
        }</span>
        <span class="cov0" title="0">if accessStructure == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("accessStructure")
        }</span>
        <span class="cov0" title="0">if vector == nil </span><span class="cov0" title="0">{
                return nil, ErrIsNil.WithMessage("verification vector")
        }</span>
        <span class="cov0" title="0">if publicKey.IsShort() </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("public key is not a long key variant")
        }</span>
        <span class="cov0" title="0">sf, ok := share.Value().Structure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("share value structure is not a prime field")
        }</span>
        <span class="cov0" title="0">partialPublicKeyValues, err := gennaro.ComputePartialPublicKey(sf, share, vector, accessStructure)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compute partial public keys from share")
        }</span>
        <span class="cov0" title="0">partialPublicKeys := hashmap.NewComparable[sharing.ID, *bls.PublicKey[P2, FE2, P1, FE1, E, S]]()
        for id, value := range partialPublicKeyValues.Iter() </span><span class="cov0" title="0">{
                pk, err := bls.NewPublicKey(value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create public key for party %d", id)
                }</span>
                <span class="cov0" title="0">partialPublicKeys.Put(id, pk)</span>
        }
        <span class="cov0" title="0">return &amp;Shard[P2, FE2, P1, FE1, E, S]{
                share: share,
                PublicMaterial: PublicMaterial[P2, FE2, P1, FE1, E, S]{
                        publicKey:         publicKey,
                        accessStructure:   accessStructure,
                        fv:                &amp;vector,
                        partialPublicKeys: partialPublicKeys.Freeze(),
                },
        }, nil</span>
}

var (
        ErrIsNil           = errs2.New("is nil")
        ErrInvalidArgument = errs2.New("invalid argument")
)
</pre>
		
		<pre class="file" id="file372" style="display: none">package dkls23

import (
        crand "crypto/rand"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
)

// PartialSignature holds a partial ECDSA signature.
type PartialSignature[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        r P
        u S
        w S
}

// NewPartialSignature returns a new partial signature.
func NewPartialSignature[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](r P, u, w S) (*PartialSignature[P, B, S], error) <span class="cov0" title="0">{
        if r.IsOpIdentity() || u.IsZero() </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid arguments")
        }</span>

        <span class="cov0" title="0">ps := &amp;PartialSignature[P, B, S]{
                r,
                u,
                w,
        }
        return ps, nil</span>
}

// Aggregate computes the sum of partial signatures to get a valid signature. It also normalises the signature to the low-s form as well as attaches the recovery id to the final signature.
func Aggregate[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](suite *ecdsa.Suite[P, B, S], publicKey *ecdsa.PublicKey[P, B, S], message []byte, partialSignatures ...*PartialSignature[P, B, S]) (*ecdsa.Signature[S], error) <span class="cov0" title="0">{
        w := suite.ScalarField().Zero()
        u := suite.ScalarField().Zero()

        r := partialSignatures[0].r
        for i, partialSignature := range partialSignatures </span><span class="cov0" title="0">{
                w = w.Add(partialSignature.w)
                u = u.Add(partialSignature.u)

                if !partialSignature.r.Equal(r) </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("partial signature mismatch between indices 0 and %d", i)
                }</span>
        }

        <span class="cov0" title="0">uInv, err := u.TryInv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute w/u")
        }</span>
        <span class="cov0" title="0">s := w.Mul(uInv)

        rxi, err := r.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute affine x")
        }</span>
        <span class="cov0" title="0">rx, err := suite.ScalarField().FromWideBytes(rxi.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert to scalar")
        }</span>

        <span class="cov0" title="0">v, err := ecdsa.ComputeRecoveryID(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not compute recovery id")
        }</span>

        <span class="cov0" title="0">signature, err := ecdsa.NewSignature(rx, s, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create signature")
        }</span>
        <span class="cov0" title="0">signature.Normalise()

        scheme, err := ecdsa.NewScheme(suite, crand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create scheme")
        }</span>
        <span class="cov0" title="0">verifier, err := scheme.Verifier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create verifier")
        }</span>
        <span class="cov0" title="0">if err := verifier.Verify(signature, publicKey, message); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("signature is invalid")
        }</span>

        <span class="cov0" title="0">return signature, nil</span>
}
</pre>
		
		<pre class="file" id="file373" style="display: none">package dkg

import (
        "crypto/sha256"
        "encoding/binary"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
        "github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        przsSetup "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs/setup"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel = "BRON_CRYPTO_DKLS23_DKG-"
        vsotLabel       = "BRON_CRYPTO_DKLS23_DKG_VSOT-"
)

// Participant represents a DKG participant.
type Participant[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        sessionID network.SID
        baseShard *tecdsa.Shard[P, B, S]
        tape      transcripts.Transcript
        prng      io.Reader
        round     network.Round

        zeroSetup       *przsSetup.Participant
        baseOTSenders   map[sharing.ID]*vsot.Sender[P, B, S]
        baseOTReceivers map[sharing.ID]*vsot.Receiver[P, B, S]
        state           state[P, B, S]
}

type state[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        senderSeeds   ds.MutableMap[sharing.ID, *vsot.SenderOutput]
        receiverSeeds ds.MutableMap[sharing.ID, *vsot.ReceiverOutput]
        zeroSeeds     przs.Seeds
}

// NewParticipant returns a new participant.
func NewParticipant[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, sharingID sharing.ID, baseShard *tecdsa.Shard[P, B, S], tape transcripts.Transcript, prng io.Reader) (*Participant[P, B, S], error) <span class="cov8" title="1">{
        if baseShard == nil || tape == nil || prng == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("argument")
        }</span>
        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s%s", transcriptLabel, sessionID))

        zeroSetup, err := przsSetup.NewParticipant(sessionID, sharingID, baseShard.AccessStructure().Shareholders(), tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("error creating zero setup for participant")
        }</span>

        <span class="cov8" title="1">curve := algebra.StructureMustBeAs[ecdsa.Curve[P, B, S]](baseShard.PublicKey().Value().Structure())
        otSuite, err := vsot.NewSuite(softspoken.Kappa, 1, curve, sha256.New)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("error creating vsot suite for participant")
        }</span>
        <span class="cov8" title="1">otSenders := make(map[sharing.ID]*vsot.Sender[P, B, S])
        otReceivers := make(map[sharing.ID]*vsot.Receiver[P, B, S])
        for id := range baseShard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">otTape := tape.Clone()
                otTape.AppendBytes(vsotLabel, binary.LittleEndian.AppendUint64(nil, uint64(sharingID)), binary.LittleEndian.AppendUint64(nil, uint64(id)))
                otSender, err := vsot.NewSender(sessionID, otSuite, otTape, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("error creating vsot sender")
                }</span>

                <span class="cov8" title="1">otTape = tape.Clone()
                otTape.AppendBytes(vsotLabel, binary.LittleEndian.AppendUint64(nil, uint64(id)), binary.LittleEndian.AppendUint64(nil, uint64(sharingID)))
                otReceiver, err := vsot.NewReceiver(sessionID, otSuite, otTape, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("error creating vsot receiver")
                }</span>

                <span class="cov8" title="1">otSenders[id] = otSender
                otReceivers[id] = otReceiver</span>
        }

        //nolint:exhaustruct // lazy initialisation
        <span class="cov8" title="1">p := &amp;Participant[P, B, S]{
                sessionID:       sessionID,
                baseShard:       baseShard,
                tape:            tape,
                prng:            prng,
                round:           1,
                zeroSetup:       zeroSetup,
                baseOTSenders:   otSenders,
                baseOTReceivers: otReceivers,
        }
        return p, nil</span>
}

// SharingID returns the participant sharing identifier.
func (p *Participant[P, B, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return p.baseShard.Share().ID()
}</span>
</pre>
		
		<pre class="file" id="file374" style="display: none">package dkg

import (
        "io"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
        "github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        przsSetup "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs/setup"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
)

// Round1 executes protocol round 1.
func (p *Participant[P, B, S]) Round1() (*Round1Broadcast[P, B, S], ds.Map[sharing.ID, *Round1P2P[P, B, S]], error) <span class="cov8" title="1">{
        zeroR1b, err := p.zeroSetup.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run round 1 of Gennaro DKG party")
        }</span>

        <span class="cov8" title="1">r1b := &amp;Round1Broadcast[P, B, S]{
                ZeroR1: zeroR1b,
        }
        r1u := hashmap.NewComparable[sharing.ID, *Round1P2P[P, B, S]]()
        for id, u := range outgoingP2PMessages(p, r1u) </span><span class="cov8" title="1">{
                var err error
                u.OtR1, err = p.baseOTSenders[id].Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run round 1 of VSOT party")
                }</span>
        }

        <span class="cov8" title="1">p.round++
        return r1b, r1u.Freeze(), nil</span>
}

// Round2 executes protocol round 2.
func (p *Participant[P, B, S]) Round2(r1b network.RoundMessages[*Round1Broadcast[P, B, S]], r1u network.RoundMessages[*Round1P2P[P, B, S]]) (network.RoundMessages[*Round2P2P[P, B, S]], error) <span class="cov8" title="1">{
        zeroR1 := hashmap.NewComparable[sharing.ID, *przsSetup.Round1Broadcast]()
        otR1 := hashmap.NewComparable[sharing.ID, *vsot.Round1P2P[P, B, S]]()
        in, err := incomingMessages(p, 2, r1b, r1u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid messages or round mismatch")
        }</span>
        <span class="cov8" title="1">for id, m := range in </span><span class="cov8" title="1">{
                zeroR1.Put(id, m.broadcast.ZeroR1)
                otR1.Put(id, m.p2p.OtR1)
        }</span>

        <span class="cov8" title="1">zeroR2u, err := p.zeroSetup.Round2(zeroR1.Freeze())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 2 of PRZS setup party")
        }</span>

        <span class="cov8" title="1">p.state.receiverSeeds = hashmap.NewComparable[sharing.ID, *vsot.ReceiverOutput]()
        r2u := hashmap.NewComparable[sharing.ID, *Round2P2P[P, B, S]]()
        for id, u := range outgoingP2PMessages(p, r2u) </span><span class="cov8" title="1">{
                var ok bool
                var err error
                var seed *vsot.ReceiverOutput

                u.ZeroR2, ok = zeroR2u.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("cannot run round 2 of PRZS setup party")
                }</span>
                <span class="cov8" title="1">otR1u, ok := otR1.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("cannot run round 2 of VSOT setup party")
                }</span>
                <span class="cov8" title="1">choices := make([]byte, (softspoken.Kappa+7)/8)
                _, err = io.ReadFull(p.prng, choices)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot sample choices")
                }</span>
                <span class="cov8" title="1">u.OtR2, seed, err = p.baseOTReceivers[id].Round2(otR1u, choices)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 2 of VSOT party")
                }</span>
                <span class="cov8" title="1">p.state.receiverSeeds.Put(id, seed)</span>
        }

        <span class="cov8" title="1">p.round++
        return r2u.Freeze(), nil</span>
}

// Round3 executes protocol round 3.
func (p *Participant[P, B, S]) Round3(r2u network.RoundMessages[*Round2P2P[P, B, S]]) (network.RoundMessages[*Round3P2P], error) <span class="cov8" title="1">{
        zeroR2u := hashmap.NewComparable[sharing.ID, *przsSetup.Round2P2P]()
        otR2u := hashmap.NewComparable[sharing.ID, *vsot.Round2P2P[P, B, S]]()
        in, err := incomingP2PMessages(p, 3, r2u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid messages or round mismatch")
        }</span>
        <span class="cov8" title="1">for id, m := range in </span><span class="cov8" title="1">{
                zeroR2u.Put(id, m.ZeroR2)
                otR2u.Put(id, m.OtR2)
        }</span>

        <span class="cov8" title="1">p.state.zeroSeeds, err = p.zeroSetup.Round3(zeroR2u.Freeze())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot run round 3 of PRZS setup party")
        }</span>

        <span class="cov8" title="1">p.state.senderSeeds = hashmap.NewComparable[sharing.ID, *vsot.SenderOutput]()
        r3u := hashmap.NewComparable[sharing.ID, *Round3P2P]()
        for id, u := range outgoingP2PMessages(p, r3u) </span><span class="cov8" title="1">{
                otR2, ok := otR2u.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("cannot run round 3 of VSOT party")
                }</span>
                <span class="cov8" title="1">var seed *vsot.SenderOutput
                u.OtR3, seed, err = p.baseOTSenders[id].Round3(otR2)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 3 of VSOT party")
                }</span>
                <span class="cov8" title="1">p.state.senderSeeds.Put(id, seed)</span>
        }

        <span class="cov8" title="1">p.round++
        return r3u.Freeze(), nil</span>
}

// Round4 executes protocol round 4.
func (p *Participant[P, B, S]) Round4(r3u network.RoundMessages[*Round3P2P]) (network.RoundMessages[*Round4P2P], error) <span class="cov8" title="1">{
        otR3u := hashmap.NewComparable[sharing.ID, *vsot.Round3P2P]()
        in, err := incomingP2PMessages(p, 4, r3u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid messages or round mismatch")
        }</span>
        <span class="cov8" title="1">for id, p2p := range in </span><span class="cov8" title="1">{
                otR3u.Put(id, p2p.OtR3)
        }</span>

        <span class="cov8" title="1">r4u := hashmap.NewComparable[sharing.ID, *Round4P2P]()
        for id, u := range outgoingP2PMessages(p, r4u) </span><span class="cov8" title="1">{
                otR3, ok := otR3u.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("cannot run round 4 of VSOT party")
                }</span>
                <span class="cov8" title="1">var err error
                u.OtR4, err = p.baseOTReceivers[id].Round4(otR3)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 4 of VSOT party")
                }</span>
        }

        <span class="cov8" title="1">p.round++
        return r4u.Freeze(), nil</span>
}

// Round5 executes protocol round 5.
func (p *Participant[P, B, S]) Round5(r4u network.RoundMessages[*Round4P2P]) (network.RoundMessages[*Round5P2P], error) <span class="cov8" title="1">{
        otR4u := hashmap.NewComparable[sharing.ID, *vsot.Round4P2P]()
        in, err := incomingP2PMessages(p, 5, r4u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid messages or round mismatch")
        }</span>
        <span class="cov8" title="1">for id, p2p := range in </span><span class="cov8" title="1">{
                otR4u.Put(id, p2p.OtR4)
        }</span>

        <span class="cov8" title="1">r5u := hashmap.NewComparable[sharing.ID, *Round5P2P]()
        for id, u := range outgoingP2PMessages(p, r5u) </span><span class="cov8" title="1">{
                otR4, ok := otR4u.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("cannot run round 5 of VSOT party")
                }</span>
                <span class="cov8" title="1">var err error
                u.OtR5, err = p.baseOTSenders[id].Round5(otR4)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 5 of VSOT part")
                }</span>
        }

        <span class="cov8" title="1">p.round++
        return r5u.Freeze(), nil</span>
}

// Round6 executes protocol round 6.
func (p *Participant[P, B, S]) Round6(r5u network.RoundMessages[*Round5P2P]) (*dkls23.Shard[P, B, S], error) <span class="cov8" title="1">{
        in, err := incomingP2PMessages(p, 6, r5u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid messages or round mismatch")
        }</span>
        <span class="cov8" title="1">for id, p2p := range in </span><span class="cov8" title="1">{
                err := p.baseOTReceivers[id].Round6(p2p.OtR5)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 6 of VSOT party")
                }</span>
        }

        <span class="cov8" title="1">auxInfo, err := dkls23.NewAuxiliaryInfo(p.state.zeroSeeds, p.state.senderSeeds.Freeze(), p.state.receiverSeeds.Freeze())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create auxiliary info")
        }</span>
        <span class="cov8" title="1">shard, err := dkls23.NewShard(p.baseShard, auxInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create tECDSA DKLSS23 shard")
        }</span>

        <span class="cov8" title="1">p.round++
        return shard, nil</span>
}
</pre>
		
		<pre class="file" id="file375" style="display: none">package testutils

import (
        "bytes"
        crand "crypto/rand"
        "encoding/hex"
        "io"
        "maps"
        "slices"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/maputils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        ntu "github.com/bronlabs/bron-crypto/pkg/network/testutils"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fiatshamir"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro"
        gennaroTU "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro/testutils"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/keygen/dkg"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid"
        "github.com/stretchr/testify/require"
)

func RunDKLs23DKG[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](tb testing.TB, curve ecdsa.Curve[P, B, S], accessStructure *sharing.ThresholdAccessStructure) map[sharing.ID]*dkls23.Shard[P, B, S] <span class="cov0" title="0">{
        tb.Helper()

        prng := crand.Reader
        var sessionID network.SID
        _, err := io.ReadFull(prng, sessionID[:])
        require.NoError(tb, err)

        tape := hagrid.NewTranscript(hex.EncodeToString(sessionID[:]))
        tapesMap := make(map[sharing.ID]transcripts.Transcript)

        ids := slices.Collect(accessStructure.Shareholders().Iter())
        gennaroDkgParticipants := make([]*gennaro.Participant[P, S], accessStructure.Shareholders().Size())
        for i, id := range ids </span><span class="cov0" title="0">{
                tapesMap[id] = tape.Clone()
                gennaroDkgParticipants[i], err = gennaro.NewParticipant(sessionID, curve, id, accessStructure, fiatshamir.Name, tapesMap[id], prng)
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">dkgOutputs, err := gennaroTU.DoGennaroDKG(tb, gennaroDkgParticipants)
        require.NoError(tb, err)

        dkgParticipantsMap := make(map[sharing.ID]*dkg.Participant[P, B, S])
        for id := range accessStructure.Shareholders().Iter() </span><span class="cov0" title="0">{
                dkgOutput, ok := dkgOutputs.Get(id)
                require.True(tb, ok)
                ecdsaShard, err := tecdsa.NewShard(dkgOutput.Share(), dkgOutput.VerificationVector(), accessStructure)
                require.NoError(tb, err)

                dkgParticipantsMap[id], err = dkg.NewParticipant(sessionID, id, ecdsaShard, tapesMap[id], prng)
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">dkgParticipants := slices.Collect(maps.Values(dkgParticipantsMap))

        r1bo := make(map[sharing.ID]*dkg.Round1Broadcast[P, B, S])
        r1uo := make(map[sharing.ID]network.RoundMessages[*dkg.Round1P2P[P, B, S]])
        for _, party := range dkgParticipants </span><span class="cov0" title="0">{
                r1bo[party.SharingID()], r1uo[party.SharingID()], err = party.Round1()
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r2bi, r2ui := ntu.MapO2I(tb, dkgParticipants, r1bo, r1uo)
        r2uo := make(map[sharing.ID]network.RoundMessages[*dkg.Round2P2P[P, B, S]])
        for _, party := range dkgParticipants </span><span class="cov0" title="0">{
                r2uo[party.SharingID()], err = party.Round2(r2bi[party.SharingID()], r2ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r3ui := ntu.MapUnicastO2I(tb, dkgParticipants, r2uo)
        r3uo := make(map[sharing.ID]network.RoundMessages[*dkg.Round3P2P])
        for _, party := range dkgParticipants </span><span class="cov0" title="0">{
                r3uo[party.SharingID()], err = party.Round3(r3ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r4ui := ntu.MapUnicastO2I(tb, dkgParticipants, r3uo)
        r4uo := make(map[sharing.ID]network.RoundMessages[*dkg.Round4P2P])
        for _, party := range dkgParticipants </span><span class="cov0" title="0">{
                r4uo[party.SharingID()], err = party.Round4(r4ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r5ui := ntu.MapUnicastO2I(tb, dkgParticipants, r4uo)
        r5uo := make(map[sharing.ID]network.RoundMessages[*dkg.Round5P2P])
        for _, party := range dkgParticipants </span><span class="cov0" title="0">{
                r5uo[party.SharingID()], err = party.Round5(r5ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r6ui := ntu.MapUnicastO2I(tb, dkgParticipants, r5uo)
        shards := make(map[sharing.ID]*dkls23.Shard[P, B, S])
        for _, party := range dkgParticipants </span><span class="cov0" title="0">{
                shards[party.SharingID()], err = party.Round6(r6ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        // transcripts match
        <span class="cov0" title="0">transcriptsBytes := make(map[sharing.ID][]byte)
        for id, tape := range tapesMap </span><span class="cov0" title="0">{
                var err error
                transcriptsBytes[id], err = tape.ExtractBytes("test", 32)
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">transcriptBytesSlice := slices.Collect(maps.Values(transcriptsBytes))
        require.True(tb, sliceutils.All(transcriptBytesSlice, func(b []byte) bool </span><span class="cov0" title="0">{ return bytes.Equal(transcriptBytesSlice[0], b) }</span>))

        // public keys match
        <span class="cov0" title="0">publicKeys := slices.Collect(maps.Values(maputils.MapValues(shards, func(_ sharing.ID, s *dkls23.Shard[P, B, S]) P </span><span class="cov0" title="0">{ return s.PublicKey().Value() }</span>)))
        <span class="cov0" title="0">for i := 1; i &lt; accessStructure.Shareholders().Size(); i++ </span><span class="cov0" title="0">{
                require.True(tb, publicKeys[0].Equal(publicKeys[i]))
        }</span>

        // secret shares match
        <span class="cov0" title="0">for th := accessStructure.Threshold(); th &lt;= uint(accessStructure.Shareholders().Size()); th++ </span><span class="cov0" title="0">{
                for shardsSubset := range sliceutils.Combinations(slices.Collect(maps.Values(shards)), th) </span><span class="cov0" title="0">{
                        feldmanScheme, err := feldman.NewScheme(curve.Generator(), accessStructure.Threshold(), accessStructure.Shareholders())
                        require.NoError(tb, err)
                        sharesSubset := sliceutils.Map(shardsSubset, func(s *dkls23.Shard[P, B, S]) *feldman.Share[S] </span><span class="cov0" title="0">{
                                return s.Share()
                        }</span>)
                        <span class="cov0" title="0">recoveredSk, err := feldmanScheme.Reconstruct(sharesSubset...)
                        require.NoError(tb, err)

                        recoveredPk := curve.ScalarBaseMul(recoveredSk.Value())
                        require.True(tb, recoveredPk.Equal(publicKeys[0]))</span>
                }
        }

        <span class="cov0" title="0">return shards</span>
}
</pre>
		
		<pre class="file" id="file376" style="display: none">package dkg

import (
        "iter"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

type message[B network.Message, U network.Message] struct {
        broadcast B
        p2p       U
}

func incomingMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], MB network.Message, MU network.Message](p *Participant[P, B, S], rIn network.Round, bIn network.RoundMessages[MB], uIn network.RoundMessages[MU]) (iter.Seq2[sharing.ID, message[MB, MU]], error) <span class="cov8" title="1">{
        if rIn != p.round </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">return func(yield func(p sharing.ID, m message[MB, MU]) bool) </span><span class="cov8" title="1">{
                for id := range p.baseShard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                        if id == p.baseShard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">b, ok := bIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing broadcast message")</span>
                        }

                        <span class="cov8" title="1">u, ok := uIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing unicast message")</span>
                        }
                        <span class="cov8" title="1">if !yield(id, message[MB, MU]{broadcast: b, p2p: u}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }, nil
}

func incomingP2PMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], MU network.Message](p *Participant[P, B, S], rIn network.Round, uIn network.RoundMessages[MU]) (iter.Seq2[sharing.ID, MU], error) <span class="cov8" title="1">{
        if rIn != p.round </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">return func(yield func(p sharing.ID, m MU) bool) </span><span class="cov8" title="1">{
                for id := range p.baseShard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                        if id == p.baseShard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">u, ok := uIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing unicast message")</span>
                        }
                        <span class="cov8" title="1">if !yield(id, u) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }, nil
}

type messagePointerConstraint[MP network.Message, M any] interface {
        *M
        network.Message
}

func outgoingP2PMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], UPtr messagePointerConstraint[UPtr, U], U any](p *Participant[P, B, S], uOut ds.MutableMap[sharing.ID, UPtr]) iter.Seq2[sharing.ID, UPtr] <span class="cov8" title="1">{
        return func(yield func(p sharing.ID, out UPtr) bool) </span><span class="cov8" title="1">{
                for id := range p.baseShard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                        if id == p.baseShard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">u := new(U)
                        if !yield(id, UPtr(u)) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">uOut.Put(id, UPtr(u))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file377" style="display: none">package trusted_dealer

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
        "github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
)

// DealRandom deals random shares from a trusted dealer.
func DealRandom[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](curve ecdsa.Curve[P, B, S], threshold uint, shareholder ds.Set[sharing.ID], prng io.Reader) (ds.Map[sharing.ID, *dkls23.Shard[P, B, S]], *ecdsa.PublicKey[P, B, S], error) <span class="cov8" title="1">{
        feldmanDealer, err := feldman.NewScheme(curve.Generator(), threshold, shareholder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not create shamir scheme")
        }</span>

        <span class="cov8" title="1">feldmanOutput, secret, err := feldmanDealer.DealRandom(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not deal shares")
        }</span>
        <span class="cov8" title="1">public := curve.ScalarBaseMul(secret.Value())

        // create zero sharing seeds
        zeroSeeds := make(map[sharing.ID]ds.MutableMap[sharing.ID, [przs.SeedLength]byte])
        for id := range feldmanOutput.Shares().Iter() </span><span class="cov8" title="1">{
                zeroSeeds[id] = hashmap.NewComparable[sharing.ID, [przs.SeedLength]byte]()
        }</span>
        <span class="cov8" title="1">for me := range feldmanOutput.Shares().Iter() </span><span class="cov8" title="1">{
                for they := range feldmanOutput.Shares().Iter() </span><span class="cov8" title="1">{
                        if me &gt;= they </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">var seed [przs.SeedLength]byte
                        if _, err = io.ReadFull(prng, seed[:]); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample seed")
                        }</span>
                        <span class="cov8" title="1">zeroSeeds[me].Put(they, seed)
                        zeroSeeds[they].Put(me, seed)</span>
                }
        }

        // create OT seeds
        <span class="cov8" title="1">senderSeeds := make(map[sharing.ID]ds.MutableMap[sharing.ID, *vsot.SenderOutput])
        receiverSeeds := make(map[sharing.ID]ds.MutableMap[sharing.ID, *vsot.ReceiverOutput])
        for id := range feldmanOutput.Shares().Iter() </span><span class="cov8" title="1">{
                senderSeeds[id] = hashmap.NewComparable[sharing.ID, *vsot.SenderOutput]()
                receiverSeeds[id] = hashmap.NewComparable[sharing.ID, *vsot.ReceiverOutput]()
        }</span>
        <span class="cov8" title="1">for me := range feldmanOutput.Shares().Iter() </span><span class="cov8" title="1">{
                for they := range feldmanOutput.Shares().Iter() </span><span class="cov8" title="1">{
                        if me == they </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">choices := make([]byte, softspoken.Kappa/8)
                        if _, err := io.ReadFull(prng, choices); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample choices")
                        }</span>
                        <span class="cov8" title="1">sender := &amp;vsot.SenderOutput{
                                SenderOutput: ot.SenderOutput[[]byte]{
                                        Messages: make([][2][][]byte, softspoken.Kappa),
                                },
                        }
                        receiver := &amp;vsot.ReceiverOutput{
                                ReceiverOutput: ot.ReceiverOutput[[]byte]{
                                        Choices:  choices,
                                        Messages: make([][][]byte, softspoken.Kappa),
                                },
                        }
                        for kappa := range softspoken.Kappa </span><span class="cov8" title="1">{
                                m0 := make([]byte, 32)
                                if _, err := io.ReadFull(prng, m0); err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errs2.Wrap(err).WithMessage("cannot sample m0")
                                }</span>
                                <span class="cov8" title="1">m1 := make([]byte, 32)
                                if _, err := io.ReadFull(prng, m1); err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errs2.Wrap(err).WithMessage("cannot sample m1")
                                }</span>
                                <span class="cov8" title="1">c := (choices[kappa/8] &gt;&gt; (kappa % 8)) &amp; 0b1
                                sender.Messages[kappa][0] = [][]byte{m0}
                                sender.Messages[kappa][1] = [][]byte{m1}
                                receiver.Messages[kappa] = sender.Messages[kappa][c]</span>
                        }

                        <span class="cov8" title="1">senderSeeds[me].Put(they, sender)
                        receiverSeeds[they].Put(me, receiver)</span>
                }
        }

        <span class="cov8" title="1">publicKey, err := ecdsa.NewPublicKey(public)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("invalid public key")
        }</span>
        <span class="cov8" title="1">result := hashmap.NewComparable[sharing.ID, *dkls23.Shard[P, B, S]]()
        for id, feldmanShare := range feldmanOutput.Shares().Iter() </span><span class="cov8" title="1">{
                baseShard, err := tecdsa.NewShard(feldmanShare, feldmanOutput.VerificationMaterial(), feldmanDealer.AccessStructure())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create tECDSA DKLSS23 shard")
                }</span>
                <span class="cov8" title="1">auxInfo, err := dkls23.NewAuxiliaryInfo(zeroSeeds[id].Freeze(), senderSeeds[id].Freeze(), receiverSeeds[id].Freeze())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create auxiliary info")
                }</span>
                <span class="cov8" title="1">shard, err := dkls23.NewShard(baseShard, auxInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create tECDSA DKLSS23 shard")
                }</span>
                <span class="cov8" title="1">result.Put(id, shard)</span>
        }

        <span class="cov8" title="1">return result.Freeze(), publicKey, nil</span>
}
</pre>
		
		<pre class="file" id="file378" style="display: none">package dkls23

import (
        "bytes"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa"
)

// AuxiliaryInfo holds auxiliary key material.
type AuxiliaryInfo struct {
        zeroSeeds       przs.Seeds
        otSenderSeeds   ds.Map[sharing.ID, *vsot.SenderOutput]
        otReceiverSeeds ds.Map[sharing.ID, *vsot.ReceiverOutput]
}

type auxiliaryInfoDTO struct {
        ZeroSeeds       map[sharing.ID][przs.SeedLength]byte `cbor:"zeroSeeds"`
        OTSenderSeeds   map[sharing.ID]*vsot.SenderOutput    `cbor:"otSenderSeeds"`
        OTReceiverSeeds map[sharing.ID]*vsot.ReceiverOutput  `cbor:"otReceiverSeeds"`
}

// ZeroSeeds returns the zero-setup seeds.
func (a *AuxiliaryInfo) ZeroSeeds() przs.Seeds <span class="cov0" title="0">{
        return a.zeroSeeds
}</span>

// OTSenderSeeds returns the OT sender seeds.
func (a *AuxiliaryInfo) OTSenderSeeds() ds.Map[sharing.ID, *vsot.SenderOutput] <span class="cov0" title="0">{
        return a.otSenderSeeds
}</span>

// OTReceiverSeeds returns the OT receiver seeds.
func (a *AuxiliaryInfo) OTReceiverSeeds() ds.Map[sharing.ID, *vsot.ReceiverOutput] <span class="cov0" title="0">{
        return a.otReceiverSeeds
}</span>

// Equal reports whether the value equals other.
func (a *AuxiliaryInfo) Equal(rhs *AuxiliaryInfo) bool <span class="cov0" title="0">{
        if a.zeroSeeds.Size() != rhs.zeroSeeds.Size() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for id, l := range a.zeroSeeds.Iter() </span><span class="cov0" title="0">{
                r, ok := rhs.zeroSeeds.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if l != r </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">if a.otSenderSeeds.Size() != rhs.otSenderSeeds.Size() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for id, l := range a.otSenderSeeds.Iter() </span><span class="cov0" title="0">{
                r, ok := rhs.otSenderSeeds.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if l.InferredXi() != r.InferredXi() </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if l.InferredL() != r.InferredL() </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for xi := range l.InferredXi() </span><span class="cov0" title="0">{
                        for ell := range l.InferredL() </span><span class="cov0" title="0">{
                                if !bytes.Equal(l.Messages[xi][0][ell], r.Messages[xi][0][ell]) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov0" title="0">if !bytes.Equal(l.Messages[xi][1][ell], r.Messages[xi][1][ell]) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return true</span>
}

// MarshalCBOR implements cbor.Marshaler.
func (a *AuxiliaryInfo) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        zeroSeeds := make(map[sharing.ID][przs.SeedLength]byte)
        for id, seed := range a.zeroSeeds.Iter() </span><span class="cov0" title="0">{
                zeroSeeds[id] = seed
        }</span>
        <span class="cov0" title="0">otSenderSeeds := make(map[sharing.ID]*vsot.SenderOutput)
        for id, seed := range a.otSenderSeeds.Iter() </span><span class="cov0" title="0">{
                otSenderSeeds[id] = seed
        }</span>
        <span class="cov0" title="0">otReceiverSeeds := make(map[sharing.ID]*vsot.ReceiverOutput)
        for id, seed := range a.otReceiverSeeds.Iter() </span><span class="cov0" title="0">{
                otReceiverSeeds[id] = seed
        }</span>
        <span class="cov0" title="0">dto := &amp;auxiliaryInfoDTO{
                ZeroSeeds:       zeroSeeds,
                OTSenderSeeds:   otSenderSeeds,
                OTReceiverSeeds: otReceiverSeeds,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal dkls23 auxiliary info")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR implements cbor.Unmarshaler.
func (a *AuxiliaryInfo) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*auxiliaryInfoDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a.zeroSeeds = hashmap.NewImmutableComparableFromNativeLike(dto.ZeroSeeds)
        a.otSenderSeeds = hashmap.NewImmutableComparableFromNativeLike(dto.OTSenderSeeds)
        a.otReceiverSeeds = hashmap.NewImmutableComparableFromNativeLike(dto.OTReceiverSeeds)
        return nil</span>
}

// NewAuxiliaryInfo returns a new auxiliary info instance.
func NewAuxiliaryInfo(zeroSeeds przs.Seeds, otSenderSeeds ds.Map[sharing.ID, *vsot.SenderOutput], otReceiverSeeds ds.Map[sharing.ID, *vsot.ReceiverOutput]) (*AuxiliaryInfo, error) <span class="cov0" title="0">{
        if zeroSeeds == nil || otSenderSeeds == nil || otReceiverSeeds == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("cannot create AuxiliaryInfo with nil fields")
        }</span>
        <span class="cov0" title="0">return &amp;AuxiliaryInfo{
                zeroSeeds:       zeroSeeds,
                otSenderSeeds:   otSenderSeeds,
                otReceiverSeeds: otReceiverSeeds,
        }, nil</span>
}

// Shard holds a tECDSA key share.
type Shard[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        *tecdsa.Shard[P, B, S]
        AuxiliaryInfo
}

// NewShard returns a new shard.
func NewShard[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](baseShard *tecdsa.Shard[P, B, S], auxInfo *AuxiliaryInfo) (*Shard[P, B, S], error) <span class="cov0" title="0">{
        if baseShard == nil || auxInfo == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("cannot create Shard with nil fields")
        }</span>
        <span class="cov0" title="0">return &amp;Shard[P, B, S]{
                Shard:         baseShard,
                AuxiliaryInfo: *auxInfo,
        }, nil</span>
}

// Equal reports whether the value equals other.
func (s *Shard[P, B, S]) Equal(rhs *Shard[P, B, S]) bool <span class="cov0" title="0">{
        if s == nil || rhs == nil </span><span class="cov0" title="0">{
                return s == rhs
        }</span>
        <span class="cov0" title="0">return s.Shard.Equal(rhs.Shard) &amp;&amp; s.AuxiliaryInfo.Equal(&amp;rhs.AuxiliaryInfo)</span>
}

type shardDTO[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        Shard *tecdsa.Shard[P, B, S] `cbor:"shard"`
        Aux   AuxiliaryInfo          `cbor:"auxiliaryInfo"`
}

// MarshalCBOR implements cbor.Marshaler.
func (s *Shard[P, B, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;shardDTO[P, B, S]{
                Shard: s.Shard,
                Aux:   s.AuxiliaryInfo,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal dkls23 Shard")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR implements cbor.Unmarshaler.
func (s *Shard[P, B, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*shardDTO[P, B, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.Shard = dto.Shard
        s.AuxiliaryInfo = dto.Aux
        return nil</span>
}
</pre>
		
		<pre class="file" id="file379" style="display: none">package sign

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "io"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
        "github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        rvole_softspoken "github.com/bronlabs/bron-crypto/pkg/threshold/rvole/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        baseOtMessageLength = 32

        transcriptLabel      = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN-"
        mulLabel             = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN_MUL-"
        ckLabel              = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN_CK-"
        przsRandomizerLabel  = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN_PRZS_RANDOMIZER-"
        otRandomizerLabel    = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN_OT_RANDOMIZER-"
        otRandomizerSender   = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN_OT_RANDOMIZER_SENDER-"
        otRandomizerReceiver = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN_OT_RANDOMIZER_RECEIVER-"
        otRandomizerKey      = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN_OT_RANDOMIZER_KEY-"
        ecbbotLabel          = "BRON_CRYPTO_TECDSA_DKLS23_ECBBOT_SOFTSPOKEN_BASE_OT-"
)

// Cosigner represents a signing participant.
type Cosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        sessionID network.SID
        sharingID sharing.ID
        shard     *dkls23.Shard[P, B, S]
        zeroSeeds przs.Seeds
        quorum    network.Quorum
        suite     *ecdsa.Suite[P, B, S]
        tape      transcripts.Transcript
        prng      io.Reader

        baseOtSenders   map[sharing.ID]*ecbbot.Sender[P, S]
        baseOtReceivers map[sharing.ID]*ecbbot.Receiver[P, S]
        aliceMul        map[sharing.ID]*rvole_softspoken.Alice[P, B, S]
        bobMul          map[sharing.ID]*rvole_softspoken.Bob[P, B, S]
        zeroSampler     *przs.Sampler[S]

        state State[P, B, S]
}

// State tracks per-round signing state.
type State[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        baseOtReceiverOutputs map[sharing.ID]*vsot.ReceiverOutput
        baseOtSenderOutputs   map[sharing.ID]*vsot.SenderOutput

        round          network.Round
        ck             *hash_comm.Scheme
        r              S
        bigR           map[sharing.ID]P
        bigRCommitment map[sharing.ID]hash_comm.Commitment
        bigRWitness    hash_comm.Witness
        phi            S
        chi            map[sharing.ID]S
        c              map[sharing.ID][]S
        sk             S
        pk             map[sharing.ID]P
}

// NewCosigner returns a new cosigner.
func NewCosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, quorum network.Quorum, suite *ecdsa.Suite[P, B, S], shard *dkls23.Shard[P, B, S], prng io.Reader, tape transcripts.Transcript) (*Cosigner[P, B, S], error) <span class="cov8" title="1">{
        if quorum == nil || suite == nil || shard == nil || prng == nil || tape == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("argument")
        }</span>
        <span class="cov8" title="1">if suite.IsDeterministic() </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("suite must be non-deterministic")
        }</span>
        <span class="cov8" title="1">if !quorum.Contains(shard.Share().ID()) </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("sharing id not part of the quorum")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        zeroSeeds, err := randomizeZeroSeeds(shard.ZeroSeeds(), tape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't randomise zero seeds")
        }</span>

        <span class="cov8" title="1">otSuite, err := ecbbot.NewSuite(softspoken.Kappa, 1, suite.Curve())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("error creating vsot suite for participant")
        }</span>
        <span class="cov8" title="1">otSenders := make(map[sharing.ID]*ecbbot.Sender[P, S])
        otReceivers := make(map[sharing.ID]*ecbbot.Receiver[P, S])
        sharingID := shard.Share().ID()
        for id := range quorum.Iter() </span><span class="cov8" title="1">{
                if id == sharingID </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">otTape := tape.Clone()
                otTape.AppendBytes(ecbbotLabel, binary.LittleEndian.AppendUint64(nil, uint64(sharingID)), binary.LittleEndian.AppendUint64(nil, uint64(id)))
                otSender, err := ecbbot.NewSender(sessionID, otSuite, otTape, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("error creating bbot sender")
                }</span>

                <span class="cov8" title="1">otTape = tape.Clone()
                otTape.AppendBytes(ecbbotLabel, binary.LittleEndian.AppendUint64(nil, uint64(id)), binary.LittleEndian.AppendUint64(nil, uint64(sharingID)))
                otReceiver, err := ecbbot.NewReceiver(sessionID, otSuite, otTape, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("error creating bbot receiver")
                }</span>

                <span class="cov8" title="1">otSenders[id] = otSender
                otReceivers[id] = otReceiver</span>
        }

        //nolint:exhaustruct // lazy initialisation
        <span class="cov8" title="1">c := &amp;Cosigner[P, B, S]{
                sessionID:       sessionID,
                sharingID:       sharingID,
                quorum:          quorum,
                shard:           shard,
                suite:           suite,
                zeroSeeds:       zeroSeeds,
                tape:            tape,
                prng:            prng,
                baseOtSenders:   otSenders,
                baseOtReceivers: otReceivers,
                aliceMul:        make(map[sharing.ID]*rvole_softspoken.Alice[P, B, S]),
                bobMul:          make(map[sharing.ID]*rvole_softspoken.Bob[P, B, S]),
                //nolint:exhaustruct // lazy initialisation
                state: State[P, B, S]{
                        baseOtReceiverOutputs: make(map[sharing.ID]*vsot.ReceiverOutput),
                        baseOtSenderOutputs:   make(map[sharing.ID]*vsot.SenderOutput),
                        round:                 1,
                },
        }
        return c, nil</span>
}

// SharingID returns the participant sharing identifier.
func (c *Cosigner[P, B, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return c.shard.Share().ID()
}</span>

// Quorum returns the protocol quorum.
func (c *Cosigner[P, B, S]) Quorum() network.Quorum <span class="cov0" title="0">{
        return c.quorum
}</span>

func randomizeZeroSeeds(seeds przs.Seeds, tape transcripts.Transcript) (przs.Seeds, error) <span class="cov8" title="1">{
        randomizerKey, err := tape.ExtractBytes(przsRandomizerLabel, (2*base.ComputationalSecurityBits+7)/8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot extract randomizer")
        }</span>

        <span class="cov8" title="1">randomizedSeeds := hashmap.NewComparable[sharing.ID, [przs.SeedLength]byte]()
        for id, seed := range seeds.Iter() </span><span class="cov8" title="1">{
                hasher, err := blake2b.New(przs.SeedLength, randomizerKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create hasher")
                }</span>
                <span class="cov8" title="1">_, err = hasher.Write(seed[:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot hash seed")
                }</span>
                <span class="cov8" title="1">randomizedSeedBytes := hasher.Sum(nil)
                var randomizedSeed [przs.SeedLength]byte
                copy(randomizedSeed[:], randomizedSeedBytes)
                randomizedSeeds.Put(id, randomizedSeed)</span>
        }
        <span class="cov8" title="1">return randomizedSeeds.Freeze(), nil</span>
}
</pre>
		
		<pre class="file" id="file380" style="display: none">package sign

import (
        "crypto/sha256"
        "encoding/binary"
        "io"
        "maps"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/ecbbot"
        "github.com/bronlabs/bron-crypto/pkg/ot/extension/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        rvole_softspoken "github.com/bronlabs/bron-crypto/pkg/threshold/rvole/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
)

// Round1 executes protocol round 1.
func (c *Cosigner[P, B, S]) Round1() (network.OutgoingUnicasts[*Round1P2P[P, B, S]], error) <span class="cov8" title="1">{
        r1u := hashmap.NewComparable[sharing.ID, *Round1P2P[P, B, S]]()
        for id, u := range outgoingP2PMessages(c, r1u) </span><span class="cov8" title="1">{
                var err error
                u.OtR1, err = c.baseOtSenders[id].Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 1 of VSOT party")
                }</span>
        }

        <span class="cov8" title="1">c.state.round++
        return r1u.Freeze(), nil</span>
}

// Round2 executes protocol round 2.
func (c *Cosigner[P, B, S]) Round2(r1u network.RoundMessages[*Round1P2P[P, B, S]]) (network.OutgoingUnicasts[*Round2P2P[P, B, S]], error) <span class="cov8" title="1">{
        incomingP2PMessages, err := validateIncomingP2PMessages(c, 2, r1u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">otR1 := hashmap.NewComparable[sharing.ID, *ecbbot.Round1P2P[P, S]]()
        for id, m := range incomingP2PMessages </span><span class="cov8" title="1">{
                otR1.Put(id, m.OtR1)
        }</span>

        <span class="cov8" title="1">globalOtTape := c.tape.Clone()
        globalOtTape.AppendDomainSeparator(otRandomizerLabel)
        r2u := hashmap.NewComparable[sharing.ID, *Round2P2P[P, B, S]]()
        for id, u := range outgoingP2PMessages(c, r2u) </span><span class="cov8" title="1">{
                otR1u, ok := otR1.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("cannot run round 2 of VSOT setup party")
                }</span>
                <span class="cov8" title="1">choices := make([]byte, (softspoken.Kappa+7)/8)
                _, err = io.ReadFull(c.prng, choices)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot sample choices")
                }</span>
                <span class="cov8" title="1">var seed *ecbbot.ReceiverOutput[S]
                u.OtR2, seed, err = c.baseOtReceivers[id].Round2(otR1u, choices)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 2 of VSOT party")
                }</span>

                <span class="cov8" title="1">otTape := globalOtTape.Clone()
                otTape.AppendBytes(otRandomizerSender, binary.LittleEndian.AppendUint64(nil, uint64(c.sharingID)))
                otTape.AppendBytes(otRandomizerReceiver, binary.LittleEndian.AppendUint64(nil, uint64(id)))
                otKey, err := otTape.ExtractBytes(otRandomizerKey, 32)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot extract OT randomizer key")
                }</span>
                <span class="cov8" title="1">c.state.baseOtReceiverOutputs[id], err = seed.ToBitsOutput(baseOtMessageLength, otKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot convert seed to bits output")
                }</span>
        }

        <span class="cov8" title="1">c.state.round++
        return r2u.Freeze(), nil</span>
}

// Round3 executes protocol round 3.
func (c *Cosigner[P, B, S]) Round3(r2u network.RoundMessages[*Round2P2P[P, B, S]]) (*Round3Broadcast, network.OutgoingUnicasts[*Round3P2P], error) <span class="cov8" title="1">{
        incomingP2PMessages, err := validateIncomingP2PMessages(c, 3, r2u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">otR2 := hashmap.NewComparable[sharing.ID, *ecbbot.Round2P2P[P, S]]()
        for id, m := range incomingP2PMessages </span><span class="cov8" title="1">{
                otR2.Put(id, m.OtR2)
        }</span>
        <span class="cov8" title="1">globalOtTape := c.tape.Clone()
        globalOtTape.AppendDomainSeparator(otRandomizerLabel)

        var ck [hash_comm.KeySize]byte
        ckBytes, err := c.tape.ExtractBytes(ckLabel, uint(len(ck)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("failed to extract commitment key")
        }</span>
        <span class="cov8" title="1">copy(ck[:], ckBytes)
        c.state.ck, err = hash_comm.NewScheme(ck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create commitment scheme")
        }</span>
        <span class="cov8" title="1">c.state.r, err = c.suite.ScalarField().Random(c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample r")
        }</span>
        <span class="cov8" title="1">c.state.bigR = make(map[sharing.ID]P)
        c.state.bigR[c.sharingID] = c.suite.Curve().ScalarBaseMul(c.state.r)
        c.state.bigRCommitment = make(map[sharing.ID]hash_comm.Commitment)
        c.state.bigRCommitment[c.sharingID], c.state.bigRWitness, err = c.state.ck.Committer().Commit(c.state.bigR[c.sharingID].ToCompressed(), c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot commit to r")
        }</span>
        <span class="cov8" title="1">c.state.phi, err = c.suite.ScalarField().Random(c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample phi")
        }</span>
        <span class="cov8" title="1">c.state.chi = make(map[sharing.ID]S)

        bOut := &amp;Round3Broadcast{
                BigRCommitment: c.state.bigRCommitment[c.sharingID],
        }

        mulSuite, err := rvole_softspoken.NewSuite(2, c.suite.Curve(), sha256.New)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create mul suite")
        }</span>
        <span class="cov8" title="1">uOut := hashmap.NewComparable[sharing.ID, *Round3P2P]()
        for id, message := range outgoingP2PMessages(c, uOut) </span><span class="cov8" title="1">{
                otR2u, ok := otR2.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("missing OT message")
                }</span>
                <span class="cov8" title="1">seed, err := c.baseOtSenders[id].Round3(otR2u)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run round 3 of VSOT party")
                }</span>

                <span class="cov8" title="1">otTape := globalOtTape.Clone()
                otTape.AppendBytes(otRandomizerSender, binary.LittleEndian.AppendUint64(nil, uint64(id)))
                otTape.AppendBytes(otRandomizerReceiver, binary.LittleEndian.AppendUint64(nil, uint64(c.sharingID)))
                otKey, err := otTape.ExtractBytes(otRandomizerKey, base.CollisionResistanceBytesCeil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot extract OT randomizer key")
                }</span>
                <span class="cov8" title="1">c.state.baseOtSenderOutputs[id], err = seed.ToBitsOutput(baseOtMessageLength, otKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot convert seed to bits output")
                }</span>
                <span class="cov8" title="1">aliceSeed, ok := c.state.baseOtReceiverOutputs[id]
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("couldn't find alice seed")
                }</span>
                <span class="cov8" title="1">aliceTape := c.tape.Clone()
                aliceTape.AppendBytes(mulLabel, binary.LittleEndian.AppendUint64(nil, uint64(c.sharingID)), binary.LittleEndian.AppendUint64(nil, uint64(id)))
                c.aliceMul[id], err = rvole_softspoken.NewAlice(c.sessionID, mulSuite, aliceSeed, c.prng, aliceTape)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("couldn't initialise Alice")
                }</span>

                <span class="cov8" title="1">bobSeed, ok := c.state.baseOtSenderOutputs[id]
                if !ok </span><span class="cov0" title="0">{
                        return nil, nil, ErrFailed.WithMessage("couldn't find bob seed")
                }</span>
                <span class="cov8" title="1">bobTape := c.tape.Clone()
                bobTape.AppendBytes(mulLabel, binary.LittleEndian.AppendUint64(nil, uint64(id)), binary.LittleEndian.AppendUint64(nil, uint64(c.sharingID)))
                c.bobMul[id], err = rvole_softspoken.NewBob(c.sessionID, mulSuite, bobSeed, c.prng, bobTape)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("couldn't initialise Bob")
                }</span>

                <span class="cov8" title="1">message.MulR1, c.state.chi[id], err = c.bobMul[id].Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run Bob mul round1")
                }</span>
        }

        <span class="cov8" title="1">c.state.round++
        return bOut, uOut.Freeze(), nil</span>
}

// Round4 executes protocol round 4.
func (c *Cosigner[P, B, S]) Round4(r3b network.RoundMessages[*Round3Broadcast], r3u network.RoundMessages[*Round3P2P]) (r4b *Round4Broadcast[P, B, S], r4u network.OutgoingUnicasts[*Round4P2P[P, B, S]], err error) <span class="cov8" title="1">{
        incomingMessages, err := validateIncomingMessages(c, 4, r3b, r3u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">mulR1 := make(map[sharing.ID]*rvole_softspoken.Round1P2P)
        for id, message := range incomingMessages </span><span class="cov8" title="1">{
                c.state.bigRCommitment[id] = message.broadcast.BigRCommitment
                mulR1[id] = message.p2p.MulR1
        }</span>

        <span class="cov8" title="1">c.zeroSampler, err = przs.NewSampler(c.sharingID, c.quorum, c.zeroSeeds, c.suite.ScalarField())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run zero setup round3")
        }</span>
        <span class="cov8" title="1">zeta, err := c.zeroSampler.Sample()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run zero setup round3")
        }</span>

        <span class="cov8" title="1">quorum, err := sharing.NewMinimalQualifiedAccessStructure(c.quorum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create minimal qualified access structure")
        }</span>
        <span class="cov8" title="1">sk, err := c.shard.Share().ToAdditive(quorum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("to additive share failed")
        }</span>
        <span class="cov8" title="1">c.state.sk = sk.Value().Add(zeta)
        c.state.pk = make(map[sharing.ID]P)
        c.state.pk[c.sharingID] = c.suite.Curve().ScalarBaseMul(c.state.sk)
        c.state.c = make(map[sharing.ID][]S)

        bOut := &amp;Round4Broadcast[P, B, S]{
                BigR:        c.state.bigR[c.sharingID],
                BigRWitness: c.state.bigRWitness,
                Pk:          c.state.pk[c.sharingID],
        }
        uOut := hashmap.NewComparable[sharing.ID, *Round4P2P[P, B, S]]()
        for id, message := range outgoingP2PMessages(c, uOut) </span><span class="cov8" title="1">{
                message.MulR2, c.state.c[id], err = c.aliceMul[id].Round2(mulR1[id], []S{c.state.r, c.state.sk})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run alice mul round2")
                }</span>
                <span class="cov8" title="1">message.GammaU = c.suite.Curve().ScalarBaseMul(c.state.c[id][0])
                message.GammaV = c.suite.Curve().ScalarBaseMul(c.state.c[id][1])
                message.Psi = c.state.phi.Sub(c.state.chi[id])</span>
        }

        <span class="cov8" title="1">c.state.round++
        return bOut, uOut.Freeze(), nil</span>
}

// Round5 executes protocol round 5.
func (c *Cosigner[P, B, S]) Round5(r4b network.RoundMessages[*Round4Broadcast[P, B, S]], r4u network.RoundMessages[*Round4P2P[P, B, S]], message []byte) (partialSignature *dkls23.PartialSignature[P, B, S], err error) <span class="cov8" title="1">{
        incomingMessages, err := validateIncomingMessages(c, 5, r4b, r4u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">psi := c.suite.ScalarField().Zero()
        cudu := c.suite.ScalarField().Zero()
        cvdv := c.suite.ScalarField().Zero()
        for id, message := range incomingMessages </span><span class="cov8" title="1">{
                if err := c.state.ck.Verifier().Verify(c.state.bigRCommitment[id], message.broadcast.BigR.ToCompressed(), message.broadcast.BigRWitness); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("invalid commitment")
                }</span>
                <span class="cov8" title="1">c.state.bigR[id] = message.broadcast.BigR

                d, err := c.bobMul[id].Round3(message.p2p.MulR2)
                if err != nil </span><span class="cov0" title="0">{
                        if errs2.Is(err, base.ErrAbort) </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("cannot run Bob mul round3")
                        }</span>
                        <span class="cov0" title="0">return nil, errs2.Wrap(err).WithMessage("cannot run Bob mul round3")</span>
                }
                <span class="cov8" title="1">if !c.state.bigR[id].ScalarMul(c.state.chi[id]).Sub(message.p2p.GammaU).Equal(c.suite.Curve().ScalarBaseMul(d[0])) </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("consistency check failed")
                }</span>
                <span class="cov8" title="1">if !message.broadcast.Pk.ScalarMul(c.state.chi[id]).Sub(message.p2p.GammaV).Equal(c.suite.Curve().ScalarBaseMul(d[1])) </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("consistency check failed")
                }</span>
                <span class="cov8" title="1">c.state.pk[id] = message.broadcast.Pk

                psi = psi.Add(message.p2p.Psi)
                cudu = cudu.Add(c.state.c[id][0].Add(d[0]))
                cvdv = cvdv.Add(c.state.c[id][1].Add(d[1]))</span>
        }

        <span class="cov8" title="1">bigR := sliceutils.Fold(func(x, y P) P </span><span class="cov8" title="1">{ return x.Add(y) }</span>, c.suite.Curve().OpIdentity(), slices.Collect(maps.Values(c.state.bigR))...)
        <span class="cov8" title="1">pk := sliceutils.Fold(func(x, y P) P </span><span class="cov8" title="1">{ return x.Add(y) }</span>, c.suite.Curve().OpIdentity(), slices.Collect(maps.Values(c.state.pk))...)
        <span class="cov8" title="1">if !pk.Equal(c.shard.PublicKey().Value()) </span><span class="cov0" title="0">{
                return nil, base.ErrAbort.WithMessage("consistency check failed")
        }</span>

        <span class="cov8" title="1">u := c.state.r.Mul(c.state.phi.Add(psi)).Add(cudu)
        v := c.state.sk.Mul(c.state.phi.Add(psi)).Add(cvdv)
        digest, err := hashing.Hash(c.suite.HashFunc(), message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash message")
        }</span>
        <span class="cov8" title="1">m, err := ecdsa.DigestToScalar(c.suite.ScalarField(), digest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute message scalar")
        }</span>
        <span class="cov8" title="1">rxi, err := bigR.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert to affine x")
        }</span>
        <span class="cov8" title="1">rx, err := c.suite.ScalarField().FromWideBytes(rxi.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert to scalar")
        }</span>
        <span class="cov8" title="1">w := m.Mul(c.state.phi).Add(rx.Mul(v))

        partialSignature, err = dkls23.NewPartialSignature(bigR, u, w)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create partial signature")
        }</span>

        <span class="cov8" title="1">c.state.round++
        return partialSignature, nil</span>
}
</pre>
		
		<pre class="file" id="file381" style="display: none">package testutils

import (
        "bytes"
        crand "crypto/rand"
        "encoding/hex"
        "hash"
        "io"
        "maps"
        "slices"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/network/testutils"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid"
        "github.com/stretchr/testify/require"
)

func RunDKLs23SignSoftspokenOT[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](tb testing.TB, shards map[sharing.ID]*dkls23.Shard[P, B, S], quorum ds.Set[sharing.ID], message []byte, hashFunc func() hash.Hash) *ecdsa.Signature[S] <span class="cov0" title="0">{
        tb.Helper()

        prng := crand.Reader
        var sessionID network.SID
        _, err := io.ReadFull(prng, sessionID[:])
        require.NoError(tb, err)
        tape := hagrid.NewTranscript(hex.EncodeToString(sessionID[:]))
        pk := slices.Collect(maps.Values(shards))[0].PublicKey()
        curve := algebra.StructureMustBeAs[ecdsa.Curve[P, B, S]](pk.Value().Structure())
        ecdsaSuite, err := ecdsa.NewSuite(curve, hashFunc)
        require.NoError(tb, err)

        tapesMap := make(map[sharing.ID]transcripts.Transcript)
        consignersMap := make(map[sharing.ID]*sign.Cosigner[P, B, S])
        for id := range quorum.Iter() </span><span class="cov0" title="0">{
                shard, ok := shards[id]
                require.True(tb, ok)
                tapesMap[id] = tape.Clone()
                consignersMap[id], err = sign.NewCosigner(sessionID, quorum, ecdsaSuite, ntu.CBORRoundTrip(tb, shard), prng, tapesMap[id])
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">cosigners := slices.Collect(maps.Values(consignersMap))

        r1uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign.Round1P2P[P, B, S]])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r1uo[cosigner.SharingID()], err = cosigner.Round1()
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r2ui := ntu.MapUnicastO2I(tb, cosigners, r1uo)
        r2uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign.Round2P2P[P, B, S]])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r2uo[cosigner.SharingID()], err = cosigner.Round2(r2ui[cosigner.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r3ui := ntu.MapUnicastO2I(tb, cosigners, r2uo)
        r3bo := make(map[sharing.ID]*sign.Round3Broadcast)
        r3uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign.Round3P2P])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r3bo[cosigner.SharingID()], r3uo[cosigner.SharingID()], err = cosigner.Round3(r3ui[cosigner.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r4bi, r4ui := ntu.MapO2I(tb, cosigners, r3bo, r3uo)
        r4bo := make(map[sharing.ID]*sign.Round4Broadcast[P, B, S])
        r4uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign.Round4P2P[P, B, S]])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r4bo[cosigner.SharingID()], r4uo[cosigner.SharingID()], err = cosigner.Round4(r4bi[cosigner.SharingID()], r4ui[cosigner.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r5bi, r5ui := ntu.MapO2I(tb, cosigners, r4bo, r4uo)
        partialSignatures := make(map[sharing.ID]*dkls23.PartialSignature[P, B, S])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                partialSignatures[cosigner.SharingID()], err = cosigner.Round5(r5bi[cosigner.SharingID()], r5ui[cosigner.SharingID()], message)
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">signature, err := dkls23.Aggregate(ecdsaSuite, pk, message, slices.Collect(maps.Values(partialSignatures))...)
        require.NoError(tb, err)

        // transcripts match
        transcriptsBytes := make(map[sharing.ID][]byte)
        for id, tape := range tapesMap </span><span class="cov0" title="0">{
                var err error
                transcriptsBytes[id], err = tape.ExtractBytes("test", 32)
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">transcriptBytesSlice := slices.Collect(maps.Values(transcriptsBytes))
        require.True(tb, sliceutils.All(transcriptBytesSlice, func(b []byte) bool </span><span class="cov0" title="0">{ return bytes.Equal(transcriptBytesSlice[0], b) }</span>))

        <span class="cov0" title="0">return signature</span>
}
</pre>
		
		<pre class="file" id="file382" style="display: none">package sign

import (
        "iter"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

type message[B network.Message, U network.Message] struct {
        broadcast B
        p2p       U
}

func validateIncomingMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], MB network.Message, MU network.Message](c *Cosigner[P, B, S], rIn network.Round, bIn network.RoundMessages[MB], uIn network.RoundMessages[MU]) (iter.Seq2[sharing.ID, message[MB, MU]], error) <span class="cov8" title="1">{
        if rIn != c.state.round </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">return func(yield func(p sharing.ID, m message[MB, MU]) bool) </span><span class="cov8" title="1">{
                for id := range c.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == c.sharingID </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">b, ok := bIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing broadcast message")</span>
                        }
                        <span class="cov8" title="1">u, ok := uIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing unicast message")</span>
                        }
                        <span class="cov8" title="1">if !yield(id, message[MB, MU]{broadcast: b, p2p: u}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }, nil
}

func validateIncomingP2PMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], MU network.Message](c *Cosigner[P, B, S], rIn network.Round, uIn network.RoundMessages[MU]) (iter.Seq2[sharing.ID, MU], error) <span class="cov8" title="1">{
        if rIn != c.state.round </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">return func(yield func(p sharing.ID, m MU) bool) </span><span class="cov8" title="1">{
                for id := range c.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == c.sharingID </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">u, ok := uIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing unicast message")</span>
                        }
                        <span class="cov8" title="1">if !yield(id, u) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }, nil
}

type messagePointerConstraint[MP network.Message, M any] interface {
        *M
        network.Message
}

func outgoingP2PMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], UPtr messagePointerConstraint[UPtr, U], U any](p *Cosigner[P, B, S], uOut ds.MutableMap[sharing.ID, UPtr]) iter.Seq2[sharing.ID, UPtr] <span class="cov8" title="1">{
        return func(yield func(p sharing.ID, out UPtr) bool) </span><span class="cov8" title="1">{
                for id := range p.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == p.sharingID </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">u := new(U)
                        if !yield(id, UPtr(u)) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">uOut.Put(id, UPtr(u))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file383" style="display: none">package sign_bbot

import (
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "io"
        "iter"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        rvole_bbot "github.com/bronlabs/bron-crypto/pkg/threshold/rvole/bbot"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        przsSetup "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs/setup"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel = "BRON_CRYPTO_TECDSA_DKLS23_BBOT-"
        mulLabel        = "BRON_CRYPTO_TECDSA_DKLS23_BBOT_MUL-"
        ckLabel         = "BRON_CRYPTO_TECDSA_DKLS23_BBOT_CK-"
)

// Cosigner represents a signing participant.
type Cosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        suite     *ecdsa.Suite[P, B, S]
        sessionID network.SID
        shard     *dkls23.Shard[P, B, S]
        quorum    network.Quorum
        prng      io.Reader
        tape      transcripts.Transcript
        state     CosignerState[P, B, S]
}

// CosignerState tracks per-round signing state.
type CosignerState[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        zeroSetup   *przsSetup.Participant
        zeroSampler *przs.Sampler[S]
        aliceMul    map[sharing.ID]*rvole_bbot.Alice[P, S]
        bobMul      map[sharing.ID]*rvole_bbot.Bob[P, S]

        round          network.Round
        ck             *hash_comm.Scheme
        r              S
        bigR           map[sharing.ID]P
        bigRCommitment map[sharing.ID]hash_comm.Commitment
        bigRWitness    hash_comm.Witness
        phi            S
        chi            map[sharing.ID]S
        c              map[sharing.ID][]S
        sk             S
        pk             map[sharing.ID]P
}

// NewCosigner returns a new cosigner.
func NewCosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, quorum network.Quorum, suite *ecdsa.Suite[P, B, S], shard *dkls23.Shard[P, B, S], prng io.Reader, tape transcripts.Transcript) (*Cosigner[P, B, S], error) <span class="cov8" title="1">{
        if quorum == nil || suite == nil || shard == nil || prng == nil || tape == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("argument")
        }</span>
        <span class="cov8" title="1">if suite.IsDeterministic() </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("suite must be non-deterministic")
        }</span>
        <span class="cov8" title="1">if !quorum.Contains(shard.Share().ID()) </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("sharing id not part of the quorum")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s%s", transcriptLabel, hex.EncodeToString(sessionID[:])))

        //nolint:exhaustruct // lazy initialisation
        c := &amp;Cosigner[P, B, S]{
                shard:  shard,
                quorum: quorum,
                suite:  suite,
                prng:   prng,
                tape:   tape,
        }

        var err error
        c.state.zeroSetup, err = przsSetup.NewParticipant(sessionID, shard.Share().ID(), quorum, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't initialise zero setup protocol")
        }</span>

        <span class="cov8" title="1">mulSuite, err := rvole_bbot.NewSuite(2, suite.Curve())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create mul suite")
        }</span>
        <span class="cov8" title="1">c.state.aliceMul = make(map[sharing.ID]*rvole_bbot.Alice[P, S])
        c.state.bobMul = make(map[sharing.ID]*rvole_bbot.Bob[P, S])
        for id := range c.otherCosigners() </span><span class="cov8" title="1">{
                aliceTape := tape.Clone()
                aliceTape.AppendBytes(mulLabel, binary.LittleEndian.AppendUint64(nil, uint64(c.shard.Share().ID())), binary.LittleEndian.AppendUint64(nil, uint64(id)))
                c.state.aliceMul[id], err = rvole_bbot.NewAlice(c.sessionID, mulSuite, prng, aliceTape)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("couldn't initialise alice")
                }</span>

                <span class="cov8" title="1">bobTape := tape.Clone()
                bobTape.AppendBytes(mulLabel, binary.LittleEndian.AppendUint64(nil, uint64(id)), binary.LittleEndian.AppendUint64(nil, uint64(c.shard.Share().ID())))
                c.state.bobMul[id], err = rvole_bbot.NewBob(c.sessionID, mulSuite, prng, bobTape)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("couldn't initialise bob")
                }</span>
        }

        <span class="cov8" title="1">c.state.round = 1
        return c, nil</span>
}

// SharingID returns the participant sharing identifier.
func (c *Cosigner[P, B, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return c.shard.Share().ID()
}</span>

// Quorum returns the protocol quorum.
func (c *Cosigner[P, B, S]) Quorum() network.Quorum <span class="cov0" title="0">{
        return c.quorum
}</span>

func (c *Cosigner[P, B, S]) otherCosigners() iter.Seq[sharing.ID] <span class="cov8" title="1">{
        return func(yield func(id sharing.ID) bool) </span><span class="cov8" title="1">{
                for id := range c.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == c.shard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if !yield(id) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file384" style="display: none">package sign_bbot

import (
        "maps"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        rvole_bbot "github.com/bronlabs/bron-crypto/pkg/threshold/rvole/bbot"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        przsSetup "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs/setup"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
)

// Round1 executes protocol round 1.
func (c *Cosigner[P, B, S]) Round1() (r1bOut *Round1Broadcast, r1uOut network.RoundMessages[*Round1P2P[P, B, S]], err error) <span class="cov8" title="1">{
        if c.state.round != 1 </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">var ck [hash_comm.KeySize]byte
        ckBytes, err := c.tape.ExtractBytes(ckLabel, uint(len(ck)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("failed to extract commitment key")
        }</span>
        <span class="cov8" title="1">copy(ck[:], ckBytes)
        c.state.ck, err = hash_comm.NewScheme(ck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create commitment scheme")
        }</span>

        <span class="cov8" title="1">c.state.r, err = c.suite.ScalarField().Random(c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample r")
        }</span>
        <span class="cov8" title="1">c.state.bigR = make(map[sharing.ID]P)
        c.state.bigR[c.shard.Share().ID()] = c.suite.Curve().ScalarBaseMul(c.state.r)
        c.state.bigRCommitment = make(map[sharing.ID]hash_comm.Commitment)
        c.state.bigRCommitment[c.shard.Share().ID()], c.state.bigRWitness, err = c.state.ck.Committer().Commit(c.state.bigR[c.shard.Share().ID()].ToCompressed(), c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot commit to r")
        }</span>

        <span class="cov8" title="1">c.state.phi, err = c.suite.ScalarField().Random(c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample phi")
        }</span>

        <span class="cov8" title="1">zeroR1, err := c.state.zeroSetup.Round1()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot round 1 of zero setup")
        }</span>

        <span class="cov8" title="1">bOut := &amp;Round1Broadcast{
                ZeroSetupR1:    zeroR1,
                BigRCommitment: c.state.bigRCommitment[c.shard.Share().ID()],
        }
        uOut := hashmap.NewComparable[sharing.ID, *Round1P2P[P, B, S]]()
        for id, message := range outgoingP2PMessages(c, uOut) </span><span class="cov8" title="1">{
                message.MulR1, err = c.state.aliceMul[id].Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run Alice mul round1")
                }</span>
        }

        <span class="cov8" title="1">c.state.round++
        return bOut, uOut.Freeze(), nil</span>
}

// Round2 executes protocol round 2.
func (c *Cosigner[P, B, S]) Round2(r1bOut network.RoundMessages[*Round1Broadcast], r1uOut network.RoundMessages[*Round1P2P[P, B, S]]) (r2bOut *Round2Broadcast[P, B, S], r2uOut network.RoundMessages[*Round2P2P[P, B, S]], err error) <span class="cov8" title="1">{
        incomingMessages, err := validateIncomingMessages(c, 2, r1bOut, r1uOut)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">zeroR1 := hashmap.NewComparable[sharing.ID, *przsSetup.Round1Broadcast]()
        mulR1 := make(map[sharing.ID]*rvole_bbot.Round1P2P[P, S])
        for id, message := range incomingMessages </span><span class="cov8" title="1">{
                c.state.bigRCommitment[id] = message.broadcast.BigRCommitment
                zeroR1.Put(id, message.broadcast.ZeroSetupR1)
                mulR1[id] = message.p2p.MulR1
        }</span>

        <span class="cov8" title="1">zeroR2, err := c.state.zeroSetup.Round2(zeroR1.Freeze())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run zero setup round2")
        }</span>

        <span class="cov8" title="1">c.state.chi = make(map[sharing.ID]S)
        bOut := &amp;Round2Broadcast[P, B, S]{
                BigR:        c.state.bigR[c.shard.Share().ID()],
                BigRWitness: c.state.bigRWitness,
        }
        uOut := hashmap.NewComparable[sharing.ID, *Round2P2P[P, B, S]]()
        for id, message := range outgoingP2PMessages(c, uOut) </span><span class="cov8" title="1">{
                message.MulR2, c.state.chi[id], err = c.state.bobMul[id].Round2(mulR1[id])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run bob mul round2")
                }</span>
                <span class="cov8" title="1">message.ZeroSetupR2, _ = zeroR2.Get(id)</span>
        }

        <span class="cov8" title="1">c.state.round++
        return bOut, uOut.Freeze(), nil</span>
}

// Round3 executes protocol round 3.
func (c *Cosigner[P, B, S]) Round3(r2bOut network.RoundMessages[*Round2Broadcast[P, B, S]], r2uOut network.RoundMessages[*Round2P2P[P, B, S]]) (r3bOut *Round3Broadcast[P, B, S], r3uOut network.RoundMessages[*Round3P2P[P, B, S]], err error) <span class="cov8" title="1">{
        incomingMessages, err := validateIncomingMessages(c, 3, r2bOut, r2uOut)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">zeroR2 := hashmap.NewComparable[sharing.ID, *przsSetup.Round2P2P]()
        mulR2 := make(map[sharing.ID]*rvole_bbot.Round2P2P[P, S])
        for id, message := range incomingMessages </span><span class="cov8" title="1">{
                if err := c.state.ck.Verifier().Verify(c.state.bigRCommitment[id], message.broadcast.BigR.ToCompressed(), message.broadcast.BigRWitness); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("invalid commitment")
                }</span>
                <span class="cov8" title="1">c.state.bigR[id] = message.broadcast.BigR
                zeroR2.Put(id, message.p2p.ZeroSetupR2)
                mulR2[id] = message.p2p.MulR2</span>
        }

        <span class="cov8" title="1">zeroSeeds, err := c.state.zeroSetup.Round3(zeroR2.Freeze())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run zero setup round3")
        }</span>
        <span class="cov8" title="1">c.state.zeroSampler, err = przs.NewSampler(c.shard.Share().ID(), c.quorum, zeroSeeds, c.suite.ScalarField())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run zero setup round3")
        }</span>
        <span class="cov8" title="1">zeta, err := c.state.zeroSampler.Sample()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run zero setup round3")
        }</span>

        <span class="cov8" title="1">quorum2, err := sharing.NewMinimalQualifiedAccessStructure(c.quorum)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">sk, err := c.shard.Share().ToAdditive(quorum2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("to additive share failed")
        }</span>

        <span class="cov8" title="1">c.state.sk = sk.Value().Add(zeta)
        c.state.pk = make(map[sharing.ID]P)
        c.state.pk[c.shard.Share().ID()] = c.suite.Curve().ScalarBaseMul(c.state.sk)
        c.state.c = make(map[sharing.ID][]S)

        bOut := &amp;Round3Broadcast[P, B, S]{Pk: c.state.pk[c.shard.Share().ID()]}
        uOut := hashmap.NewComparable[sharing.ID, *Round3P2P[P, B, S]]()
        for id, message := range outgoingP2PMessages(c, uOut) </span><span class="cov8" title="1">{
                message.MulR3, c.state.c[id], err = c.state.aliceMul[id].Round3(mulR2[id], []S{c.state.r, c.state.sk})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run alice mul round3")
                }</span>
                <span class="cov8" title="1">message.GammaU = c.suite.Curve().ScalarBaseMul(c.state.c[id][0])
                message.GammaV = c.suite.Curve().ScalarBaseMul(c.state.c[id][1])
                message.Psi = c.state.phi.Sub(c.state.chi[id])</span>
        }

        <span class="cov8" title="1">c.state.round++
        return bOut, uOut.Freeze(), nil</span>
}

// Round4 executes protocol round 4.
func (c *Cosigner[P, B, S]) Round4(r3bOut network.RoundMessages[*Round3Broadcast[P, B, S]], r3uOut network.RoundMessages[*Round3P2P[P, B, S]], message []byte) (partialSignature *dkls23.PartialSignature[P, B, S], err error) <span class="cov8" title="1">{
        incomingMessages, err := validateIncomingMessages(c, 4, r3bOut, r3uOut)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">psi := c.suite.ScalarField().Zero()
        cudu := c.suite.ScalarField().Zero()
        cvdv := c.suite.ScalarField().Zero()
        for id, message := range incomingMessages </span><span class="cov8" title="1">{
                d, err := c.state.bobMul[id].Round4(message.p2p.MulR3)
                if err != nil </span><span class="cov0" title="0">{
                        if errs2.Is(err, base.ErrAbort) </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("cannot run Bob mul round4")
                        }</span>
                        <span class="cov0" title="0">return nil, errs2.Wrap(err).WithMessage("cannot run Bob mul round4")</span>
                }
                <span class="cov8" title="1">c.state.pk[id] = message.broadcast.Pk

                if !c.state.bigR[id].ScalarMul(c.state.chi[id]).Sub(message.p2p.GammaU).Equal(c.suite.Curve().ScalarBaseMul(d[0])) </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("consistency check failed")
                }</span>
                <span class="cov8" title="1">if !message.broadcast.Pk.ScalarMul(c.state.chi[id]).Sub(message.p2p.GammaV).Equal(c.suite.Curve().ScalarBaseMul(d[1])) </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("consistency check failed")
                }</span>

                <span class="cov8" title="1">psi = psi.Add(message.p2p.Psi)
                cudu = cudu.Add(c.state.c[id][0].Add(d[0]))
                cvdv = cvdv.Add(c.state.c[id][1].Add(d[1]))</span>
        }

        <span class="cov8" title="1">bigR := sliceutils.Fold(func(x, y P) P </span><span class="cov8" title="1">{ return x.Add(y) }</span>, c.suite.Curve().OpIdentity(), slices.Collect(maps.Values(c.state.bigR))...)
        <span class="cov8" title="1">pk := sliceutils.Fold(func(x, y P) P </span><span class="cov8" title="1">{ return x.Add(y) }</span>, c.suite.Curve().OpIdentity(), slices.Collect(maps.Values(c.state.pk))...)
        <span class="cov8" title="1">if !pk.Equal(c.shard.PublicKey().Value()) </span><span class="cov0" title="0">{
                return nil, base.ErrAbort.WithMessage("consistency check failed")
        }</span>

        <span class="cov8" title="1">u := c.state.r.Mul(c.state.phi.Add(psi)).Add(cudu)
        v := c.state.sk.Mul(c.state.phi.Add(psi)).Add(cvdv)
        digest, err := hashing.Hash(c.suite.HashFunc(), message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash message")
        }</span>
        <span class="cov8" title="1">m, err := ecdsa.DigestToScalar(c.suite.ScalarField(), digest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert digest to scalar")
        }</span>
        <span class="cov8" title="1">rxi, err := bigR.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert to affine x")
        }</span>
        <span class="cov8" title="1">rx, err := c.suite.ScalarField().FromWideBytes(rxi.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert to scalar")
        }</span>
        <span class="cov8" title="1">w := m.Mul(c.state.phi).Add(rx.Mul(v))

        partialSignature, err = dkls23.NewPartialSignature(bigR, u, w)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create partial signature")
        }</span>
        <span class="cov8" title="1">return partialSignature, nil</span>
}
</pre>
		
		<pre class="file" id="file385" style="display: none">package testutils

import (
        "bytes"
        crand "crypto/rand"
        "encoding/hex"
        "hash"
        "io"
        "maps"
        "slices"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/network/testutils"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_bbot"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid"
        "github.com/stretchr/testify/require"
)

func RunDKLs23SignBBOT[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](tb testing.TB, shards map[sharing.ID]*dkls23.Shard[P, B, S], quorum ds.Set[sharing.ID], message []byte, hashFunc func() hash.Hash) *ecdsa.Signature[S] <span class="cov0" title="0">{
        tb.Helper()

        prng := crand.Reader
        var sessionID network.SID
        _, err := io.ReadFull(prng, sessionID[:])
        require.NoError(tb, err)
        tape := hagrid.NewTranscript(hex.EncodeToString(sessionID[:]))
        pk := slices.Collect(maps.Values(shards))[0].PublicKey()
        curve := algebra.StructureMustBeAs[ecdsa.Curve[P, B, S]](pk.Value().Structure())
        ecdsaSuite, err := ecdsa.NewSuite(curve, hashFunc)
        require.NoError(tb, err)

        tapesMap := make(map[sharing.ID]transcripts.Transcript)
        consignersMap := make(map[sharing.ID]*sign_bbot.Cosigner[P, B, S])
        for id := range quorum.Iter() </span><span class="cov0" title="0">{
                shard, ok := shards[id]
                require.True(tb, ok)
                tapesMap[id] = tape.Clone()
                consignersMap[id], err = sign_bbot.NewCosigner(sessionID, quorum, ecdsaSuite, ntu.CBORRoundTrip(tb, shard), prng, tapesMap[id])
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">cosigners := slices.Collect(maps.Values(consignersMap))

        r1bo := make(map[sharing.ID]*sign_bbot.Round1Broadcast)
        r1uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign_bbot.Round1P2P[P, B, S]])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r1bo[cosigner.SharingID()], r1uo[cosigner.SharingID()], err = cosigner.Round1()
                require.NoError(tb, err)

        }</span>

        <span class="cov0" title="0">r2bi, r2ui := ntu.MapO2I(tb, cosigners, r1bo, r1uo)
        r2bo := make(map[sharing.ID]*sign_bbot.Round2Broadcast[P, B, S])
        r2uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign_bbot.Round2P2P[P, B, S]])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r2bo[cosigner.SharingID()], r2uo[cosigner.SharingID()], err = cosigner.Round2(r2bi[cosigner.SharingID()], r2ui[cosigner.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r3bi, r3ui := ntu.MapO2I(tb, cosigners, r2bo, r2uo)
        r3bo := make(map[sharing.ID]*sign_bbot.Round3Broadcast[P, B, S])
        r3uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign_bbot.Round3P2P[P, B, S]])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r3bo[cosigner.SharingID()], r3uo[cosigner.SharingID()], err = cosigner.Round3(r3bi[cosigner.SharingID()], r3ui[cosigner.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r4bi, r4ui := ntu.MapO2I(tb, cosigners, r3bo, r3uo)
        partialSignatures := make(map[sharing.ID]*dkls23.PartialSignature[P, B, S])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                partialSignatures[cosigner.SharingID()], err = cosigner.Round4(r4bi[cosigner.SharingID()], r4ui[cosigner.SharingID()], message)
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">signature, err := dkls23.Aggregate(ecdsaSuite, pk, message, slices.Collect(maps.Values(partialSignatures))...)
        require.NoError(tb, err)

        // transcripts match
        transcriptsBytes := make(map[sharing.ID][]byte)
        for id, tape := range tapesMap </span><span class="cov0" title="0">{
                var err error
                transcriptsBytes[id], err = tape.ExtractBytes("test", 32)
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">transcriptBytesSlice := slices.Collect(maps.Values(transcriptsBytes))
        require.True(tb, sliceutils.All(transcriptBytesSlice, func(b []byte) bool </span><span class="cov0" title="0">{ return bytes.Equal(transcriptBytesSlice[0], b) }</span>))

        <span class="cov0" title="0">return signature</span>
}
</pre>
		
		<pre class="file" id="file386" style="display: none">package sign_bbot

import (
        "iter"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

type message[B network.Message, U network.Message] struct {
        broadcast B
        p2p       U
}

func validateIncomingMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], MB network.Message, MU network.Message](c *Cosigner[P, B, S], rIn network.Round, bIn network.RoundMessages[MB], uIn network.RoundMessages[MU]) (iter.Seq2[sharing.ID, message[MB, MU]], error) <span class="cov8" title="1">{
        if rIn != c.state.round </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">return func(yield func(p sharing.ID, m message[MB, MU]) bool) </span><span class="cov8" title="1">{
                for id := range c.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == c.shard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">b, ok := bIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing broadcast message")</span>
                        }
                        <span class="cov8" title="1">u, ok := uIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing broadcast message")</span>
                        }
                        <span class="cov8" title="1">if !yield(id, message[MB, MU]{broadcast: b, p2p: u}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }, nil
}

type messagePointerConstraint[MP network.Message, M any] interface {
        *M
        network.Message
}

func outgoingP2PMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], UPtr messagePointerConstraint[UPtr, U], U any](c *Cosigner[P, B, S], uOut ds.MutableMap[sharing.ID, UPtr]) iter.Seq2[sharing.ID, UPtr] <span class="cov8" title="1">{
        return func(yield func(p sharing.ID, out UPtr) bool) </span><span class="cov8" title="1">{
                for id := range c.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == c.shard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">u := new(U)
                        if !yield(id, UPtr(u)) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">uOut.Put(id, UPtr(u))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file387" style="display: none">package sign_softspoken

import (
        "crypto/sha256"
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "io"
        "iter"

        "golang.org/x/crypto/blake2b"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/ot"
        "github.com/bronlabs/bron-crypto/pkg/ot/base/vsot"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        rvole_softspoken "github.com/bronlabs/bron-crypto/pkg/threshold/rvole/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel     = "BRON_CRYPTO_TECDSA_DKLS23_SOFTSPOKEN-"
        mulLabel            = "BRON_CRYPTO_TECDSA_DKLS23_SOFTSPOKEN_MUL-"
        ckLabel             = "BRON_CRYPTO_TECDSA_DKLS23_SOFTSPOKEN_CK-"
        przsRandomizerLabel = "BRON_CRYPTO_TECDSA_DKLS23_SOFTSPOKEN_PRZS_RANDOMIZER-"
        otRandomizerLabel   = "BRON_CRYPTO_TECDSA_DKLS23_SOFTSPOKEN_OT_RANDOMIZER-"
)

// Cosigner represents a signing participant.
type Cosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        suite     *ecdsa.Suite[P, B, S]
        sessionID network.SID
        shard     *dkls23.Shard[P, B, S]
        zeroSeeds przs.Seeds
        quorum    network.Quorum
        prng      io.Reader
        tape      transcripts.Transcript
        state     CosignerState[P, B, S]
}

// CosignerState tracks per-round signing state.
type CosignerState[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        zeroSampler *przs.Sampler[S]
        aliceMul    map[sharing.ID]*rvole_softspoken.Alice[P, B, S]
        bobMul      map[sharing.ID]*rvole_softspoken.Bob[P, B, S]

        round          network.Round
        ck             *hash_comm.Scheme
        r              S
        bigR           map[sharing.ID]P
        bigRCommitment map[sharing.ID]hash_comm.Commitment
        bigRWitness    hash_comm.Witness
        phi            S
        chi            map[sharing.ID]S
        c              map[sharing.ID][]S
        sk             S
        pk             map[sharing.ID]P
}

// NewCosigner returns a new cosigner.
func NewCosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, quorum network.Quorum, suite *ecdsa.Suite[P, B, S], shard *dkls23.Shard[P, B, S], prng io.Reader, tape transcripts.Transcript) (*Cosigner[P, B, S], error) <span class="cov8" title="1">{
        if quorum == nil || suite == nil || shard == nil || prng == nil || tape == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("argument")
        }</span>
        <span class="cov8" title="1">if suite.IsDeterministic() </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("suite must be non-deterministic")
        }</span>
        <span class="cov8" title="1">if !quorum.Contains(shard.Share().ID()) </span><span class="cov0" title="0">{
                return nil, ErrValidation.WithMessage("sharing id not part of the quorum")
        }</span>

        <span class="cov8" title="1">tape.AppendDomainSeparator(fmt.Sprintf("%s%s", transcriptLabel, hex.EncodeToString(sessionID[:])))
        zeroSeeds, err := randomizeZeroSeeds(shard.ZeroSeeds(), tape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't randomise zero seeds")
        }</span>
        <span class="cov8" title="1">otSenderSeeds, otReceiverSeeds, err := randomizeOTSeeds(shard.OTSenderSeeds(), shard.OTReceiverSeeds(), tape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("couldn't randomise OT seeds")
        }</span>

        //nolint:exhaustruct // lazy initialisation
        <span class="cov8" title="1">c := &amp;Cosigner[P, B, S]{
                shard:     shard,
                zeroSeeds: zeroSeeds,
                quorum:    quorum,
                suite:     suite,
                prng:      prng,
                tape:      tape,
        }

        c.state.aliceMul = make(map[sharing.ID]*rvole_softspoken.Alice[P, B, S])
        c.state.bobMul = make(map[sharing.ID]*rvole_softspoken.Bob[P, B, S])
        mulSuite, err := rvole_softspoken.NewSuite(2, suite.Curve(), sha256.New)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create mul suite")
        }</span>
        <span class="cov8" title="1">for id := range c.otherCosigners() </span><span class="cov8" title="1">{
                aliceSeed, ok := otReceiverSeeds.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("couldn't find alice seed")
                }</span>
                <span class="cov8" title="1">aliceTape := tape.Clone()
                aliceTape.AppendBytes(mulLabel, binary.LittleEndian.AppendUint64(nil, uint64(c.shard.Share().ID())), binary.LittleEndian.AppendUint64(nil, uint64(id)))
                c.state.aliceMul[id], err = rvole_softspoken.NewAlice(c.sessionID, mulSuite, aliceSeed, prng, aliceTape)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("couldn't initialise Alice")
                }</span>

                <span class="cov8" title="1">bobSeed, ok := otSenderSeeds.Get(id)
                if !ok </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("couldn't find bob seed")
                }</span>
                <span class="cov8" title="1">bobTape := tape.Clone()
                bobTape.AppendBytes(mulLabel, binary.LittleEndian.AppendUint64(nil, uint64(id)), binary.LittleEndian.AppendUint64(nil, uint64(c.shard.Share().ID())))
                c.state.bobMul[id], err = rvole_softspoken.NewBob(c.sessionID, mulSuite, bobSeed, prng, bobTape)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("couldn't initialise Bob")
                }</span>
        }

        <span class="cov8" title="1">c.state.round = 1
        return c, nil</span>
}

// SharingID returns the participant sharing identifier.
func (c *Cosigner[P, B, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return c.shard.Share().ID()
}</span>

// Quorum returns the protocol quorum.
func (c *Cosigner[P, B, S]) Quorum() network.Quorum <span class="cov0" title="0">{
        return c.quorum
}</span>

func (c *Cosigner[P, B, S]) otherCosigners() iter.Seq[sharing.ID] <span class="cov8" title="1">{
        return func(yield func(id sharing.ID) bool) </span><span class="cov8" title="1">{
                for id := range c.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == c.shard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if !yield(id) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

func randomizeZeroSeeds(seeds przs.Seeds, tape transcripts.Transcript) (przs.Seeds, error) <span class="cov8" title="1">{
        randomizerKey, err := tape.ExtractBytes(przsRandomizerLabel, (2*base.ComputationalSecurityBits+7)/8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot extract randomizer")
        }</span>

        <span class="cov8" title="1">randomizedSeeds := hashmap.NewComparable[sharing.ID, [przs.SeedLength]byte]()
        for id, seed := range seeds.Iter() </span><span class="cov8" title="1">{
                hasher, err := blake2b.New(przs.SeedLength, randomizerKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create hasher")
                }</span>
                <span class="cov8" title="1">_, err = hasher.Write(seed[:])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot hash seed")
                }</span>
                <span class="cov8" title="1">randomizedSeedBytes := hasher.Sum(nil)
                var randomizedSeed [przs.SeedLength]byte
                copy(randomizedSeed[:], randomizedSeedBytes)
                randomizedSeeds.Put(id, randomizedSeed)</span>
        }
        <span class="cov8" title="1">return randomizedSeeds.Freeze(), nil</span>
}

func randomizeOTSeeds(senderSeeds ds.Map[sharing.ID, *vsot.SenderOutput], receiverSeeds ds.Map[sharing.ID, *vsot.ReceiverOutput], tape transcripts.Transcript) (rss ds.Map[sharing.ID, *vsot.SenderOutput], rrs ds.Map[sharing.ID, *vsot.ReceiverOutput], err error) <span class="cov8" title="1">{
        randomizerKey, err := tape.ExtractBytes(otRandomizerLabel, (2*base.ComputationalSecurityBits+7)/8)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot extract randomizer")
        }</span>

        <span class="cov8" title="1">randomizedSenderSeeds := hashmap.NewComparable[sharing.ID, *vsot.SenderOutput]()
        for id, seed := range senderSeeds.Iter() </span><span class="cov8" title="1">{
                randomizedSenderMessagePairs := make([][2][][]byte, seed.InferredXi())
                for xi := range seed.InferredXi() </span><span class="cov8" title="1">{
                        randomizedSenderMessagePairs[xi][0] = make([][]byte, seed.InferredL())
                        randomizedSenderMessagePairs[xi][1] = make([][]byte, seed.InferredL())
                        for l := range seed.InferredL() </span><span class="cov8" title="1">{
                                hasher, err := blake2b.New(len(seed.Messages[xi][0][l]), randomizerKey)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create hasher")
                                }</span>
                                <span class="cov8" title="1">_, err = hasher.Write(seed.Messages[xi][0][l])
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errs2.Wrap(err).WithMessage("cannot hash seed")
                                }</span>
                                <span class="cov8" title="1">randomizedSenderMessagePairs[xi][0][l] = hasher.Sum(nil)

                                hasher, err = blake2b.New(len(seed.Messages[xi][1][l]), randomizerKey)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create hasher")
                                }</span>
                                <span class="cov8" title="1">_, err = hasher.Write(seed.Messages[xi][1][l])
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errs2.Wrap(err).WithMessage("cannot hash seed")
                                }</span>
                                <span class="cov8" title="1">randomizedSenderMessagePairs[xi][1][l] = hasher.Sum(nil)</span>
                        }
                }
                <span class="cov8" title="1">randomizedSenderSeeds.Put(id, &amp;vsot.SenderOutput{
                        SenderOutput: ot.SenderOutput[[]byte]{
                                Messages: randomizedSenderMessagePairs,
                        },
                })</span>
        }

        <span class="cov8" title="1">randomizedReceiverSeeds := hashmap.NewComparable[sharing.ID, *vsot.ReceiverOutput]()
        for id, seed := range receiverSeeds.Iter() </span><span class="cov8" title="1">{
                randomizedReceiverMessages := make([][][]byte, seed.InferredXi())
                for xi := range seed.InferredXi() </span><span class="cov8" title="1">{
                        randomizedReceiverMessages[xi] = make([][]byte, seed.InferredL())
                        randomizedReceiverMessages[xi] = make([][]byte, seed.InferredL())
                        for l := range seed.InferredL() </span><span class="cov8" title="1">{
                                hasher, err := blake2b.New(len(seed.Messages[xi][l]), randomizerKey)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create hasher")
                                }</span>
                                <span class="cov8" title="1">_, err = hasher.Write(seed.Messages[xi][l])
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, errs2.Wrap(err).WithMessage("cannot hash seed")
                                }</span>
                                <span class="cov8" title="1">randomizedReceiverMessages[xi][l] = hasher.Sum(nil)</span>
                        }
                }
                <span class="cov8" title="1">randomizedReceiverSeeds.Put(id, &amp;vsot.ReceiverOutput{
                        ReceiverOutput: ot.ReceiverOutput[[]byte]{
                                Choices:  seed.Choices,
                                Messages: randomizedReceiverMessages,
                        },
                })</span>
        }

        <span class="cov8" title="1">return randomizedSenderSeeds.Freeze(), randomizedReceiverSeeds.Freeze(), nil</span>
}
</pre>
		
		<pre class="file" id="file388" style="display: none">package sign_softspoken

import (
        "maps"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        rvole_softspoken "github.com/bronlabs/bron-crypto/pkg/threshold/rvole/softspoken"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/zero/przs"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
)

// Round1 executes protocol round 1.
func (c *Cosigner[P, B, S]) Round1() (r1b *Round1Broadcast, r1u network.RoundMessages[*Round1P2P], err error) <span class="cov8" title="1">{
        if c.state.round != 1 </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">var ck [hash_comm.KeySize]byte
        ckBytes, err := c.tape.ExtractBytes(ckLabel, uint(len(ck)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("failed to extract commitment key")
        }</span>
        <span class="cov8" title="1">copy(ck[:], ckBytes)
        c.state.ck, err = hash_comm.NewScheme(ck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create commitment scheme")
        }</span>

        <span class="cov8" title="1">c.state.r, err = c.suite.ScalarField().Random(c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample r")
        }</span>
        <span class="cov8" title="1">c.state.bigR = make(map[sharing.ID]P)
        c.state.bigR[c.shard.Share().ID()] = c.suite.Curve().ScalarBaseMul(c.state.r)
        c.state.bigRCommitment = make(map[sharing.ID]hash_comm.Commitment)
        c.state.bigRCommitment[c.shard.Share().ID()], c.state.bigRWitness, err = c.state.ck.Committer().Commit(c.state.bigR[c.shard.Share().ID()].ToCompressed(), c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot commit to r")
        }</span>

        <span class="cov8" title="1">c.state.phi, err = c.suite.ScalarField().Random(c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot sample phi")
        }</span>

        <span class="cov8" title="1">c.state.chi = make(map[sharing.ID]S)
        bOut := &amp;Round1Broadcast{
                BigRCommitment: c.state.bigRCommitment[c.shard.Share().ID()],
        }
        uOut := hashmap.NewComparable[sharing.ID, *Round1P2P]()
        for id, message := range outgoingP2PMessages(c, uOut) </span><span class="cov8" title="1">{
                message.MulR1, c.state.chi[id], err = c.state.bobMul[id].Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run Bob mul round1")
                }</span>
        }

        <span class="cov8" title="1">c.state.round++
        return bOut, uOut.Freeze(), nil</span>
}

// Round2 executes protocol round 2.
func (c *Cosigner[P, B, S]) Round2(r1b network.RoundMessages[*Round1Broadcast], r1u network.RoundMessages[*Round1P2P]) (r2b *Round2Broadcast[P, B, S], r2u network.RoundMessages[*Round2P2P[P, B, S]], err error) <span class="cov8" title="1">{
        incomingMessages, err := validateIncomingMessages(c, 2, r1b, r1u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, ErrFailed.WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">mulR1 := make(map[sharing.ID]*rvole_softspoken.Round1P2P)
        for id, message := range incomingMessages </span><span class="cov8" title="1">{
                c.state.bigRCommitment[id] = message.broadcast.BigRCommitment
                mulR1[id] = message.p2p.MulR1
        }</span>

        <span class="cov8" title="1">c.state.zeroSampler, err = przs.NewSampler(c.shard.Share().ID(), c.quorum, c.zeroSeeds, c.suite.ScalarField())
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run zero setup round3")
        }</span>
        <span class="cov8" title="1">zeta, err := c.state.zeroSampler.Sample()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot run zero setup round3")
        }</span>

        <span class="cov8" title="1">quorum, err := sharing.NewMinimalQualifiedAccessStructure(c.quorum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create minimal qualified access structure")
        }</span>
        <span class="cov8" title="1">sk, err := c.shard.Share().ToAdditive(quorum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("to additive share failed")
        }</span>
        <span class="cov8" title="1">c.state.sk = sk.Value().Add(zeta)
        c.state.pk = make(map[sharing.ID]P)
        c.state.pk[c.shard.Share().ID()] = c.suite.Curve().ScalarBaseMul(c.state.sk)
        c.state.c = make(map[sharing.ID][]S)

        bOut := &amp;Round2Broadcast[P, B, S]{
                BigR:        c.state.bigR[c.shard.Share().ID()],
                BigRWitness: c.state.bigRWitness,
                Pk:          c.state.pk[c.shard.Share().ID()],
        }
        uOut := hashmap.NewComparable[sharing.ID, *Round2P2P[P, B, S]]()
        for id, message := range outgoingP2PMessages(c, uOut) </span><span class="cov8" title="1">{
                message.MulR2, c.state.c[id], err = c.state.aliceMul[id].Round2(mulR1[id], []S{c.state.r, c.state.sk})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot run alice mul round2")
                }</span>
                <span class="cov8" title="1">message.GammaU = c.suite.Curve().ScalarBaseMul(c.state.c[id][0])
                message.GammaV = c.suite.Curve().ScalarBaseMul(c.state.c[id][1])
                message.Psi = c.state.phi.Sub(c.state.chi[id])</span>
        }

        <span class="cov8" title="1">c.state.round++
        return bOut, uOut.Freeze(), nil</span>
}

// Round3 executes protocol round 3.
func (c *Cosigner[P, B, S]) Round3(r2b network.RoundMessages[*Round2Broadcast[P, B, S]], r2u network.RoundMessages[*Round2P2P[P, B, S]], message []byte) (partialSignature *dkls23.PartialSignature[P, B, S], err error) <span class="cov8" title="1">{
        incomingMessages, err := validateIncomingMessages(c, 3, r2b, r2u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid input or round mismatch")
        }</span>

        <span class="cov8" title="1">psi := c.suite.ScalarField().Zero()
        cudu := c.suite.ScalarField().Zero()
        cvdv := c.suite.ScalarField().Zero()
        for id, message := range incomingMessages </span><span class="cov8" title="1">{
                if err := c.state.ck.Verifier().Verify(c.state.bigRCommitment[id], message.broadcast.BigR.ToCompressed(), message.broadcast.BigRWitness); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("invalid commitment")
                }</span>
                <span class="cov8" title="1">c.state.bigR[id] = message.broadcast.BigR

                d, err := c.state.bobMul[id].Round3(message.p2p.MulR2)
                if err != nil </span><span class="cov0" title="0">{
                        if errs2.Is(err, base.ErrAbort) </span><span class="cov0" title="0">{
                                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("cannot run Bob mul round3")
                        }</span>
                        <span class="cov0" title="0">return nil, errs2.Wrap(err).WithMessage("cannot run Bob mul round3")</span>
                }
                <span class="cov8" title="1">if !c.state.bigR[id].ScalarMul(c.state.chi[id]).Sub(message.p2p.GammaU).Equal(c.suite.Curve().ScalarBaseMul(d[0])) </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("consistency check failed")
                }</span>
                <span class="cov8" title="1">if !message.broadcast.Pk.ScalarMul(c.state.chi[id]).Sub(message.p2p.GammaV).Equal(c.suite.Curve().ScalarBaseMul(d[1])) </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("consistency check failed")
                }</span>
                <span class="cov8" title="1">c.state.pk[id] = message.broadcast.Pk

                psi = psi.Add(message.p2p.Psi)
                cudu = cudu.Add(c.state.c[id][0].Add(d[0]))
                cvdv = cvdv.Add(c.state.c[id][1].Add(d[1]))</span>
        }

        <span class="cov8" title="1">bigR := sliceutils.Fold(func(x, y P) P </span><span class="cov8" title="1">{ return x.Add(y) }</span>, c.suite.Curve().OpIdentity(), slices.Collect(maps.Values(c.state.bigR))...)
        <span class="cov8" title="1">pk := sliceutils.Fold(func(x, y P) P </span><span class="cov8" title="1">{ return x.Add(y) }</span>, c.suite.Curve().OpIdentity(), slices.Collect(maps.Values(c.state.pk))...)
        <span class="cov8" title="1">if !pk.Equal(c.shard.PublicKey().Value()) </span><span class="cov0" title="0">{
                return nil, base.ErrAbort.WithMessage("consistency check failed")
        }</span>

        <span class="cov8" title="1">u := c.state.r.Mul(c.state.phi.Add(psi)).Add(cudu)
        v := c.state.sk.Mul(c.state.phi.Add(psi)).Add(cvdv)
        digest, err := hashing.Hash(c.suite.HashFunc(), message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot hash message")
        }</span>
        <span class="cov8" title="1">m, err := ecdsa.DigestToScalar(c.suite.ScalarField(), digest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute message scalar")
        }</span>
        <span class="cov8" title="1">rxi, err := bigR.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert to affine x")
        }</span>
        <span class="cov8" title="1">rx, err := c.suite.ScalarField().FromWideBytes(rxi.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert to scalar")
        }</span>
        <span class="cov8" title="1">w := m.Mul(c.state.phi).Add(rx.Mul(v))

        partialSignature, err = dkls23.NewPartialSignature(bigR, u, w)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create partial signature")
        }</span>
        <span class="cov8" title="1">return partialSignature, nil</span>
}
</pre>
		
		<pre class="file" id="file389" style="display: none">package testutils

import (
        "bytes"
        crand "crypto/rand"
        "encoding/hex"
        "hash"
        "io"
        "maps"
        "slices"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/network/testutils"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/dkls23/signing/interactive/sign_softspoken"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid"
        "github.com/stretchr/testify/require"
)

func RunDKLs23SignSoftspokenOT[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](tb testing.TB, shards map[sharing.ID]*dkls23.Shard[P, B, S], quorum ds.Set[sharing.ID], message []byte, hashFunc func() hash.Hash) *ecdsa.Signature[S] <span class="cov0" title="0">{
        tb.Helper()

        prng := crand.Reader
        var sessionID network.SID
        _, err := io.ReadFull(prng, sessionID[:])
        require.NoError(tb, err)
        tape := hagrid.NewTranscript(hex.EncodeToString(sessionID[:]))
        pk := slices.Collect(maps.Values(shards))[0].PublicKey()
        curve := algebra.StructureMustBeAs[ecdsa.Curve[P, B, S]](pk.Value().Structure())
        ecdsaSuite, err := ecdsa.NewSuite(curve, hashFunc)
        require.NoError(tb, err)

        tapesMap := make(map[sharing.ID]transcripts.Transcript)
        consignersMap := make(map[sharing.ID]*sign_softspoken.Cosigner[P, B, S])
        for id := range quorum.Iter() </span><span class="cov0" title="0">{
                shard, ok := shards[id]
                require.True(tb, ok)
                tapesMap[id] = tape.Clone()
                consignersMap[id], err = sign_softspoken.NewCosigner(sessionID, quorum, ecdsaSuite, ntu.CBORRoundTrip(tb, shard), prng, tapesMap[id])
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">cosigners := slices.Collect(maps.Values(consignersMap))

        r1bo := make(map[sharing.ID]*sign_softspoken.Round1Broadcast)
        r1uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign_softspoken.Round1P2P])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r1bo[cosigner.SharingID()], r1uo[cosigner.SharingID()], err = cosigner.Round1()
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r2bi, r2ui := ntu.MapO2I(tb, cosigners, r1bo, r1uo)
        r2bo := make(map[sharing.ID]*sign_softspoken.Round2Broadcast[P, B, S])
        r2uo := make(map[sharing.ID]ds.Map[sharing.ID, *sign_softspoken.Round2P2P[P, B, S]])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                r2bo[cosigner.SharingID()], r2uo[cosigner.SharingID()], err = cosigner.Round2(r2bi[cosigner.SharingID()], r2ui[cosigner.SharingID()])
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">r3bi, r3ui := ntu.MapO2I(tb, cosigners, r2bo, r2uo)
        partialSignatures := make(map[sharing.ID]*dkls23.PartialSignature[P, B, S])
        for _, cosigner := range cosigners </span><span class="cov0" title="0">{
                partialSignatures[cosigner.SharingID()], err = cosigner.Round3(r3bi[cosigner.SharingID()], r3ui[cosigner.SharingID()], message)
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">signature, err := dkls23.Aggregate(ecdsaSuite, pk, message, slices.Collect(maps.Values(partialSignatures))...)
        require.NoError(tb, err)

        // transcripts match
        transcriptsBytes := make(map[sharing.ID][]byte)
        for id, tape := range tapesMap </span><span class="cov0" title="0">{
                var err error
                transcriptsBytes[id], err = tape.ExtractBytes("test", 32)
                require.NoError(tb, err)
        }</span>
        <span class="cov0" title="0">transcriptBytesSlice := slices.Collect(maps.Values(transcriptsBytes))
        require.True(tb, sliceutils.All(transcriptBytesSlice, func(b []byte) bool </span><span class="cov0" title="0">{ return bytes.Equal(transcriptBytesSlice[0], b) }</span>))

        <span class="cov0" title="0">return signature</span>
}
</pre>
		
		<pre class="file" id="file390" style="display: none">package sign_softspoken

import (
        "iter"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

type message[B network.Message, U network.Message] struct {
        broadcast B
        p2p       U
}

func validateIncomingMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], MB network.Message, MU network.Message](c *Cosigner[P, B, S], rIn network.Round, bIn network.RoundMessages[MB], uIn network.RoundMessages[MU]) (iter.Seq2[sharing.ID, message[MB, MU]], error) <span class="cov8" title="1">{
        if rIn != c.state.round </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("invalid round")
        }</span>

        <span class="cov8" title="1">return func(yield func(p sharing.ID, m message[MB, MU]) bool) </span><span class="cov8" title="1">{
                for id := range c.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == c.shard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">b, ok := bIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing broadcast message")</span>
                        }
                        <span class="cov8" title="1">u, ok := uIn.Get(id)
                        if !ok </span><span class="cov0" title="0">{
                                panic("this should never happen: missing unicast message")</span>
                        }
                        <span class="cov8" title="1">if !yield(id, message[MB, MU]{broadcast: b, p2p: u}) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }, nil
}

type messagePointerConstraint[MP network.Message, M any] interface {
        *M
        network.Message
}

func outgoingP2PMessages[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S], UPtr messagePointerConstraint[UPtr, U], U any](c *Cosigner[P, B, S], uOut ds.MutableMap[sharing.ID, UPtr]) iter.Seq2[sharing.ID, UPtr] <span class="cov8" title="1">{
        return func(yield func(p sharing.ID, out UPtr) bool) </span><span class="cov8" title="1">{
                for id := range c.quorum.Iter() </span><span class="cov8" title="1">{
                        if id == c.shard.Share().ID() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">u := new(U)
                        if !yield(id, UPtr(u)) </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">uOut.Put(id, UPtr(u))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file391" style="display: none">package lindell17

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
)

// DecomposeTwoThirds splits a scalar into x', x with x = 3x' + x in range [q/3, 2q/3).
func DecomposeTwoThirds[S algebra.PrimeFieldElement[S]](scalar S, prng io.Reader) (xPrime, xDoublePrime S, err error) <span class="cov0" title="0">{
        var nilS S
        field := algebra.StructureMustBeAs[algebra.PrimeField[S]](scalar.Structure())

        switch </span>{
        case inEighteenth(0, 3, scalar):<span class="cov0" title="0">
                xPrime, err = randomInEighteenth(9, 10, field, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilS, nilS, errs2.Wrap(err).WithMessage("could not construct xPrime")
                }</span>
                <span class="cov0" title="0">xDoublePrime = scalar.Sub(xPrime).Sub(xPrime).Sub(xPrime)</span>
        case inEighteenth(3, 6, scalar):<span class="cov0" title="0">
                xPrime, err = randomInEighteenth(10, 11, field, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilS, nilS, errs2.Wrap(err).WithMessage("could not construct xPrime")
                }</span>
                <span class="cov0" title="0">xDoublePrime = scalar.Sub(xPrime).Sub(xPrime).Sub(xPrime)</span>
        case inEighteenth(6, 9, scalar):<span class="cov0" title="0">
                xPrime, err = randomInEighteenth(11, 12, field, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilS, nilS, errs2.Wrap(err).WithMessage("could not construct xPrime")
                }</span>
                <span class="cov0" title="0">xDoublePrime = scalar.Sub(xPrime).Sub(xPrime).Sub(xPrime)</span>
        case inEighteenth(9, 12, scalar):<span class="cov0" title="0">
                xPrime, err = randomInEighteenth(6, 7, field, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilS, nilS, errs2.Wrap(err).WithMessage("could not construct xPrime")
                }</span>
                <span class="cov0" title="0">xDoublePrime = scalar.Sub(xPrime).Sub(xPrime).Sub(xPrime)</span>
        case inEighteenth(12, 15, scalar):<span class="cov0" title="0">
                xPrime, err = randomInEighteenth(7, 8, field, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilS, nilS, errs2.Wrap(err).WithMessage("could not construct xPrime")
                }</span>
                <span class="cov0" title="0">xDoublePrime = scalar.Sub(xPrime).Sub(xPrime).Sub(xPrime)</span>
        case inEighteenth(15, 18, scalar):<span class="cov0" title="0">
                xPrime, err = randomInEighteenth(8, 9, field, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nilS, nilS, errs2.Wrap(err).WithMessage("could not construct xPrime")
                }</span>
                <span class="cov0" title="0">xDoublePrime = scalar.Sub(xPrime).Sub(xPrime).Sub(xPrime)</span>
        default:<span class="cov0" title="0">
                panic("this should never happen")</span>
        }

        <span class="cov0" title="0">if !inEighteenth(6, 12, xPrime) || !inEighteenth(6, 12, xDoublePrime) </span><span class="cov0" title="0">{
                return nilS, nilS, ErrFailed.WithMessage("split failed")
        }</span>
        <span class="cov0" title="0">if !xPrime.Add(xPrime).Add(xPrime).Add(xDoublePrime).Equal(scalar) </span><span class="cov0" title="0">{
                return nilS, nilS, ErrFailed.WithMessage("split failed")
        }</span>
        <span class="cov0" title="0">return xPrime, xDoublePrime, nil</span>
}

func inEighteenth[S algebra.PrimeFieldElement[S]](lowBoundInclusive, highBoundExclusive uint64, x S) bool <span class="cov0" title="0">{
        field := algebra.StructureMustBeAs[algebra.PrimeField[S]](x.Structure())
        orderNat, err := num.N().FromCardinal(field.Order())
        if err != nil </span><span class="cov0" title="0">{
                // this should never happen
                panic(err)</span>
        }
        <span class="cov0" title="0">order := orderNat.Lift()

        xNat, err := num.N().FromBytes(x.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                // this should never happen
                panic(err)</span>
        }
        <span class="cov0" title="0">xInt := xNat.Lift()

        x18 := xInt.Mul(num.Z().FromUint64(18))
        low18 := order.Mul(num.Z().FromUint64(lowBoundInclusive))
        high18 := order.Mul(num.Z().FromUint64(highBoundExclusive))
        if low18.IsLessThanOrEqual(x18) &amp;&amp; !high18.IsLessThanOrEqual(x18) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func randomInEighteenth[S algebra.PrimeFieldElement[S]](lowBoundInclusive, highBoundExclusive uint64, field algebra.PrimeField[S], prng io.Reader) (S, error) <span class="cov0" title="0">{
        var nilS S
        orderNat, err := num.N().FromCardinal(field.Order())
        if err != nil </span><span class="cov0" title="0">{
                // this should never happen
                panic(err)</span>
        }
        <span class="cov0" title="0">order := orderNat.Lift()

        l18 := order.Mul(num.Z().FromUint64(lowBoundInclusive))
        h18 := order.Mul(num.Z().FromUint64(highBoundExclusive))
        l, _, err := l18.Add(num.Z().FromUint64(17)).EuclideanDivVarTime(num.Z().FromUint64(18))
        if err != nil </span><span class="cov0" title="0">{
                return nilS, errs2.Wrap(err).WithMessage("could not compute lower bound")
        }</span>
        <span class="cov0" title="0">h, _, err := h18.EuclideanDivVarTime(num.Z().FromUint64(18))
        if err != nil </span><span class="cov0" title="0">{
                return nilS, errs2.Wrap(err).WithMessage("could not compute upper bound")
        }</span>
        <span class="cov0" title="0">x, err := num.Z().Random(l, h, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nilS, errs2.Wrap(err).WithMessage("could not generate random rational")
        }</span>
        <span class="cov0" title="0">s, err := field.FromWideBytes(x.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nilS, errs2.Wrap(err).WithMessage("could not convert to scalar")
        }</span>
        <span class="cov0" title="0">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file392" style="display: none">package dkg

import (
        "encoding/binary"
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/network"
        schnorrpok "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lp"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lpdl"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel = "BRON_CRYPTO_LINDELL17_DKG-"
)

// Participant runs the Lindell17 DKG protocol.
type Participant[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        round uint
        // Base participant
        prng  io.Reader
        curve ecdsa.Curve[P, B, S]
        sid   network.SID
        tape  transcripts.Transcript

        // Threshold participant
        shard       *tecdsa.Shard[P, B, S]
        nic         compiler.Name
        quorumBytes [][]byte
        state       *State[P, B, S]
}

// State holds internal DKG state across rounds.
type State[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        myXPrime          S
        myXDoublePrime    S
        myBigQPrime       P
        myBigQDoublePrime P
        myBigQOpening     hash_comm.Witness
        myPaillierPk      *paillier.PublicKey
        myPaillierSk      *paillier.PrivateKey
        myRPrime          *paillier.Nonce
        myRDoublePrime    *paillier.Nonce

        paillierScheme    *paillier.Scheme
        commitmentSchemes map[sharing.ID]*hash_comm.Scheme
        niDlogScheme      compiler.NonInteractiveProtocol[*schnorrpok.Statement[P, S], *schnorrpok.Witness[S]]

        theirBigQCommitment          map[sharing.ID]hash_comm.Commitment
        theirBigQPrime               map[sharing.ID]P
        theirBigQDoublePrime         map[sharing.ID]P
        theirPaillierPublicKeys      map[sharing.ID]*paillier.PublicKey
        theirPaillierEncryptedShares map[sharing.ID]*paillier.Ciphertext

        lpProvers                map[sharing.ID]*lp.Prover
        lpVerifiers              map[sharing.ID]*lp.Verifier
        lpdlPrimeProvers         map[sharing.ID]*lpdl.Prover[P, B, S]
        lpdlPrimeVerifiers       map[sharing.ID]*lpdl.Verifier[P, B, S]
        lpdlDoublePrimeProvers   map[sharing.ID]*lpdl.Prover[P, B, S]
        lpdlDoublePrimeVerifiers map[sharing.ID]*lpdl.Verifier[P, B, S]
}

// NewParticipant constructs a DKG participant.
func NewParticipant[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](
        sid network.SID,
        shard *tecdsa.Shard[P, B, S],
        curve ecdsa.Curve[P, B, S],
        prng io.Reader,
        nic compiler.Name,
        tape transcripts.Transcript,
) (*Participant[P, B, S], error) <span class="cov8" title="1">{
        if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("prng must not be nil")
        }</span>
        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("tape must not be nil")
        }</span>
        <span class="cov8" title="1">if shard == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("shard must not be nil")
        }</span>
        <span class="cov8" title="1">if !compiler.IsSupported(nic) </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("unsupported NIC: %s", nic)
        }</span>

        <span class="cov8" title="1">dst := fmt.Sprintf("%s_%s_%s_%s", transcriptLabel, sid, nic, curve.Name())
        tape.AppendDomainSeparator(dst)

        commitmentSchemes := make(map[sharing.ID]*hash_comm.Scheme)
        for id := range shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                ck, err := hash_comm.NewKeyFromCRSBytes(
                        sid, dst, binary.BigEndian.AppendUint64(nil, uint64(id)),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not create commitment key from CRS")
                }</span>
                <span class="cov8" title="1">scheme, err := hash_comm.NewScheme(ck)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("could not create commitment scheme")
                }</span>
                <span class="cov8" title="1">commitmentSchemes[id] = scheme</span>
        }

        <span class="cov8" title="1">schnorrProtocol, err := schnorrpok.NewProtocol(curve.Generator(), prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create schnorr protocol")
        }</span>
        <span class="cov8" title="1">niDlogScheme, err := compiler.Compile(nic, schnorrProtocol, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compile niDlogProver")
        }</span>

        //nolint:exhaustruct // partially initialised
        <span class="cov8" title="1">return &amp;Participant[P, B, S]{
                round:       1,
                prng:        prng,
                curve:       curve,
                sid:         sid,
                nic:         nic,
                tape:        tape,
                shard:       shard,
                quorumBytes: lindell17.QuorumBytes(shard.AccessStructure().Shareholders()),
                //nolint:exhaustruct // partially initialised
                state: &amp;State[P, B, S]{
                        paillierScheme:    paillier.NewScheme(),
                        commitmentSchemes: commitmentSchemes,
                        niDlogScheme:      niDlogScheme,

                        theirBigQCommitment:          make(map[sharing.ID]hash_comm.Commitment),
                        theirBigQPrime:               make(map[sharing.ID]P),
                        theirBigQDoublePrime:         make(map[sharing.ID]P),
                        theirPaillierPublicKeys:      make(map[sharing.ID]*paillier.PublicKey),
                        theirPaillierEncryptedShares: make(map[sharing.ID]*paillier.Ciphertext),

                        lpProvers:                make(map[sharing.ID]*lp.Prover),
                        lpVerifiers:              make(map[sharing.ID]*lp.Verifier),
                        lpdlPrimeProvers:         make(map[sharing.ID]*lpdl.Prover[P, B, S]),
                        lpdlPrimeVerifiers:       make(map[sharing.ID]*lpdl.Verifier[P, B, S]),
                        lpdlDoublePrimeProvers:   make(map[sharing.ID]*lpdl.Prover[P, B, S]),
                        lpdlDoublePrimeVerifiers: make(map[sharing.ID]*lpdl.Verifier[P, B, S]),
                },
        }, nil</span>
}

// SharingID returns the participant sharing identifier.
func (p *Participant[P, B, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return p.shard.Share().ID()
}</span>
</pre>
		
		<pre class="file" id="file393" style="display: none">package dkg

import (
        "encoding/binary"
        "slices"

        "golang.org/x/sync/errgroup"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        schnorrpok "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lp"
        "github.com/bronlabs/bron-crypto/pkg/proofs/paillier/lpdl"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptDLogSLabel = "Lindell2017DKGDLogS-"
        proverLabel          = "Lindell2017DKGProver-"
        bigQTwinLabel        = "Lindell2017DKGBigQTwin-"
)

// Round1 executes the first DKG round.
func (p *Participant[P, B, S]) Round1() (output *Round1Broadcast, err error) <span class="cov8" title="1">{
        // Validation
        if p.round != 1 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but participant expected round %d", 1, p.round)
        }</span>

        // 1.i. choose randomly x' and x'' such that x = 3x' + x'' and both x' and x'' are in (q/3, 2q/3) range
        <span class="cov8" title="1">xPrime, xDoublePrime, err := lindell17.DecomposeTwoThirds(p.shard.Share().Value(), p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot split share")
        }</span>

        // 1.ii. calculate Q' and Q''
        <span class="cov8" title="1">bigQPrime := p.curve.ScalarBaseMul(xPrime)
        bigQDoublePrime := p.curve.ScalarBaseMul(xDoublePrime)

        // 1.iii. calculates commitments Qcom to Q' and Q''
        bigQCommitment, bigQOpening, err := p.state.commitmentSchemes[p.shard.Share().ID()].Committer().Commit(
                slices.Concat(bigQPrime.ToCompressed(), bigQDoublePrime.ToCompressed()),
                p.prng,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot commit to (Q', Q'')")
        }</span>

        <span class="cov8" title="1">p.state.myXPrime = xPrime
        p.state.myXDoublePrime = xDoublePrime
        p.state.myBigQPrime = bigQPrime
        p.state.myBigQDoublePrime = bigQDoublePrime
        p.state.myBigQOpening = bigQOpening

        // 1.iv. broadcast commitments
        p.round++
        return &amp;Round1Broadcast{
                BigQCommitment: bigQCommitment,
        }, nil</span>
}

// Round2 executes the second DKG round.
func (p *Participant[P, B, S]) Round2(input network.RoundMessages[*Round1Broadcast]) (output *Round2Broadcast[P, B, S], err error) <span class="cov8" title="1">{
        // Validation
        if p.round != 2 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but participant expected round %d", 2, p.round)
        }</span>

        // 2. store commitments
        <span class="cov8" title="1">for id := range p.shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.shard.Share().ID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">message, exists := input.Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("no input from participant with sharing id %d", id)
                }</span>
                <span class="cov8" title="1">p.state.theirBigQCommitment[id] = message.BigQCommitment</span>
        }

        // 2.i. calculate proofs of dlog knowledge of Q' and Q'' (Qdl' and Qdl'' respectively)
        <span class="cov8" title="1">dlogTranscript := p.tape.Clone()
        bigQPrimeProof, err := dlogProve(p, p.state.myBigQPrime, p.state.myBigQDoublePrime, p.state.myXPrime, dlogTranscript)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog proof of Q'")
        }</span>
        <span class="cov8" title="1">bigQDoublePrimeProof, err := dlogProve(p, p.state.myBigQDoublePrime, p.state.myBigQPrime, p.state.myXDoublePrime, dlogTranscript)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog proof of Q''")
        }</span>

        // 2.ii. send opening of Qcom revealing Q', Q'' and broadcast proofs of dlog knowledge of these (Qdl', Qdl'' respectively)
        <span class="cov8" title="1">p.round++
        return &amp;Round2Broadcast[P, B, S]{
                BigQOpening:          p.state.myBigQOpening,
                BigQPrime:            p.state.myBigQPrime,
                BigQPrimeProof:       bigQPrimeProof,
                BigQDoublePrime:      p.state.myBigQDoublePrime,
                BigQDoublePrimeProof: bigQDoublePrimeProof,
        }, nil</span>
}

// Round3 executes the third DKG round.
func (p *Participant[P, B, S]) Round3(input network.RoundMessages[*Round2Broadcast[P, B, S]]) (output *Round3Broadcast, err error) <span class="cov8" title="1">{
        // Validation
        if p.round != 3 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but participant expected round %d", 3, p.round)
        }</span>
        // 3.i. verify proofs of dlog knowledge of Qdl'_j Qdl''_j
        <span class="cov8" title="1">for id := range p.shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.SharingID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">message, exists := input.Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("no input from participant with sharing id %d", id)
                }</span>

                // 3.i. open commitments
                <span class="cov8" title="1">if err := p.state.commitmentSchemes[id].Verifier().Verify(
                        p.state.theirBigQCommitment[id],
                        slices.Concat(message.BigQPrime.ToCompressed(), message.BigQDoublePrime.ToCompressed()),
                        message.BigQOpening,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("cannot open (Q', Q'') commitment")
                }</span>

                <span class="cov8" title="1">dlogTranscript := p.tape.Clone()
                if err := dlogVerify(p, id, message.BigQPrimeProof, message.BigQPrime, message.BigQDoublePrime, dlogTranscript); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("cannot verify dlog proof of Q'")
                }</span>
                <span class="cov8" title="1">if err := dlogVerify(p, id, message.BigQDoublePrimeProof, message.BigQDoublePrime, message.BigQPrime, dlogTranscript); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("cannot verify dlog proof of Q''")
                }</span>
                <span class="cov8" title="1">p.state.theirBigQPrime[id] = message.BigQPrime
                p.state.theirBigQDoublePrime[id] = message.BigQDoublePrime

                // 3.ii. verify that y_j == 3Q'_j + Q''_j and abort if not
                theirBigQ := message.BigQPrime.Add(message.BigQPrime).Add(message.BigQPrime).Add(message.BigQDoublePrime)
                partialPublicKey, exists := p.shard.PartialPublicKeys().Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrMissing.WithMessage("could not find participant partial publickey (sharing id=%d)", id)
                }</span>
                <span class="cov8" title="1">if !theirBigQ.Equal(partialPublicKey.Value()) </span><span class="cov0" title="0">{
                        return nil, base.ErrAbort.WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("invalid Q' or Q''")
                }</span>
        }

        // 3.iii. generate a Paillier key pair
        <span class="cov8" title="1">keyGenerator, err := p.state.paillierScheme.Keygen()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate Paillier key generator")
        }</span>
        <span class="cov8" title="1">p.state.myPaillierSk, p.state.myPaillierPk, err = keyGenerator.Generate(p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate Paillier keys")
        }</span>
        // 3.iv. calculate ckey' = Enc(x'; r') and ckey'' = Enc(x''; r'')
        <span class="cov8" title="1">ps := p.state.myPaillierPk.PlaintextSpace()
        xPrimeMessage, err := ps.FromBytes(p.state.myXPrime.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create plaintext from x'")
        }</span>
        <span class="cov8" title="1">selfEncrypter, err := p.state.paillierScheme.SelfEncrypter(p.state.myPaillierSk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create paillier self encrypter")
        }</span>
        <span class="cov8" title="1">cKeyPrime, rPrime, err := selfEncrypter.SelfEncrypt(xPrimeMessage, p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot encrypt x'")
        }</span>
        <span class="cov8" title="1">xDoublePrimeMessage, err := ps.FromBytes(p.state.myXDoublePrime.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create plaintext from x'")
        }</span>
        <span class="cov8" title="1">cKeyDoublePrime, rDoublePrime, err := selfEncrypter.SelfEncrypt(xDoublePrimeMessage, p.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot encrypt x''")
        }</span>
        <span class="cov8" title="1">p.state.myRPrime = rPrime
        p.state.myRDoublePrime = rDoublePrime

        // 3.vi. prove pairwise iz ZK that pk was generated correctly (LP)
        //       and that (ckey', ckey'') encrypt dlogs of (Q', Q'') (LPDL)
        // Note: Share single transcript clone across all proofs to preserve state
        paillierProofsTranscript := p.tape.Clone()
        for id := range p.shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.shard.Share().ID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">p.state.lpProvers[id], err = lp.NewProver(p.sid, base.ComputationalSecurityBits, p.state.myPaillierSk, paillierProofsTranscript, p.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create LP prover")
                }</span>
                <span class="cov8" title="1">p.state.lpdlPrimeProvers[id], err = lpdl.NewProver(p.sid, p.curve, p.state.myPaillierSk, p.state.myXPrime, p.state.myRPrime, paillierProofsTranscript, p.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create PDL prover")
                }</span>
                <span class="cov8" title="1">p.state.lpdlDoublePrimeProvers[id], err = lpdl.NewProver(p.sid, p.curve, p.state.myPaillierSk, p.state.myXDoublePrime, p.state.myRDoublePrime, paillierProofsTranscript, p.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create PDL prover")
                }</span>
        }

        // 3.v. broadcast (pk, ckey', ckey'')
        <span class="cov8" title="1">p.round++
        return &amp;Round3Broadcast{
                CKeyPrime:         cKeyPrime,
                CKeyDoublePrime:   cKeyDoublePrime,
                PaillierPublicKey: p.state.myPaillierPk,
        }, nil</span>
}

// Round4 executes the fourth DKG round.
func (p *Participant[P, B, S]) Round4(input network.RoundMessages[*Round3Broadcast]) (output network.OutgoingUnicasts[*Round4P2P], err error) <span class="cov8" title="1">{
        // Validation
        if p.round != 4 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but participant expected round %d", 4, p.round)
        }</span>

        <span class="cov8" title="1">r4o := hashmap.NewComparable[sharing.ID, *Round4P2P]()
        for id := range p.shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.shard.Share().ID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">message, exists := input.Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("no input from participant with sharing id %d", id)
                }</span>
                <span class="cov8" title="1">theirPaillierPublicKey := message.PaillierPublicKey
                p.state.theirPaillierPublicKeys[id] = theirPaillierPublicKey
                theirCKeyPrime := message.CKeyPrime
                theirCKeyDoublePrime := message.CKeyDoublePrime

                // 4.i. calculate and store ckey_j = 3 (*) ckey'_j (+) ckey''_j
                p.state.theirPaillierEncryptedShares[id] = theirCKeyPrime.HomAdd(theirCKeyDoublePrime).HomAdd(theirCKeyDoublePrime).HomAdd(theirCKeyDoublePrime)

                // 4.ii. LP and LPDL continue
                // Share single transcript clone across all verifiers to preserve state
                paillierProofsTranscript := p.tape.Clone()
                p.state.lpVerifiers[id], err = lp.NewVerifier(p.sid, base.ComputationalSecurityBits, theirPaillierPublicKey, paillierProofsTranscript, p.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create P verifier")
                }</span>
                <span class="cov8" title="1">p.state.lpdlPrimeVerifiers[id], err = lpdl.NewVerifier(p.sid, theirPaillierPublicKey, p.state.theirBigQPrime[id], theirCKeyPrime, paillierProofsTranscript, p.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create PDL verifier")
                }</span>
                <span class="cov8" title="1">p.state.lpdlDoublePrimeVerifiers[id], err = lpdl.NewVerifier(p.sid, theirPaillierPublicKey, p.state.theirBigQDoublePrime[id], theirCKeyDoublePrime, paillierProofsTranscript, p.prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot create PDL verifier")
                }</span>

                <span class="cov8" title="1">outgoingMessage := new(Round4P2P)
                outgoingMessage.LpRound1Output, err = p.state.lpVerifiers[id].Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 1 of LP verifier")
                }</span>
                <span class="cov8" title="1">outgoingMessage.LpdlPrimeRound1Output, err = p.state.lpdlPrimeVerifiers[id].Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 1 of LPDL verifier")
                }</span>
                <span class="cov8" title="1">outgoingMessage.LpdlDoublePrimeRound1Output, err = p.state.lpdlDoublePrimeVerifiers[id].Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 1 of LPDLP verifier")
                }</span>
                <span class="cov8" title="1">r4o.Put(id, outgoingMessage)</span>
        }

        <span class="cov8" title="1">p.round++
        return r4o.Freeze(), nil</span>
}

// Round5 executes the fifth DKG round.
func (p *Participant[P, B, S]) Round5(input network.RoundMessages[*Round4P2P]) (output network.OutgoingUnicasts[*Round5P2P], err error) <span class="cov8" title="1">{
        // Validation
        if p.round != 5 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but participant expected round %d", 5, p.round)
        }</span>
        // 5. LP and LPDL continue
        <span class="cov8" title="1">r5o := hashmap.NewComparable[sharing.ID, *Round5P2P]()
        for id := range p.shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.SharingID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">message, exists := input.Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("no input from participant with sharing id %d", id)
                }</span>

                <span class="cov8" title="1">outgoingMessage := new(Round5P2P)
                errGroup := errgroup.Group{}
                errGroup.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        outgoingMessage.LpRound2Output, err = p.state.lpProvers[id].Round2(message.LpRound1Output)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot run round 2 of LP prover")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">errGroup.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        outgoingMessage.LpdlPrimeRound2Output, err = p.state.lpdlPrimeProvers[id].Round2(message.LpdlPrimeRound1Output)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot run round 2 of LPDL prover")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">errGroup.Go(func() error </span><span class="cov8" title="1">{
                        var err error
                        outgoingMessage.LpdlDoublePrimeRound2Output, err = p.state.lpdlDoublePrimeProvers[id].Round2(message.LpdlDoublePrimeRound1Output)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs2.Wrap(err).WithMessage("cannot run round 2 of LPDL prover")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err := errGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("round 5")
                }</span>
                <span class="cov8" title="1">r5o.Put(id, outgoingMessage)</span>
        }

        <span class="cov8" title="1">p.round++
        return r5o.Freeze(), nil</span>
}

// Round6 executes the sixth DKG round.
func (p *Participant[P, B, S]) Round6(input network.RoundMessages[*Round5P2P]) (output network.OutgoingUnicasts[*Round6P2P], err error) <span class="cov8" title="1">{
        // Validation
        if p.round != 6 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but participant expected round %d", 6, p.round)
        }</span>
        // 6. LP and LPDL continue
        <span class="cov8" title="1">r6o := hashmap.NewComparable[sharing.ID, *Round6P2P]()
        for id := range p.shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.SharingID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">message, exists := input.Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("no input from participant with sharing id %d", id)
                }</span>

                <span class="cov8" title="1">outgoingMessage := new(Round6P2P)
                outgoingMessage.LpRound3Output, err = p.state.lpVerifiers[id].Round3(message.LpRound2Output)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 3 of LP verifier")
                }</span>
                <span class="cov8" title="1">outgoingMessage.LpdlPrimeRound3Output, err = p.state.lpdlPrimeVerifiers[id].Round3(message.LpdlPrimeRound2Output)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 3 of LP verifier")
                }</span>
                <span class="cov8" title="1">outgoingMessage.LpdlDoublePrimeRound3Output, err = p.state.lpdlDoublePrimeVerifiers[id].Round3(message.LpdlDoublePrimeRound2Output)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 3 of LP verifier")
                }</span>
                <span class="cov8" title="1">r6o.Put(id, outgoingMessage)</span>
        }

        <span class="cov8" title="1">p.round++
        return r6o.Freeze(), nil</span>
}

// Round7 executes the seventh DKG round.
func (p *Participant[P, B, S]) Round7(input network.RoundMessages[*Round6P2P]) (output network.OutgoingUnicasts[*Round7P2P[P, B, S]], err error) <span class="cov8" title="1">{
        // Validation
        if p.round != 7 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but participant expected round %d", 7, p.round)
        }</span>
        // 7. LP and LPDL continue
        <span class="cov8" title="1">r7o := hashmap.NewComparable[sharing.ID, *Round7P2P[P, B, S]]()
        for id := range p.shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.SharingID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">message, exists := input.Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("no input from participant with sharing id %d", id)
                }</span>

                <span class="cov8" title="1">outgoingMessage := new(Round7P2P[P, B, S])
                outgoingMessage.LpRound4Output, err = p.state.lpProvers[id].Round4(message.LpRound3Output)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 2 of LP prover")
                }</span>
                <span class="cov8" title="1">outgoingMessage.LpdlPrimeRound4Output, err = p.state.lpdlPrimeProvers[id].Round4(message.LpdlPrimeRound3Output)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 2 of LP prover")
                }</span>
                <span class="cov8" title="1">outgoingMessage.LpdlDoublePrimeRound4Output, err = p.state.lpdlDoublePrimeProvers[id].Round4(message.LpdlDoublePrimeRound3Output)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("cannot run round 2 of LP prover")
                }</span>
                <span class="cov8" title="1">r7o.Put(id, outgoingMessage)</span>
        }

        <span class="cov8" title="1">p.round++
        return r7o.Freeze(), nil</span>
}

// Round8 executes the final DKG round.
func (p *Participant[P, B, S]) Round8(input network.RoundMessages[*Round7P2P[P, B, S]]) (*lindell17.Shard[P, B, S], error) <span class="cov8" title="1">{
        // Validation
        if p.round != 8 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but participant expected round %d", 8, p.round)
        }</span>
        <span class="cov8" title="1">for id := range p.shard.AccessStructure().Shareholders().Iter() </span><span class="cov8" title="1">{
                if id == p.SharingID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">message, exists := input.Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, ErrFailed.WithMessage("no input from participant with sharing id %d", id)
                }</span>

                <span class="cov8" title="1">if err := p.state.lpVerifiers[id].Round5(message.LpRound4Output); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("failed to verify valid Paillier public-key")
                }</span>
                <span class="cov8" title="1">if err := p.state.lpdlPrimeVerifiers[id].Round5(message.LpdlPrimeRound4Output); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("failed to verify encrypted dlog")
                }</span>
                <span class="cov8" title="1">if err := p.state.lpdlDoublePrimeVerifiers[id].Round5(message.LpdlDoublePrimeRound4Output); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, id).WithMessage("failed to verify encrypted dlog")
                }</span>
        }

        <span class="cov8" title="1">p.round++
        // 8. store encrypted x_j aka ckey_j (ckey_j = Enc(x_j) = Enc(3x'_j + x''_j)) and pk_j alongside share
        auxInfo, err := lindell17.NewAuxiliaryInfo(
                p.state.myPaillierSk,
                hashmap.NewComparableFromNativeLike(p.state.theirPaillierPublicKeys).Freeze(),
                hashmap.NewComparableFromNativeLike(p.state.theirPaillierEncryptedShares).Freeze(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create auxiliary info")
        }</span>
        <span class="cov8" title="1">shard, err := lindell17.NewShard(p.shard, auxInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create lindell17 shard")
        }</span>
        <span class="cov8" title="1">return shard, nil</span>
}

func dlogProve[
        P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S],
](c *Participant[P, B, S], bigQ, bigQTwin P, x S, tape transcripts.Transcript) (compiler.NIZKPoKProof, error) <span class="cov8" title="1">{
        proverIDBytes := binary.BigEndian.AppendUint64(nil, uint64(c.SharingID()))
        tape.AppendBytes(transcriptDLogSLabel, c.quorumBytes...)
        tape.AppendBytes(proverLabel, proverIDBytes)
        tape.AppendBytes(bigQTwinLabel, bigQTwin.ToCompressed())
        prover, err := c.state.niDlogScheme.NewProver(c.sid, tape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog prover")
        }</span>
        <span class="cov8" title="1">statement := &amp;schnorrpok.Statement[P, S]{
                X: bigQ,
        }
        witness := &amp;schnorrpok.Witness[S]{
                W: x,
        }
        proof, err := prover.Prove(statement, witness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog proof")
        }</span>
        <span class="cov8" title="1">return proof, nil</span>
}

func dlogVerify[
        P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S],
](c *Participant[P, B, S], proverID sharing.ID, proof compiler.NIZKPoKProof, bigQ, bigQTwin P, tape transcripts.Transcript) error <span class="cov8" title="1">{
        proverIDBytes := binary.BigEndian.AppendUint64(nil, uint64(proverID))
        tape.AppendBytes(transcriptDLogSLabel, c.quorumBytes...)
        tape.AppendBytes(proverLabel, proverIDBytes)
        tape.AppendBytes(bigQTwinLabel, bigQTwin.ToCompressed())
        verifier, err := c.state.niDlogScheme.NewVerifier(c.sid, tape)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create dlog verifier")
        }</span>
        <span class="cov8" title="1">statement := &amp;schnorrpok.Statement[P, S]{
                X: bigQ,
        }
        if err := verifier.Verify(statement, proof); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot verify dlog proof for participant %d", proverID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file394" style="display: none">package testutils

import (
        crand "crypto/rand"
        "encoding/hex"
        "io"
        "maps"
        "slices"
        "testing"

        "github.com/stretchr/testify/require"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/maputils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        ntu "github.com/bronlabs/bron-crypto/pkg/network/testutils"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fiatshamir"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17/keygen/dkg"
        "github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid"
)

// RunLindell17DKG runs a complete Lindell17 DKG protocol and returns the resulting shards.
// It verifies that all participants produce consistent outputs.
func RunLindell17DKG[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](
        tb testing.TB,
        curve ecdsa.Curve[P, B, S],
        accessStructure *sharing.ThresholdAccessStructure,
) map[sharing.ID]*lindell17.Shard[P, B, S] <span class="cov0" title="0">{
        tb.Helper()

        prng := crand.Reader
        var sessionID network.SID
        _, err := io.ReadFull(prng, sessionID[:])
        require.NoError(tb, err)

        tape := hagrid.NewTranscript(hex.EncodeToString(sessionID[:]))

        // Create initial shards from Feldman DKG (or use a dealer)
        feldmanScheme, err := feldman.NewScheme(curve.Generator(), accessStructure.Threshold(), accessStructure.Shareholders())
        require.NoError(tb, err)

        feldmanOutput, _, err := feldmanScheme.DealRandom(prng)
        require.NoError(tb, err)

        // Create base tecdsa shards
        baseShards := make(map[sharing.ID]*tecdsa.Shard[P, B, S])
        for id, share := range feldmanOutput.Shares().Iter() </span><span class="cov0" title="0">{
                baseShard, err := tecdsa.NewShard(share, feldmanOutput.VerificationMaterial(), accessStructure)
                require.NoError(tb, err)
                baseShards[id] = baseShard
        }</span>

        // Create DKG participants
        <span class="cov0" title="0">participants := make(map[sharing.ID]*dkg.Participant[P, B, S])
        for id, shard := range baseShards </span><span class="cov0" title="0">{
                participants[id], err = dkg.NewParticipant(
                        sessionID,
                        shard,
                        curve,
                        prng,
                        fiatshamir.Name,
                        tape.Clone(),
                )
                require.NoError(tb, err)
        }</span>

        <span class="cov0" title="0">participantsList := slices.Collect(maps.Values(participants))

        // Round 1: Broadcast commitments
        r1bo := make(map[sharing.ID]*dkg.Round1Broadcast)
        for _, party := range participantsList </span><span class="cov0" title="0">{
                r1bo[party.SharingID()], err = party.Round1()
                require.NoError(tb, err)
        }</span>

        // Round 2: Broadcast openings and DLog proofs
        <span class="cov0" title="0">r2bi := ntu.MapBroadcastO2I(tb, participantsList, r1bo)
        r2bo := make(map[sharing.ID]*dkg.Round2Broadcast[P, B, S])
        for _, party := range participantsList </span><span class="cov0" title="0">{
                r2bo[party.SharingID()], err = party.Round2(r2bi[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        // Round 3: Broadcast Paillier keys and encrypted shares
        <span class="cov0" title="0">r3bi := ntu.MapBroadcastO2I(tb, participantsList, r2bo)
        r3bo := make(map[sharing.ID]*dkg.Round3Broadcast)
        for _, party := range participantsList </span><span class="cov0" title="0">{
                r3bo[party.SharingID()], err = party.Round3(r3bi[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        // Round 4: P2P for LP and LPDL proofs
        <span class="cov0" title="0">r4bi := ntu.MapBroadcastO2I(tb, participantsList, r3bo)
        r4uo := make(map[sharing.ID]network.OutgoingUnicasts[*dkg.Round4P2P])
        for _, party := range participantsList </span><span class="cov0" title="0">{
                r4uo[party.SharingID()], err = party.Round4(r4bi[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        // Round 5: P2P continuation
        <span class="cov0" title="0">r5ui := ntu.MapUnicastO2I(tb, participantsList, r4uo)
        r5uo := make(map[sharing.ID]network.OutgoingUnicasts[*dkg.Round5P2P])
        for _, party := range participantsList </span><span class="cov0" title="0">{
                r5uo[party.SharingID()], err = party.Round5(r5ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        // Round 6: P2P continuation
        <span class="cov0" title="0">r6ui := ntu.MapUnicastO2I(tb, participantsList, r5uo)
        r6uo := make(map[sharing.ID]network.OutgoingUnicasts[*dkg.Round6P2P])
        for _, party := range participantsList </span><span class="cov0" title="0">{
                r6uo[party.SharingID()], err = party.Round6(r6ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        // Round 7: P2P continuation
        <span class="cov0" title="0">r7ui := ntu.MapUnicastO2I(tb, participantsList, r6uo)
        r7uo := make(map[sharing.ID]network.OutgoingUnicasts[*dkg.Round7P2P[P, B, S]])
        for _, party := range participantsList </span><span class="cov0" title="0">{
                r7uo[party.SharingID()], err = party.Round7(r7ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        // Round 8: Final round - get shards
        <span class="cov0" title="0">r8ui := ntu.MapUnicastO2I(tb, participantsList, r7uo)
        shards := make(map[sharing.ID]*lindell17.Shard[P, B, S])
        for _, party := range participantsList </span><span class="cov0" title="0">{
                shards[party.SharingID()], err = party.Round8(r8ui[party.SharingID()])
                require.NoError(tb, err)
        }</span>

        // Verify consistency

        // 1. Public keys should match across all shards
        <span class="cov0" title="0">publicKeys := slices.Collect(maps.Values(maputils.MapValues(shards, func(_ sharing.ID, s *lindell17.Shard[P, B, S]) P </span><span class="cov0" title="0">{
                return s.PublicKey().Value()
        }</span>)))
        <span class="cov0" title="0">for i := 1; i &lt; accessStructure.Shareholders().Size(); i++ </span><span class="cov0" title="0">{
                require.True(tb, publicKeys[0].Equal(publicKeys[i]), "All participants should derive the same public key")
        }</span>

        // 2. Secret shares should reconstruct to the same secret for any threshold-sized subset
        <span class="cov0" title="0">for th := accessStructure.Threshold(); th &lt;= uint(accessStructure.Shareholders().Size()); th++ </span><span class="cov0" title="0">{
                for shardsSubset := range sliceutils.Combinations(slices.Collect(maps.Values(shards)), th) </span><span class="cov0" title="0">{
                        sharesSubset := sliceutils.Map(shardsSubset, func(s *lindell17.Shard[P, B, S]) *feldman.Share[S] </span><span class="cov0" title="0">{
                                return s.Share()
                        }</span>)
                        <span class="cov0" title="0">recoveredSk, err := feldmanScheme.Reconstruct(sharesSubset...)
                        require.NoError(tb, err)
                        recoveredPk := curve.ScalarBaseMul(recoveredSk.Value())
                        require.True(tb, recoveredPk.Equal(publicKeys[0]),
                                "Reconstructed secret should match the public key")</span>
                }
        }

        <span class="cov0" title="0">return shards</span>
}
</pre>
		
		<pre class="file" id="file395" style="display: none">package trusted_dealer

import (
        "io"
        "maps"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17"
)

// DealRandom creates Lindell17 shards using a trusted dealer.
func DealRandom[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](curve ecdsa.Curve[P, B, S], shareholder ds.Set[sharing.ID], keyLen uint, prng io.Reader) (ds.Map[sharing.ID, *lindell17.Shard[P, B, S]], *ecdsa.PublicKey[P, B, S], error) <span class="cov0" title="0">{
        if curve == nil || shareholder == nil || shareholder.Size() == 0 || prng == nil </span><span class="cov0" title="0">{
                return nil, nil, ErrInvalidArgument.WithMessage("invalid input to trusted dealer")
        }</span>
        <span class="cov0" title="0">feldmanDealer, err := feldman.NewScheme(curve.Generator(), 2, shareholder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not create shamir scheme")
        }</span>

        <span class="cov0" title="0">feldmanOutput, secret, err := feldmanDealer.DealRandom(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("could not deal shares")
        }</span>
        <span class="cov0" title="0">publicKey, err := ecdsa.NewPublicKey(curve.ScalarBaseMul(secret.Value()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create ecdsa public key")
        }</span>

        <span class="cov0" title="0">scheme := paillier.NewScheme()

        paillierPrivateKeys := make(map[sharing.ID]*paillier.PrivateKey)
        paillierPublicKeys := make(map[sharing.ID]*paillier.PublicKey)
        shareCiphertexts := make(map[sharing.ID]*paillier.Ciphertext)

        keyGenerator, err := scheme.Keygen(paillier.WithKeyLen(keyLen))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create paillier key generator")
        }</span>

        <span class="cov0" title="0">for id, share := range feldmanOutput.Shares().Iter() </span><span class="cov0" title="0">{
                paillierPrivateKeys[id], paillierPublicKeys[id], err = keyGenerator.Generate(prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot generate paillier keypair")
                }</span>
                <span class="cov0" title="0">sharePlaintext, err := paillierPublicKeys[id].PlaintextSpace().FromBytes(share.Bytes())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create paillier plaintext from share bytes")
                }</span>

                <span class="cov0" title="0">encrypter, err := scheme.SelfEncrypter(paillierPrivateKeys[id])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create paillier encrypter")
                }</span>

                <span class="cov0" title="0">shareCiphertexts[id], _, err = encrypter.SelfEncrypt(sharePlaintext, prng)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot encrypt share under paillier public key")
                }</span>
        }

        <span class="cov0" title="0">shards := make(map[sharing.ID]*lindell17.Shard[P, B, S])
        for id := range feldmanOutput.Shares().Iter() </span><span class="cov0" title="0">{
                ppks := maps.Clone(paillierPublicKeys)
                delete(ppks, id)
                encs := maps.Clone(shareCiphertexts)
                delete(encs, id)

                auxInfo, err := lindell17.NewAuxiliaryInfo(
                        paillierPrivateKeys[id],
                        hashmap.NewComparableFromNativeLike(ppks).Freeze(),
                        hashmap.NewComparableFromNativeLike(encs).Freeze(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create auxiliary info")
                }</span>

                <span class="cov0" title="0">share, exists := feldmanOutput.Shares().Get(id)
                if !exists </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot get share for shareholder %d", id)
                }</span>
                <span class="cov0" title="0">baseShard, err := tecdsa.NewShard(share, feldmanOutput.VerificationMaterial(), feldmanDealer.AccessStructure())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create tECDSA Lindell17 shard")
                }</span>

                <span class="cov0" title="0">shards[id], err = lindell17.NewShard(baseShard, auxInfo)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, errs2.Wrap(err).WithMessage("cannot create lindell17 shard")
                }</span>
        }
        <span class="cov0" title="0">return hashmap.NewComparableFromNativeLike(shards).Freeze(), publicKey, nil</span>
}
</pre>
		
		<pre class="file" id="file396" style="display: none">package lindell17

import (
        "encoding/binary"
        "slices"

        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
)

// Threshold is the Lindell17 tECDSA threshold.
const Threshold = 2

// PartialSignature carries the encrypted partial signature value.
type PartialSignature struct {
        C3 *paillier.Ciphertext
}

// NewPartialSignature constructs a partial signature wrapper.
func NewPartialSignature(c3 *paillier.Ciphertext) (*PartialSignature, error) <span class="cov0" title="0">{
        if c3 == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("invalid ciphertext")
        }</span>
        <span class="cov0" title="0">return &amp;PartialSignature{C3: c3}, nil</span>
}

// QuorumBytes returns sorted quorum IDs in big-endian byte format.
func QuorumBytes(quorum ds.Set[sharing.ID]) [][]byte <span class="cov0" title="0">{
        if quorum == nil || quorum.Size() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">bigS := make([][]byte, quorum.Size())
        for i, id := range slices.Sorted(quorum.Iter()) </span><span class="cov0" title="0">{
                bigS[i] = binary.BigEndian.AppendUint64(nil, uint64(id))
        }</span>
        <span class="cov0" title="0">return bigS</span>
}
</pre>
		
		<pre class="file" id="file397" style="display: none">package lindell17

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/serde"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa"
)

// AuxiliaryInfo holds Paillier keys and encrypted shares for Lindell17.
type AuxiliaryInfo struct {
        paillierPrivateKey *paillier.PrivateKey
        paillierPublicKeys ds.Map[sharing.ID, *paillier.PublicKey]
        encryptedShares    ds.Map[sharing.ID, *paillier.Ciphertext]
}

type auxiliaryInfoDTO struct {
        PaillierPrivateKey *paillier.PrivateKey                `cbor:"paillierPrivateKey"`
        PaillierPublicKeys map[sharing.ID]*paillier.PublicKey  `cbor:"paillierPublicKeys"`
        EncryptedShares    map[sharing.ID]*paillier.Ciphertext `cbor:"encryptedShares"`
}

// PaillierPrivateKey returns the stored Paillier private key.
func (a *AuxiliaryInfo) PaillierPrivateKey() *paillier.PrivateKey <span class="cov0" title="0">{
        return a.paillierPrivateKey
}</span>

// PaillierPublicKeys returns the map of Paillier public keys.
func (a *AuxiliaryInfo) PaillierPublicKeys() ds.Map[sharing.ID, *paillier.PublicKey] <span class="cov0" title="0">{
        return a.paillierPublicKeys
}</span>

// EncryptedShares returns the encrypted shares map.
func (a *AuxiliaryInfo) EncryptedShares() ds.Map[sharing.ID, *paillier.Ciphertext] <span class="cov0" title="0">{
        return a.encryptedShares
}</span>

// Equal compares two AuxiliaryInfo values.
func (a *AuxiliaryInfo) Equal(rhs *AuxiliaryInfo) bool <span class="cov0" title="0">{
        if a == nil || rhs == nil </span><span class="cov0" title="0">{
                return a == rhs
        }</span>
        <span class="cov0" title="0">if !a.paillierPrivateKey.Equal(rhs.paillierPrivateKey) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if a.paillierPublicKeys.Size() != rhs.paillierPublicKeys.Size() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if a.encryptedShares.Size() != rhs.encryptedShares.Size() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for id, pkl := range a.paillierPublicKeys.Iter() </span><span class="cov0" title="0">{
                pkr, ok := rhs.paillierPublicKeys.Get(id)
                if !ok || !pkl.Equal(pkr) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">for id, skl := range a.encryptedShares.Iter() </span><span class="cov0" title="0">{
                skr, ok := rhs.encryptedShares.Get(id)
                if !ok || !skl.Equal(skr) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// MarshalCBOR encodes AuxiliaryInfo in CBOR.
func (a *AuxiliaryInfo) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        paillierPublicKeys := make(map[sharing.ID]*paillier.PublicKey)
        for id, pk := range a.paillierPublicKeys.Iter() </span><span class="cov0" title="0">{
                paillierPublicKeys[id] = pk
        }</span>
        <span class="cov0" title="0">encryptedShares := make(map[sharing.ID]*paillier.Ciphertext)
        for id, c := range a.encryptedShares.Iter() </span><span class="cov0" title="0">{
                encryptedShares[id] = c
        }</span>
        <span class="cov0" title="0">dto := &amp;auxiliaryInfoDTO{
                PaillierPrivateKey: a.paillierPrivateKey,
                PaillierPublicKeys: paillierPublicKeys,
                EncryptedShares:    encryptedShares,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal dkls23 auxiliary info")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR decodes AuxiliaryInfo from CBOR.
func (a *AuxiliaryInfo) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*auxiliaryInfoDTO](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a.paillierPrivateKey = dto.PaillierPrivateKey
        a.paillierPublicKeys = hashmap.NewImmutableComparableFromNativeLike(dto.PaillierPublicKeys)
        a.encryptedShares = hashmap.NewImmutableComparableFromNativeLike(dto.EncryptedShares)
        return nil</span>
}

// NewAuxiliaryInfo constructs an AuxiliaryInfo instance.
func NewAuxiliaryInfo(paillierPrivateKey *paillier.PrivateKey, paillierPublicKeys ds.Map[sharing.ID, *paillier.PublicKey], encryptedShares ds.Map[sharing.ID, *paillier.Ciphertext]) (*AuxiliaryInfo, error) <span class="cov0" title="0">{
        if paillierPrivateKey == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("paillier private key is nil")
        }</span>
        <span class="cov0" title="0">if paillierPublicKeys == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("paillier public keys map is nil")
        }</span>
        <span class="cov0" title="0">if encryptedShares == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("encrypted shares map is nil")
        }</span>
        <span class="cov0" title="0">return &amp;AuxiliaryInfo{
                paillierPrivateKey: paillierPrivateKey,
                paillierPublicKeys: paillierPublicKeys,
                encryptedShares:    encryptedShares,
        }, nil</span>
}

// Shard wraps a base tECDSA shard with Lindell17 auxiliary info.
type Shard[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        *tecdsa.Shard[P, B, S]
        AuxiliaryInfo
}

// NewShard constructs a Lindell17 shard from a base shard and auxiliary info.
func NewShard[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](baseShard *tecdsa.Shard[P, B, S], auxInfo *AuxiliaryInfo) (*Shard[P, B, S], error) <span class="cov0" title="0">{
        if baseShard == nil || auxInfo == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("cannot create Shard with nil fields")
        }</span>
        <span class="cov0" title="0">return &amp;Shard[P, B, S]{
                Shard:         baseShard,
                AuxiliaryInfo: *auxInfo,
        }, nil</span>
}

// Equal compares two shards for equality.
func (s *Shard[P, B, S]) Equal(rhs *Shard[P, B, S]) bool <span class="cov0" title="0">{
        if s == nil || rhs == nil </span><span class="cov0" title="0">{
                return s == rhs
        }</span>
        <span class="cov0" title="0">return s.Shard.Equal(rhs.Shard) &amp;&amp; s.AuxiliaryInfo.Equal(&amp;rhs.AuxiliaryInfo)</span>
}

type shardDTO[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        Shard *tecdsa.Shard[P, B, S] `cbor:"shard"`
        Aux   AuxiliaryInfo          `cbor:"auxiliaryInfo"`
}

// MarshalCBOR encodes the shard in CBOR.
func (s *Shard[P, B, S]) MarshalCBOR() ([]byte, error) <span class="cov0" title="0">{
        dto := &amp;shardDTO[P, B, S]{
                Shard: s.Shard,
                Aux:   s.AuxiliaryInfo,
        }
        data, err := serde.MarshalCBOR(dto)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to marshal dkls23 Shard")
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// UnmarshalCBOR decodes the shard from CBOR.
func (s *Shard[P, B, S]) UnmarshalCBOR(data []byte) error <span class="cov0" title="0">{
        dto, err := serde.UnmarshalCBOR[*shardDTO[P, B, S]](data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.Shard = dto.Shard
        s.AuxiliaryInfo = dto.Aux
        return nil</span>
}
</pre>
		
		<pre class="file" id="file398" style="display: none">package signing

import (
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        schnorrpok "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptLabel = "BRON_CRYPTO_LINDELL17_SIGN-"
)

// Cosigner holds common state for signing participants.
type Cosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        round uint
        // Base participant
        prng  io.Reader
        sid   network.SID
        tape  transcripts.Transcript
        suite *ecdsa.Suite[P, B, S]

        // Threshold participant
        shard *lindell17.Shard[P, B, S]

        commitmentScheme *hash_comm.Scheme
        niDlogScheme     compiler.NonInteractiveProtocol[*schnorrpok.Statement[P, S], *schnorrpok.Witness[S]]
}

// PrimaryCosignerState tracks the primary cosigner's internal state.
type PrimaryCosignerState[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        k1           S
        bigR1Opening hash_comm.Witness
        bigR         P
        r            S
        bigR1        P
}

// PrimaryCosigner runs the primary role in Lindell17 signing.
type PrimaryCosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        Cosigner[P, B, S]

        secondarySharingID sharing.ID
        state              *PrimaryCosignerState[P, B, S]
}

// SecondaryCosignerState tracks the secondary cosigner's internal state.
type SecondaryCosignerState[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        bigR1Commitment hash_comm.Commitment
        k2              S
        bigR2           P
}

// SecondaryCosigner runs the secondary role in Lindell17 signing.
type SecondaryCosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        Cosigner[P, B, S]

        primarySharingID sharing.ID
        state            *SecondaryCosignerState[P, B, S]
}

// SharingID returns the cosigner's sharing identifier.
func (cosigner *Cosigner[P, B, S]) SharingID() sharing.ID <span class="cov8" title="1">{
        return cosigner.shard.Share().ID()
}</span>

func newCosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *ecdsa.Suite[P, B, S], hisSharingID sharing.ID, myShard *lindell17.Shard[P, B, S], niCompiler compiler.Name, tape transcripts.Transcript, prng io.Reader, roundNo uint) (cosigner *Cosigner[P, B, S], err error) <span class="cov8" title="1">{
        err = validateInputs(suite, hisSharingID, myShard, niCompiler, tape, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("invalid input arguments")
        }</span>

        <span class="cov8" title="1">dst := fmt.Sprintf("%s_%s_%s_%s", transcriptLabel, sessionID, niCompiler, suite.Curve().Name())
        tape.AppendDomainSeparator(dst)

        ck, err := hash_comm.NewKeyFromCRSBytes(sessionID, dst, myShard.PublicKey().Value().ToCompressed())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create commitment key from CRS")
        }</span>
        <span class="cov8" title="1">commitmentScheme, err := hash_comm.NewScheme(ck)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create commitment scheme")
        }</span>
        <span class="cov8" title="1">schnorrProtocol, err := schnorrpok.NewProtocol(suite.Curve().Generator(), prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create schnorr protocol")
        }</span>

        <span class="cov8" title="1">niDlogScheme, err := compiler.Compile(niCompiler, schnorrProtocol, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compile niDlogProver")
        }</span>

        <span class="cov8" title="1">return &amp;Cosigner[P, B, S]{
                round:            roundNo,
                prng:             prng,
                suite:            suite,
                sid:              sessionID,
                tape:             tape,
                shard:            myShard,
                commitmentScheme: commitmentScheme,
                niDlogScheme:     niDlogScheme,
        }, nil</span>
}

// NewPrimaryCosigner constructs a primary cosigner.
func NewPrimaryCosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *ecdsa.Suite[P, B, S], secondarySharingID sharing.ID, myShard *lindell17.Shard[P, B, S], niCompiler compiler.Name, tape transcripts.Transcript, prng io.Reader) (primaryCosigner *PrimaryCosigner[P, B, S], err error) <span class="cov8" title="1">{
        cosigner, err := newCosigner(sessionID, suite, secondarySharingID, myShard, niCompiler, tape, prng, 1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not construct primary cosigner")
        }</span>
        <span class="cov8" title="1">primaryCosigner = &amp;PrimaryCosigner[P, B, S]{
                Cosigner:           *cosigner,
                secondarySharingID: secondarySharingID,
                //nolint:exhaustruct // partially initialised
                state: &amp;PrimaryCosignerState[P, B, S]{},
        }
        return primaryCosigner, nil</span>
}

// NewSecondaryCosigner constructs a secondary cosigner.
func NewSecondaryCosigner[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](sessionID network.SID, suite *ecdsa.Suite[P, B, S], primarySharingID sharing.ID, myShard *lindell17.Shard[P, B, S], niCompiler compiler.Name, tape transcripts.Transcript, prng io.Reader) (secondaryCosigner *SecondaryCosigner[P, B, S], err error) <span class="cov8" title="1">{
        cosigner, err := newCosigner(sessionID, suite, primarySharingID, myShard, niCompiler, tape, prng, 2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not construct secondary cosigner")
        }</span>

        //nolint:exhaustruct // partially initialised
        <span class="cov8" title="1">secondaryCosigner = &amp;SecondaryCosigner[P, B, S]{
                Cosigner:         *cosigner,
                primarySharingID: primarySharingID,
                state:            &amp;SecondaryCosignerState[P, B, S]{},
        }
        return secondaryCosigner, nil</span>
}

func validateInputs[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](suite *ecdsa.Suite[P, B, S], other sharing.ID, myShard *lindell17.Shard[P, B, S], nic compiler.Name, tape transcripts.Transcript, prng io.Reader) error <span class="cov8" title="1">{
        if suite == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("suite is nil")
        }</span>
        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("tape is nil")
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("prng is nil")
        }</span>
        <span class="cov8" title="1">if myShard == nil </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("myShard is nil")
        }</span>

        <span class="cov8" title="1">if suite.IsDeterministic() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("suite cannot be deterministic for MPC signing")
        }</span>
        <span class="cov8" title="1">if other == myShard.Share().ID() </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("other sharing ID %d is equal to my sharing ID", other)
        }</span>
        <span class="cov8" title="1">if !myShard.AccessStructure().Shareholders().Contains(other) || !myShard.AccessStructure().Shareholders().Contains(myShard.Share().ID()) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("sharing ID %d not in my shard access structure", other)
        }</span>
        <span class="cov8" title="1">if !compiler.IsSupported(nic) </span><span class="cov0" title="0">{
                return ErrInvalidArgument.WithMessage("unsupported NI compiler: %s", nic)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file399" style="display: none">package signing

import (
        "encoding/binary"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/network"
        schnorrpok "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/shamir"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tecdsa/lindell17"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const (
        transcriptDLogSLabel = "Lindell2017SignDLogS-"
        proverLabel          = "Lindell2017SignProver-"
)

// Round1 executes the primary cosigner's first round.
func (pc *PrimaryCosigner[P, B, S]) Round1() (r1out *Round1OutputP2P, err error) <span class="cov8" title="1">{
        // Validation
        if pc.round != 1 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but primary cosigner expected round %d", 1, pc.round)
        }</span>

        // step 1.1: k1 &lt;-$ Zq     &amp;    R1 &lt;- k1 * G
        <span class="cov8" title="1">pc.state.k1, err = pc.suite.Curve().ScalarField().Random(pc.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate k1")
        }</span>
        <span class="cov8" title="1">pc.state.bigR1 = pc.suite.Curve().ScalarBaseMul(pc.state.k1)
        // step 1.2: c1 &lt;- Commit(sid || Q || R1)
        bigR1Commitment, bigR1Opening, err := pc.commitmentScheme.Committer().Commit(pc.state.bigR1.ToCompressed(), pc.prng) // sid and Q are part of the commitment key
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFailed.WithMessage("cannot commit to R")
        }</span>

        <span class="cov8" title="1">pc.state.bigR1Opening = bigR1Opening

        pc.round += 2
        // step 1.3: Send(c1) -&gt; P_2
        return &amp;Round1OutputP2P{
                BigR1Commitment: bigR1Commitment,
        }, nil</span>
}

// Round2 executes the secondary cosigner's second round.
func (sc *SecondaryCosigner[P, B, S]) Round2(r1out *Round1OutputP2P) (r2out *Round2OutputP2P[P, B, S], err error) <span class="cov8" title="1">{
        // Validation
        if sc.round != 2 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but secondary cosigner expected round %d", 2, sc.round)
        }</span>

        <span class="cov8" title="1">sc.state.bigR1Commitment = r1out.BigR1Commitment
        // step 2.1: k2 &lt;-$ Zq     &amp;    R2 &lt;- k2 * G
        sc.state.k2, err = sc.suite.Curve().ScalarField().Random(sc.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate k2")
        }</span>
        <span class="cov8" title="1">sc.state.bigR2 = sc.suite.Curve().ScalarBaseMul(sc.state.k2)
        // step 2.2:  &lt;- NIPoK.Prove(k2)
        bigR2Proof, err := dlogProve(&amp;sc.Cosigner, sc.state.k2, sc.state.bigR2, sc.primarySharingID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not prove dlog")
        }</span>

        <span class="cov8" title="1">sc.round += 2
        // step 2.3: Send(R2, ) -&gt; P_1
        return &amp;Round2OutputP2P[P, B, S]{
                BigR2:      sc.state.bigR2,
                BigR2Proof: bigR2Proof,
        }, nil</span>
}

// Round3 executes the primary cosigner's third round.
func (pc *PrimaryCosigner[P, B, S]) Round3(r2out *Round2OutputP2P[P, B, S]) (r3out *Round3OutputP2P[P, B, S], err error) <span class="cov8" title="1">{
        if pc.round != 3 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but primary cosigner expected round %d", 3, pc.round)
        }</span>

        <span class="cov8" title="1">if err := dlogVerify(pc.tape, pc.niDlogScheme, pc.secondarySharingID, pc.sid, r2out.BigR2Proof, r2out.BigR2, pc.SharingID()); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pc.secondarySharingID).WithMessage("cannot verify R2 dlog proof")
        }</span>

        <span class="cov8" title="1">bigR1Proof, err := dlogProve(&amp;pc.Cosigner, pc.state.k1, pc.state.bigR1, pc.secondarySharingID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create R1 dlog proof")
        }</span>

        <span class="cov8" title="1">pc.state.bigR = r2out.BigR2.ScalarMul(pc.state.k1)
        rx, err := pc.state.bigR.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not get bigR x-coordinate")
        }</span>
        <span class="cov8" title="1">pc.state.r, err = pc.suite.Curve().ScalarField().FromBytes(rx.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not convert bigR x-coordinate to scalar")
        }</span>

        <span class="cov8" title="1">pc.round += 2
        return &amp;Round3OutputP2P[P, B, S]{
                BigR1Opening: pc.state.bigR1Opening,
                BigR1:        pc.state.bigR1,
                BigR1Proof:   bigR1Proof,
        }, nil</span>
}

// Round4 executes the secondary cosigner's fourth round.
func (sc *SecondaryCosigner[P, B, S]) Round4(r3out *Round3OutputP2P[P, B, S], message []byte) (round4Output *lindell17.PartialSignature, err error) <span class="cov8" title="1">{
        // Validation
        if sc.round != 4 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but secondary cosigner expected round %d", 4, sc.round)
        }</span>

        <span class="cov8" title="1">if err := sc.commitmentScheme.Verifier().Verify(sc.state.bigR1Commitment, r3out.BigR1.ToCompressed(), r3out.BigR1Opening); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot open R1 commitment")
        }</span>

        <span class="cov8" title="1">if err := dlogVerify(sc.tape, sc.niDlogScheme, sc.primarySharingID, sc.sid, r3out.BigR1Proof, r3out.BigR1, sc.SharingID()); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, sc.primarySharingID).WithMessage("cannot verify R1 dlog proof")
        }</span>

        <span class="cov8" title="1">bigR := r3out.BigR1.ScalarMul(sc.state.k2)
        rx, err := bigR.AffineX()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not get bigR x-coordinate")
        }</span>
        <span class="cov8" title="1">r, err := sc.suite.Curve().ScalarField().FromBytes(rx.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not convert bigR x-coordinate to scalar")
        }</span>

        <span class="cov8" title="1">k2 := sc.state.k2

        quorum := hashset.NewComparable(sc.SharingID(), sc.primarySharingID)
        ac, err := sharing.NewMinimalQualifiedAccessStructure(quorum.Freeze())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create access structure for additive sharing")
        }</span>
        <span class="cov8" title="1">additiveShare, err := sc.shard.Share().ToAdditive(ac)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not convert Shamir share to additive share")
        }</span>
        <span class="cov8" title="1">paillierPublicKey, exists := sc.shard.PaillierPublicKeys().Get(sc.primarySharingID)
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrMissing.WithMessage("couldn't get primary paillier public key")
        }</span>
        <span class="cov8" title="1">cKey, exists := sc.shard.EncryptedShares().Get(sc.primarySharingID)
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrMissing.WithMessage("couldn't get primary encrypted signing key share")
        }</span>

        <span class="cov8" title="1">coefficients, err := shamir.LagrangeCoefficients(sc.suite.Curve().ScalarField(), ac.Shareholders().List()...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get Lagrange coefficients")
        }</span>
        <span class="cov8" title="1">primaryLagrangeCoefficient, exists := coefficients.Get(sc.primarySharingID)
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrMissing.WithMessage("could not get primary Lagrange coefficient")
        }</span>

        <span class="cov8" title="1">mPrime, err := MessageToScalar(sc.suite, message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get scalar from message")
        }</span>

        // c3 = Enc(q + k2^(-1)(m' + r * (y1 * 1 + y2 * 2)))
        <span class="cov8" title="1">c3, err := CalcC3(primaryLagrangeCoefficient, k2, mPrime, r, additiveShare.Value(), sc.suite.Curve().Order(), paillierPublicKey, cKey, sc.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot calculate c3")
        }</span>

        <span class="cov8" title="1">sc.round += 2
        return &amp;lindell17.PartialSignature{
                C3: c3,
        }, nil</span>
}

// Round5 executes the primary cosigner's final round.
func (pc *PrimaryCosigner[P, B, S]) Round5(r4out *lindell17.PartialSignature, message []byte) (*ecdsa.Signature[S], error) <span class="cov8" title="1">{
        // Validation
        if pc.round != 5 </span><span class="cov0" title="0">{
                return nil, ErrRound.WithMessage("Running round %d but primary cosigner expected round %d", 5, pc.round)
        }</span>
        <span class="cov8" title="1">decrypter, err := paillier.NewScheme().Decrypter(pc.shard.PaillierPrivateKey())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create paillier decrypter")
        }</span>
        <span class="cov8" title="1">sPrimeInt, err := decrypter.Decrypt(r4out.C3)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pc.secondarySharingID).WithMessage("cannot decrypt c3")
        }</span>
        <span class="cov8" title="1">sPrime, err := pc.suite.Curve().ScalarField().FromBytesBEReduce(sPrimeInt.Normalise().BytesBE())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pc.secondarySharingID).WithMessage("cannot convert decrypted c3 to scalar")
        }</span>
        <span class="cov8" title="1">k1Inv, err := pc.state.k1.TryInv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not compute k1 inverse")
        }</span>
        <span class="cov8" title="1">sDoublePrime := k1Inv.Mul(sPrime)

        v := new(int)
        *v, err = ecdsa.ComputeRecoveryID(pc.state.bigR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not compute recovery id")
        }</span>

        <span class="cov8" title="1">signature, err := ecdsa.NewSignature(pc.state.r, sDoublePrime, v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create signature")
        }</span>
        <span class="cov8" title="1">signature.Normalise()

        ecdsaScheme, err := ecdsa.NewScheme(pc.suite, pc.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create ecdsa scheme")
        }</span>
        <span class="cov8" title="1">verifier, err := ecdsaScheme.Verifier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create ecdsa verifier")
        }</span>
        <span class="cov8" title="1">if err := verifier.Verify(signature, pc.shard.PublicKey(), message); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pc.secondarySharingID).WithMessage("could not verify produced signature")
        }</span>
        <span class="cov8" title="1">pc.round += 2
        return signature, nil</span>
}

func dlogProve[
        P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S],
](c *Cosigner[P, B, S], k S, bigR P, otherSharingID sharing.ID) (compiler.NIZKPoKProof, error) <span class="cov8" title="1">{
        proverIDBytes := binary.BigEndian.AppendUint64(nil, uint64(c.SharingID()))
        receiverIDBytes := binary.BigEndian.AppendUint64(nil, uint64(otherSharingID))
        quorumBytes := slices.Concat(proverIDBytes, receiverIDBytes)
        c.tape.AppendBytes(transcriptDLogSLabel, quorumBytes)
        c.tape.AppendBytes(proverLabel, proverIDBytes)
        prover, err := c.niDlogScheme.NewProver(c.sid, c.tape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog prover")
        }</span>
        <span class="cov8" title="1">statement := &amp;schnorrpok.Statement[P, S]{
                X: bigR,
        }
        witness := &amp;schnorrpok.Witness[S]{
                W: k,
        }
        proof, err := prover.Prove(statement, witness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create dlog proof")
        }</span>
        <span class="cov8" title="1">return proof, nil</span>
}

func dlogVerify[
        P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S],
](tape transcripts.Transcript, niDlogScheme compiler.NonInteractiveProtocol[*schnorrpok.Statement[P, S], *schnorrpok.Witness[S]], proverID sharing.ID, sid network.SID, proof compiler.NIZKPoKProof, theirBigR P, mySharingID sharing.ID) error <span class="cov8" title="1">{
        proverIDBytes := binary.BigEndian.AppendUint64(nil, uint64(proverID))
        receiverIDBytes := binary.BigEndian.AppendUint64(nil, uint64(mySharingID))
        quorumBytes := slices.Concat(proverIDBytes, receiverIDBytes)
        tape.AppendBytes(transcriptDLogSLabel, quorumBytes)
        tape.AppendBytes(proverLabel, proverIDBytes)
        statement := &amp;schnorrpok.Statement[P, S]{
                X: theirBigR,
        }
        verifier, err := niDlogScheme.NewVerifier(sid, tape)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create dlog verifier")
        }</span>
        <span class="cov8" title="1">if err := verifier.Verify(statement, proof); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot verify dlog proof for participant %d", proverID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file400" style="display: none">package signing

import (
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/num"
        "github.com/bronlabs/bron-crypto/pkg/base/nt/numct"
        "github.com/bronlabs/bron-crypto/pkg/encryption/paillier"
        "github.com/bronlabs/bron-crypto/pkg/hashing"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
)

// CalcC3 calculates Enc_pk(q + k2^(-1)(m' + r * (cKey *  + share * ))).
func CalcC3[S algebra.PrimeFieldElement[S]](lambda, k2, mPrime, r, additiveShare S, curveOrder algebra.Cardinal, pk *paillier.PublicKey, cKey *paillier.Ciphertext, prng io.Reader) (c3 *paillier.Ciphertext, err error) <span class="cov8" title="1">{
        k2Inv, err := k2.TryInv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot get k2 inverse")
        }</span>

        <span class="cov8" title="1">qNat, err := num.NPlus().FromCardinal(curveOrder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert q to Nat")
        }</span>
        <span class="cov8" title="1">zModQ2, err := num.NewZMod(qNat.Square())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create ZMod q^2")
        }</span>
        <span class="cov8" title="1">q, err := zModQ2.FromNatPlus(qNat)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert qNat to ZMod q^2")
        }</span>

        // c1 = Enc(q + k2^(-1) * m')
        <span class="cov8" title="1">c1Plain := k2Inv.Mul(mPrime)
        rho, err := zModQ2.Random(prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot generate random int")
        }</span>
        <span class="cov8" title="1">rhoMulQ := rho.Mul(q)

        c1PlainUint, err := zModQ2.FromNatCTReduced(numct.NewNatFromBytes(c1Plain.Bytes()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert c1Plain to ZMod q^2")
        }</span>
        <span class="cov8" title="1">c1Message, err := pk.PlaintextSpace().FromNat(rhoMulQ.Add(c1PlainUint).Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert c1PlainUint to plaintext")
        }</span>

        <span class="cov8" title="1">enc, err := paillier.NewScheme().Encrypter()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create paillier encrypter")
        }</span>
        <span class="cov8" title="1">c1, _, err := enc.Encrypt(c1Message, pk, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot encrypt c1")
        }</span>

        // c2 = Enc(k2^(-1) * r * (cKey *  + share * ))
        <span class="cov8" title="1">c2LeftExponent, err := num.N().FromBytes(k2Inv.Mul(r).Mul(lambda).Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert c2 left exponent to Nat")
        }</span>
        <span class="cov8" title="1">c2Left := cKey.ScalarMul(c2LeftExponent)

        c2RightMessage, err := pk.PlaintextSpace().FromBytes(k2Inv.Mul(r).Mul(additiveShare).Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert c2 right message to plaintext")
        }</span>
        <span class="cov8" title="1">c2Right, _, err := enc.Encrypt(c2RightMessage, pk, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot encrypt c2")
        }</span>
        <span class="cov8" title="1">c2 := c2Left.HomAdd(c2Right)

        // c3 = c1 + c2 = Enc(q + k2^(-1)(m' + r * (y1 *  + y2 * )))
        c3 = c1.HomAdd(c2)

        return c3, nil</span>
}

// MessageToScalar hashes a message into a curve scalar.
func MessageToScalar[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](cipherSuite *ecdsa.Suite[P, B, S], message []byte) (S, error) <span class="cov8" title="1">{
        messageHash, err := hashing.Hash(cipherSuite.HashFunc(), message)
        if err != nil </span><span class="cov0" title="0">{
                return *new(S), errs2.Wrap(err).WithMessage("cannot hash message")
        }</span>
        <span class="cov8" title="1">sc, err := ecdsa.DigestToScalar(cipherSuite.ScalarField(), messageHash)
        if err != nil </span><span class="cov0" title="0">{
                return *new(S), errs2.Wrap(err).WithMessage("cannot convert digest to scalar")
        }</span>
        <span class="cov8" title="1">return sc, nil</span>
}
</pre>
		
		<pre class="file" id="file401" style="display: none">package tecdsa

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/curves"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/signatures/ecdsa"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig"
)

// PublicMaterial holds public key material.
type PublicMaterial[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        tsig.BasePublicMaterial[P, S]

        pk     *ecdsa.PublicKey[P, B, S]
        pkOnce sync.Once
}

// PublicKey returns the public key.
func (pm *PublicMaterial[P, B, S]) PublicKey() *ecdsa.PublicKey[P, B, S] <span class="cov0" title="0">{
        pm.pkOnce.Do(func() </span><span class="cov0" title="0">{
                var err error
                pm.pk, err = ecdsa.NewPublicKey(pm.BasePublicMaterial.PublicKey())
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        })
        <span class="cov0" title="0">return pm.pk</span>
}

// Shard holds a tECDSA key share.
type Shard[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]] struct {
        tsig.BaseShard[P, S]

        pk     *ecdsa.PublicKey[P, B, S]
        pkOnce sync.Once
}

// PublicKeyMaterial returns the public key material.
func (sh *Shard[P, B, S]) PublicKeyMaterial() *PublicMaterial[P, B, S] <span class="cov0" title="0">{
        //nolint:exhaustruct // lazy initialisation
        return &amp;PublicMaterial[P, B, S]{
                BasePublicMaterial: sh.BasePublicMaterial,
                pk:                 sh.pk,
        }
}</span>

// PublicKey returns the public key.
func (sh *Shard[P, B, S]) PublicKey() *ecdsa.PublicKey[P, B, S] <span class="cov0" title="0">{
        sh.pkOnce.Do(func() </span><span class="cov0" title="0">{
                var err error
                sh.pk, err = ecdsa.NewPublicKey(sh.BaseShard.PublicKey())
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        })
        <span class="cov0" title="0">return sh.pk</span>
}

// Equal reports whether the value equals other.
func (sh *Shard[P, B, S]) Equal(other tsig.Shard[*ecdsa.PublicKey[P, B, S], *feldman.Share[S], *sharing.ThresholdAccessStructure]) bool <span class="cov0" title="0">{
        o, ok := other.(*Shard[P, B, S])
        return ok &amp;&amp; sh.BaseShard.Equal(&amp;o.BaseShard)
}</span>

// NewShard returns a new shard.
func NewShard[P curves.Point[P, B, S], B algebra.PrimeFieldElement[B], S algebra.PrimeFieldElement[S]](
        share *feldman.Share[S],
        fv feldman.VerificationVector[P, S],
        accessStructure *sharing.ThresholdAccessStructure,
) (*Shard[P, B, S], error) <span class="cov0" title="0">{
        if share == nil || fv == nil || accessStructure == nil </span><span class="cov0" title="0">{
                return nil, ErrNil.WithMessage("nil input parameters")
        }</span>
        <span class="cov0" title="0">bs, err := tsig.NewBaseShard(share, fv, accessStructure)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create base shard")
        }</span>
        <span class="cov0" title="0">pk, err := ecdsa.NewPublicKey(fv.Coefficients()[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create public key from verification vector")
        }</span>

        //nolint:exhaustruct // lazy initialisation
        <span class="cov0" title="0">return &amp;Shard[P, B, S]{BaseShard: *bs, pk: pk}, nil</span>
}
</pre>
		
		<pre class="file" id="file402" style="display: none">package keygen

import (
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22"
)

// DKGOutput is the output of a distributed key generation protocol.
type DKGOutput[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = gennaro.DKGOutput[GE, S]

// NewShard creates a threshold Schnorr shard from DKG output.
func NewShard[
        GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S],
](
        output *gennaro.DKGOutput[GE, S],
) (*lindell22.Shard[GE, S], error) <span class="cov0" title="0">{
        shard, err := tschnorr.NewShard(
                output.Share(),
                output.VerificationVector(),
                output.AccessStructure(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create tSchnorr shard from DKG output")
        }</span>
        <span class="cov0" title="0">return shard, nil</span>
}
</pre>
		
		<pre class="file" id="file403" style="display: none">package lindell22

import (
        "encoding/binary"
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        hash_comm "github.com/bronlabs/bron-crypto/pkg/commitments/hash"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
)

const commitmentDomainRLabel = "Lindell2022SignR-"

type (
        // Shard represents a party's secret key share for threshold Schnorr signing.
        Shard[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = tschnorr.Shard[GE, S]
        // PublicMaterial contains public information shared among signing parties.
        PublicMaterial[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = tschnorr.PublicMaterial[GE, S]
        // PartialSignature is a party's contribution to the threshold signature.
        PartialSignature[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] = tschnorr.PartialSignature[GE, S]
)

// Lindell22 is proven to be secure in standard model only if a UC-secure commitment scheme is used.
// Due to CF01, no such scheme can exist without a trusted setup/interaction. So we use a hash-based
// commitment scheme to save some rounds. Implication is having to rely on RO.
type (
        // CommitmentScheme is the hash-based commitment scheme used in the protocol.
        CommitmentScheme = hash_comm.Scheme
        // Commitment is a hiding commitment to a value.
        Commitment = hash_comm.Commitment
        // Opening contains the witness needed to open a commitment.
        Opening = hash_comm.Witness
        // CommitmentKey is the public key for the commitment scheme.
        CommitmentKey = hash_comm.Key
)

// NewCommitmentScheme creates a new hash-based commitment scheme.
var NewCommitmentScheme = hash_comm.NewScheme

// NewCommitmentKey creates a commitment key from session ID, party ID, and quorum information.
func NewCommitmentKey(sid network.SID, pid sharing.ID, quorumBytes [][]byte) (CommitmentKey, error) <span class="cov0" title="0">{
        pidBytes := binary.BigEndian.AppendUint64(nil, uint64(pid))
        key, err := hash_comm.NewKeyFromCRSBytes(sid, commitmentDomainRLabel, append([][]byte{pidBytes}, quorumBytes...)...)
        if err != nil </span><span class="cov0" title="0">{
                return CommitmentKey{}, errs2.Wrap(err).WithMessage("cannot create key for commitment scheme")
        }</span>
        <span class="cov0" title="0">return key, nil</span>
}

// QuorumBytes returns sorted quorum IDs in big-endian format, used for commitment scheme CRS and dlog proofs.
func QuorumBytes(quorum ds.Set[sharing.ID]) [][]byte <span class="cov0" title="0">{
        if quorum == nil || quorum.Size() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">bigS := make([][]byte, quorum.Size())
        for i, id := range slices.Sorted(quorum.Iter()) </span><span class="cov0" title="0">{
                bigS[i] = binary.BigEndian.AppendUint64(nil, uint64(id))
        }</span>
        <span class="cov0" title="0">return bigS</span>
}
</pre>
		
		<pre class="file" id="file404" style="display: none">package signing

import (
        "slices"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashset"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/iterutils"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22"
)

// Aggregator combines partial signatures into a complete threshold signature.
type Aggregator[
        VR tschnorr.MPCFriendlyVariant[GE, S, M], GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message,
] struct {
        pkm          *lindell22.PublicMaterial[GE, S]
        group        algebra.PrimeGroup[GE, S]
        sf           algebra.PrimeField[S]
        variant      VR
        verifier     schnorrlike.Verifier[VR, GE, S, M]
        psigVerifier schnorrlike.Verifier[VR, GE, S, M]
}

// PublicMaterial returns the public key material for signature verification.
func (a *Aggregator[VR, GE, S, M]) PublicMaterial() *lindell22.PublicMaterial[GE, S] <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return a.pkm</span>
}

// NewAggregator creates a new signature aggregator for the given public material and scheme.
func NewAggregator[
        SCH tschnorr.MPCFriendlyScheme[VR, GE, S, M, KG, SG, VF],
        VR tschnorr.MPCFriendlyVariant[GE, S, M],
        GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message,
        KG schnorrlike.KeyGenerator[GE, S], SG schnorrlike.Signer[VR, GE, S, M], VF schnorrlike.Verifier[VR, GE, S, M],
](
        pk *lindell22.PublicMaterial[GE, S],
        scheme SCH,
) (*Aggregator[VR, GE, S, M], error) <span class="cov8" title="1">{
        if pk == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("public material cannot be nil")
        }</span>
        <span class="cov8" title="1">group := pk.PublicKey().Group()
        sf, ok := group.ScalarStructure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidType.WithMessage("group scalar structure is not a prime field")
        }</span>
        <span class="cov8" title="1">verifier, err := scheme.Verifier()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create verifier for scheme %s", scheme.Name())
        }</span>
        <span class="cov8" title="1">psigVerifier, err := scheme.PartialSignatureVerifier(pk.PublicKey())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create partial signature verifier for scheme %s", scheme.Name())
        }</span>
        <span class="cov8" title="1">return &amp;Aggregator[VR, GE, S, M]{pkm: pk, group: group, sf: sf, variant: scheme.Variant(), verifier: verifier, psigVerifier: psigVerifier}, nil</span>
}

// Aggregate combines partial signatures into a complete signature, verifying validity.
// Returns an identifiable abort error if any partial signature is invalid.
func (a *Aggregator[VR, GE, S, M]) Aggregate(
        partialSignatures network.RoundMessages[*lindell22.PartialSignature[GE, S]],
        message M,
) (*schnorrlike.Signature[GE, S], error) <span class="cov8" title="1">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("aggregator cannot be nil")
        }</span>
        <span class="cov8" title="1">if partialSignatures == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("partial signatures cannot be nil")
        }</span>
        <span class="cov8" title="1">quorum := hashset.NewComparable(partialSignatures.Keys()...).Freeze()
        if !a.pkm.AccessStructure().IsAuthorized(quorum.List()...) </span><span class="cov0" title="0">{
                return nil, ErrInvalidMembership.WithMessage("invalid authorization: not enough shares are qualified")
        }</span>
        <span class="cov8" title="1">R := iterutils.Reduce(slices.Values(partialSignatures.Values()),
                a.group.OpIdentity(), func(acc GE, x *lindell22.PartialSignature[GE, S]) GE </span><span class="cov8" title="1">{ return acc.Op(x.Sig.R) }</span>,
        )
        <span class="cov8" title="1">s := iterutils.Reduce(slices.Values(partialSignatures.Values()),
                a.sf.Zero(), func(acc S, x *lindell22.PartialSignature[GE, S]) S </span><span class="cov8" title="1">{ return acc.Add(x.Sig.S) }</span>,
        )
        <span class="cov8" title="1">e, err := a.variant.ComputeChallenge(R, a.pkm.PublicKey().Value(), message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compute challenge")
        }</span>
        <span class="cov8" title="1">if sliceutils.Any(partialSignatures.Values(), func(x *lindell22.PartialSignature[GE, S]) bool </span><span class="cov8" title="1">{
                return x == nil || !x.Sig.E.Equal(e)
        }</span>) <span class="cov0" title="0">{

                return nil, ErrInvalidType.WithMessage("invalid partial signature")
        }</span>
        <span class="cov8" title="1">aggregatedSignature, err := schnorrlike.NewSignature(e, R, s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create aggregated signature")
        }</span>

        <span class="cov8" title="1">if err := a.verifier.Verify(aggregatedSignature, a.pkm.PublicKey(), message); err == nil </span><span class="cov8" title="1">{
                return aggregatedSignature, nil
        }</span>

        // aggregated signature verification failed, now doing identifiable abort

        <span class="cov8" title="1">identityAborts := []error{}
        quorumAsMinimalQualifiedSet, err := sharing.NewMinimalQualifiedAccessStructure(quorum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create minimal qualified access structure")
        }</span>
        <span class="cov8" title="1">for sender, psig := range partialSignatures.Iter() </span><span class="cov8" title="1">{
                if psig == nil </span><span class="cov0" title="0">{
                        return nil, ErrNilArgument.WithMessage("partial signature cannot be nil")
                }</span>
                <span class="cov8" title="1">senderPartialPublicKey, _ := a.pkm.PartialPublicKeys().Get(sender)
                senderPKShare, err := feldman.NewLiftedShare(sender, senderPartialPublicKey.Value())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create lifted share for sender %d", sender)
                }</span>
                <span class="cov8" title="1">senderAdditivePKShare, err := senderPKShare.ToAdditive(quorumAsMinimalQualifiedSet)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to convert lifted share to additive share for sender %d", sender)
                }</span>
                <span class="cov8" title="1">senderAdditivePK, err := schnorrlike.NewPublicKey(senderAdditivePKShare.Value())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create public key for sender %d", sender)
                }</span>
                <span class="cov8" title="1">if err := a.psigVerifier.Verify(&amp;psig.Sig, senderAdditivePK, message); err != nil </span><span class="cov8" title="1">{
                        identityAborts = append(identityAborts, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, sender).WithMessage("failed to verify partial signature"))
                }</span>
        }
        <span class="cov8" title="1">if len(identityAborts) != 0 </span><span class="cov8" title="1">{
                return nil, errs2.Join(identityAborts...).WithMessage("verification failed")
        }</span>

        <span class="cov0" title="0">panic("should not reach here: not all partial signatures should have been valid")</span>
}
</pre>
		
		<pre class="file" id="file405" style="display: none">package signing

import (
        "fmt"
        "io"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        schnorrpok "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22"
        ts "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

var (
        // ErrNilArgument is returned when a required argument is nil.
        ErrNilArgument = errs2.New("nil argument")
        // ErrInvalidRound is returned when an operation is attempted in the wrong round.
        ErrInvalidRound = errs2.New("invalid round")
        // ErrInvalidType is returned when a type assertion or check fails.
        ErrInvalidType = errs2.New("invalid type")
        // ErrInvalidMembership is returned when a party is not authorized for an operation.
        ErrInvalidMembership = errs2.New("invalid membership")
)

const (
        transcriptLabel = "BRON_CRYPTO_TSCHNORR_LINDELL22_SIGNING-"
)

// Cosigner is a participant in the Lindell22 threshold Schnorr signing protocol.
type Cosigner[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message] struct {
        sid     network.SID
        shard   *lindell22.Shard[GE, S]
        quorum  network.Quorum
        tape    ts.Transcript
        group   algebra.PrimeGroup[GE, S]
        sf      algebra.PrimeField[S]
        prng    io.Reader
        round   network.Round
        variant tschnorr.MPCFriendlyVariant[GE, S, M]

        niDlogScheme compiler.NonInteractiveProtocol[*schnorrpok.Statement[GE, S], *schnorrpok.Witness[S]]
        state        *State[GE, S]
}

// State holds the cosigner's internal state during the signing protocol.
type State[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S]] struct {
        quorumBytes               [][]byte
        k                         S
        bigR                      GE
        opening                   lindell22.Opening
        theirBigRCommitments      map[sharing.ID]lindell22.Commitment
        tapeFrozenBeforeDlogProof ts.Transcript
}

// SessionID returns the session identifier for this signing session.
func (c *Cosigner[GE, S, M]) SessionID() network.SID <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return network.SID([32]byte{})
        }</span>
        <span class="cov0" title="0">return c.sid</span>
}

// SharingID returns the party's identifier in the secret sharing scheme.
func (c *Cosigner[GE, S, M]) SharingID() sharing.ID <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return c.shard.Share().ID()</span>
}

// Quorum returns the set of parties participating in this signing session.
func (c *Cosigner[GE, S, M]) Quorum() network.Quorum <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.quorum</span>
}

// Shard returns the party's secret key share.
func (c *Cosigner[GE, S, M]) Shard() *lindell22.Shard[GE, S] <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return c.shard</span>
}

// Variant returns the Schnorr variant being used for signing.
func (c *Cosigner[GE, S, M]) Variant() tschnorr.MPCFriendlyVariant[GE, S, M] <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.variant</span>
}

// ComputePartialSignature computes this party's contribution to the threshold signature.
func (c *Cosigner[GE, S, M]) ComputePartialSignature(aggregatedNonceCommitment GE, challenge S) (*lindell22.PartialSignature[GE, S], error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("cosigner cannot be nil")
        }</span>
        <span class="cov8" title="1">if c.round != 3 </span><span class="cov0" title="0">{
                return nil, ErrInvalidRound.WithMessage("cosigner %d cannot compute partial signature in round %d, expected round 3", c.sid, c.round)
        }</span>
        // step 3.7.1: compute additive share d_i'
        <span class="cov8" title="1">mqac, err := sharing.NewMinimalQualifiedAccessStructure(c.quorum)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create minimal qualified access structure for quorum %v", c.quorum)
        }</span>
        <span class="cov8" title="1">ashare, err := c.shard.Share().ToAdditive(mqac)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot convert share %d to additive share", c.shard.Share().ID())
        }</span>
        <span class="cov8" title="1">myAdditiveShare, err := c.variant.CorrectAdditiveSecretShareParity(c.shard.PublicKey(), ashare)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot correct share %d parity", c.shard.Share().ID())
        }</span>
        // step 3.7.3 &amp; 3.8: compute s'_i and set s_i &lt;- s'_i + _i
        <span class="cov8" title="1">correctedR, correctedK, err := c.variant.CorrectPartialNonceParity(aggregatedNonceCommitment, c.state.k)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot correct nonce parity")
        }</span>
        <span class="cov8" title="1">s, err := c.variant.ComputeResponse(myAdditiveShare.Value(), correctedK, challenge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute response")
        }</span>
        <span class="cov8" title="1">return &amp;lindell22.PartialSignature[GE, S]{
                Sig: schnorrlike.Signature[GE, S]{
                        E: challenge,
                        R: correctedR,
                        S: s,
                },
        }, nil</span>
}

// NewCosigner creates a new cosigner for threshold Schnorr signing.
func NewCosigner[
        GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message,
](
        sid network.SID,
        shard *lindell22.Shard[GE, S],
        quorum network.Quorum,
        group algebra.PrimeGroup[GE, S],
        niCompilerName compiler.Name,
        variant tschnorr.MPCFriendlyVariant[GE, S, M],
        prng io.Reader,
        tape ts.Transcript,
) (*Cosigner[GE, S, M], error) <span class="cov8" title="1">{
        if shard == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("shard cannot be nil")
        }</span>
        <span class="cov8" title="1">if tape == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("transcript cannot be nil")
        }</span>
        <span class="cov8" title="1">if group == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("group cannot be nil")
        }</span>
        <span class="cov8" title="1">sf, ok := group.ScalarStructure().(algebra.PrimeField[S])
        if !ok </span><span class="cov0" title="0">{
                return nil, ErrInvalidType.WithMessage("group %s structure is not a prime field", group.Name())
        }</span>
        <span class="cov8" title="1">if quorum == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("quorum cannot be nil")
        }</span>
        <span class="cov8" title="1">if !quorum.Contains(shard.Share().ID()) </span><span class="cov0" title="0">{
                return nil, ErrInvalidMembership.WithMessage("quorum %s cannot contain participant %d", quorum, sid)
        }</span>
        <span class="cov8" title="1">if !shard.AccessStructure().IsAuthorized(quorum.List()...) </span><span class="cov0" title="0">{
                return nil, ErrInvalidMembership.WithMessage("shard %d access structure is not authorized for quorum %s", shard.Share().ID(), quorum)
        }</span>
        <span class="cov8" title="1">if prng == nil </span><span class="cov0" title="0">{
                return nil, ErrNilArgument.WithMessage("prng cannot be nil")
        }</span>
        <span class="cov8" title="1">if !group.Order().IsProbablyPrime() </span><span class="cov0" title="0">{
                return nil, ErrInvalidType.WithMessage("group %s order is not prime", group.Name())
        }</span>
        <span class="cov8" title="1">schnorrProtocol, err := schnorrpok.NewProtocol(group.Generator(), prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create schnorr protocol")
        }</span>
        <span class="cov8" title="1">niDlogScheme, err := compiler.Compile(niCompilerName, schnorrProtocol, prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to compile niDlogProver")
        }</span>

        <span class="cov8" title="1">dst := fmt.Sprintf("%s-%d-%s", transcriptLabel, sid, group.Name())
        tape.AppendDomainSeparator(dst)
        quorumBytes := lindell22.QuorumBytes(quorum)

        return &amp;Cosigner[GE, S, M]{
                sid:          sid,
                shard:        shard,
                quorum:       quorum,
                tape:         tape,
                group:        group,
                sf:           sf,
                prng:         prng,
                niDlogScheme: niDlogScheme,
                variant:      variant,
                round:        1,
                state: &amp;State[GE, S]{
                        quorumBytes:               quorumBytes,
                        k:                         *new(S),
                        bigR:                      *new(GE),
                        opening:                   lindell22.Opening{},
                        theirBigRCommitments:      make(map[sharing.ID]lindell22.Commitment, quorum.Size()-1),
                        tapeFrozenBeforeDlogProof: nil,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file406" style="display: none">package signing

import (
        "encoding/binary"

        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/algebrautils"
        "github.com/bronlabs/bron-crypto/pkg/network"
        schnorrpok "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22"
        ts "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

const transcriptDLogSLabel = "Lindell2022SignDLogS-"

// Round1 samples a random nonce, commits to it, and broadcasts the commitment.
func (c *Cosigner[E, S, M]) Round1() (*Round1Broadcast, error) <span class="cov8" title="1">{
        if c.round != 1 </span><span class="cov0" title="0">{
                return nil, ErrInvalidRound.WithMessage("Running round %d but participant expected round %d", 1, c.round)
        }</span>

        // step 1.1: Sample k_i &lt;-$- _q  &amp;  compute R_i = k_i * G
        // We won't use ComputeNonceCommitment of single party schnorr due to requiring message independence.
        // Any usable single party schnorr variant will have extra methods to allows us to correct parity and alike later.
        <span class="cov8" title="1">k, err := algebrautils.RandomNonIdentity(c.sf, c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create randomised nonce commitment")
        }</span>
        <span class="cov8" title="1">bigR := c.group.ScalarBaseOp(k)

        // step 1.2: Run c_i &lt;= commit(sid || R_i || i || S)
        commitment, opening, err := commitBigR(c, bigR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot commit to R")
        }</span>

        // step 1.4: Broadcast(c_i)
        <span class="cov8" title="1">broadcast := &amp;Round1Broadcast{
                BigRCommitment: commitment,
        }

        c.state.k = k
        c.state.bigR = bigR
        c.state.opening = opening
        c.round++

        return broadcast, nil</span>
}

// Round2 receives commitments from other parties and broadcasts the nonce with a discrete log proof.
func (c *Cosigner[E, S, M]) Round2(inb network.RoundMessages[*Round1Broadcast]) (*Round2Broadcast[E, S], error) <span class="cov8" title="1">{
        if c.round != 2 </span><span class="cov0" title="0">{
                return nil, ErrInvalidRound.WithMessage("Running round %d but participant expected round %d", 2, c.round)
        }</span>
        <span class="cov8" title="1">for pid := range c.quorum.Iter() </span><span class="cov8" title="1">{
                if c.SharingID() == pid </span><span class="cov8" title="1">{
                        continue</span> // skip self
                }
                <span class="cov8" title="1">received, _ := inb.Get(pid)
                c.state.theirBigRCommitments[pid] = received.BigRCommitment</span>
        }
        // step 2.1: ^dl_i &lt;- NIPoKDL.Prove(k_i, R_i, sessionID, S, nic)
        <span class="cov8" title="1">c.state.tapeFrozenBeforeDlogProof = c.tape.Clone()
        bigRProof, statement, err := dlogProve(c, c.state.k, c.state.bigR, c.state.quorumBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot prove dlog")
        }</span>

        // step 2.3: Broadcast(^dl_i, R_i, c_i)
        <span class="cov8" title="1">broadcast := &amp;Round2Broadcast[E, S]{
                BigR:        statement,
                BigROpening: c.state.opening,
                BigRProof:   bigRProof,
        }

        c.round++
        return broadcast, nil</span>
}

// Round3 verifies other parties' commitments and proofs, then computes the partial signature.
func (c *Cosigner[E, S, M]) Round3(inb network.RoundMessages[*Round2Broadcast[E, S]], message M) (*tschnorr.PartialSignature[E, S], error) <span class="cov8" title="1">{
        if c.round != 3 </span><span class="cov0" title="0">{
                return nil, ErrInvalidRound.WithMessage("Running round %d but participant expected round %d", 3, c.round)
        }</span>
        <span class="cov8" title="1">summedR := c.state.bigR
        for pid := range c.quorum.Iter() </span><span class="cov8" title="1">{
                if c.SharingID() == pid </span><span class="cov8" title="1">{
                        continue</span> // skip self
                }
                <span class="cov8" title="1">received, _ := inb.Get(pid)
                theirBigR := received.BigR
                theirOpening := received.BigROpening
                theirCommitment := c.state.theirBigRCommitments[pid]
                // step 3.2: Open(sid || R_j || j || S)
                if err := verifyBigRCommitment(c, pid, theirBigR.X, theirOpening, theirCommitment); err != nil </span><span class="cov8" title="1">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pid).WithMessage("cannot verify commitment for participant")
                }</span>
                // step 3.3: Run NIPoKDL.Verify(R_j, ^dl_j)
                <span class="cov8" title="1">if err := dlogVerify(
                        c.state.tapeFrozenBeforeDlogProof.Clone(), c.niDlogScheme, pid, c.sid, received.BigRProof, theirBigR, c.state.quorumBytes,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithTag(base.IdentifiableAbortPartyIDTag, pid).WithMessage("cannot verify dlog proof for participant")
                }</span>
                // step 3.4: R &lt;-  R_j
                <span class="cov8" title="1">summedR = summedR.Op(theirBigR.X)</span>
        }
        // step 3.7.2: compute e
        <span class="cov8" title="1">e, err := c.variant.ComputeChallenge(summedR, c.shard.PublicKey().Value(), message)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot create digest scalar")
        }</span>

        <span class="cov8" title="1">psig, err := c.ComputePartialSignature(summedR, e)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("cannot compute partial signature")
        }</span>
        <span class="cov8" title="1">c.round++
        return psig, nil</span>
}

func commitBigR[
        E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message,
](c *Cosigner[E, S, M], bigR E) (commitment lindell22.Commitment, opening lindell22.Opening, err error) <span class="cov8" title="1">{
        key, err := lindell22.NewCommitmentKey(c.sid, c.SharingID(), c.state.quorumBytes)
        if err != nil </span><span class="cov0" title="0">{
                return lindell22.Commitment{}, lindell22.Opening{}, errs2.Wrap(err).WithMessage("cannot create commitment key")
        }</span>
        // step 1.2: Run c_i &lt;= commit(sid || R_i || i || S)
        <span class="cov8" title="1">commitmentScheme, err := lindell22.NewCommitmentScheme(key)
        if err != nil </span><span class="cov0" title="0">{
                return lindell22.Commitment{}, lindell22.Opening{}, errs2.Wrap(err).WithMessage("cannot create commitment scheme")
        }</span>
        <span class="cov8" title="1">commitment, opening, err = commitmentScheme.Committer().Commit(bigR.Bytes(), c.prng)
        if err != nil </span><span class="cov0" title="0">{
                return lindell22.Commitment{}, lindell22.Opening{}, errs2.Wrap(err).WithMessage("cannot commit to R")
        }</span>
        <span class="cov8" title="1">return commitment, opening, nil</span>
}

func verifyBigRCommitment[
        E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message,
](c *Cosigner[E, S, M], theirID sharing.ID, theirBigR E, theirOpening lindell22.Opening, theirCommitment lindell22.Commitment) error <span class="cov8" title="1">{
        key, err := lindell22.NewCommitmentKey(c.sid, theirID, c.state.quorumBytes)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create commitment key for participant %d", theirID)
        }</span>
        <span class="cov8" title="1">commitmentScheme, err := lindell22.NewCommitmentScheme(key)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create commitment scheme for participant %d", theirID)
        }</span>
        <span class="cov8" title="1">if err := commitmentScheme.Verifier().Verify(theirCommitment, theirBigR.Bytes(), theirOpening); err != nil </span><span class="cov8" title="1">{
                return errs2.Wrap(err).WithMessage("cannot verify commitment for participant %d", theirID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func dlogProve[
        E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message,
](c *Cosigner[E, S, M], k S, bigR E, quorumBytes [][]byte) (proof compiler.NIZKPoKProof, statement *schnorrpok.Statement[E, S], err error) <span class="cov8" title="1">{
        proverIDBytes := binary.BigEndian.AppendUint64(nil, uint64(c.SharingID()))
        c.tape.AppendBytes(transcriptDLogSLabel, quorumBytes...)
        c.tape.AppendBytes("prover", proverIDBytes)
        prover, err := c.niDlogScheme.NewProver(c.sid, c.tape)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create dlog prover")
        }</span>
        <span class="cov8" title="1">statement = &amp;schnorrpok.Statement[E, S]{
                X: bigR,
        }
        witness := &amp;schnorrpok.Witness[S]{
                W: k,
        }
        proof, err = prover.Prove(statement, witness)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errs2.Wrap(err).WithMessage("cannot create dlog proof")
        }</span>
        <span class="cov8" title="1">return proof, statement, nil</span>
}

func dlogVerify[
        E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S],
](tape ts.Transcript, niDlogScheme compiler.NonInteractiveProtocol[*schnorrpok.Statement[E, S], *schnorrpok.Witness[S]], proverID sharing.ID, sid network.SID, proof compiler.NIZKPoKProof, theirBigR *schnorrpok.Statement[E, S], quorumBytes [][]byte) error <span class="cov8" title="1">{
        proverIDBytes := binary.BigEndian.AppendUint64(nil, uint64(proverID))
        tape.AppendBytes(transcriptDLogSLabel, quorumBytes...)
        tape.AppendBytes("prover", proverIDBytes)
        verifier, err := niDlogScheme.NewVerifier(sid, tape)
        if err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot create dlog verifier")
        }</span>
        <span class="cov8" title="1">if err := verifier.Verify(theirBigR, proof); err != nil </span><span class="cov0" title="0">{
                return errs2.Wrap(err).WithMessage("cannot verify dlog proof for participant %d", proverID)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file407" style="display: none">package testutils

import (
        "io"
        "testing"

        "github.com/stretchr/testify/require"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        ds "github.com/bronlabs/bron-crypto/pkg/base/datastructures"
        "github.com/bronlabs/bron-crypto/pkg/base/datastructures/hashmap"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/network"
        ntu "github.com/bronlabs/bron-crypto/pkg/network/testutils"
        dlogschnorr "github.com/bronlabs/bron-crypto/pkg/proofs/dlog/schnorr"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler"
        "github.com/bronlabs/bron-crypto/pkg/proofs/sigma/compiler/fiatshamir"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro"
        gentu "github.com/bronlabs/bron-crypto/pkg/threshold/dkg/gennaro/testutils"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22/keygen"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig/tschnorr/lindell22/signing"
        ts "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// DoLindell22DKG runs a complete DKG process and returns Lindell22 shards.
func DoLindell22DKG[
        GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S],
](
        t *testing.T,
        participants []*gennaro.Participant[GE, S],
) (shards ds.MutableMap[sharing.ID, *lindell22.Shard[GE, S]], err error) <span class="cov0" title="0">{
        t.Helper()

        // Run Gennaro DKG
        dkgOutputs, err := gentu.DoGennaroDKG(t, participants)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to run Gennaro DKG")
        }</span>
        <span class="cov0" title="0">shards = hashmap.NewComparable[sharing.ID, *lindell22.Shard[GE, S]]()
        for id, output := range dkgOutputs.Iter() </span><span class="cov0" title="0">{
                shard, err := keygen.NewShard(output)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("failed to create shard for participant %d", id)
                }</span>
                <span class="cov0" title="0">shards.Put(id, shard)</span>
        }
        <span class="cov0" title="0">return shards, nil</span>
}

// CreateLindell22Cosigners creates a set of cosigners for testing.
func CreateLindell22Cosigners[
        GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message,
](
        t *testing.T,
        signingSID network.SID,
        shards map[sharing.ID]*lindell22.Shard[GE, S],
        quorum network.Quorum,
        variant tschnorr.MPCFriendlyVariant[GE, S, M],
        newCompilerMaker func(protocol *dlogschnorr.Protocol[GE, S]) (compiler.NonInteractiveProtocol[*dlogschnorr.Statement[GE, S], *dlogschnorr.Witness[S]], error),
        transcript ts.Transcript,
        prng io.Reader,
) []*signing.Cosigner[GE, S, M] <span class="cov0" title="0">{
        t.Helper()

        cosigners := make([]*signing.Cosigner[GE, S, M], 0, quorum.Size())
        var group algebra.PrimeGroup[GE, S]

        for id := range quorum.Iter() </span><span class="cov0" title="0">{
                shard := shards[id]
                if group == nil </span><span class="cov0" title="0">{
                        group = shard.PublicKey().Group()
                }</span>

                <span class="cov0" title="0">niCompilerName := fiatshamir.Name
                cosigner, err := signing.NewCosigner[
                        GE, S, M,
                ](
                        signingSID,
                        ntu.CBORRoundTrip(t, shard),
                        quorum,
                        group,
                        niCompilerName,
                        variant,
                        prng,
                        transcript.Clone(),
                )
                require.NoError(t, err)
                cosigners = append(cosigners, cosigner)</span>
        }

        <span class="cov0" title="0">return cosigners</span>
}

func DoLindell22Round1[
        E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S],
        M schnorrlike.Message,
](
        participants []*signing.Cosigner[E, S, M],
) (
        r1bo map[sharing.ID]*signing.Round1Broadcast, err error,
) <span class="cov0" title="0">{
        r1bo = make(map[sharing.ID]*signing.Round1Broadcast, len(participants))
        for _, pi := range participants </span><span class="cov0" title="0">{
                r1bo[pi.SharingID()], err = pi.Round1()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("%d could not run lindell22 signing round 1", pi.SharingID())
                }</span>
        }

        <span class="cov0" title="0">return r1bo, nil</span>
}

func DoLindell22Round2[
        E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S],
        M schnorrlike.Message,
](
        participants []*signing.Cosigner[E, S, M], r2bi map[sharing.ID]network.RoundMessages[*signing.Round1Broadcast],
) (
        r2bo map[sharing.ID]*signing.Round2Broadcast[E, S], err error,
) <span class="cov0" title="0">{
        r2bo = make(map[sharing.ID]*signing.Round2Broadcast[E, S], len(participants))
        for _, pi := range participants </span><span class="cov0" title="0">{
                r2bo[pi.SharingID()], err = pi.Round2(r2bi[pi.SharingID()])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("%d could not run lindell22 signing round 2", pi.SharingID())
                }</span>
        }
        <span class="cov0" title="0">return r2bo, nil</span>
}

func DoLindell22Round3[
        E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S],
        M schnorrlike.Message,
](
        participants []*signing.Cosigner[E, S, M], r3bi map[sharing.ID]network.RoundMessages[*signing.Round2Broadcast[E, S]],
        message M,
) (
        psigs ds.MutableMap[sharing.ID, *lindell22.PartialSignature[E, S]], err error,
) <span class="cov0" title="0">{
        psigs = hashmap.NewComparable[sharing.ID, *lindell22.PartialSignature[E, S]]()
        for _, pi := range participants </span><span class="cov0" title="0">{
                v, err := pi.Round3(r3bi[pi.SharingID()], message)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errs2.Wrap(err).WithMessage("%d could not run Gennaro round 3", pi.SharingID())
                }</span>
                <span class="cov0" title="0">psigs.Put(pi.SharingID(), v)</span>
        }
        <span class="cov0" title="0">return psigs, nil</span>
}

// CreateCorruptedPartialSignature creates an invalid partial signature for testing.
func CreateCorruptedPartialSignature[
        GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S],
](
        t *testing.T,
        validPsig *lindell22.PartialSignature[GE, S],
        sf algebra.PrimeField[S],
) *lindell22.PartialSignature[GE, S] <span class="cov0" title="0">{
        t.Helper()

        // Corrupt the S value by adding 1
        corruptedS := validPsig.Sig.S.Add(sf.One())

        return &amp;lindell22.PartialSignature[GE, S]{
                Sig: schnorrlike.Signature[GE, S]{
                        E: validPsig.Sig.E,
                        R: validPsig.Sig.R,
                        S: corruptedS,
                },
        }
}</span>

// NewFiatShamirCompiler creates a new Fiat-Shamir compiler for the given protocol.
func NewFiatShamirCompiler[
        GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S],
](
        protocol *dlogschnorr.Protocol[GE, S],
) (compiler.NonInteractiveProtocol[*dlogschnorr.Statement[GE, S], *dlogschnorr.Witness[S]], error) <span class="cov0" title="0">{
        return fiatshamir.NewCompiler(protocol)
}</span>
</pre>
		
		<pre class="file" id="file408" style="display: none">package tschnorr

import (
        "sync"

        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/signatures"
        "github.com/bronlabs/bron-crypto/pkg/signatures/schnorrlike"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/additive"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing/feldman"
        "github.com/bronlabs/bron-crypto/pkg/threshold/tsig"
)

// MPCFriendlyVariant extends schnorrlike.Variant with methods needed for threshold signing.
// It provides parity correction for secret shares and nonces required by some Schnorr variants.
type MPCFriendlyVariant[GE algebra.PrimeGroupElement[GE, S], S algebra.PrimeFieldElement[S], M schnorrlike.Message] interface {
        schnorrlike.Variant[GE, S, M]
        CorrectAdditiveSecretShareParity(publicKey *schnorrlike.PublicKey[GE, S], share *additive.Share[S]) (*additive.Share[S], error)
        CorrectPartialNonceParity(aggregatedNonceCommitment GE, nonce S) (GE, S, error)
}

// MPCFriendlyScheme extends schnorrlike.Scheme with threshold signing capabilities.
// It provides a partial signature verifier for validating individual party contributions.
type MPCFriendlyScheme[
        VR MPCFriendlyVariant[GE, S, M],
        GE algebra.PrimeGroupElement[GE, S],
        S algebra.PrimeFieldElement[S],
        M schnorrlike.Message,
        KG signatures.KeyGenerator[*schnorrlike.PrivateKey[GE, S], *schnorrlike.PublicKey[GE, S]],
        SG schnorrlike.Signer[VR, GE, S, M],
        VF schnorrlike.Verifier[VR, GE, S, M],
] interface {
        schnorrlike.Scheme[VR, GE, S, M, KG, SG, VF]
        PartialSignatureVerifier(
                fullPublicKey *schnorrlike.PublicKey[GE, S],
                opts ...signatures.VerifierOption[VF, *schnorrlike.PublicKey[GE, S], M, *schnorrlike.Signature[GE, S]],
        ) (schnorrlike.Verifier[VR, GE, S, M], error) // making batch verification etc is not objective here, so won't return VF
}

// PartialSignature represents a party's contribution to a threshold Schnorr signature.
type PartialSignature[
        GE algebra.PrimeGroupElement[GE, S],
        S algebra.PrimeFieldElement[S],
] struct {
        Sig schnorrlike.Signature[GE, S]
}

// AsSchnorrSignature returns the underlying Schnorr signature.
func (ps *PartialSignature[GE, S]) AsSchnorrSignature() *schnorrlike.Signature[GE, S] <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;ps.Sig</span>
}

// Bytes serialises the partial signature to a byte slice.
func (ps *PartialSignature[E, S]) Bytes() []byte <span class="cov0" title="0">{
        if ps == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := ps.Sig.S.Bytes()
        out = append(out, ps.Sig.R.Bytes()...)
        out = append(out, ps.Sig.E.Bytes()...)
        return out</span>
}

// PublicMaterial contains public information for threshold Schnorr signature verification.
type PublicMaterial[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]] struct {
        tsig.BasePublicMaterial[E, S]

        pk     *schnorrlike.PublicKey[E, S]
        pkOnce sync.Once
}

// PublicKey returns the threshold public key as a schnorrlike.PublicKey.
func (pm *PublicMaterial[E, S]) PublicKey() *schnorrlike.PublicKey[E, S] <span class="cov0" title="0">{
        pm.pkOnce.Do(func() </span><span class="cov0" title="0">{
                var err error
                pm.pk, err = schnorrlike.NewPublicKey(pm.BasePublicMaterial.PublicKey())
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        })
        <span class="cov0" title="0">return pm.pk</span>
}

// Shard represents a party's secret key share for threshold Schnorr signing.
type Shard[
        E algebra.PrimeGroupElement[E, S],
        S algebra.PrimeFieldElement[S],
] struct {
        tsig.BaseShard[E, S]

        pk     *schnorrlike.PublicKey[E, S]
        pkOnce sync.Once
}

// PublicKeyMaterial returns the public material derived from this shard.
func (sh *Shard[E, S]) PublicKeyMaterial() *PublicMaterial[E, S] <span class="cov0" title="0">{
        return &amp;PublicMaterial[E, S]{
                BasePublicMaterial: sh.BasePublicMaterial,
                pk:                 sh.pk,
                pkOnce:             sync.Once{},
        }
}</span>

// PublicKey returns the threshold public key as a schnorrlike.PublicKey.
func (sh *Shard[E, S]) PublicKey() *schnorrlike.PublicKey[E, S] <span class="cov0" title="0">{
        sh.pkOnce.Do(func() </span><span class="cov0" title="0">{
                var err error
                sh.pk, err = schnorrlike.NewPublicKey(sh.BaseShard.PublicKey())
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        })
        <span class="cov0" title="0">return sh.pk</span>
}

// Equal returns true if this shard equals another shard.
func (sh *Shard[E, S]) Equal(other tsig.Shard[*schnorrlike.PublicKey[E, S], *feldman.Share[S], *sharing.ThresholdAccessStructure]) bool <span class="cov0" title="0">{
        o, ok := other.(*Shard[E, S])
        return ok &amp;&amp; sh.BaseShard.Equal(&amp;o.BaseShard)
}</span>

// AsSchnorrPrivateKey converts the shard to a schnorrlike.PrivateKey for single-party operations.
func (sh *Shard[E, S]) AsSchnorrPrivateKey() (*schnorrlike.PrivateKey[E, S], error) <span class="cov0" title="0">{
        if sh == nil || sh.Share() == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("shard or share is nil")
        }</span>
        <span class="cov0" title="0">sk, err := schnorrlike.NewPrivateKey(sh.Share().Value(), sh.PublicKey())
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("failed to create schnorr private key from share")
        }</span>
        <span class="cov0" title="0">return sk, nil</span>
}

// NewShard creates a new threshold Schnorr shard from a Feldman share, verification vector, and access structure.
func NewShard[E algebra.PrimeGroupElement[E, S], S algebra.PrimeFieldElement[S]](
        share *feldman.Share[S],
        fv feldman.VerificationVector[E, S],
        accessStructure *sharing.ThresholdAccessStructure,
) (*Shard[E, S], error) <span class="cov0" title="0">{
        if share == nil || fv == nil || accessStructure == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidArgument.WithMessage("nil input parameters")
        }</span>
        <span class="cov0" title="0">bs, err := tsig.NewBaseShard(share, fv, accessStructure)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create base shard")
        }</span>
        <span class="cov0" title="0">pk, err := schnorrlike.NewPublicKey(fv.Coefficients()[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not create public key from verification vector")
        }</span>
        <span class="cov0" title="0">return &amp;Shard[E, S]{BaseShard: *bs, pk: pk, pkOnce: sync.Once{}}, nil</span>
}

var (
        ErrInvalidArgument = errs2.New("invalid argument")
)
</pre>
		
		<pre class="file" id="file409" style="display: none">package hagrid

import (
        "encoding/binary"
        "io"

        "golang.org/x/crypto/sha3"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
)

// Keep the tag at constant length.
type tag byte

const (
        customizedShakeName = "BRON_CRYPTO_HAGRID_TRANSCRIPT-"

        domainTag tag = iota + 0xa0
        appendTag
        extractTag
        extractedTag
        continuedTag
)

type transcript struct {
        h sha3.ShakeHash
}

// NewTranscript returns a transcript instance bound to the provided protocol name.
func NewTranscript(name string) transcripts.Transcript <span class="cov0" title="0">{
        t := &amp;transcript{h: sha3.NewCShake256(nil, []byte(customizedShakeName+name))}
        return t
}</span>

// AppendDomainSeparator adds a domain separator tag to the transcript.
func (t *transcript) AppendDomainSeparator(domainSeparatorTag string) <span class="cov0" title="0">{
        _, _ = t.h.Write([]byte{byte(domainTag)})
        _, _ = t.h.Write(binary.BigEndian.AppendUint64(nil, uint64(len(domainSeparatorTag))))
        _, _ = t.h.Write([]byte(domainSeparatorTag))
}</span>

// AppendBytes appends labelled message bytes to the transcript.
func (t *transcript) AppendBytes(label string, messages ...[]byte) <span class="cov0" title="0">{
        _, _ = t.h.Write([]byte{byte(appendTag)})
        _, _ = t.h.Write(binary.BigEndian.AppendUint64(nil, uint64(len(label))))
        _, _ = t.h.Write([]byte(label))
        _, _ = t.h.Write(binary.BigEndian.AppendUint64(nil, uint64(len(messages))))
        for _, message := range messages </span><span class="cov0" title="0">{
                _, _ = t.h.Write(binary.BigEndian.AppendUint64(nil, uint64(len(message))))
                _, _ = t.h.Write(message)
        }</span>
}

// ExtractBytes derives outLen bytes from the transcript under the given label.
func (t *transcript) ExtractBytes(label string, outLen uint) ([]byte, error) <span class="cov0" title="0">{
        _, _ = t.h.Write([]byte{byte(extractTag)})
        _, _ = t.h.Write(binary.BigEndian.AppendUint64(nil, uint64(len(label))))
        _, _ = t.h.Write([]byte(label))
        _, _ = t.h.Write(binary.BigEndian.AppendUint64(nil, uint64(outLen)))
        hClone := t.h.Clone()

        // Explicitly fork these transcripts to prevent length extension attacks from being possible
        // (at least, without the additional ability to remove a byte from a finalised hash).
        _, _ = t.h.Write([]byte{byte(continuedTag)})
        _, _ = hClone.Write([]byte{byte(extractedTag)})

        buf := make([]byte, outLen)
        if _, err := io.ReadFull(hClone, buf); err != nil </span><span class="cov0" title="0">{
                return nil, errs2.Wrap(err).WithMessage("could not read from SHAKE hash")
        }</span>

        <span class="cov0" title="0">return buf, nil</span>
}

// Clone returns a copy of the transcript in its current state.
func (t *transcript) Clone() transcripts.Transcript <span class="cov0" title="0">{
        h := t.h.Clone()
        return &amp;transcript{h}
}</span>
</pre>
		
		<pre class="file" id="file410" style="display: none">package transcripts_tu

import (
        "encoding/hex"
        "io"
        "testing"

        "github.com/bronlabs/bron-crypto/pkg/network"
        "github.com/bronlabs/bron-crypto/pkg/threshold/sharing"
        "github.com/bronlabs/bron-crypto/pkg/transcripts"
        "github.com/bronlabs/bron-crypto/pkg/transcripts/hagrid"
        "github.com/stretchr/testify/require"
)

func MakeRandomTapes(tb testing.TB, prng io.Reader, quorum network.Quorum) map[sharing.ID]transcripts.Transcript <span class="cov0" title="0">{
        tb.Helper()

        var label [32]byte
        _, err := io.ReadFull(prng, label[:])
        require.NoError(tb, err)

        tapes := make(map[sharing.ID]transcripts.Transcript)
        for id := range quorum.Iter() </span><span class="cov0" title="0">{
                tape := hagrid.NewTranscript(hex.EncodeToString(label[:]))
                tapes[id] = tape
        }</span>

        <span class="cov0" title="0">return tapes</span>
}
</pre>
		
		<pre class="file" id="file411" style="display: none">package transcripts

import (
        "github.com/bronlabs/bron-crypto/pkg/base"
        "github.com/bronlabs/bron-crypto/pkg/base/algebra"
        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
)

// Append writes BytesLike values to the transcript under the given label.
func Append[T base.BytesLike](tape Transcript, label string, xs ...T) <span class="cov0" title="0">{
        for _, x := range xs </span><span class="cov0" title="0">{
                tape.AppendBytes(label, x.Bytes())
        }</span>
}

// Extract derives a field element from the transcript using the given structure.
func Extract[T base.BytesLike](tape Transcript, label string, f algebra.FiniteStructure[T]) (T, error) <span class="cov0" title="0">{
        buf, err := tape.ExtractBytes(label, uint(f.ElementSize()+(base.StatisticalSecurityBytesCeil)))
        if err != nil </span><span class="cov0" title="0">{
                return *new(T), errs2.Wrap(err).WithMessage("could not extract bytes from transcript")
        }</span>
        <span class="cov0" title="0">x, err := f.Hash(buf)
        if err != nil </span><span class="cov0" title="0">{
                return *new(T), errs2.Wrap(err).WithMessage("could not extract bytes from transcript")
        }</span>

        <span class="cov0" title="0">return x, nil</span>
}
</pre>
		
		<pre class="file" id="file412" style="display: none">// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build gc &amp;&amp; !purego

package chacha20

const bufSize = 256

//go:noescape
func xorKeyStreamVX(dst, src []byte, key *[8]uint32, nonce *[3]uint32, counter *uint32)

func (c *Cipher) xorKeyStreamBlocks(dst, src []byte, key *[8]uint32) <span class="cov0" title="0">{
        // CUSTOM: expose key choice
        xorKeyStreamVX(dst, src, key, &amp;c.nonce, &amp;c.counter)
}</span>
</pre>
		
		<pre class="file" id="file413" style="display: none">// Copyright 2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package chacha20 implements the ChaCha20 and XChaCha20 encryption algorithms
// as specified in RFC 8439 and draft-irtf-cfrg-xchacha-01.
package chacha20

import (
        "crypto/cipher"
        "encoding/binary"
        "math/bits"

        "github.com/bronlabs/bron-crypto/thirdparty/golang/crypto/internal/alias"
)

const (
        // KeySize is the size of the key used by this cipher, in bytes.
        KeySize = 32

        // NonceSize is the size of the nonce used with the standard variant of this
        // cipher, in bytes.
        //
        // Note that this is too short to be safely generated at random if the same
        // key is reused more than 2 times.
        NonceSize = 12

        // NonceSizeX is the size of the nonce used with the XChaCha20 variant of
        // this cipher, in bytes.
        NonceSizeX = 24
)

// Cipher is a stateful instance of ChaCha20 or XChaCha20 using a particular key
// and nonce. A *Cipher implements the cipher.Stream interface.
type Cipher struct {
        // The ChaCha20 state is 16 words: 4 constant, 8 of key, 1 of counter
        // (incremented after each block), and 3 of nonce.
        key     [8]uint32
        counter uint32
        nonce   [3]uint32

        // The last remaining bytes of buf are leftover key stream bytes from the previous
        // XORKeyStream invocation. The size of buf depends on how many blocks are
        // computed at a time by xorKeyStreamBlocks.
        buf       [bufSize]byte
        remaining int

        // overflow is set when the counter overflowed, no more blocks can be
        // generated, and the next XORKeyStream call should panic.
        overflow bool

        // The counter-independent results of the first round are cached after they
        // are computed the first time.
        precompDone      bool
        p1, p5, p9, p13  uint32
        p2, p6, p10, p14 uint32
        p3, p7, p11, p15 uint32
}

var _ cipher.Stream = (*Cipher)(nil)

// NewUnauthenticatedCipher creates a new ChaCha20 stream cipher with the given
// 32 bytes key and a 12 or 24 bytes nonce. If a nonce of 24 bytes is provided,
// the XChaCha20 construction will be used. It returns an error if key or nonce
// have any other length.
//
// Note that ChaCha20, like all stream ciphers, is not authenticated and allows
// attackers to silently tamper with the plaintext. For this reason, it is more
// appropriate as a building block than as a standalone encryption mechanism.
// Instead, consider using package golang.org/x/crypto/chacha20poly1305.
func NewUnauthenticatedCipher(key, nonce []byte) (*Cipher, error) <span class="cov0" title="0">{
        // This function is split into a wrapper so that the Cipher allocation will
        // be inlined, and depending on how the caller uses the return value, won't
        // escape to the heap.
        c := &amp;Cipher{}
        return newUnauthenticatedCipher(c, key, nonce)
}</span>

func newUnauthenticatedCipher(c *Cipher, key, nonce []byte) (*Cipher, error) <span class="cov0" title="0">{
        if len(key) != KeySize </span><span class="cov0" title="0">{
                return nil, ErrInvalidSize.WithMessage("chacha20: wrong key size")
        }</span>
        <span class="cov0" title="0">if len(nonce) == NonceSizeX </span><span class="cov0" title="0">{
                // XChaCha20 uses the ChaCha20 core to mix 16 bytes of the nonce into a
                // derived key, allowing it to operate on a nonce of 24 bytes. See
                // draft-irtf-cfrg-xchacha-01, Section 2.3.
                key, _ = HChaCha20(key, nonce[0:16])
                cNonce := make([]byte, NonceSize)
                copy(cNonce[4:12], nonce[16:24])
                nonce = cNonce
        }</span> else<span class="cov0" title="0"> if len(nonce) != NonceSize </span><span class="cov0" title="0">{
                return nil, ErrInvalidSize.WithMessage("chacha20: wrong nonce size")
        }</span>

        <span class="cov0" title="0">key, nonce = key[:KeySize], nonce[:NonceSize] // bounds check elimination hint
        c.key = [8]uint32{
                binary.LittleEndian.Uint32(key[0:4]),
                binary.LittleEndian.Uint32(key[4:8]),
                binary.LittleEndian.Uint32(key[8:12]),
                binary.LittleEndian.Uint32(key[12:16]),
                binary.LittleEndian.Uint32(key[16:20]),
                binary.LittleEndian.Uint32(key[20:24]),
                binary.LittleEndian.Uint32(key[24:28]),
                binary.LittleEndian.Uint32(key[28:32]),
        }
        c.nonce = [3]uint32{
                binary.LittleEndian.Uint32(nonce[0:4]),
                binary.LittleEndian.Uint32(nonce[4:8]),
                binary.LittleEndian.Uint32(nonce[8:12]),
        }
        return c, nil</span>
}

// The constant first 4 words of the ChaCha20 state.
const (
        j0 uint32 = 0x61707865 // expa
        j1 uint32 = 0x3320646e // nd 3
        j2 uint32 = 0x79622d32 // 2-by
        j3 uint32 = 0x6b206574 // te k
)

const blockSize = 64

// quarterRound is the core of ChaCha20. It shuffles the bits of 4 state words.
// It's executed 4 times for each of the 20 ChaCha20 rounds, operating on all 16
// words each round, in columnar or diagonal groups of 4 at a time.
func quarterRound(a, b, c, d uint32) (ra, rb, rc, rd uint32) <span class="cov0" title="0">{
        a += b
        d ^= a
        d = bits.RotateLeft32(d, 16)
        c += d
        b ^= c
        b = bits.RotateLeft32(b, 12)
        a += b
        d ^= a
        d = bits.RotateLeft32(d, 8)
        c += d
        b ^= c
        b = bits.RotateLeft32(b, 7)
        return a, b, c, d
}</span>

// SetCounter sets the Cipher counter. The next invocation of XORKeyStream will
// behave as if (64 * counter) bytes had been encrypted so far.
//
// To prevent accidental counter reuse, SetCounter panics if counter is less
// than the current value.
//
// Note that the execution time of XORKeyStream is not independent of the
// counter value.
func (s *Cipher) SetCounter(counter uint32) <span class="cov0" title="0">{
        // Internally, s may buffer multiple blocks, which complicates this
        // implementation slightly. When checking whether the counter has rolled
        // back, we must use both s.counter and s.remaining to determine how many
        // blocks we have already output.
        outputCounter := s.counter - uint32(s.remaining)/blockSize
        if s.overflow || counter &lt; outputCounter </span><span class="cov0" title="0">{
                panic("chacha20: SetCounter attempted to rollback counter")</span>
        }

        // In the general case, we set the new counter value and reset s.remaining
        // to 0, causing the next call to XORKeyStream to refill the buffer. However,
        // if we're advancing within the existing buffer, we can save work by simply
        // setting s.remaining.
        <span class="cov0" title="0">if counter &lt; s.counter </span><span class="cov0" title="0">{
                s.remaining = int(s.counter-counter) * blockSize
        }</span> else<span class="cov0" title="0"> {
                s.counter = counter
                s.remaining = 0
        }</span>
}

// XORKeyStream XORs each byte in the given slice with a byte from the
// cipher's key stream. Dst and src must overlap entirely or not at all.
//
// If len(dst) &lt; len(src), XORKeyStream will panic. It is acceptable
// to pass a dst bigger than src, and in that case, XORKeyStream will
// only update dst[:len(src)] and will not touch the rest of dst.
//
// Multiple calls to XORKeyStream behave as if the concatenation of
// the src buffers was passed in a single run. That is, Cipher
// maintains state and does not reset at each XORKeyStream call.
func (s *Cipher) XORKeyStream(dst, src []byte) <span class="cov0" title="0">{
        if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(dst) &lt; len(src) </span><span class="cov0" title="0">{
                panic("chacha20: output smaller than input")</span>
        }
        <span class="cov0" title="0">dst = dst[:len(src)]
        if alias.InexactOverlap(dst, src) </span><span class="cov0" title="0">{
                panic("chacha20: invalid buffer overlap")</span>
        }

        // First, drain any remaining key stream from a previous XORKeyStream.
        <span class="cov0" title="0">if s.remaining != 0 </span><span class="cov0" title="0">{
                keyStream := s.buf[bufSize-s.remaining:]
                if len(src) &lt; len(keyStream) </span><span class="cov0" title="0">{
                        keyStream = keyStream[:len(src)]
                }</span>
                <span class="cov0" title="0">_ = src[len(keyStream)-1] // bounds check elimination hint
                for i, b := range keyStream </span><span class="cov0" title="0">{
                        dst[i] = src[i] ^ b
                }</span>
                <span class="cov0" title="0">s.remaining -= len(keyStream)
                dst, src = dst[len(keyStream):], src[len(keyStream):]</span>
        }
        <span class="cov0" title="0">if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // If we'd need to let the counter overflow and keep generating output,
        // panic immediately. If instead we'd only reach the last block, remember
        // not to generate any more output after the buffer is drained.
        <span class="cov0" title="0">numBlocks := (uint64(len(src)) + blockSize - 1) / blockSize
        if s.overflow || uint64(s.counter)+numBlocks &gt; 1&lt;&lt;32 </span><span class="cov0" title="0">{
                panic("chacha20: counter overflow")</span>
        } else<span class="cov0" title="0"> if uint64(s.counter)+numBlocks == 1&lt;&lt;32 </span><span class="cov0" title="0">{
                s.overflow = true
        }</span>

        // xorKeyStreamBlocks implementations expect input lengths that are a
        // multiple of bufSize. Platform-specific ones process multiple blocks at a
        // time, so have bufSizes that are a multiple of blockSize.

        <span class="cov0" title="0">full := len(src) - len(src)%bufSize
        if full &gt; 0 </span><span class="cov0" title="0">{
                s.xorKeyStreamBlocks(dst[:full], src[:full], &amp;s.key)
        }</span>
        <span class="cov0" title="0">dst, src = dst[full:], src[full:]

        // If using a multi-block xorKeyStreamBlocks would overflow, use the generic
        // one that does one block at a time.
        const blocksPerBuf = bufSize / blockSize
        if uint64(s.counter)+blocksPerBuf &gt; 1&lt;&lt;32 </span><span class="cov0" title="0">{
                s.buf = [bufSize]byte{}
                numBlocks := (len(src) + blockSize - 1) / blockSize
                buf := s.buf[bufSize-numBlocks*blockSize:]
                copy(buf, src)
                s.xorKeyStreamBlocksGeneric(buf, buf, &amp;s.key)
                s.remaining = len(buf) - copy(dst, buf)
                return
        }</span>

        // If we have a partial (multi-)block, pad it for xorKeyStreamBlocks, and
        // keep the leftover keystream for the next XORKeyStream invocation.
        <span class="cov0" title="0">if len(src) &gt; 0 </span><span class="cov0" title="0">{
                s.buf = [bufSize]byte{}
                copy(s.buf[:], src)
                s.xorKeyStreamBlocks(s.buf[:], s.buf[:], &amp;s.key)
                s.remaining = bufSize - copy(dst, s.buf[:])
        }</span>
}

func (s *Cipher) xorKeyStreamBlocksGeneric(dst, src []byte, key *[8]uint32) <span class="cov0" title="0">{
        if len(dst) != len(src) || len(dst)%blockSize != 0 </span><span class="cov0" title="0">{
                panic("chacha20: internal error: wrong dst and/or src length")</span>
        }

        // To generate each block of key stream, the initial cipher state
        // (represented below) is passed through 20 rounds of shuffling,
        // alternatively applying quarterRounds by columns (like 1, 5, 9, 13)
        // or by diagonals (like 1, 6, 11, 12).
        //
        //      0:cccccccc   1:cccccccc   2:cccccccc   3:cccccccc
        //      4:kkkkkkkk   5:kkkkkkkk   6:kkkkkkkk   7:kkkkkkkk
        //      8:kkkkkkkk   9:kkkkkkkk  10:kkkkkkkk  11:kkkkkkkk
        //     12:bbbbbbbb  13:nnnnnnnn  14:nnnnnnnn  15:nnnnnnnn
        //
        //            c=constant k=key b=blockcount n=nonce
        <span class="cov0" title="0">var (
                c0, c1, c2, c3   = j0, j1, j2, j3
                c4, c5, c6, c7   = key[0], key[1], key[2], key[3]
                c8, c9, c10, c11 = key[4], key[5], key[6], key[7]
                _, c13, c14, c15 = s.counter, s.nonce[0], s.nonce[1], s.nonce[2]
        )

        // Three quarters of the first round don't depend on the counter, so we can
        // calculate them here, and reuse them for multiple blocks in the loop, and
        // for future XORKeyStream invocations.
        if !s.precompDone </span><span class="cov0" title="0">{
                s.p1, s.p5, s.p9, s.p13 = quarterRound(c1, c5, c9, c13)
                s.p2, s.p6, s.p10, s.p14 = quarterRound(c2, c6, c10, c14)
                s.p3, s.p7, s.p11, s.p15 = quarterRound(c3, c7, c11, c15)
                s.precompDone = true
        }</span>

        // A condition of len(src) &gt; 0 would be sufficient, but this also
        // acts as a bounds check elimination hint.
        <span class="cov0" title="0">for len(src) &gt;= 64 &amp;&amp; len(dst) &gt;= 64 </span><span class="cov0" title="0">{
                // The remainder of the first column round.
                fcr0, fcr4, fcr8, fcr12 := quarterRound(c0, c4, c8, s.counter)

                // The second diagonal round.
                x0, x5, x10, x15 := quarterRound(fcr0, s.p5, s.p10, s.p15)
                x1, x6, x11, x12 := quarterRound(s.p1, s.p6, s.p11, fcr12)
                x2, x7, x8, x13 := quarterRound(s.p2, s.p7, fcr8, s.p13)
                x3, x4, x9, x14 := quarterRound(s.p3, fcr4, s.p9, s.p14)

                // The remaining 18 rounds.
                for i := 0; i &lt; 9; i++ </span><span class="cov0" title="0">{
                        // Column round.
                        x0, x4, x8, x12 = quarterRound(x0, x4, x8, x12)
                        x1, x5, x9, x13 = quarterRound(x1, x5, x9, x13)
                        x2, x6, x10, x14 = quarterRound(x2, x6, x10, x14)
                        x3, x7, x11, x15 = quarterRound(x3, x7, x11, x15)

                        // Diagonal round.
                        x0, x5, x10, x15 = quarterRound(x0, x5, x10, x15)
                        x1, x6, x11, x12 = quarterRound(x1, x6, x11, x12)
                        x2, x7, x8, x13 = quarterRound(x2, x7, x8, x13)
                        x3, x4, x9, x14 = quarterRound(x3, x4, x9, x14)
                }</span>

                // Add back the initial state to generate the key stream, then
                // XOR the key stream with the source and write out the result.
                <span class="cov0" title="0">addXor(dst[0:4], src[0:4], x0, c0)
                addXor(dst[4:8], src[4:8], x1, c1)
                addXor(dst[8:12], src[8:12], x2, c2)
                addXor(dst[12:16], src[12:16], x3, c3)
                addXor(dst[16:20], src[16:20], x4, c4)
                addXor(dst[20:24], src[20:24], x5, c5)
                addXor(dst[24:28], src[24:28], x6, c6)
                addXor(dst[28:32], src[28:32], x7, c7)
                addXor(dst[32:36], src[32:36], x8, c8)
                addXor(dst[36:40], src[36:40], x9, c9)
                addXor(dst[40:44], src[40:44], x10, c10)
                addXor(dst[44:48], src[44:48], x11, c11)
                addXor(dst[48:52], src[48:52], x12, s.counter)
                addXor(dst[52:56], src[52:56], x13, c13)
                addXor(dst[56:60], src[56:60], x14, c14)
                addXor(dst[60:64], src[60:64], x15, c15)

                s.counter++

                src, dst = src[blockSize:], dst[blockSize:]</span>
        }
}

// HChaCha20 uses the ChaCha20 core to generate a derived key from a 32 bytes
// key and a 16 bytes nonce. It returns an error if key or nonce have any other
// length. It is used as part of the XChaCha20 construction.
func HChaCha20(key, nonce []byte) ([]byte, error) <span class="cov0" title="0">{
        // This function is split into a wrapper so that the slice allocation will
        // be inlined, and depending on how the caller uses the return value, won't
        // escape to the heap.
        out := make([]byte, 32)
        return hChaCha20(out, key, nonce)
}</span>

func hChaCha20(out, key, nonce []byte) ([]byte, error) <span class="cov0" title="0">{
        if len(key) != KeySize </span><span class="cov0" title="0">{
                return nil, ErrInvalidSize.WithMessage("chacha20: wrong HChaCha20 key size")
        }</span>
        <span class="cov0" title="0">if len(nonce) != 16 </span><span class="cov0" title="0">{
                return nil, ErrInvalidSize.WithMessage("chacha20: wrong HChaCha20 nonce size")
        }</span>

        <span class="cov0" title="0">x0, x1, x2, x3 := j0, j1, j2, j3
        x4 := binary.LittleEndian.Uint32(key[0:4])
        x5 := binary.LittleEndian.Uint32(key[4:8])
        x6 := binary.LittleEndian.Uint32(key[8:12])
        x7 := binary.LittleEndian.Uint32(key[12:16])
        x8 := binary.LittleEndian.Uint32(key[16:20])
        x9 := binary.LittleEndian.Uint32(key[20:24])
        x10 := binary.LittleEndian.Uint32(key[24:28])
        x11 := binary.LittleEndian.Uint32(key[28:32])
        x12 := binary.LittleEndian.Uint32(nonce[0:4])
        x13 := binary.LittleEndian.Uint32(nonce[4:8])
        x14 := binary.LittleEndian.Uint32(nonce[8:12])
        x15 := binary.LittleEndian.Uint32(nonce[12:16])

        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                // Diagonal round.
                x0, x4, x8, x12 = quarterRound(x0, x4, x8, x12)
                x1, x5, x9, x13 = quarterRound(x1, x5, x9, x13)
                x2, x6, x10, x14 = quarterRound(x2, x6, x10, x14)
                x3, x7, x11, x15 = quarterRound(x3, x7, x11, x15)

                // Column round.
                x0, x5, x10, x15 = quarterRound(x0, x5, x10, x15)
                x1, x6, x11, x12 = quarterRound(x1, x6, x11, x12)
                x2, x7, x8, x13 = quarterRound(x2, x7, x8, x13)
                x3, x4, x9, x14 = quarterRound(x3, x4, x9, x14)
        }</span>

        <span class="cov0" title="0">_ = out[31] // bounds check elimination hint
        binary.LittleEndian.PutUint32(out[0:4], x0)
        binary.LittleEndian.PutUint32(out[4:8], x1)
        binary.LittleEndian.PutUint32(out[8:12], x2)
        binary.LittleEndian.PutUint32(out[12:16], x3)
        binary.LittleEndian.PutUint32(out[16:20], x12)
        binary.LittleEndian.PutUint32(out[20:24], x13)
        binary.LittleEndian.PutUint32(out[24:28], x14)
        binary.LittleEndian.PutUint32(out[28:32], x15)
        return out, nil</span>
}
</pre>
		
		<pre class="file" id="file414" style="display: none">package chacha20

import (
        "encoding/binary"

        "github.com/bronlabs/bron-crypto/pkg/base/errs2"
        "github.com/bronlabs/bron-crypto/pkg/base/utils/sliceutils"
        "github.com/bronlabs/bron-crypto/thirdparty/golang/crypto/internal/alias"
)

var (
        ErrInvalidSize = errs2.New("chacha20: invalid size")
)

type FastKeyErasureCipher struct {
        *Cipher
}

func NewFastErasureCipher(key, nonce []byte) (*FastKeyErasureCipher, error) <span class="cov0" title="0">{
        c, err := NewUnauthenticatedCipher(key, nonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;FastKeyErasureCipher{c}, nil</span>
}

func (c *FastKeyErasureCipher) setKey(key []byte) <span class="cov0" title="0">{
        key = key[:KeySize]
        c.precompDone = false
        c.key = [8]uint32{
                binary.LittleEndian.Uint32(key[0:4]),
                binary.LittleEndian.Uint32(key[4:8]),
                binary.LittleEndian.Uint32(key[8:12]),
                binary.LittleEndian.Uint32(key[12:16]),
                binary.LittleEndian.Uint32(key[16:20]),
                binary.LittleEndian.Uint32(key[20:24]),
                binary.LittleEndian.Uint32(key[24:28]),
                binary.LittleEndian.Uint32(key[28:32]),
        }
}</span>

// XORKeyStream XORs each byte in the given slice with a byte from the
// cipher's key stream. Dst and src must overlap entirely or not at all.
//
// NOTE: This is a copy-paste of XORKeyStream, modified to erase the key stream
// after it is used, and to refresh the key on every read unless the buffer is
// not exhausted, providing a degree of forward secrecy. Changes are flagged
// with the comment "CUSTOM".
//
// If len(dst) &lt; len(src), XORKeyStream will panic. It is acceptable
// to pass a dst bigger than src, and in that case, XORKeyStream will
// only update dst[:len(src)] and will not touch the rest of dst.
//
// Multiple calls to XORKeyStream behave as if the concatenation of
// the src buffers was passed in a single run. That is, Cipher
// maintains state and does not reset at each XORKeyStream call.
//

func (c *FastKeyErasureCipher) XORKeyStream(dst, src []byte) <span class="cov0" title="0">{
        if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if len(dst) &lt; len(src) </span><span class="cov0" title="0">{
                panic("chacha20: output smaller than input")</span>
        }
        <span class="cov0" title="0">dst = dst[:len(src)]
        if alias.InexactOverlap(dst, src) </span><span class="cov0" title="0">{
                panic("chacha20: invalid buffer overlap")</span>
        }

        // First, drain any remaining key stream from a previous XORKeyStream.
        <span class="cov0" title="0">if c.remaining != 0 </span><span class="cov0" title="0">{
                keyStream := c.buf[bufSize-c.remaining:]
                if len(src) &lt; len(keyStream) </span><span class="cov0" title="0">{
                        keyStream = keyStream[:len(src)]
                }</span>
                <span class="cov0" title="0">_ = src[len(keyStream)-1] // bounds check elimination hint
                for i, b := range keyStream </span><span class="cov0" title="0">{
                        dst[i] = src[i] ^ b
                }</span>
                <span class="cov0" title="0">c.remaining -= len(keyStream)
                sliceutils.Fill(keyStream, 0) // CUSTOM: fast erasure of keystream
                dst, src = dst[len(keyStream):], src[len(keyStream):]</span>
        }
        <span class="cov0" title="0">if len(src) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // If we'd need to let the counter overflow and keep generating output,
        // panic immediately. If instead we'd only reach the last block, remember
        // not to generate any more output after the buffer is drained.
        <span class="cov0" title="0">numBlocks := (uint64(len(src)) + blockSize - 1) / blockSize
        if c.overflow || uint64(c.counter)+numBlocks &gt; 1&lt;&lt;32 </span><span class="cov0" title="0">{
                panic("chacha20: counter overflow")</span>
        } else<span class="cov0" title="0"> if uint64(c.counter)+numBlocks == 1&lt;&lt;32 </span><span class="cov0" title="0">{
                c.overflow = true
        }</span>

        // CUSTOM: fast reseeding.
        <span class="cov0" title="0">c.buf = [bufSize]byte{}
        copy(c.buf[:], src)
        c.xorKeyStreamBlocksGeneric(c.buf[:blockSize], c.buf[:blockSize], &amp;c.key)
        c.setKey(c.buf[:KeySize])
        copy(dst, c.buf[KeySize:blockSize])
        if len(src) &lt;= blockSize-KeySize </span><span class="cov0" title="0">{
                c.remaining = blockSize - KeySize - len(src)
                copy(c.buf[bufSize-c.remaining:], c.buf[KeySize+len(src):blockSize]) // needed if bufSize &gt; blockSize
                sliceutils.Fill(c.buf[:bufSize-c.remaining], 0)
                return
        }</span> else<span class="cov0" title="0"> {
                sliceutils.Fill(c.buf[:blockSize], 0)
                dst, src = dst[blockSize-KeySize:], src[blockSize-KeySize:]
        }</span>

        // xorKeyStreamBlocks implementations expect input lengths that are a
        // multiple of bufSize. Platform-specific ones process multiple blocks at a
        // time, so have bufSizes that are a multiple of blockSize.

        <span class="cov0" title="0">full := len(src) - len(src)%bufSize
        if full &gt; 0 </span><span class="cov0" title="0">{
                c.xorKeyStreamBlocks(dst[:full], src[:full], &amp;c.key)
        }</span>
        <span class="cov0" title="0">dst, src = dst[full:], src[full:]

        // If using a multi-block xorKeyStreamBlocks would overflow, use the generic
        // one that does one block at a time.
        const blocksPerBuf = bufSize / blockSize
        if uint64(c.counter)+blocksPerBuf &gt; 1&lt;&lt;32 </span><span class="cov0" title="0">{
                c.buf = [bufSize]byte{}
                numBlocks := (len(src) + blockSize - 1) / blockSize
                buf := c.buf[bufSize-numBlocks*blockSize:]
                copy(buf, src)
                c.xorKeyStreamBlocksGeneric(buf, buf, &amp;c.key)
                c.remaining = len(buf) - copy(dst, buf)
                sliceutils.Fill(buf, 0) // CUSTOM: erasure of keystream
                return
        }</span>

        // If we have a partial (multi-)block, pad it for xorKeyStreamBlocks, and
        // keep the leftover keystream for the next XORKeyStream invocation.
        <span class="cov0" title="0">if len(src) &gt; 0 </span><span class="cov0" title="0">{
                c.buf = [bufSize]byte{}
                copy(c.buf[:], src)
                c.xorKeyStreamBlocks(c.buf[:], c.buf[:], &amp;c.key)
                c.remaining = bufSize - copy(dst, c.buf[:])
                sliceutils.Fill(c.buf[:bufSize-c.remaining], 0) // CUSTOM: erasure of keystream
        }</span>
}
</pre>
		
		<pre class="file" id="file415" style="display: none">// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found src the LICENSE file.

package chacha20

import "runtime"

// Platforms that have fast unaligned 32-bit little endian accesses.
const unaligned = runtime.GOARCH == "386" ||
        runtime.GOARCH == "amd64" ||
        runtime.GOARCH == "arm64" ||
        runtime.GOARCH == "ppc64le" ||
        runtime.GOARCH == "s390x"

// addXor reads a little endian uint32 from src, XORs it with (a + b) and
// places the result in little endian byte order in dst.
func addXor(dst, src []byte, a, b uint32) <span class="cov0" title="0">{
        _, _ = src[3], dst[3] // bounds check elimination hint
        if unaligned </span><span class="cov0" title="0">{
                // The compiler should optimise this code into
                // 32-bit unaligned little endian loads and stores.
                // TODO: delete once the compiler does a reliably
                // good job with the generic code below.
                // See issue #25111 for more details.
                v := uint32(src[0])
                v |= uint32(src[1]) &lt;&lt; 8
                v |= uint32(src[2]) &lt;&lt; 16
                v |= uint32(src[3]) &lt;&lt; 24
                v ^= a + b
                dst[0] = byte(v)
                dst[1] = byte(v &gt;&gt; 8)
                dst[2] = byte(v &gt;&gt; 16)
                dst[3] = byte(v &gt;&gt; 24)
        }</span> else<span class="cov0" title="0"> {
                a += b
                dst[0] = src[0] ^ byte(a)
                dst[1] = src[1] ^ byte(a&gt;&gt;8)
                dst[2] = src[2] ^ byte(a&gt;&gt;16)
                dst[3] = src[3] ^ byte(a&gt;&gt;24)
        }</span>
}
</pre>
		
		<pre class="file" id="file416" style="display: none">// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build !purego

// Package alias implements memory aliasing tests.
package alias

import "unsafe"

// AnyOverlap reports whether x and y share memory at any (not necessarily
// corresponding) index. The memory beyond the slice length is ignored.
func AnyOverlap(x, y []byte) bool <span class="cov0" title="0">{
        return len(x) &gt; 0 &amp;&amp; len(y) &gt; 0 &amp;&amp;
                uintptr(unsafe.Pointer(&amp;x[0])) &lt;= uintptr(unsafe.Pointer(&amp;y[len(y)-1])) &amp;&amp;
                uintptr(unsafe.Pointer(&amp;y[0])) &lt;= uintptr(unsafe.Pointer(&amp;x[len(x)-1]))
}</span>

// InexactOverlap reports whether x and y share memory at any non-corresponding
// index. The memory beyond the slice length is ignored. Note that x and y can
// have different lengths and still not have any inexact overlap.
//
// InexactOverlap can be used to implement the requirements of the crypto/cipher
// AEAD, Block, BlockMode and Stream interfaces.
func InexactOverlap(x, y []byte) bool <span class="cov0" title="0">{
        if len(x) == 0 || len(y) == 0 || &amp;x[0] == &amp;y[0] </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return AnyOverlap(x, y)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
