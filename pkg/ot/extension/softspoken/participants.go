package softspoken

import (
	"github.com/copperexchange/crypto-primitives-go/pkg/core/curves"
	"github.com/copperexchange/crypto-primitives-go/pkg/core/errs"
	"github.com/copperexchange/crypto-primitives-go/pkg/ot/base/simplest"
	"github.com/gtank/merlin"
)

const (
	// ------------------------ CONFIGURABLE PARAMETERS --------------------- //
	// Kappa (κ) is the computational security parameter in bits. Set |q| = κ
	// for a curve of prime order q. It is the size of the PRG seeds (the BaseOT
	// options) as well as the number of output elements per batch.
	Kappa = 256

	// L is the ratio between scalars generated by the OTextension
	// and the number of BaseOT seeds. Set to 1 for DKLS23.
	L = 1

	// Sigma (σ) is the statistical security parameter. Eta%σ=0.
	// Sigma is the numbet of bits to consume/discard in the consistency check.
	Sigma = 128

	// OTeWidth is the number of scalars processed per "slot" of the OT extension.
	// For each choice bit, the sender provides `OTeWidth` scalars and both the
	// sender and receiver will obtain `OTWidth` scalars.
	OTeWidth = 2

	// ---------------------- NON-CONFIGURABLE PARAMETERS ------------------- //
	// Zeta (ξ) is the batch size in bits used in the cOT functionality.
	Zeta = L * Kappa

	// ZetaPrime (ξ') is the bit-length of pseudorandom seed expansions.
	ZetaPrime = Zeta + Sigma

	// number of blocks of size Sigma in the output batch
	M = Zeta / Sigma

	// Equivalents in Bytes
	KappaBytes     = Kappa >> 3     // KappaBytes (κ) is the computational security parameter in bytes
	ZetaBytes      = Zeta >> 3      // ZetaBytes (ξ) is the batch size in bytes
	SigmaBytes     = Sigma >> 3     // SigmaBytes (σ) is the statistical security parameter in bytes
	ZetaPrimeBytes = ZetaPrime >> 3 // ZetaPrimeBytes (ξ) is the batch size in bytesused in the cOT functionality.
	MBytes         = M >> 3         // M Bytesis the number of blocks in the consistency check in bytes
)

type (
	// ---------------------------- EXTENSION ------------------------------- //
	// ExpansionMask (u_i) ∈ [κ][ξ']bits is the expanded and masked PRG outputs
	ExpansionMask [Kappa][ZetaPrimeBytes]byte

	// OTeInputChoices (x_i) ∈ [ξ]bits are the choice bits for the OTe.
	OTeInputChoices [ZetaBytes]byte

	// ExtPackedChoices (x_i) ∈ [ξ']bits are the choice bits for the OTe filled with σ random values.
	ExtPackedChoices [ZetaPrimeBytes]byte

	// ExtOptions (t^i_0, t^i_1) ∈ [2][κ][ξ]bits are expansions of BaseOT results using a PRG.
	ExtOptions [2][Kappa][ZetaPrimeBytes]byte

	// ExtDeltaOpt (t^i_{Δ_i}) ∈ [κ][ξ]bits are the extended (via a PRG) baseOT deltaOpts.
	ExtDeltaOpt [Kappa][ZetaPrimeBytes]byte

	// ExtCorrelations (q_i) ∈ [κ][ξ]bits are the extended correlations, q^i = Δ_i • x + t^i
	ExtCorrelations [Kappa][ZetaPrimeBytes]byte

	// ------------------------ CONSISTENCY CHECK --------------------------- //
	// Challenge (χ_i) ∈ [M]×[σ]bits is the random challenge for the consistency check.
	Challenge [M][SigmaBytes]byte

	// ChallengeResponse (x_val, t_val) is the consistency check from the receiver,
	// to be verified by the Sender.
	ChallengeResponse struct {
		x_val [SigmaBytes]byte        // plain x in the protocol
		t_val [Kappa][SigmaBytes]byte // plain t^i in the protocol
	}

	// --------------------------- (Random) OTe ----------------------------- //
	// OTeSenderOutput (v_0, v_1) ∈ [2][ξ][κ]bits is the output of the sender in
	// the OTe protocol ("InputOpt1" & "InputOpt2" in the diagram above)
	OTeSenderOutput [2][Zeta][OTeWidth][KappaBytes]byte

	// OTeReceiverOutput (v_x) ∈ [ξ][κ]bits is the output of the receiver in the
	// OTe protocol ("DeltaOpt" in the diagram above)
	OTeReceiverOutput [Zeta][OTeWidth][KappaBytes]byte

	// ------------------------- (Correlated) COTe -------------------------- //
	// COTeInputOpt (α) ∈ [ξ]curve.Scalar is the input of the sender in the COTe protocol
	COTeInputOpt [Zeta][OTeWidth]curves.Scalar

	// DerandomizeMask (τ) ∈ [ξ]curve.Scalar is the correlation mask
	DerandomizeMask [Zeta][OTeWidth]curves.Scalar

	// COTeSenderOutput (z_A) ∈ [ξ]curve.Scalar is the output of the sender in
	// the COTe protocol, ("Correlation" in the diagram above)
	COTeSenderOutput [Zeta][OTeWidth]curves.Scalar

	// COTeReceiverOutput (z_B) is the output of the receiver in the COTe protocol (DeltaOpt)
	COTeReceiverOutput [Zeta][OTeWidth]curves.Scalar // z_B ∈ [ξ]curve.Scalar are correlated group elements.

)

type Receiver struct {
	// baseOtSeeds (k^i_0, k^i_1) ∈ [2][κ][κ]bits are the options used while
	//  of playing the sender in a base OT protocol. They act as seeds to COTe.
	baseOtSeeds *simplest.SenderOutput

	// uniqueSessionId is the unique identifier of the current session (sid in DKLs19)
	uniqueSessionId [simplest.DigestSize]byte

	// transcript is the transcript containing the protocol's publicly exchanged messages.
	transcript *merlin.Transcript

	// curve is the elliptic curve used in the protocol.
	curve *curves.Curve

	// useForcedReuse is a flag that indicates whether the protocol should use forced reuse.
	useForcedReuse bool
}

type Sender struct {
	// baseOtSeeds (Δ_i ∈ [κ]bits, k^i_{Δ_i} ∈ [κ][κ]bits) are the results
	// of playing the receiver in a base OT protocol. They act as seeds of COTe.
	baseOtSeeds *simplest.ReceiverOutput

	// uniqueSessionId is the unique identifier of the current session (sid in DKLs19)
	uniqueSessionId [simplest.DigestSize]byte

	// transcript is the transcript containing the protocol's publicly exchanged messages.
	transcript *merlin.Transcript

	// curve is the elliptic curve used in the protocol.
	curve *curves.Curve

	// useForcedReuse is a flag that indicates whether the protocol should use forced reuse.
	useForcedReuse bool
}

// NewCOtReceiver creates a `Receiver` instance for the SoftSpokenOT protocol.
// The `baseOtResults` are the results of playing the sender role in kappa baseOTs.
func NewCOtReceiver(
	baseOtResults *simplest.SenderOutput,
	uniqueSessionId [simplest.DigestSize]byte,
	transcript *merlin.Transcript,
	curve *curves.Curve,
	useForcedReuse bool,
) (*Receiver, error) {
	// Validate parameters: L must be 1 for forced reuse
	if useForcedReuse && (L != 1) {
		return nil, errs.NewInvalidArgument("forced reuse is only supported for COTe batch size L=1")
	}
	if transcript == nil {
		transcript = merlin.NewTranscript("KNOX_PRIMITIVES_SOFTSPOKEN_COTe")
	}
	transcript.AppendMessage([]byte("session_id"), uniqueSessionId[:])
	return &Receiver{
		baseOtSeeds:     baseOtResults,
		uniqueSessionId: uniqueSessionId,
		transcript:      transcript,
		curve:           curve,
		useForcedReuse:  useForcedReuse,
	}, nil
}

// NewCOtSender creates a `Sender` instance for the SoftSpokenOT protocol.
// The `baseOtResults` are the results of playing the receiver role in kappa baseOTs.
func NewCOtSender(
	baseOtResults *simplest.ReceiverOutput,
	uniqueSessionId [simplest.DigestSize]byte,
	transcript *merlin.Transcript,
	curve *curves.Curve,
	useForcedReuse bool,
) (*Sender, error) {
	// L must be 1 for forced reuse
	if useForcedReuse && (L != 1) {
		return nil, errs.NewInvalidArgument("forced reuse is only supported for COTe batch size L=1")
	}
	if transcript == nil {
		transcript = merlin.NewTranscript("KNOX_PRIMITIVES_SOFTSPOKEN_COTe")
	}
	transcript.AppendMessage([]byte("session_id"), uniqueSessionId[:])
	return &Sender{
		baseOtSeeds:     baseOtResults,
		uniqueSessionId: uniqueSessionId,
		transcript:      transcript,
		curve:           curve,
		useForcedReuse:  useForcedReuse,
	}, nil
}
