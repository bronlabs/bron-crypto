package softspoken

import (
	"github.com/copperexchange/crypto-primitives-go/pkg/core/curves"
	"github.com/copperexchange/crypto-primitives-go/pkg/core/errs"
	"github.com/copperexchange/crypto-primitives-go/pkg/ot/base/simplest"
	"github.com/gtank/merlin"
)

const (
	// ------------------------ CONFIGURABLE PARAMETERS --------------------- //
	// Kappa (κ) is the computational security parameter in bits. Set |q| = κ
	// for a curve of prime order q. It is the size of the PRG seeds (the BaseOT
	// options) as well as the number of output elements per batch.
	Kappa = 256

	// L is the ratio between scalars generated by the OTextension
	// and the number of BaseOT seeds. Set to 1 for DKLS23.
	L = 1

	// Sigma (σ) is the statistical security parameter. Eta%σ=0.
	// Sigma is the numbet of bits to consume/discard in the consistency check.
	Sigma = 128

	// OTeWidth is the number of scalars processed per "slot" of the OT extension.
	// For each choice bit, the sender provides `OTeWidth` scalars and both the
	// sender and receiver will obtain `OTWidth` scalars.
	OTeWidth = 2

	// ---------------------- NON-CONFIGURABLE PARAMETERS ------------------- //
	// Zeta (ξ) is the batch size in bits used in the cOT functionality.
	Zeta = L * Kappa

	// ZetaPrime (ξ') is the bit-length of pseudorandom seed expansions.
	ZetaPrime = Zeta + Sigma

	// number of blocks of size Sigma in the output batch
	M = Zeta / Sigma

	// Equivalents in Bytes
	KappaBytes     = Kappa >> 3     // KappaBytes (κ) is the computational security parameter in bytes
	ZetaBytes      = Zeta >> 3      // ZetaBytes (ξ) is the batch size in bytes
	SigmaBytes     = Sigma >> 3     // SigmaBytes (σ) is the statistical security parameter in bytes
	ZetaPrimeBytes = ZetaPrime >> 3 // ZetaPrimeBytes (ξ) is the batch size in bytesused in the cOT functionality.
	MBytes         = M >> 3         // M Bytesis the number of blocks in the consistency check in bytes
)

type Receiver struct {
	// baseOtSeeds (k^i_0, k^i_1) ∈ [2][κ][κ]bits are the options used while
	//  of playing the sender in a base OT protocol. They act as seeds to COTe.
	baseOtSeeds *simplest.SenderOutput

	// uniqueSessionId is the unique identifier of the current session (sid in DKLs19)
	uniqueSessionId [simplest.DigestSize]byte

	// transcript is the transcript containing the protocol's publicly exchanged messages.
	transcript *merlin.Transcript

	// curve is the elliptic curve used in the protocol.
	curve *curves.Curve

	// useForcedReuse is a flag that indicates whether the protocol should use forced reuse.
	useForcedReuse bool
}

type Sender struct {
	// baseOtSeeds (Δ_i ∈ [κ]bits, k^i_{Δ_i} ∈ [κ][κ]bits) are the results
	// of playing the receiver in a base OT protocol. They act as seeds of COTe.
	baseOtSeeds *simplest.ReceiverOutput

	// uniqueSessionId is the unique identifier of the current session (sid in DKLs19)
	uniqueSessionId [simplest.DigestSize]byte

	// transcript is the transcript containing the protocol's publicly exchanged messages.
	transcript *merlin.Transcript

	// curve is the elliptic curve used in the protocol.
	curve *curves.Curve

	// useForcedReuse is a flag that indicates whether the protocol should use forced reuse.
	useForcedReuse bool
}

// NewCOtReceiver creates a `Receiver` instance for the SoftSpokenOT protocol.
// The `baseOtResults` are the results of playing the sender role in kappa baseOTs.
func NewCOtReceiver(
	baseOtResults *simplest.SenderOutput,
	uniqueSessionId [simplest.DigestSize]byte,
	transcript *merlin.Transcript,
	curve *curves.Curve,
	useForcedReuse bool,
) (*Receiver, error) {
	// Validate parameters: L must be 1 for forced reuse
	if useForcedReuse && (L != 1) {
		return nil, errs.NewInvalidArgument("forced reuse is only supported for COTe batch size L=1")
	}
	if transcript == nil {
		transcript = merlin.NewTranscript("KNOX_PRIMITIVES_SOFTSPOKEN_COTe")
	}
	transcript.AppendMessage([]byte("session_id"), uniqueSessionId[:])
	return &Receiver{
		baseOtSeeds:     baseOtResults,
		uniqueSessionId: uniqueSessionId,
		transcript:      transcript,
		curve:           curve,
		useForcedReuse:  useForcedReuse,
	}, nil
}

// NewCOtSender creates a `Sender` instance for the SoftSpokenOT protocol.
// The `baseOtResults` are the results of playing the receiver role in kappa baseOTs.
func NewCOtSender(
	baseOtResults *simplest.ReceiverOutput,
	uniqueSessionId [simplest.DigestSize]byte,
	transcript *merlin.Transcript,
	curve *curves.Curve,
	useForcedReuse bool,
) (*Sender, error) {
	// L must be 1 for forced reuse
	if useForcedReuse && (L != 1) {
		return nil, errs.NewInvalidArgument("forced reuse is only supported for COTe batch size L=1")
	}
	if transcript == nil {
		transcript = merlin.NewTranscript("KNOX_PRIMITIVES_SOFTSPOKEN_COTe")
	}
	transcript.AppendMessage([]byte("session_id"), uniqueSessionId[:])
	return &Sender{
		baseOtSeeds:     baseOtResults,
		uniqueSessionId: uniqueSessionId,
		transcript:      transcript,
		curve:           curve,
		useForcedReuse:  useForcedReuse,
	}, nil
}
