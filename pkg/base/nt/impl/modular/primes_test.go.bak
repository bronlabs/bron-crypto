package modular_test

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/bronlabs/bron-crypto/pkg/base/ct"
	"github.com/bronlabs/bron-crypto/pkg/base/nt/impl"
	"github.com/bronlabs/bron-crypto/pkg/base/nt/impl/modular"
	"github.com/cronokirby/saferith"
)

// Helper to create a Nat from uint64
func natFromU64(v uint64) *impl.Nat {
	return (*impl.Nat)(new(saferith.Nat).SetUint64(v).Resize(64))
}

func TestNewExponentiatorPrimeFactors(t *testing.T) {
	t.Parallel()

	t.Run("valid coprime factors", func(t *testing.T) {
		// Test with small primes p=3, q=5 (coprime)
		p := natFromU64(3)
		q := natFromU64(5)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)

		assert.Equal(t, ct.True, ok, "Should succeed for coprime factors")
		require.NotNil(t, exp)

		// Verify modulus is p*q = 15
		modulus := exp.Modulus()
		assert.Equal(t, uint64(15), modulus.Nat().Uint64())
	})

	t.Run("larger coprime primes", func(t *testing.T) {
		// Test with p=11, q=13
		p := natFromU64(11)
		q := natFromU64(13)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)

		assert.Equal(t, ct.True, ok)
		require.NotNil(t, exp)

		// Verify modulus is p*q = 143
		modulus := exp.Modulus()
		assert.Equal(t, uint64(143), modulus.Nat().Uint64())
	})

	t.Run("non-coprime factors should fail", func(t *testing.T) {
		// Test with non-coprime factors p=6, q=9 (gcd=3)
		p := natFromU64(6)
		q := natFromU64(9)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)

		assert.Equal(t, ct.False, ok, "Should fail for non-coprime factors")
		// exp may be non-nil but should not be used when ok is false
		_ = exp
	})

	t.Run("equal factors should fail", func(t *testing.T) {
		// Test with equal factors p=q=7
		p := natFromU64(7)
		q := natFromU64(7)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)

		assert.Equal(t, ct.False, ok, "Should fail for equal factors")
		_ = exp
	})

	t.Run("factor is 1 should fail", func(t *testing.T) {
		// Edge case: p=1, q=7 (p=1 is not valid for CRT)
		p := natFromU64(1)
		q := natFromU64(7)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)

		// Should fail because p must be > 1
		assert.Equal(t, ct.False, ok, "Should fail when p=1")
		_ = exp
	})
}

func TestExponentiatorPrimeFactors_Exp(t *testing.T) {
	t.Parallel()

	t.Run("basic exponentiation", func(t *testing.T) {
		// Use p=3, q=5, so modulus n=15
		// φ(15) = φ(3)*φ(5) = 2*4 = 8
		p := natFromU64(3)
		q := natFromU64(5)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
		require.Equal(t, ct.True, ok)
		require.NotNil(t, exp)

		testCases := []struct {
			name     string
			base     uint64
			exponent uint64
			expected uint64
		}{
			// Basic cases
			{"2^1 mod 15", 2, 1, 2},
			{"2^2 mod 15", 2, 2, 4},
			{"2^3 mod 15", 2, 3, 8},
			{"2^4 mod 15", 2, 4, 1}, // 16 mod 15 = 1
			{"2^8 mod 15", 2, 8, 1}, // 256 mod 15 = 1

			// Different bases (must be coprime to 15)
			// Note: 3 and 5 are not coprime to 15, so skip them

			{"4^1 mod 15", 4, 1, 4},
			{"4^2 mod 15", 4, 2, 1}, // 16 mod 15 = 1
			{"4^3 mod 15", 4, 3, 4}, // 64 mod 15 = 4

			// Edge cases (bases must be coprime to 15 for CRT to work correctly)
			// 0 is not coprime to 15
			{"1^100 mod 15", 1, 100, 1},
			{"14^2 mod 15", 14, 2, 1}, // 196 mod 15 = 1

			// Fermat's little theorem cases
			// For p=3: a^2 ≡ 1 (mod 3) if gcd(a,3)=1
			// For q=5: a^4 ≡ 1 (mod 5) if gcd(a,5)=1
			// For n=15: a^8 ≡ 1 (mod 15) if gcd(a,15)=1
			{"2^8 mod 15", 2, 8, 1},
			{"4^8 mod 15", 4, 8, 1},
			{"7^8 mod 15", 7, 8, 1},
			{"8^8 mod 15", 8, 8, 1},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				base := natFromU64(tc.base)
				exponent := natFromU64(tc.exponent)
				result := natFromU64(0)

				ok := exp.Exp(result, base, exponent)
				require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
				assert.Equal(t, tc.expected, result.Uint64(),
					"%d^%d mod 15 should be %d", tc.base, tc.exponent, tc.expected)
			})
		}
	})

	t.Run("larger modulus", func(t *testing.T) {
		// Use p=7, q=11, so modulus n=77
		// φ(77) = φ(7)*φ(11) = 6*10 = 60
		p := natFromU64(7)
		q := natFromU64(11)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
		require.Equal(t, ct.True, ok)
		require.NotNil(t, exp)

		testCases := []struct {
			base     uint64
			exponent uint64
			expected uint64
		}{
			{2, 1, 2},
			{2, 10, 23}, // 1024 mod 77 = 23
			{3, 1, 3},
			{3, 5, 12},  // 243 mod 77 = 12
			{5, 3, 48},  // 125 mod 77 = 48
			{10, 2, 23}, // 100 mod 77 = 23
			{10, 60, 1}, // By Euler's theorem
		}

		for _, tc := range testCases {
			base := natFromU64(tc.base)
			exponent := natFromU64(tc.exponent)
			result := natFromU64(0)

			ok := exp.Exp(result, base, exponent)
			require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
			assert.Equal(t, tc.expected, result.Uint64(),
				"%d^%d mod 77 should be %d", tc.base, tc.exponent, tc.expected)
		}
	})

	t.Run("exponent reduction", func(t *testing.T) {
		// Test that large exponents are reduced modulo φ(n)
		// Use p=3, q=5, n=15, φ(n)=8
		p := natFromU64(3)
		q := natFromU64(5)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
		require.Equal(t, ct.True, ok)

		base := natFromU64(2)

		// These should all give the same result due to exponent reduction
		// 2^9 ≡ 2^1 (mod 15) because 9 ≡ 1 (mod 8)
		// 2^17 ≡ 2^1 (mod 15) because 17 ≡ 1 (mod 8)
		exponents := []uint64{1, 9, 17, 25, 33}

		results := make([]uint64, len(exponents))
		for i, exp_val := range exponents {
			exponent := natFromU64(exp_val)
			result := natFromU64(0)
			ok := exp.Exp(result, base, exponent)
			require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
			results[i] = result.Uint64()
		}

		// All should equal 2^1 mod 15 = 2
		for i, res := range results {
			assert.Equal(t, uint64(2), res, "2^%d mod 15 should be 2", exponents[i])
		}
	})
}

func TestExponentiatorPrimeFactors_EdgeCases(t *testing.T) {
	t.Parallel()

	t.Run("zero exponent", func(t *testing.T) {
		p := natFromU64(3)
		q := natFromU64(5)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
		require.Equal(t, ct.True, ok)

		// Any number to the power of 0 should be 1
		bases := []uint64{0, 1, 2, 3, 14, 15}
		for _, b := range bases {
			base := natFromU64(b)
			exponent := natFromU64(0)
			result := natFromU64(999) // Initialize with non-1 value

			ok := exp.Exp(result, base, exponent)

			// Now all bases should work
			require.Equal(t, ct.True, ok, "Exp should succeed for base=%d", b)
			if b == 0 || b == 15 {
				// 0^0 mod 15 and 15^0 mod 15 are edge cases
				// Mathematically 0^0 is undefined, but modular arithmetic often treats it as 1
				assert.Equal(t, uint64(1), result.Uint64(),
					"%d^0 mod 15 should be 1", b)
			} else {
				assert.Equal(t, uint64(1), result.Uint64(),
					"%d^0 mod 15 should be 1", b)
			}
		}
	})

	t.Run("euler-totient handling with gcd(base, modulus) > 1", func(t *testing.T) {
		p := natFromU64(3)
		q := natFromU64(5)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
		require.Equal(t, ct.True, ok)

		a := natFromU64(3)
		b := natFromU64(2)
		expected := natFromU64(9) // 3^2 mod 15 = 9
		var actual impl.Nat
		exp.Exp(&actual, a, b)
		require.Equal(t, ct.True, actual.Equal(expected), "3^2 mod 15 should be 9 but is %d", actual.Uint64())
	})

	t.Run("base with common factors works", func(t *testing.T) {
		// CRT-based exponentiation now works even when gcd(base, n) > 1
		p := natFromU64(3)
		q := natFromU64(5)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
		require.Equal(t, ct.True, ok)

		// Test with base = 6 (shares factor 3 with modulus 15)
		base := natFromU64(6) // gcd(6, 15) = 3
		exponent := natFromU64(2)
		result := natFromU64(0)

		// Exp should now work and compute 6^2 mod 15 = 36 mod 15 = 6
		ok = exp.Exp(result, base, exponent)
		assert.Equal(t, ct.True, ok, "Exp should succeed even when base shares factors with modulus")
		assert.Equal(t, uint64(6), result.Uint64(), "6^2 mod 15 = 6")

		// Test with base = 15 (equal to modulus)
		base = natFromU64(15)
		ok = exp.Exp(result, base, exponent)
		assert.Equal(t, ct.True, ok, "Exp should succeed when base equals modulus")
		assert.Equal(t, uint64(0), result.Uint64(), "15^2 mod 15 = 0")

		// Test with coprime base should still succeed
		base = natFromU64(2) // gcd(2, 15) = 1
		ok = exp.Exp(result, base, exponent)
		assert.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
		assert.Equal(t, uint64(4), result.Uint64(), "2^2 mod 15 = 4")
	})

	t.Run("base larger than modulus", func(t *testing.T) {
		p := natFromU64(3)
		q := natFromU64(5)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
		require.Equal(t, ct.True, ok)

		// Test with bases larger than 15
		testCases := []struct {
			base     uint64
			exponent uint64
			expected uint64
		}{
			{16, 1, 1}, // 16 ≡ 1 (mod 15)
			{17, 1, 2}, // 17 ≡ 2 (mod 15)
			// {30, 1, 0},   // 30 ≡ 0 (mod 15) - skip, shares factor with 15
			{16, 2, 1}, // 1^2 = 1 (mod 15)
			{17, 3, 8}, // 2^3 = 8 (mod 15)
		}

		for _, tc := range testCases {
			base := natFromU64(tc.base)
			exponent := natFromU64(tc.exponent)
			result := natFromU64(0)

			ok := exp.Exp(result, base, exponent)
			require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
			assert.Equal(t, tc.expected, result.Uint64(),
				"%d^%d mod 15 should be %d", tc.base, tc.exponent, tc.expected)
		}
	})
}

func TestExponentiatorPrimeFactors_Concurrency(t *testing.T) {
	t.Parallel()

	t.Run("concurrent exponentiation", func(t *testing.T) {
		// The Exp method uses goroutines internally
		// Test that it works correctly under concurrent use

		p := natFromU64(7)
		q := natFromU64(11)

		exp, ok := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
		require.Equal(t, ct.True, ok)

		// Run multiple exponentiations concurrently
		type testCase struct {
			base     uint64
			exponent uint64
			expected uint64
		}

		cases := []testCase{
			{2, 5, 32},
			{5, 3, 48},
			{6, 2, 36}, // Changed from 7 to 6, since gcd(6, 77) = 1 but gcd(7, 77) = 7
		}

		results := make([]uint64, len(cases))

		// Note: The Exp method itself uses goroutines internally
		// We're just testing that it works correctly
		for i, tc := range cases {
			base := natFromU64(tc.base)
			exponent := natFromU64(tc.exponent)
			result := natFromU64(0)

			ok := exp.Exp(result, base, exponent)
			require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
			results[i] = result.Uint64()
		}

		for i, tc := range cases {
			assert.Equal(t, tc.expected, results[i],
				"%d^%d mod 77 should be %d", tc.base, tc.exponent, tc.expected)
		}
	})
}

// Benchmark tests
func BenchmarkExponentiatorPrimeFactors_New(b *testing.B) {
	p := natFromU64(65537) // Common prime (2^16 + 1)
	q := natFromU64(65539) // Next prime

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)
	}
}

func BenchmarkExponentiatorPrimeFactors_Exp(b *testing.B) {
	p := natFromU64(65537)
	q := natFromU64(65539)

	exp, _ := modular.NewPrimeFactors[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](p, q)

	base := natFromU64(12345)
	exponent := natFromU64(67890)
	result := natFromU64(0)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = exp.Exp(result, base, exponent) // Ignore return value in benchmark
	}
}

// Tests for ExponentiatorPrimeFactorsMulti

func TestNewExponentiatorPrimeFactorsMulti(t *testing.T) {
	t.Parallel()

	t.Run("three primes", func(t *testing.T) {
		// Test with three small primes p=3, q=5, r=7
		primes := []uint64{3, 5, 7}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)

		assert.Equal(t, ct.True, ok, "Should succeed for coprime primes")
		require.NotNil(t, exp)

		// Verify modulus is 3*5*7 = 105
		modulus := exp.Modulus()
		assert.Equal(t, uint64(105), modulus.Nat().Uint64())
	})

	t.Run("four primes", func(t *testing.T) {
		// Test with four odd primes (2 cannot be used with ModulusOddPrime)
		primes := []uint64{3, 5, 7, 11}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)

		assert.Equal(t, ct.True, ok)
		require.NotNil(t, exp)

		// Verify modulus is 3*5*7*11 = 1155
		modulus := exp.Modulus()
		assert.Equal(t, uint64(1155), modulus.Nat().Uint64())
	})

	t.Run("larger primes", func(t *testing.T) {
		// Test with larger primes
		primes := []uint64{11, 13, 17, 19}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)

		assert.Equal(t, ct.True, ok)
		require.NotNil(t, exp)

		// Verify modulus is 11*13*17*19 = 46189
		modulus := exp.Modulus()
		assert.Equal(t, uint64(46189), modulus.Nat().Uint64())
	})

	t.Run("non-prime should fail", func(t *testing.T) {
		// Test with non-prime factors
		factors := []uint64{3, 5, 9} // 9 is not prime
		ps := make([]*impl.Nat, len(factors))
		for i, p := range factors {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)

		assert.Equal(t, ct.False, ok, "Should fail when a factor is not prime")
		_ = exp
	})

	t.Run("duplicate prime should fail", func(t *testing.T) {
		// Test with duplicate primes
		// This should fail because M_i won't be coprime to p_i
		primes := []uint64{3, 5, 3} // 3 appears twice
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)

		// This should fail because primes are not pairwise coprime
		// The failure happens when computing M_i^{-1} mod p_i
		// For duplicate prime p, we have M_i = N/p which includes p as a factor
		// So gcd(M_i, p) = p > 1, making the inverse not exist
		assert.Equal(t, ct.False, ok, "Should fail with duplicate primes")
		_ = exp
	})

	t.Run("single prime should fail", func(t *testing.T) {
		// Test with only one prime
		ps := []*impl.Nat{natFromU64(7)}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)

		assert.Equal(t, ct.False, ok, "Should fail with only one prime")
		_ = exp
	})
}

func TestExponentiatorPrimeFactorsMulti_Exp(t *testing.T) {
	t.Parallel()

	t.Run("three primes basic", func(t *testing.T) {
		// Use p=3, q=5, r=7, so modulus n=105
		// φ(105) = φ(3)*φ(5)*φ(7) = 2*4*6 = 48
		primes := []uint64{3, 5, 7}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)
		require.Equal(t, ct.True, ok)
		require.NotNil(t, exp)

		testCases := []struct {
			name     string
			base     uint64
			exponent uint64
			expected uint64
		}{
			// Basic cases
			{"2^1 mod 105", 2, 1, 2},
			{"2^2 mod 105", 2, 2, 4},
			{"2^3 mod 105", 2, 3, 8},
			{"2^4 mod 105", 2, 4, 16},
			{"2^10 mod 105", 2, 10, 79}, // 1024 mod 105 = 79

			// Different bases (must be coprime to 105 = 3*5*7)
			{"4^2 mod 105", 4, 2, 16},
			{"4^3 mod 105", 4, 3, 64},

			{"11^2 mod 105", 11, 2, 16}, // 121 mod 105 = 16
			{"11^3 mod 105", 11, 3, 71}, // 1331 mod 105 = 71

			// Euler's theorem: a^48 ≡ 1 (mod 105) if gcd(a,105)=1
			{"2^48 mod 105", 2, 48, 1},
			{"4^48 mod 105", 4, 48, 1},
			{"11^48 mod 105", 11, 48, 1},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				base := natFromU64(tc.base)
				exponent := natFromU64(tc.exponent)
				result := natFromU64(0)

				ok := exp.Exp(result, base, exponent)
				require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
				assert.Equal(t, tc.expected, result.Uint64(),
					"%d^%d mod 105 should be %d", tc.base, tc.exponent, tc.expected)
			})
		}
	})

	t.Run("four primes", func(t *testing.T) {
		// Use p=3, q=5, r=7, s=11, so modulus n=1155
		// φ(1155) = φ(3)*φ(5)*φ(7)*φ(11) = 2*4*6*10 = 480
		primes := []uint64{3, 5, 7, 11}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)
		require.Equal(t, ct.True, ok)

		testCases := []struct {
			base     uint64
			exponent uint64
			expected uint64
		}{
			{2, 1, 2},
			{2, 2, 4},
			{2, 3, 8},
			{13, 2, 169},
			{13, 3, 1042}, // 2197 mod 1155 = 1042
			{2, 480, 1},   // Euler's theorem: φ(1155) = 480
			{13, 480, 1},  // Euler's theorem
		}

		for _, tc := range testCases {
			base := natFromU64(tc.base)
			exponent := natFromU64(tc.exponent)
			result := natFromU64(0)

			ok := exp.Exp(result, base, exponent)
			// Base 11 would fail since gcd(11, 1155) = 11
			if tc.base == 11 || tc.base == 3 || tc.base == 5 || tc.base == 7 {
				require.Equal(t, ct.False, ok, "Exp should fail for non-coprime base")
			} else {
				require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
				assert.Equal(t, tc.expected, result.Uint64(),
					"%d^%d mod 1155 should be %d", tc.base, tc.exponent, tc.expected)
			}
		}
	})

	t.Run("exponent reduction", func(t *testing.T) {
		// Test that large exponents are reduced modulo φ(n)
		primes := []uint64{3, 5, 7}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)
		require.Equal(t, ct.True, ok)

		base := natFromU64(2)

		// φ(105) = 48, so these should give same results
		// 2^49 ≡ 2^1 (mod 105)
		// 2^97 ≡ 2^1 (mod 105)
		exponents := []uint64{1, 49, 97}

		results := make([]uint64, len(exponents))
		for i, exp_val := range exponents {
			exponent := natFromU64(exp_val)
			result := natFromU64(0)
			ok := exp.Exp(result, base, exponent)
			require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
			results[i] = result.Uint64()
		}

		// All should equal 2^1 mod 105 = 2
		for i, res := range results {
			assert.Equal(t, uint64(2), res, "2^%d mod 105 should be 2", exponents[i])
		}
	})
}

func TestExponentiatorPrimeFactorsMulti_EdgeCases(t *testing.T) {
	t.Run("base with common factors works", func(t *testing.T) {
		// CRT-based exponentiation now works even when gcd(base, n) > 1
		primes := []uint64{3, 5, 7} // modulus = 105
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)
		require.Equal(t, ct.True, ok)

		// Test with base = 15 (shares factors 3 and 5 with modulus 105)
		base := natFromU64(15) // gcd(15, 105) = 15
		exponent := natFromU64(2)
		result := natFromU64(0)

		// Exp should work and compute 15^2 mod 105 = 225 mod 105 = 15
		ok = exp.Exp(result, base, exponent)
		assert.Equal(t, ct.True, ok, "Exp should succeed even when base = 15 shares factors with modulus 105")
		assert.Equal(t, uint64(15), result.Uint64(), "15^2 mod 105 = 15")

		// Test with base = 21 (shares factors 3 and 7 with modulus 105)
		base = natFromU64(21) // gcd(21, 105) = 21
		ok = exp.Exp(result, base, exponent)
		assert.Equal(t, ct.True, ok, "Exp should succeed even when base = 21 shares factors with modulus 105")
		assert.Equal(t, uint64(21), result.Uint64(), "21^2 mod 105 = 441 mod 105 = 21")

		// Test with base = 105 (equal to modulus)
		base = natFromU64(105)
		ok = exp.Exp(result, base, exponent)
		assert.Equal(t, ct.True, ok, "Exp should succeed when base equals modulus")
		assert.Equal(t, uint64(0), result.Uint64(), "105^2 mod 105 = 0")

		// Test with coprime base should still succeed
		base = natFromU64(2) // gcd(2, 105) = 1
		ok = exp.Exp(result, base, exponent)
		assert.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
		assert.Equal(t, uint64(4), result.Uint64(), "2^2 mod 105 = 4")
	})

	t.Parallel()

	t.Run("zero exponent", func(t *testing.T) {
		primes := []uint64{3, 5, 7}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)
		require.Equal(t, ct.True, ok)

		// Any number to the power of 0 should be 1
		bases := []uint64{1, 2, 11, 104}
		for _, b := range bases {
			base := natFromU64(b)
			exponent := natFromU64(0)
			result := natFromU64(999)

			ok := exp.Exp(result, base, exponent)
			// All these bases are coprime to 105
			require.Equal(t, ct.True, ok, "Exp should succeed for base=%d coprime to modulus 105", b)
			assert.Equal(t, uint64(1), result.Uint64(),
				"%d^0 mod 105 should be 1", b)
		}
	})

	t.Run("base larger than modulus", func(t *testing.T) {
		primes := []uint64{3, 5, 7}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)
		require.Equal(t, ct.True, ok)

		// Test with bases larger than 105
		testCases := []struct {
			base     uint64
			exponent uint64
			expected uint64
		}{
			{106, 1, 1}, // 106 ≡ 1 (mod 105)
			{107, 1, 2}, // 107 ≡ 2 (mod 105)
			{210, 1, 0}, // 210 ≡ 0 (mod 105) - shares factors
			{106, 2, 1}, // 1^2 = 1 (mod 105)
			{107, 3, 8}, // 2^3 = 8 (mod 105)
		}

		for _, tc := range testCases {
			// Skip cases with common factors
			if tc.base%3 == 0 || tc.base%5 == 0 || tc.base%7 == 0 {
				continue
			}

			base := natFromU64(tc.base)
			exponent := natFromU64(tc.exponent)
			result := natFromU64(0)

			ok := exp.Exp(result, base, exponent)
			require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
			assert.Equal(t, tc.expected, result.Uint64(),
				"%d^%d mod 105 should be %d", tc.base, tc.exponent, tc.expected)
		}
	})
}

func TestExponentiatorPrimeFactorsMulti_Concurrency(t *testing.T) {
	t.Parallel()

	t.Run("concurrent exponentiation", func(t *testing.T) {
		// The Exp method uses goroutines internally for each prime
		primes := []uint64{11, 13, 17, 19}
		ps := make([]*impl.Nat, len(primes))
		for i, p := range primes {
			ps[i] = natFromU64(p)
		}

		exp, ok := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)
		require.Equal(t, ct.True, ok)

		// n = 11*13*17*19 = 46189
		type testCase struct {
			base     uint64
			exponent uint64
			expected uint64
		}

		cases := []testCase{
			{2, 5, 32},
			{3, 4, 81},
			{5, 3, 125},
		}

		results := make([]uint64, len(cases))

		for i, tc := range cases {
			base := natFromU64(tc.base)
			exponent := natFromU64(tc.exponent)
			result := natFromU64(0)

			ok := exp.Exp(result, base, exponent)
			require.Equal(t, ct.True, ok, "Exp should succeed for coprime base")
			results[i] = result.Uint64()
		}

		for i, tc := range cases {
			assert.Equal(t, tc.expected, results[i],
				"%d^%d mod 46189 should be %d", tc.base, tc.exponent, tc.expected)
		}
	})
}

// Benchmark tests
func BenchmarkExponentiatorPrimeFactorsMulti_New(b *testing.B) {
	primes := []uint64{257, 263, 269, 271} // Small primes around 2^8
	ps := make([]*impl.Nat, len(primes))
	for i, p := range primes {
		ps[i] = natFromU64(p)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)
	}
}

func BenchmarkExponentiatorPrimeFactorsMulti_Exp(b *testing.B) {
	primes := []uint64{257, 263, 269, 271}
	ps := make([]*impl.Nat, len(primes))
	for i, p := range primes {
		ps[i] = natFromU64(p)
	}

	exp, _ := modular.NewOddPrimeFactorsMulti[*impl.ModulusOddPrime, *impl.Modulus, *impl.Nat](ps...)

	base := natFromU64(12345)
	exponent := natFromU64(67890)
	result := natFromU64(0)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = exp.Exp(result, base, exponent) // Ignore return value in benchmark
	}
}
