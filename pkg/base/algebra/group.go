package algebra

import "github.com/cronokirby/saferith"

// AbstractGroup defines methods needed for S to be considered as a Group.
// Group is a Monoid where every element is invertible.
type AbstractGroup[S Structure, E Element] interface {
	// Group is a Monoid.
	AbstractMonoid[S, E]
}

// AbstractGroupElement defines methods needed for E to be considered as an element of group S.
// Group is a Monoid where every element is invertible.
type AbstractGroupElement[S Structure, E Element] interface {
	// Group element is a Monoid element.
	AbstractMonoidElement[S, E]

	// Inverse returns inverse of this element ie. S.Operate(this, this.Inverse()).Equal(S.Identity()) == true
	Inverse() E
	// IsInverse checks whether the input is an inverse of this element.
	IsInverse(of E) bool
	// IsTorsionElement returns true if this.Mul(order) is identity.
	IsTorsionElement(order *saferith.Modulus) bool
}

// SubGroupTrait defined additional methods for group S if S is to be considered as a subgroup of some other group.
type SubGroupTrait interface {
	// Cofactor outputs the result of order of this subgroup divided by order of the group.
	Cofactor() *saferith.Nat
	// SubGroupOrder outputs the order of this subgroup.
	SubGroupOrder() *saferith.Modulus
}

// SubGroupElementTrait defines additional methods for elements of type E of subgroup S.
type SubGroupElementTrait[S Structure, E Element] interface {
	// IsSmallOrder returns true dependend on S and the context wherein it is used.
	// Example: Order <=8 elements of edwards25519 whose structure is Zq X Z8.
	IsSmallOrder() bool
	// ClearCofactor returns the value of this.Mul(cofactor).
	ClearCofactor() E
}

// AdditiveGroupTrait defines additional methods for group S if the operation is some form of addition.
type AdditiveGroupTrait[S Structure, E Element] interface {
	// Additive group is an additive monoid
	AdditiveMonoidTrait[S, E]

	// Sub is inverse of Add, and accepts elements x and a the list of elements ys and adds returns sum(x, -ys).
	Sub(x E, ys ...E) E
}

// AdditiveGroupElementTrait defines additional methods for elements of type E of group S if operator
// is some form of addition.
type AdditiveGroupElementTrait[S Structure, E Element] interface {
	// Additive group element is an additive monoid.
	AdditiveMonoidElementTrait[S, E]

	// AdditiveInverse returns an element that is the inverse of this element under addition.
	AdditiveInverse() E
	// IsAdditiveInverse returns true if the input is the additive inverse of this element.
	IsAdditiveInverse(of E) bool
	// Neg returns additive inverse of this element.
	Neg() E

	// Sub is the inverse of Add, and returns the value of this.Add(x.Inverse())
	Sub(x E) E
	// ApplySub calls this.Sub(x).Sub(x)...Sub(x), `n` many times.
	ApplySub(x E, n *saferith.Nat) E
}

// MultiplicativeGroupTrait defines additional methods for elements of type E of group S if operator
// is some form of multiplication.
type MultiplicativeGroupTrait[S Structure, E Element] interface {
	// Multiplicative group is a multiplicatiev monoid.
	MultiplicativeMonoidTrait[S, E]

	// Div is inverse of Mul, and accepts elements x and a the list of elements ys and adds returns product(x, ys^-1).
	Div(x E, ys ...E) E
}

// MultiplicativeGroupElementTrait defines additional methods for elements of type E of group S if operator
// is some form of multiplication.
type MultiplicativeGroupElementTrait[S Structure, E Element] interface {
	// Multiplicative group element is a multiplicative monoid element.
	MultiplicativeMonoidElementTrait[S, E]

	// MultiplicativeInverse returns the inverse of this element under multiplication.
	MultiplicativeInverse() E
	// IsMultiplicativeInverse returns true if the input is the multiplicative inverse of this element.
	IsMultiplicativeInverse(of E) bool

	// Div is the inverse of Mul, and returns the value of this.Mul(x.Inverse())
	Div(x E) E
	// ApplyDiv calls this.Div(x).Div(x)...Div(x), `n` many times.
	ApplyDiv(x E, n *saferith.Nat) E
}

// AbstractCyclicGroup defines methods needed for group S to be cyclic.
// We assume generator of S is previously agreed upon.
// Cyclic group is a group generated by a single element.
type AbstractCyclicGroup[S Structure, E Element] interface {
	// Cyclic group is a group.
	AbstractGroup[S, E]
	// Generator returns the previously agreed-upon element that generates the entire group S.
	Generator() E
}

// AbstractCyclicGroupElement defines methods needed for elements of type E of cyclic group S.
// Cyclic group is a group generated by a single element.
type AbstractCyclicGroupElement[S Structure, E Element] interface {
	// Cyclic group element is a group element.
	AbstractGroupElement[S, E]
}
