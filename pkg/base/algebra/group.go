package algebra

import "github.com/cronokirby/saferith"

// Group defines methods needed for S to be considered as a Group.
// Group is a Monoid where every element is invertible.
type Group[G Structure, E Element] interface {
	// Group is a Monoid.
	Monoid[G, E]
}

// GroupElement defines methods needed for E to be considered as an element of group S.
// Group is a Monoid where every element is invertible.
type GroupElement[G Structure, E Element] interface {
	// Group element is a Monoid element.
	MonoidElement[G, E]
	// Inverse returns inverse of this element ie. S.Operate(this, this.Inverse()).Equal(S.Identity()) == true
	Inverse(under BinaryOperator[E]) (E, error)
	// IsInverse checks whether the input is an inverse of this element.
	IsInverse(of GroupElement[G, E], under BinaryOperator[E]) (bool, error)
	// IsTorsionElement returns true if this.Mul(order) is identity.
	IsTorsionElement(order *saferith.Modulus, under BinaryOperator[E]) (bool, error)
}

// SubGroup defined additional methods for group S if S is to be considered as a subgroup of some other group.
type SubGroup[G Structure, E Element] interface {
	Group[G, E]
	// Cofactor outputs the result of order of this subgroup divided by order of the group.
	CoFactor() *saferith.Nat
	// SuperGroupOrder outputs the order of the parent of this subgroup.
	SuperGroupOrder() *saferith.Modulus
}

// SubGroupElement defines additional methods for elements of type E of subgroup S.
type SubGroupElement[G Structure, E Element] interface {
	GroupElement[G, E]
	// IsSmallOrder returns true if it this.IsTorsionElement($SMALL) where $SMALL
	// is context dependent and depends on S.
	// Example: SMALL = 8 for edwards25519 whose structure is Zq X Z8.
	IsSmallOrder() bool
	// ClearCofactor returns the value of this.Mul(cofactor).
	ClearCofactor() E
}

// AdditiveGroup defines additional methods for group S if the operation is some form of addition.
type AdditiveGroup[G Structure, E Element] interface {
	// Additive group is an additive monoid
	AdditiveMonoid[G, E]
	Group[G, E]

	// Sub is inverse of Add, and accepts elements x and a the list of elements ys and adds returns sum(x, -ys).
	Sub(x AdditiveGroupElement[G, E], ys ...AdditiveGroupElement[G, E]) E
}

// AdditiveGroupElement defines additional methods for elements of type E of group S if operator
// is some form of addition.
type AdditiveGroupElement[G Structure, E Element] interface {
	// Additive group element is an additive monoid.
	AdditiveMonoidElement[G, E]
	GroupElement[G, E]

	// AdditiveInverse returns an element that is the inverse of this element under addition.
	AdditiveInverse() E
	// IsAdditiveInverse returns true if the input is the additive inverse of this element.
	IsAdditiveInverse(of AdditiveGroupElement[G, E]) bool
	IsTorsionElementUnderAddition(order *saferith.Modulus) bool
	// Neg returns additive inverse of this element.
	Neg() E

	// Sub is the inverse of Add, and returns the value of this.Add(x.Inverse())
	Sub(x AdditiveGroupElement[G, E]) E
	// ApplySub calls this.Sub(x).Sub(x)...Sub(x), `n` many times.
	ApplySub(x AdditiveGroupElement[G, E], n *saferith.Nat) E
}

// MultiplicativeGroup defines additional methods for elements of type E of group S if operator
// is some form of multiplication.
type MultiplicativeGroup[G Structure, E Element] interface {
	// Multiplicative group is a multiplicatiev monoid.
	MultiplicativeMonoid[G, E]
	Group[G, E]

	// Div is inverse of Mul, and accepts elements x and a the list of elements ys and adds returns product(x, ys^-1).
	Div(x MultiplicativeGroupElement[G, E], ys ...MultiplicativeGroupElement[G, E]) (E, error)
}

// MultiplicativeGroupElement defines additional methods for elements of type E of group S if operator
// is some form of multiplication.
type MultiplicativeGroupElement[G Structure, E Element] interface {
	// Multiplicative group element is a multiplicative monoid element.
	MultiplicativeMonoidElement[G, E]
	GroupElement[G, E]

	// MultiplicativeInverse returns the inverse of this element under multiplication.
	MultiplicativeInverse() (E, error)
	// IsMultiplicativeInverse returns true if the input is the multiplicative inverse of this element.
	IsMultiplicativeInverse(of MultiplicativeGroupElement[G, E]) bool
	IsTorsionElementUnderMultiplication(order *saferith.Modulus) bool

	// Div is the inverse of Mul, and returns the value of this.Mul(x.Inverse())
	Div(x MultiplicativeGroupElement[G, E]) (E, error)
	// ApplyDiv calls this.Div(x).Div(x)...Div(x), `n` many times.
	ApplyDiv(x MultiplicativeGroupElement[G, E], n *saferith.Nat) (E, error)
}

// CyclicGroup defines methods needed for group S to be cyclic.
// We assume generator of S is previously agreed upon.
// Cyclic group is a group generated by a single element.
type CyclicGroup[G Structure, E Element] interface {
	// Cyclic group is a group.
	CyclicMonoid[G, E]
	Group[G, E]
	DLog(base, x CyclicGroupElement[G, E], under BinaryOperator[E]) (*saferith.Nat, error)
}

// CyclicGroupElement defines methods needed for elements of type E of cyclic group S.
// Cyclic group is a group generated by a single element.
type CyclicGroupElement[G Structure, E Element] interface {
	// Cyclic group element is a group element.
	CyclicMonoidElement[G, E]
	GroupElement[G, E]
}

type AdditiveCyclicGroup[G Structure, E Element] interface {
	// Cyclic group is a group.
	AdditiveGroup[G, E]
	CyclicGroup[G, E]
}

// CyclicGroupElement defines methods needed for elements of type E of cyclic group S.
// Cyclic group is a group generated by a single element.
type AdditiveCyclicGroupElement[G Structure, E Element] interface {
	// Cyclic group element is a group element.
	AdditiveGroupElement[G, E]
	CyclicGroupElement[G, E]
}

type AutGroupOperator[E Element] interface {
	BinaryOperator[AutoFunction[E]]
	FunctionComposition[E, E, E]
}

type Aut[G Structure, ObjE Element] Group[G, AutoFunction[ObjE]]
