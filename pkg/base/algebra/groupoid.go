package algebra

import (
	"github.com/cronokirby/saferith"
)

type Successor[E Element] interface {
	UnaryOperator[E]
	Next(x E) E
}

type Addition[E Element] interface {
	BinaryOperator[E]
	Add(x, y E) E
}

type Multiplication[E Element] interface {
	BinaryOperator[E]
	Multiply(x, y E) E
}

type DiscreteExponentiation[E Element] interface {
	BinaryOperator[E]
	Exp(base E, exponent *saferith.Nat) E
}

// Groupoid defines methods needed for S to be considered as a Groupoid.
// We assume the Groupoid is right associative.
// Groupoid/Magma is a set equipped with a binary operator that is closed under
// said operator.
type Groupoid[G Structure, E Element] interface {
	// Groupoid is a structured set.
	StructuredSet[G, E]
	IsDefinedUnder(operator BinaryOperator[E]) bool
	Op(operator BinaryOperator[E], x GroupoidElement[G, E], ys ...GroupoidElement[G, E]) (E, error)
}

// GroupoidElement defines methods for E to be considered an element of S
// where S is a Groupoid.
// Groupoid/Magma is a set equipped with a binary operator that is closed under
// said operator.
type GroupoidElement[G Structure, E Element] interface {
	// Groupoid Element is an element of a structured set.
	StructuredSetElement[G, E]
	// Order is the size the structure of the same type S generated by this element.
	Order(operator BinaryOperator[E]) (*saferith.Modulus, error)
	ApplyOp(operator BinaryOperator[E], x GroupoidElement[G, E], n *saferith.Nat) (E, error)
}

// AdditiveGroupoid defines additional methods for the groupoid S if the operator is some form of addition.
type AdditiveGroupoid[G Structure, E Element] interface {
	Groupoid[G, E]
	// Add accepts elements x and a the list of elements ys and adds returns sum(x, ys). We assume S with its
	// addition operator is right associative.
	Add(x AdditiveGroupoidElement[G, E], ys ...AdditiveGroupoidElement[G, E]) E

	Addition() Addition[E]
}

// AdditiveGroupoidElement defines additional methods for the elements of type E of the groupoid S, if
// the operator is some form of addition.
type AdditiveGroupoidElement[G Structure, E Element] interface {
	GroupoidElement[G, E]
	// Add adds this element to the input element and returns an element of type E.
	Add(rhs AdditiveGroupoidElement[G, E]) E
	// ApplyAdd calls this.Add(x).Add(x)...Add(x), `n-1` many times.
	ApplyAdd(x AdditiveGroupoidElement[G, E], n *saferith.Nat) E
	// Double returns the value of x.Add(x)
	Double() E
	// Triple returns the value of x.Add(x).Add(x)
	Triple() E
}

// MultiplicativeGroupoid defines additional methods for the elements of type E of the groupoid S, if
// the operator is some form of multiplication.
type MultiplicativeGroupoid[G Structure, E Element] interface {
	Groupoid[G, E]
	// Multiply accepts elements x and a the list of elements ys and adds returns product(x, ys). We assume S with its
	// multiplication operator is right associative.
	Mul(x MultiplicativeGroupoidElement[G, E], ys ...MultiplicativeGroupoidElement[G, E]) E
	Exp(base, power E) E

	SimExp(bases []MultiplicativeGroupoidElement[G, E], exponents []*saferith.Nat) (E, error)
	MultiBaseExp(bases []MultiplicativeGroupoidElement[G, E], exponent *saferith.Nat) E
	MultiExponentExp(base MultiplicativeGroupoidElement[G, E], exponents []*saferith.Nat) E

	Multiplication() Multiplication[E]
	DiscreteExponentiation() DiscreteExponentiation[E]
}

// MultiplicativeGroupoidElement defines additional methods for the elements of type E of the groupoid S, if
// the operator is some form of multiplication.
type MultiplicativeGroupoidElement[G Structure, E Element] interface {
	GroupoidElement[G, E]
	// Mul multiplies this element to the input element and returns an element of type E.
	Mul(rhs MultiplicativeGroupoidElement[G, E]) E
	// ApplyMul calls this.Mul(x).Mul(x)...Mul(x), `n-1` many times.
	ApplyMul(x MultiplicativeGroupoidElement[G, E], n *saferith.Nat) E
	// Square returns the values of x.Mul(x)
	Square() E
	// Cube returns the values of x.Mul(x).Mul(x)
	Cube() E

	Exp(exponent *saferith.Nat) E
}

type CyclicGroupoid[G Structure, E Element] interface {
	Groupoid[G, E]
	PointedSet[G, E]
	Generator() E
}

type CyclicGroupoidElement[G Structure, E Element] interface {
	GroupoidElement[G, E]
	PointedSetElement[G, E]

	CanGenerateAllElements() bool
	IsDesignatedGenerator() bool
}
