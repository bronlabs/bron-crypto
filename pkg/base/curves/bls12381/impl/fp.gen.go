// Code generated by krypton-primitives. DO NOT EDIT.

package impl

import (
	"encoding/hex"
	internal "github.com/bronlabs/krypton-primitives/pkg/base/curves/bls12381/impl/internal/fiat"
	fields "github.com/bronlabs/krypton-primitives/pkg/base/curves/impl/fields"
	"io"
	"slices"
)

const (
	FpLimbs     = 6
	FpSatLimbs  = FpLimbs + 1
	FpBits      = 381
	FpBytes     = 8 * (((FpBits - 1) / 64) + 1)
	FpWideBytes = 2 * FpBytes
	FpDivSteps  = ((49 * FpBits) + 57) / 17
	FpE         = 1
)

var (
    _ fields.PrimeField[*Fp] = (*Fp)(nil)

	FpProgenitorExp = [...]byte{0xaa, 0xea, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0xee, 0xff, 0xff, 0x54, 0xac, 0xff, 0xff, 0xaa, 0x07, 0x89, 0x3d, 0xac, 0x3d, 0xa8, 0x34, 0xcc, 0xd9, 0xaf, 0x44, 0xe1, 0x3c, 0xe1, 0xd2, 0x1d, 0xd9, 0x35, 0xeb, 0xd2, 0x90, 0xed, 0xe9, 0xc6, 0x92, 0xa6, 0xf9, 0x5f, 0x8e, 0x7a, 0x44, 0x80, 0x06}
	FpModulus       [FpSatLimbs]uint64
	FpRootOfUnity   Fp
)

func init() {
	internal.FpMsat(&FpModulus)
	FpRootOfUnity.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa")
}

func (f *Fp) Set(v *Fp) {
	*f = *v
}

func (f *Fp) SetZero() {
	*f = Fp{}
}

func (f *Fp) SetOne() {
	internal.FpSetOne(&f.FpMontgomeryDomainFieldElement)
}

func (f *Fp) SetUint64(v uint64) {
	limbs := [FpLimbs]uint64{v}
	f.SetLimbs(limbs[:])
}

func (f *Fp) SetLimbs(data []uint64) (ok uint64) {
	internal.FpToMontgomery(&f.FpMontgomeryDomainFieldElement, (*internal.FpNonMontgomeryDomainFieldElement)(data))
	return 1
}

func (f *Fp) SetBytes(data []byte) (ok uint64) {
	if len(data) != FpBytes {
		return 0
	}

	var nonMonty internal.FpNonMontgomeryDomainFieldElement
	internal.FpFromBytes((*[FpLimbs]uint64)(&nonMonty), (*[FpBytes]uint8)(data))
	internal.FpToMontgomery(&f.FpMontgomeryDomainFieldElement, &nonMonty)
	return 1
}

func (f *Fp) SetBytesWide(data []byte) (ok uint64) {
	if len(data) > FpWideBytes {
		return 0
	}

	var wideData [FpWideBytes]uint8
	copy(wideData[:], data)

	var d1, d0 [FpLimbs]uint64
	internal.FpFromBytes(&d0, (*[FpBytes]uint8)(wideData[:FpBytes]))
	internal.FpFromBytes(&d1, (*[FpBytes]uint8)(wideData[FpBytes:]))

	// d0*r2 + d1*r3
	internal.FpToMontgomery((*internal.FpMontgomeryDomainFieldElement)(&d0), (*internal.FpNonMontgomeryDomainFieldElement)(&d0))
	internal.FpToMontgomery((*internal.FpMontgomeryDomainFieldElement)(&d1), (*internal.FpNonMontgomeryDomainFieldElement)(&d1))
	internal.FpToMontgomery((*internal.FpMontgomeryDomainFieldElement)(&d1), (*internal.FpNonMontgomeryDomainFieldElement)(&d1))
	internal.FpAdd(&f.FpMontgomeryDomainFieldElement, (*internal.FpMontgomeryDomainFieldElement)(&d0), (*internal.FpMontgomeryDomainFieldElement)(&d1))
	return 1
}

func (f *Fp) SetUniformBytes(componentsData ...[]byte) (ok uint64) {
	if len(componentsData) != 1 {
		return 0
	}

	return f.SetBytesWide(componentsData[0])
}

func (f *Fp) SetRandom(prng io.Reader) (ok uint64) {
	var uniformBytes [(FpBits + 128 + 7) / 8]byte
	_, err := io.ReadFull(prng, uniformBytes[:])
	if err != nil {
		return 0
	}
	return f.SetUniformBytes(uniformBytes[:])
}

func (f *Fp) Select(choice uint64, z, nz *Fp) {
	internal.FpSelect((*[FpLimbs]uint64)(&f.FpMontgomeryDomainFieldElement), choice, (*[FpLimbs]uint64)(&z.FpMontgomeryDomainFieldElement), (*[FpLimbs]uint64)(&nz.FpMontgomeryDomainFieldElement))
}

func (f *Fp) Add(lhs, rhs *Fp) {
	internal.FpAdd(&f.FpMontgomeryDomainFieldElement, &lhs.FpMontgomeryDomainFieldElement, &rhs.FpMontgomeryDomainFieldElement)
}

func (f *Fp) Sub(lhs, rhs *Fp) {
	internal.FpSub(&f.FpMontgomeryDomainFieldElement, &lhs.FpMontgomeryDomainFieldElement, &rhs.FpMontgomeryDomainFieldElement)
}

func (f *Fp) Neg(v *Fp) {
	internal.FpOpp(&f.FpMontgomeryDomainFieldElement, &v.FpMontgomeryDomainFieldElement)
}

func (f *Fp) Mul(lhs, rhs *Fp) {
	internal.FpMul(&f.FpMontgomeryDomainFieldElement, &lhs.FpMontgomeryDomainFieldElement, &rhs.FpMontgomeryDomainFieldElement)
}

func (f *Fp) Square(v *Fp) {
	internal.FpSquare(&f.FpMontgomeryDomainFieldElement, &v.FpMontgomeryDomainFieldElement)
}

func (f *Fp) Inv(a *Fp) (ok uint64) {
	var precomp, h, v, r, out4, out5 [FpLimbs]uint64
	var ff, g, out2, out3 [FpSatLimbs]uint64
	var out1, inverted uint64

	d := uint64(1)
	internal.FpDivstepPrecomp(&precomp)
	internal.FpFromMontgomery((*internal.FpNonMontgomeryDomainFieldElement)(g[:FpLimbs]), &a.FpMontgomeryDomainFieldElement)
	internal.FpMsat(&ff)
	internal.FpSetOne((*internal.FpMontgomeryDomainFieldElement)(&r))

	for i := 0; i < FpDivSteps-(FpDivSteps%2); i += 2 {
		internal.FpDivstep(&out1, &out2, &out3, &out4, &out5, d, &ff, &g, &v, &r)
		internal.FpDivstep(&d, &ff, &g, &v, &r, out1, &out2, &out3, &out4, &out5)
	}
	if (FpDivSteps % 2) != 0 { // compile time if - always true
		internal.FpDivstep(&out1, &out2, &out3, &out4, &out5, d, &ff, &g, &v, &r)
		v = out4
		ff = out2
	}

	internal.FpOpp((*internal.FpMontgomeryDomainFieldElement)(&h), (*internal.FpMontgomeryDomainFieldElement)(&v))
	internal.FpSelect(&v, ff[FpLimbs] >> 63, &v, &h)
	internal.FpMul(&f.FpMontgomeryDomainFieldElement, (*internal.FpMontgomeryDomainFieldElement)(&v), (*internal.FpMontgomeryDomainFieldElement)(&precomp))
	internal.FpNonzero(&inverted, (*[FpLimbs]uint64)(&f.FpMontgomeryDomainFieldElement))

	return (inverted | -inverted) >> 63
}

func (f *Fp) Div(lhs, rhs *Fp) (ok uint64) {
	var rhsInv Fp
	ok = rhsInv.Inv(rhs)
	f.Mul(lhs, &rhsInv)
	return ok
}

func (f *Fp) Sqrt(x *Fp) (ok uint64) {
	return f.SqrtTrait.Sqrt(f, x, &FpRootOfUnity, FpE, FpProgenitorExp[:])
}

func (f *Fp) IsNonZero() uint64 {
	// montgomery form might not be "fully reduced"
	var nonMonty internal.FpNonMontgomeryDomainFieldElement
	internal.FpFromMontgomery(&nonMonty, &f.FpMontgomeryDomainFieldElement)

	var nonZero uint64
	internal.FpNonzero(&nonZero, (*[FpLimbs]uint64)(&nonMonty))
	return (nonZero | -nonZero) >> 63
}

func (f *Fp) IsZero() uint64 {
	return f.IsNonZero() ^ 1
}

func (f *Fp) IsOne() uint64 {
	var one Fp
	one.SetOne()
	return f.Equals(&one)
}

func (f *Fp) Equals(v *Fp) uint64 {
	var diff Fp
	diff.Sub(f, v)
	return diff.IsZero()
}

func (f *Fp) ComponentsBytes() [][]byte {
	return [][]byte{f.Bytes()}
}

func (f *Fp) Bytes() []byte {
	var nonMonty internal.FpNonMontgomeryDomainFieldElement
	internal.FpFromMontgomery(&nonMonty, &f.FpMontgomeryDomainFieldElement)
	var data [FpBytes]byte
	internal.FpToBytes(&data, (*[FpLimbs]uint64)(&nonMonty))
	return data[:]

}

func (f *Fp) Limbs() []uint64 {
	var nonMonty internal.FpNonMontgomeryDomainFieldElement
	internal.FpFromMontgomery(&nonMonty, &f.FpMontgomeryDomainFieldElement)
	return nonMonty[:]
}

func (f *Fp) MustSetHex(v string) {
	data, err := hex.DecodeString(v)
	if err != nil {
		panic(err)
	}
	slices.Reverse(data)
	ok := f.SetBytes(data)
	if ok != 1 {
		panic("invalid data")
	}
}

func (f *Fp) Hex() string {
	data := f.Bytes()
	slices.Reverse(data)
	return hex.EncodeToString(data)
}

func (f *Fp) Degree() uint64 {
	return 1
}
