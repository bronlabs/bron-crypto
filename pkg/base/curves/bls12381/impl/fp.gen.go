// Code generated by bron-crypto. DO NOT EDIT.

package impl

import (
	"encoding/hex"
	"io"
	"math/big"
	"slices"
)

const (
	FpLimbs     = 6
	FpSatLimbs  = FpLimbs + 1
	FpBits      = 381
	FpBytes     = 8 * (((FpBits - 1) / 64) + 1)
	FpWideBytes = 2 * FpBytes
	FpDivSteps  = ((49 * FpBits) + 57) / 17
	FpE         = 1
)

var (
	FpProgenitorExp = [...]byte{0xaa, 0xea, 0xff, 0xff, 0xff, 0xbf, 0x7f, 0xee, 0xff, 0xff, 0x54, 0xac, 0xff, 0xff, 0xaa, 0x07, 0x89, 0x3d, 0xac, 0x3d, 0xa8, 0x34, 0xcc, 0xd9, 0xaf, 0x44, 0xe1, 0x3c, 0xe1, 0xd2, 0x1d, 0xd9, 0x35, 0xeb, 0xd2, 0x90, 0xed, 0xe9, 0xc6, 0x92, 0xa6, 0xf9, 0x5f, 0x8e, 0x7a, 0x44, 0x80, 0x06}
	FpModulus       = [...]byte{0xab, 0xaa, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xb9, 0xff, 0xff, 0x53, 0xb1, 0xfe, 0xff, 0xab, 0x1e, 0x24, 0xf6, 0xb0, 0xf6, 0xa0, 0xd2, 0x30, 0x67, 0xbf, 0x12, 0x85, 0xf3, 0x84, 0x4b, 0x77, 0x64, 0xd7, 0xac, 0x4b, 0x43, 0xb6, 0xa7, 0x1b, 0x4b, 0x9a, 0xe6, 0x7f, 0x39, 0xea, 0x11, 0x01, 0x1a}
	FpRootOfUnity   Fp
)

func init() {
	FpRootOfUnity.MustSetHex("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa")
}

type Fp struct {
	fiatFpMontgomeryDomainFieldElement
}

func (f *Fp) Set(v *Fp) {
	*f = *v
}

func (f *Fp) SetZero() {
	*f = Fp{}
}

func (f *Fp) SetOne() {
	fiatFpSetOne(&f.fiatFpMontgomeryDomainFieldElement)
}

func (f *Fp) SetUint64(v uint64) {
	limbs := [FpLimbs]uint64{v}
	f.SetLimbs(limbs[:])
}

func (f *Fp) SetLimbs(data []uint64) (ok uint64) {
	fiatFpToMontgomery(&f.fiatFpMontgomeryDomainFieldElement, (*fiatFpNonMontgomeryDomainFieldElement)(data))
	return 1
}

func (f *Fp) SetBytes(data []byte) (ok uint64) {
	if len(data) != FpBytes {
		return 0
	}

	var nonMonty fiatFpNonMontgomeryDomainFieldElement
	fiatFpFromBytes((*[FpLimbs]uint64)(&nonMonty), (*[FpBytes]uint8)(data))
	fiatFpToMontgomery(&f.fiatFpMontgomeryDomainFieldElement, &nonMonty)
	return 1
}

func (f *Fp) SetBytesWide(data []byte) (ok uint64) {
	if len(data) > FpWideBytes {
		return 0
	}

	var wideData [FpWideBytes]uint8
	copy(wideData[:], data)

	var d1, d0 [FpLimbs]uint64
	fiatFpFromBytes(&d0, (*[FpBytes]uint8)(wideData[:FpBytes]))
	fiatFpFromBytes(&d1, (*[FpBytes]uint8)(wideData[FpBytes:]))

	// d0*r2 + d1*r3
	fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&d0), (*fiatFpNonMontgomeryDomainFieldElement)(&d0))
	fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&d1), (*fiatFpNonMontgomeryDomainFieldElement)(&d1))
	fiatFpToMontgomery((*fiatFpMontgomeryDomainFieldElement)(&d1), (*fiatFpNonMontgomeryDomainFieldElement)(&d1))
	fiatFpAdd(&f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&d0), (*fiatFpMontgomeryDomainFieldElement)(&d1))
	return 1
}

func (f *Fp) SetUniformBytes(componentsData ...[]byte) (ok uint64) {
	if len(componentsData) != 1 {
		return 0
	}

	return f.SetBytesWide(componentsData[0])
}

func (f *Fp) SetRandom(prng io.Reader) (ok uint64) {
	var uniformBytes [(FpBits + 128 + 7) / 8]byte
	_, err := io.ReadFull(prng, uniformBytes[:])
	if err != nil {
		return 0
	}
	return f.SetUniformBytes(uniformBytes[:])
}

func (f *Fp) Select(choice uint64, z, nz *Fp) {
	fiatFpSelectznz((*[FpLimbs]uint64)(&f.fiatFpMontgomeryDomainFieldElement),fiatFpUint1(choice), (*[FpLimbs]uint64)(&z.fiatFpMontgomeryDomainFieldElement), (*[FpLimbs]uint64)(&nz.fiatFpMontgomeryDomainFieldElement))
}

func (f *Fp) Add(lhs, rhs *Fp) {
	fiatFpAdd(&f.fiatFpMontgomeryDomainFieldElement, &lhs.fiatFpMontgomeryDomainFieldElement, &rhs.fiatFpMontgomeryDomainFieldElement)
}

func (f *Fp) Sub(lhs, rhs *Fp) {
	fiatFpSub(&f.fiatFpMontgomeryDomainFieldElement, &lhs.fiatFpMontgomeryDomainFieldElement, &rhs.fiatFpMontgomeryDomainFieldElement)
}

func (f *Fp) Neg(v *Fp) {
	fiatFpOpp(&f.fiatFpMontgomeryDomainFieldElement, &v.fiatFpMontgomeryDomainFieldElement)
}

func (f *Fp) Mul(lhs, rhs *Fp) {
	fiatFpMul(&f.fiatFpMontgomeryDomainFieldElement, &lhs.fiatFpMontgomeryDomainFieldElement, &rhs.fiatFpMontgomeryDomainFieldElement)
}

func (f *Fp) Square(v *Fp) {
	fiatFpSquare(&f.fiatFpMontgomeryDomainFieldElement, &v.fiatFpMontgomeryDomainFieldElement)
}

func (f *Fp) Inv(a *Fp) (ok uint64) {
	var precomp, h, v, r, out4, out5 [FpLimbs]uint64
	var ff, g, out2, out3 [FpSatLimbs]uint64
	var out1, inverted uint64

	d := uint64(1)
	fiatFpDivstepPrecomp(&precomp)
	fiatFpFromMontgomery((*fiatFpNonMontgomeryDomainFieldElement)(g[:FpLimbs]), &a.fiatFpMontgomeryDomainFieldElement)
	fiatFpMsat(&ff)
	fiatFpSetOne((*fiatFpMontgomeryDomainFieldElement)(&r))

	for i := 0; i < FpDivSteps-(FpDivSteps%2); i += 2 {
		fiatFpDivstep(&out1, &out2, &out3, &out4, &out5, d, &ff, &g, &v, &r)
		fiatFpDivstep(&d, &ff, &g, &v, &r, out1, &out2, &out3, &out4, &out5)
	}
	if (FpDivSteps % 2) != 0 { // compile time if - always true
		fiatFpDivstep(&out1, &out2, &out3, &out4, &out5, d, &ff, &g, &v, &r)
		v = out4
		ff = out2
	}

	fiatFpOpp((*fiatFpMontgomeryDomainFieldElement)(&h), (*fiatFpMontgomeryDomainFieldElement)(&v))
	fiatFpSelectznz(&v, fiatFpUint1(ff[FpLimbs]>>63), &v, &h)
	fiatFpMul(&f.fiatFpMontgomeryDomainFieldElement, (*fiatFpMontgomeryDomainFieldElement)(&v), (*fiatFpMontgomeryDomainFieldElement)(&precomp))
	fiatFpNonzero(&inverted, (*[FpLimbs]uint64)(&f.fiatFpMontgomeryDomainFieldElement))

	return (inverted | -inverted) >> 63
}

func (f *Fp) Div(lhs, rhs *Fp) (ok uint64) {
	var rhsInv Fp
	ok = rhsInv.Inv(rhs)
	f.Mul(lhs, &rhsInv)
	return ok
}

func (f *Fp) Sqrt(x *Fp) (ok uint64) {
	return sqrt(f, x, &FpRootOfUnity, FpE, FpProgenitorExp[:])
}

func (f *Fp) IsNonZero() uint64 {
	// montgomery form might not be "fully reduced"
	var nonMonty fiatFpNonMontgomeryDomainFieldElement
	fiatFpFromMontgomery(&nonMonty, &f.fiatFpMontgomeryDomainFieldElement)

	var nonZero uint64
	fiatFpNonzero(&nonZero, (*[FpLimbs]uint64)(&nonMonty))
	return (nonZero | -nonZero) >> 63
}

func (f *Fp) IsZero() uint64 {
	return f.IsNonZero() ^ 1
}

func (f *Fp) IsOne() uint64 {
	var one Fp
	one.SetOne()
	return f.Equals(&one)
}

func (f *Fp) Equals(v *Fp) uint64 {
	var diff Fp
	diff.Sub(f, v)
	return diff.IsZero()
}

func (f *Fp) ComponentsBytes() [][]byte {
	return [][]byte{f.Bytes()}
}

func (f *Fp) Bytes() []byte {
	var nonMonty fiatFpNonMontgomeryDomainFieldElement
	fiatFpFromMontgomery(&nonMonty, &f.fiatFpMontgomeryDomainFieldElement)
	var data [FpBytes]byte
	fiatFpToBytes(&data, (*[FpLimbs]uint64)(&nonMonty))
	return data[:]

}

func (f *Fp) Limbs() []uint64 {
	var nonMonty fiatFpNonMontgomeryDomainFieldElement
	fiatFpFromMontgomery(&nonMonty, &f.fiatFpMontgomeryDomainFieldElement)
	return nonMonty[:]
}

func (f *Fp) MustSetHex(v string) {
	data, err := hex.DecodeString(v)
	if err != nil {
		panic(err)
	}
	slices.Reverse(data)
	ok := f.SetBytes(data)
	if ok != 1 {
		panic("invalid data")
	}
}

func (f *Fp) Hex() string {
	data := f.Bytes()
	slices.Reverse(data)
	return hex.EncodeToString(data)
}

func (f *Fp) Degree() uint64 {
	return 1
}

func (f *Fp) String() string {
	fBytes := f.Bytes()
	slices.Reverse(fBytes)
	fBi := new(big.Int).SetBytes(fBytes)
	return fBi.String()
}

func (f *Fp) GoString() string {
	fBytes := f.Bytes()
	slices.Reverse(fBytes)
	return "0x" + hex.EncodeToString(f.Bytes())
}
