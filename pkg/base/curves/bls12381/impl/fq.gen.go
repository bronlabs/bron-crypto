// Code generated by krypton-primitives. DO NOT EDIT.

package impl

import (
	"encoding/hex"
	internal "github.com/bronlabs/krypton-primitives/pkg/base/curves/bls12381/impl/internal/fiat"
	fields "github.com/bronlabs/krypton-primitives/pkg/base/curves/impl/fields"
	"io"
	"slices"
)

const (
	FqLimbs     = 4
	FqSatLimbs  = FqLimbs + 1
	FqBits      = 255
	FqBytes     = 8 * (((FqBits - 1) / 64) + 1)
	FqWideBytes = 2 * FqBytes
	FqDivSteps  = ((49 * FqBits) + 57) / 17
	FqE         = 32
)

var (
    _ fields.PrimeFieldPtr[*Fq] = (*Fq)(nil)

	FqProgenitorExp = [...]byte{0xff, 0xff, 0xff, 0x7f, 0xff, 0x2d, 0xff, 0x7f, 0x01, 0xd2, 0xde, 0xa9, 0x02, 0xec, 0xd0, 0x04, 0x04, 0xec, 0x9c, 0x19, 0xa4, 0xbe, 0xce, 0x94, 0xa9, 0xd3, 0xf6, 0x39}
	FqModulus       [FqSatLimbs]uint64
	FqRootOfUnity   Fq
)

func init() {
	internal.FqMsat(&FqModulus)
	FqRootOfUnity.MustSetHex("16a2a19edfe81f20d09b681922c813b4b63683508c2280b93829971f439f0d2b")
}

func (f *Fq) Set(v *Fq) {
	*f = *v
}

func (f *Fq) SetZero() {
	*f = Fq{}
}

func (f *Fq) SetOne() {
	internal.FqSetOne(&f.FqMontgomeryDomainFieldElement)
}

func (f *Fq) SetUint64(v uint64) {
	limbs := [FqLimbs]uint64{v}
	f.SetLimbs(limbs[:])
}

func (f *Fq) SetLimbs(data []uint64) (ok uint64) {
	internal.FqToMontgomery(&f.FqMontgomeryDomainFieldElement, (*internal.FqNonMontgomeryDomainFieldElement)(data))
	return 1
}

func (f *Fq) SetBytes(data []byte) (ok uint64) {
	if len(data) != FqBytes {
		return 0
	}

	var nonMonty internal.FqNonMontgomeryDomainFieldElement
	internal.FqFromBytes((*[FqLimbs]uint64)(&nonMonty), (*[FqBytes]uint8)(data))
	internal.FqToMontgomery(&f.FqMontgomeryDomainFieldElement, &nonMonty)
	return 1
}

func (f *Fq) SetBytesWide(data []byte) (ok uint64) {
	if len(data) > FqWideBytes {
		return 0
	}

	var wideData [FqWideBytes]uint8
	copy(wideData[:], data)

	var d1, d0 [FqLimbs]uint64
	internal.FqFromBytes(&d0, (*[FqBytes]uint8)(wideData[:FqBytes]))
	internal.FqFromBytes(&d1, (*[FqBytes]uint8)(wideData[FqBytes:]))

	// d0*r2 + d1*r3
	internal.FqToMontgomery((*internal.FqMontgomeryDomainFieldElement)(&d0), (*internal.FqNonMontgomeryDomainFieldElement)(&d0))
	internal.FqToMontgomery((*internal.FqMontgomeryDomainFieldElement)(&d1), (*internal.FqNonMontgomeryDomainFieldElement)(&d1))
	internal.FqToMontgomery((*internal.FqMontgomeryDomainFieldElement)(&d1), (*internal.FqNonMontgomeryDomainFieldElement)(&d1))
	internal.FqAdd(&f.FqMontgomeryDomainFieldElement, (*internal.FqMontgomeryDomainFieldElement)(&d0), (*internal.FqMontgomeryDomainFieldElement)(&d1))
	return 1
}

func (f *Fq) SetUniformBytes(componentsData ...[]byte) (ok uint64) {
	if len(componentsData) != 1 {
		return 0
	}

	return f.SetBytesWide(componentsData[0])
}

func (f *Fq) SetRandom(prng io.Reader) (ok uint64) {
	var uniformBytes [(FqBits + 128 + 7) / 8]byte
	_, err := io.ReadFull(prng, uniformBytes[:])
	if err != nil {
		return 0
	}
	return f.SetUniformBytes(uniformBytes[:])
}

func (f *Fq) Select(choice uint64, z, nz *Fq) {
	internal.FqSelect((*[FqLimbs]uint64)(&f.FqMontgomeryDomainFieldElement), choice, (*[FqLimbs]uint64)(&z.FqMontgomeryDomainFieldElement), (*[FqLimbs]uint64)(&nz.FqMontgomeryDomainFieldElement))
}

func (f *Fq) Add(lhs, rhs *Fq) {
	internal.FqAdd(&f.FqMontgomeryDomainFieldElement, &lhs.FqMontgomeryDomainFieldElement, &rhs.FqMontgomeryDomainFieldElement)
}

func (f *Fq) Sub(lhs, rhs *Fq) {
	internal.FqSub(&f.FqMontgomeryDomainFieldElement, &lhs.FqMontgomeryDomainFieldElement, &rhs.FqMontgomeryDomainFieldElement)
}

func (f *Fq) Neg(v *Fq) {
	internal.FqOpp(&f.FqMontgomeryDomainFieldElement, &v.FqMontgomeryDomainFieldElement)
}

func (f *Fq) Mul(lhs, rhs *Fq) {
	internal.FqMul(&f.FqMontgomeryDomainFieldElement, &lhs.FqMontgomeryDomainFieldElement, &rhs.FqMontgomeryDomainFieldElement)
}

func (f *Fq) Square(v *Fq) {
	internal.FqSquare(&f.FqMontgomeryDomainFieldElement, &v.FqMontgomeryDomainFieldElement)
}

func (f *Fq) Inv(a *Fq) (ok uint64) {
	var precomp, h, v, r, out4, out5 [FqLimbs]uint64
	var ff, g, out2, out3 [FqSatLimbs]uint64
	var out1, inverted uint64

	d := uint64(1)
	internal.FqDivstepPrecomp(&precomp)
	internal.FqFromMontgomery((*internal.FqNonMontgomeryDomainFieldElement)(g[:FqLimbs]), &a.FqMontgomeryDomainFieldElement)
	internal.FqMsat(&ff)
	internal.FqSetOne((*internal.FqMontgomeryDomainFieldElement)(&r))

	for i := 0; i < FqDivSteps-(FqDivSteps%2); i += 2 {
		internal.FqDivstep(&out1, &out2, &out3, &out4, &out5, d, &ff, &g, &v, &r)
		internal.FqDivstep(&d, &ff, &g, &v, &r, out1, &out2, &out3, &out4, &out5)
	}
	if (FqDivSteps % 2) != 0 { // compile time if - always true
		internal.FqDivstep(&out1, &out2, &out3, &out4, &out5, d, &ff, &g, &v, &r)
		v = out4
		ff = out2
	}

	internal.FqOpp((*internal.FqMontgomeryDomainFieldElement)(&h), (*internal.FqMontgomeryDomainFieldElement)(&v))
	internal.FqSelect(&v, ff[FqLimbs] >> 63, &v, &h)
	internal.FqMul(&f.FqMontgomeryDomainFieldElement, (*internal.FqMontgomeryDomainFieldElement)(&v), (*internal.FqMontgomeryDomainFieldElement)(&precomp))
	internal.FqNonzero(&inverted, (*[FqLimbs]uint64)(&f.FqMontgomeryDomainFieldElement))

	return (inverted | -inverted) >> 63
}

func (f *Fq) Div(lhs, rhs *Fq) (ok uint64) {
	var rhsInv Fq
	ok = rhsInv.Inv(rhs)
	f.Mul(lhs, &rhsInv)
	return ok
}

func (f *Fq) Sqrt(x *Fq) (ok uint64) {
	return f.SqrtTrait.Sqrt(f, x, &FqRootOfUnity, FqE, FqProgenitorExp[:])
}

func (f *Fq) IsNonZero() uint64 {
	// montgomery form might not be "fully reduced"
	var nonMonty internal.FqNonMontgomeryDomainFieldElement
	internal.FqFromMontgomery(&nonMonty, &f.FqMontgomeryDomainFieldElement)

	var nonZero uint64
	internal.FqNonzero(&nonZero, (*[FqLimbs]uint64)(&nonMonty))
	return (nonZero | -nonZero) >> 63
}

func (f *Fq) IsZero() uint64 {
	return f.IsNonZero() ^ 1
}

func (f *Fq) IsOne() uint64 {
	var one Fq
	one.SetOne()
	return f.Equals(&one)
}

func (f *Fq) Equals(v *Fq) uint64 {
	var diff Fq
	diff.Sub(f, v)
	return diff.IsZero()
}

func (f *Fq) ComponentsBytes() [][]byte {
	return [][]byte{f.Bytes()}
}

func (f *Fq) Bytes() []byte {
	var nonMonty internal.FqNonMontgomeryDomainFieldElement
	internal.FqFromMontgomery(&nonMonty, &f.FqMontgomeryDomainFieldElement)
	var data [FqBytes]byte
	internal.FqToBytes(&data, (*[FqLimbs]uint64)(&nonMonty))
	return data[:]

}

func (f *Fq) Limbs() []uint64 {
	var nonMonty internal.FqNonMontgomeryDomainFieldElement
	internal.FqFromMontgomery(&nonMonty, &f.FqMontgomeryDomainFieldElement)
	return nonMonty[:]
}

func (f *Fq) MustSetHex(v string) {
	data, err := hex.DecodeString(v)
	if err != nil {
		panic(err)
	}
	slices.Reverse(data)
	ok := f.SetBytes(data)
	if ok != 1 {
		panic("invalid data")
	}
}

func (f *Fq) Hex() string {
	data := f.Bytes()
	slices.Reverse(data)
	return hex.EncodeToString(data)
}

func (f *Fq) Degree() uint64 {
	return 1
}
