package curves_test

import (
	"testing"

	bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/bls12381/impl"
	"github.com/bronlabs/bron-crypto/pkg/base/curves/impl/points"
	k256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/k256/impl"
	p256Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/p256/impl"
	pastaImpl "github.com/bronlabs/bron-crypto/pkg/base/curves/pasta/impl"
)

func Benchmark_K256(b *testing.B) {
	var p k256Impl.Point
	p.SetGenerator()
	s := [32]byte{
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
	}
	h2cDst := "test"
	h2cBytes := [128]byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	b.Run("PointAdd", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Add(&p, &p)
		}
	})

	b.Run("PointDouble", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Double(&p)
		}
	})

	b.Run("PointScalarMul", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			points.ScalarMul[*k256Impl.Fp](&p, &p, s[:])
		}
	})

	b.Run("PointHashToCurve", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Hash(h2cDst, h2cBytes[:])
		}
	})
}

func Benchmark_P256(b *testing.B) {
	var p p256Impl.Point
	p.SetGenerator()
	s := [32]byte{
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
	}
	h2cDst := "test"
	h2cBytes := [128]byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	b.Run("PointAdd", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Add(&p, &p)
		}
	})

	b.Run("PointDouble", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Double(&p)
		}
	})

	b.Run("PointScalarMul", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			points.ScalarMul[*p256Impl.Fp](&p, &p, s[:])
		}
	})

	b.Run("PointHashToCurve", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Hash(h2cDst, h2cBytes[:])
		}
	})
}

func Benchmark_Pallas(b *testing.B) {
	var p pastaImpl.PallasPoint
	p.SetGenerator()
	s := [32]byte{
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
	}
	h2cDst := "test"
	h2cBytes := [128]byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	b.Run("PointAdd", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Add(&p, &p)
		}
	})

	b.Run("PointDouble", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Double(&p)
		}
	})

	b.Run("PointScalarMul", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			points.ScalarMul[*pastaImpl.Fp](&p, &p, s[:])
		}
	})

	b.Run("PointHashToCurve", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Hash(h2cDst, h2cBytes[:])
		}
	})
}

func Benchmark_Vesta(b *testing.B) {
	var p pastaImpl.VestaPoint
	p.SetGenerator()
	s := [32]byte{
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
	}
	h2cDst := "test"
	h2cBytes := [128]byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	b.Run("PointAdd", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Add(&p, &p)
		}
	})

	b.Run("PointDouble", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Double(&p)
		}
	})

	b.Run("PointScalarMul", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			points.ScalarMul[*pastaImpl.Fq](&p, &p, s[:])
		}
	})

	b.Run("PointHashToCurve", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Hash(h2cDst, h2cBytes[:])
		}
	})
}

func Benchmark_BLS12381G1(b *testing.B) {
	var p bls12381Impl.G1Point
	p.SetGenerator()
	s := [32]byte{
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
	}
	h2cDst := "test"
	h2cBytes := [128]byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	b.Run("PointAdd", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Add(&p, &p)
		}
	})

	b.Run("PointDouble", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Double(&p)
		}
	})

	b.Run("PointScalarMul", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			points.ScalarMul[*bls12381Impl.Fp](&p, &p, s[:])
		}
	})

	b.Run("PointHashToCurve", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Hash(h2cDst, h2cBytes[:])
		}
	})
}

func Benchmark_BLS12381G2(b *testing.B) {
	var p bls12381Impl.G2Point
	p.SetGenerator()
	s := [32]byte{
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
		0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
	}
	h2cDst := "test"
	h2cBytes := [128]byte{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	}

	b.Run("PointAdd", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Add(&p, &p)
		}
	})

	b.Run("PointDouble", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Double(&p)
		}
	})

	b.Run("PointScalarMul", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			points.ScalarMul[*bls12381Impl.Fp2](&p, &p, s[:])
		}
	})

	b.Run("PointHashToCurve", func(b *testing.B) {
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			p.Hash(h2cDst, h2cBytes[:])
		}
	})
}

func Benchmark_BLS12381Pairing(b *testing.B) {
	var p1 bls12381Impl.G1Point
	var p2 bls12381Impl.G2Point
	p1.SetGenerator()
	p2.SetGenerator()

	engine := new(bls12381Impl.Engine)
	engine.AddPair(&p1, &p2)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = engine.Result()
	}
}
