package curves

import (
	"github.com/cronokirby/saferith"
)

type CurveIdentifier interface{}

// Curve represents a named elliptic curve with a scalar field and point group.
type Curve[C CurveIdentifier] interface {
	// Profile returns the profile of the curve, with the field, subgroup order, and cofactor.
	Profile() CurveProfile[C]
	// Scalar exposes the curve.Scalar interface.
	Scalar() Scalar[C]
	// Point exposes the curve.Point interface.
	Point() Point[C]
	// FieldElement exposes the curve.FieldElement interface.
	FieldElement() FieldElement[C]

	// Name returns the name of the curve as defined in the `constants` package.
	Name() string
	// Generator returns the generator G of the curve group.
	Generator() Point[C]
	// ScalarBaseMult returns sc*G = G+G+...+G, where G is the generator of the curve group.
	ScalarBaseMult(sc Scalar[C]) Point[C]
	// MultiScalarMult returns scs[0]*ps[0] + scs[1]*ps[1] + ... + scs[n-1]*ps[n-1].
	MultiScalarMult(scs []Scalar[C], ps []Point[C]) (Point[C], error)
	// DeriveFromAffineX returns the two points (x, y) and (x, -y) on the curve, given x.
	DeriveFromAffineX(x FieldElement[C]) (evenY, oddY Point[C], err error)
	// HashToFieldElement hashes `msg` using the default curve hasher ([RFC9380])
	// to obtain `count` field elements. Optionally, a custom domain separation
	// tag (dst) can be provided for message expansion (default nil).
	//
	// [RFC9380]: https://datatracker.ietf.org/doc/html/rfc9380#section-5
	HashToFieldElements(count int, msg, optionalDst []byte) (u []FieldElement[C], err error)
	// HashToScalar hashes `msg` using the default curve hasher ([RFC9380])
	// to obtain `count` scalars (in a prime field Fq). Optionally, a custom domain
	//  separation  tag (dst) can be provided for message expansion (default nil).
	//
	// [RFC9380]: https://datatracker.ietf.org/doc/html/rfc9380#section-5
	HashToScalars(count int, msg, optionalDst []byte) (u []Scalar[C], err error)
}

type PairingCurve[C CurveIdentifier] interface {
	PairingCurveProfile() PairingCurveProfile
	Name() string

	// Yes. These are not curves, but the API is nice and gives us access to the base fields and scalar fields etc.

	G1() Curve[C]
	PointG1() PairingPoint[C]
	G2() Curve[C]
	PointG2() PairingPoint[C]
	Gt() Scalar[C]

	Pairing(pG1, pG2 PairingPoint[C]) Scalar[C]
	MultiPairing(...PairingPoint[C]) Scalar[C]
}

type WeierstrassCurve[C CurveIdentifier] interface {
	Curve[C]
	WeierstrassPoint[C]
}

type CurveProfile[C CurveIdentifier] interface {
	// Field returns the finite field profile over which the curve is defined
	Field() FieldProfile
	// SubGroupOrder returns the order of the subgroup generated by G
	SubGroupOrder() *saferith.Modulus
	// Cofactor return cofactor defined as Ord(Fp) / Ord(G)
	Cofactor() Scalar[C]
	// ToPairingCurve returns the larger PairingCurve interface, or nil if the curve is not pairing friendly.
	ToPairingCurve() PairingCurve[C]
}

type PairingCurveProfile interface {
	EmbeddingDegree() *saferith.Nat
}
