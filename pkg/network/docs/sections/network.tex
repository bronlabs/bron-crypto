% ---------------------------------------------------------------------------- %
\subsubsection{Networking}\label{sec:mpc_networking}
% ---------------------------------------------------------------------------- %
We assume that participants are connected via point-to-point authenticated channels. Sending a message through this channel is denoted by invoking $\idealfnref{Send}$ functionality, which is defined in Functionality \ref{func:p2psend}. To simplify the notation, we will call this functionality \fndef{Send} and use it via the convention $\send{\party{i}}{\party{j}}{m}$

\inputFunctionality{network}{send.tex}

We also use a broadcast functionality (Functionality \ref{func:broadcast}), which is when players need to send the same message to all other players.

\inputFunctionality{network}{broadcast.tex}

$\idealfnref{Broadcast}$ can be UC-realized, with security with abort in a Byzantine setting, via the two-round \fn{Echo\shortminus Broadcast} protocol formalized in~\cite[Protocol 2]{GL02}. In this context, we require that whenever a party aborts, they send a message to all other parties indicating that they have aborted. Honest parties should abort whenever they receive an abort message.

\paragraph{On the Coordinator.}

Although we do not make any assumptions regarding which protocols realize the above two functionalities, in practice, the networking layer is often implemented as a star graph: The communication is usually carried out through an trustless, possibly centralized third party that effectively routes signed messages between participants (e.g., a "coordinator" in \cite{L22}).

Such a pattern may be used for various reasons: It may be too costly to set up direct communication channels between parties (in terms of bandwidth or the round complexity of the entire protocol), or some aspects of the protocol may be simplified (e.g., no need for a session-id), or it may even be the case that parties do not know anything more than the public key of others.

In case a user of this primitive is to implement the networking layer as such, we should note that the protocol would remain secure as no sensitive information is passed that enables the coordinator to reconstruct the private key or forge any signatures, but the following should be considered:

First, A maliciously behaving coordinator can induce an abort of the protocol by simply not sending a message from a participant. A participant cannot distinguish the malicious coordinator from the counter-party simply timing out. This issue, however, does not break the identifiable abort subprotocol of our primitive as it is only attributing aborts based on the consistency of the delivered messages, not the delivery itself.

Second, if the coordinator is also set as an external signature aggregator and there is only one signature aggregator, then a coordinator alone can learn the signature and not send it back to the signature requester. In practice, however, it may be possible to detect a malicious coordinator if there is a log of the participant's activities. In either case, this should be fine, because we are operating in the no-honest majority setting and guaranteed output delivery is impossible~\cite{cleve1986limits,ishai2006combining}. 

Finally, note that it is critical to have the messages signed/authenticated before sending them to the coordinator. If the coordinator is to distribute the initial identity keys, then authentication for the Distributed Key Generation (DKG) protocol (detailed in Protocol \ref{alg:gennarodkg}) is mandatory. Otherwise the coordinator could simulate other parties, compromising key generation with potentially catastrophic consequences for the crypto custody use case.

