package bls

import (
	"io"

	"golang.org/x/crypto/hkdf"

	"github.com/bronlabs/krypton-primitives/pkg/base"
	"github.com/bronlabs/krypton-primitives/pkg/base/bitstring"
	"github.com/bronlabs/krypton-primitives/pkg/base/curves"
	"github.com/bronlabs/krypton-primitives/pkg/base/curves/bls12381"
	bls12381Impl "github.com/bronlabs/krypton-primitives/pkg/base/curves/bls12381/impl"
	"github.com/bronlabs/krypton-primitives/pkg/base/errs"
	"github.com/bronlabs/krypton-primitives/pkg/hashing"
)

const (
	// Secret key in Fr.
	SecretKeySize = bls12381Impl.FqBytes
	// The salt used with generating secret keys
	// See section 2.3 from https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-keygen
	HKDFKeyGenSalt = "BLS-SIG-KEYGEN-SALT-"
)

// The KeyGen procedure described in this section generates a secret key SK deterministically from a secret octet string IKM. SK is guaranteed to be nonzero.
// For security, IKM MUST be infeasible to guess, e.g., generated by a trusted source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.
func KeyGenWithSeed[K KeySubGroup](ikm []byte) (*PrivateKey[K], error) {
	if len(ikm) < 32 {
		return nil, errs.NewLength("ikm is too short. Must be at least 32")
	}

	keySubGroup := bls12381.GetSourceSubGroup[K]()
	d := keySubGroup.ScalarField().Zero()

	// We assume h models a random oracle, so we don't parametrize salt.
	// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#choosesalt
	salt, err := hashing.Hash(base.RandomOracleHashFunction, []byte(HKDFKeyGenSalt))
	if err != nil {
		return nil, errs.WrapHashing(err, "could not produce salt")
	}

	// step 2.3.1
	for d.IsZero() {
		ikm = append(ikm, 0)
		// step 2.3.2
		kdf := hkdf.New(base.RandomOracleHashFunction, ikm, salt, []byte{0, 48})
		var okm [bls12381Impl.FqWideBytes]byte
		// Leaves key_info parameter as the default empty string
		// step 2.3.3
		_, err := io.ReadFull(kdf, okm[:48])
		if err != nil {
			return nil, errs.WrapRandomSample(err, "could not read from kdf")
		}
		copy(okm[:48], bitstring.ReverseBytes(okm[:48]))

		// step 2.3.4
		di := &bls12381.Scalar{G: keySubGroup}
		ok := di.V.SetBytesWide(okm[:])
		if ok != 1 {
			return nil, errs.NewFailed("could not set key bytes")
		}
		d = di

		salt, err = hashing.Hash(base.RandomOracleHashFunction, salt)
		if err != nil {
			return nil, errs.WrapHashing(err, "could not produce salt")
		}
	}

	// 2.4: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-sktopk
	Y := keySubGroup.ScalarBaseMult(d).(curves.PairingPoint)
	dValue := d.(*bls12381.Scalar)
	dValue.G = keySubGroup

	return &PrivateKey[K]{
		d: dValue,
		PublicKey: &PublicKey[K]{
			Y: Y,
		},
	}, nil
}

func KeyGen[K KeySubGroup](prng io.Reader) (*PrivateKey[K], error) {
	if prng == nil {
		return nil, errs.NewIsNil("prng is nil")
	}
	ikm := make([]byte, 32)
	if _, err := io.ReadFull(prng, ikm); err != nil {
		return nil, errs.WrapRandomSample(err, "could not read random bytes")
	}
	return KeyGenWithSeed[K](ikm)
}
