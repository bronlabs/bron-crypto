package bls

import (
	"github.com/bronlabs/bron-crypto/pkg/base"
	"github.com/bronlabs/bron-crypto/pkg/base/algebra/fields"
	"github.com/bronlabs/bron-crypto/pkg/base/curves"
	bls12381Impl "github.com/bronlabs/bron-crypto/pkg/base/curves/bls12381/impl"
	"github.com/bronlabs/bron-crypto/pkg/base/errs"
	"github.com/bronlabs/bron-crypto/pkg/hashing"
	"golang.org/x/crypto/hkdf"
	"io"
	"slices"
)

const (
	// SecretKeySize Secret key length in Fr.
	SecretKeySize = bls12381Impl.FqBytes

	// HKDFKeyGenSalt is the salt used with generating secret keys
	// See section 2.3 from https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-keygen
	HKDFKeyGenSalt = "BLS-SIG-KEYGEN-SALT-"
)

// KeyGenWithSeed procedure described in this section generates a secret key SK deterministically from a secret octet string IKM. SK is guaranteed to be nonzero.
// For security, IKM MUST be infeasible to guess, e.g., generated by a trusted source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.
func KeyGenWithSeed[P curves.Point[P, B, S], B fields.FiniteFieldElement[B], S fields.PrimeFieldElement[S]](curve curves.Curve[P, B, S], ikm []byte) (*PrivateKey[P, B, S], error) {
	if len(ikm) < 32 {
		return nil, errs.NewLength("ikm is too short. Must be at least 32")
	}

	d := curve.ScalarField().Zero()

	// We assume h models a random oracle, so we don't parametrize salt.
	// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#choosesalt
	salt, err := hashing.Hash(base.RandomOracleHashFunction, []byte(HKDFKeyGenSalt))
	if err != nil {
		return nil, errs.WrapHashing(err, "could not produce salt")
	}

	// step 2.3.1
	for d.IsZero() {
		ikm = append(ikm, 0)
		// step 2.3.2
		kdf := hkdf.New(base.RandomOracleHashFunction, ikm, salt, []byte{0, 48})
		var okm [bls12381Impl.FqWideBytes]byte
		// Leaves key_info parameter as the default empty string
		// step 2.3.3
		_, err := io.ReadFull(kdf, okm[:48])
		if err != nil {
			return nil, errs.WrapRandomSample(err, "could not read from kdf")
		}
		slices.Reverse(okm[:])

		// step 2.3.4
		di, err := curve.ScalarField().FromWideBytes(okm[:])
		if err != nil {
			return nil, errs.WrapFailed(err, "could not set key bytes")
		}
		d = di

		salt, err = hashing.Hash(base.RandomOracleHashFunction, salt)
		if err != nil {
			return nil, errs.WrapHashing(err, "could not produce salt")
		}
	}

	// 2.4: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-sktopk
	Y := curve.Generator().ScalarMul(d)

	return &PrivateKey[P, B, S]{
		d: d,
		PublicKey: &PublicKey[P, B, S]{
			Y: Y,
		},
	}, nil
}

func KeyGen[P curves.Point[P, B, S], B fields.FiniteFieldElement[B], S fields.PrimeFieldElement[S]](curve curves.Curve[P, B, S], prng io.Reader) (*PrivateKey[P, B, S], error) {
	if prng == nil {
		return nil, errs.NewIsNil("prng is nil")
	}
	ikm := make([]byte, 32)
	if _, err := io.ReadFull(prng, ikm); err != nil {
		return nil, errs.WrapRandomSample(err, "could not read random bytes")
	}
	return KeyGenWithSeed[P, B, S](curve, ikm)
}
