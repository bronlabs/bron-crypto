package bls

import (
	"crypto/sha256"
	"io"

	"golang.org/x/crypto/hkdf"

	"github.com/copperexchange/krypton-primitives/pkg/base/bitstring"
	"github.com/copperexchange/krypton-primitives/pkg/base/constants"
	"github.com/copperexchange/krypton-primitives/pkg/base/curves"
	"github.com/copperexchange/krypton-primitives/pkg/base/curves/bls12381"
	bimpl "github.com/copperexchange/krypton-primitives/pkg/base/curves/bls12381/impl"
	"github.com/copperexchange/krypton-primitives/pkg/base/errs"
	"github.com/copperexchange/krypton-primitives/pkg/hashing"
)

const (
	// Secret key in Fr.
	SecretKeySize = 32
	// The salt used with generating secret keys
	// See section 2.3 from https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-keygen
	HKDFKeyGenSalt = "BLS-SIG-KEYGEN-SALT-"
)

// The KeyGen procedure described in this section generates a secret key SK deterministically from a secret octet string IKM. SK is guaranteed to be nonzero.
// For security, IKM MUST be infeasible to guess, e.g., generated by a trusted source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.
func KeyGenWithSeed[K KeySubGroup](ikm []byte) (*PrivateKey[K], error) {
	if len(ikm) < 32 {
		return nil, errs.NewInvalidLength("ikm is too short. Must be at least 32")
	}

	pointInK := new(K)
	d := (*pointInK).Scalar().Zero()

	// We assume h models a random oracle, so we don't parametrize salt.
	// https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#choosesalt
	salt, err := hashing.Hash(sha256.New, []byte(HKDFKeyGenSalt))
	if err != nil {
		return nil, errs.WrapFailed(err, "could not produce salt")
	}

	// step 2.3.1
	for d.IsZero() {
		ikm = append(ikm, 0)
		// step 2.3.2
		kdf := hkdf.New(sha256.New, ikm, salt, []byte{0, 48})
		var okm [constants.WideFieldBytes]byte
		// Leaves key_info parameter as the default empty string
		// step 2.3.3
		read, err := kdf.Read(okm[:48])
		if err != nil {
			return nil, errs.WrapRandomSampleFailed(err, "could not read from kdf")
		}
		if read != 48 {
			return nil, errs.NewFailed("failed to create private key")
		}
		copy(okm[:48], bitstring.ReverseBytes(okm[:48]))

		// step 2.3.4
		v := bimpl.FqNew().SetBytesWide(&okm)

		pairingIdentityInK, ok := (*pointInK).Identity().(curves.PairingPoint)
		if !ok {
			return nil, errs.NewInvalidType("could not get pairable identity point in K")
		}
		d = &bls12381.Scalar{
			Value:  v,
			Point_: pairingIdentityInK,
		}
		salt, err = hashing.Hash(sha256.New, salt)
		if err != nil {
			return nil, errs.WrapFailed(err, "could not produce salt")
		}
	}

	// 2.4: https://www.ietf.org/archive/id/draft-irtf-cfrg-bls-signature-05.html#name-sktopk
	Y, ok := (*pointInK).Curve().ScalarBaseMult(d).(curves.PairingPoint)
	if !ok {
		return nil, errs.NewInvalidType("public key could not be converted to pairing point. This should never happen.")
	}
	dValue, ok := d.(*bls12381.Scalar)
	if !ok {
		return nil, errs.NewInvalidType("d could not be converted to a bls scalar. This should never happen.")
	}

	return &PrivateKey[K]{
		d: dValue,
		PublicKey: &PublicKey[K]{
			Y: Y,
		},
	}, nil
}

func KeyGen[K KeySubGroup](prng io.Reader) (*PrivateKey[K], error) {
	if prng == nil {
		return nil, errs.NewIsNil("prng is nil")
	}
	ikm := make([]byte, 32)
	if _, err := prng.Read(ikm); err != nil {
		return nil, errs.WrapFailed(err, "could not read random bytes")
	}
	return KeyGenWithSeed[K](ikm)
}
