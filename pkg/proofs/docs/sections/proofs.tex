In cryptography, a Proof of Knowledge (PoK) is a protocol in which a prover can convince a verifier that it knows something \cite{katz2007introduction}. More formally, a PoK is defined for a certain relation $R:\{(x,w): x \in L, w \in W(x)\}$ composed of a statement $x$ (e.g., I know a value whose hash is a certain known digest $d$) from a language\footnote{That is, a set of statements with some common properties. $L \in N\!P$ for our purposes, making it computationally unfeasible to craft statements without appropriate witnesses.} $L$ and all the witnesses $w$ that satisfy that statement $W(x)$ (e.g., the values $m$ such that $\fn{H}(m) = d$). For such a relation, and with knowledge error $\kappa$, a PoK is a two party protocol between a prover $\mathcal{P}$ and a verifier $\mathcal{V}$ with the following two properties:
\begin{itemize}
    \item \textit{Completeness}: if the statement is true and thus $(x,w) \in R$, then a prover $\mathcal{P}$ who knows a witness $w$ for $x$ succeeds in convincing the verifier $\mathcal{V}$ of his knowledge with probability $1$.
    \item \textit{Soundness}: if the statement is false and thus  $\mathcal{P}$ doesn't know a witness $w$ for $x$, the probability that any prover $\mathcal{P}$ can convince the verifier $\mathcal{V}$ of his knowledge of $x$ is at most $\kappa$.
\end{itemize}

Additionally, a PoK is \textit{zero-knowledge} (ZKPoK) if the verifier $\mathcal{V}$ learns nothing about the witness $w$ other than the fact that it satisfies the relation $R$\footnote{This property is formalized by the existence of a simulator $\mathcal{S}$ named the \textit{knowledge extractor} that can produce a transcript of the protocol between $\mathcal{P}$ and $\mathcal{V}$ without knowing any witness $w$ for $x$.}. The proofs presented in this section are all ZK. We require these proofs to protect against active adversaries in our protocols and abort upon detection of malicious behavior.

We are mainly interested on public-coin Interactive Proofs (\fndef{IP}) where, after a protocol setup $\fn{IP}.\fn{Setup}$, the verifier $\mathcal{V}$ sends in one or multiple rounds some random challenges $\assign{e_i}{\fn{IP}.\fn{Challenge}}$ (the public coins) to the prover $\assign{\pi_i}{\fn{IP}.\fn{Prove}}$, who then responds with a proof $\pi_i$. The verifier $\mathcal{V}$ can then verify each proof $\fn{IP}.\fn{Verify}(\pi_i, x, e_i)$ using the statement $x$ and its challenge $e_i$.