//
// Copyright Coinbase, Inc. All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

package elgamal

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/sha256"

	"github.com/copperexchange/knox-primitives/pkg/core/curves"
	"github.com/copperexchange/knox-primitives/pkg/core/errs"
	"github.com/copperexchange/knox-primitives/pkg/core/hashing"
	"github.com/copperexchange/knox-primitives/pkg/core/integration"
)

// DecryptionKey decrypts verifiable ciphertext and verifies proofs.
type DecryptionKey struct {
	x curves.Scalar
}

type Decryptor struct {
	decryptionKey *DecryptionKey
}

func NewDecryptor(decryptionKey *DecryptionKey) *Decryptor {
	return &Decryptor{decryptionKey: decryptionKey}
}

// EncryptionKey returns the corresponding encryption key for this decryption key.
func (dk *DecryptionKey) EncryptionKey() *EncryptionKey {
	return &EncryptionKey{
		Value: dk.x.Curve().ScalarBaseMult(dk.x),
	}
}

// Decrypt returns the resulting point from El-Gamal decryption.
// No checking is performed whether the ciphertext has been modified.
// M = H * m = C2 - C1 * x.
func (d *Decryptor) Decrypt(cipherText *HomomorphicCipherText) curves.Point {
	if cipherText == nil {
		return nil
	}
	return cipherText.C2.Sub(cipherText.C1.Mul(d.decryptionKey.x))
}

// VerifiableDecrypt the ciphertext. This performs verifiable decryption
// such that the decrypted data is checked against El-Gamal C2 value.
// If the plaintext does not match, an error is returned
// been generated by Encrypt.
func (d *Decryptor) VerifiableDecrypt(cipherText *CipherText) ([]byte, curves.Scalar, error) {
	msgBytes, msgScalar, rhs, err := d.decryptData(cipherText)
	if err != nil {
		return nil, nil, err
	}
	h := d.decryptionKey.EncryptionKey().Value.Generator()
	lhs := h.Mul(msgScalar)
	if !lhs.Equal(rhs) {
		return nil, nil, errs.NewFailed("ciphertext mismatch")
	}
	return msgBytes, msgScalar, nil
}

// VerifiableDecryptWithDomain the ciphertext. This performs verifiable decryption
// such that the decrypted data is checked against El-Gamal C2 value.
// If the plaintext does not match, an error is returned
// The Domain component is meant for scenarios where `msg` is used in more
// than just one setting and should be contextualised. The ciphertext must have
// been generated by EncryptWithDomain.
func (d *Decryptor) VerifiableDecryptWithDomain(domain []byte, cipherText *CipherText) ([]byte, curves.Scalar, error) {
	msgBytes, msgScalar, rhs, err := d.decryptData(cipherText)
	if err != nil {
		return nil, nil, err
	}
	ek := d.decryptionKey.EncryptionKey()
	genBytes := append(domain, ek.Value.ToAffineUncompressed()...)
	genBytes = append(genBytes, cipherText.Nonce...)

	h := ek.Value.Hash(genBytes)
	lhs := h.Mul(msgScalar)
	if !lhs.Equal(rhs) {
		return nil, nil, errs.NewFailed("ciphertext mismatch")
	}
	return msgBytes, msgScalar, nil
}

func (d *Decryptor) decryptData(cipherText *CipherText) ([]byte, curves.Scalar, curves.Point, error) {
	if cipherText == nil || cipherText.C1 == nil || cipherText.C2 == nil || cipherText.Nonce == nil || cipherText.Aead == nil {
		return nil, nil, nil, errs.NewIsNil("cipher text is is or has nil values")
	}

	// Have to check these because aesgcm will panic if not the correct length
	if len(cipherText.Nonce) < 12 || len(cipherText.Aead) < 16 {
		return nil, nil, nil, errs.NewInvalidLength("nonce or AEAD has invalid length")
	}
	// r * Q
	t := cipherText.C1.Mul(d.decryptionKey.x)

	aeadKey, err := hashing.FiatShamir(&integration.CipherSuite{
		Curve: t.Curve(),
		Hash:  sha256.New,
	}, t.ToAffineUncompressed())
	if err != nil {
		return nil, nil, nil, errs.WrapFailed(err, "cannot derive AEAD key")
	}

	block, err := aes.NewCipher(aeadKey.Bytes())
	if err != nil {
		return nil, nil, nil, errs.WrapFailed(err, "cannot create AES cipher")
	}
	aesGcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, nil, nil, errs.WrapFailed(err, "cannot create GCM")
	}

	aad := cipherText.C1.ToAffineUncompressed()
	aad = append(aad, cipherText.C2.ToAffineUncompressed()...)
	// AAD = C1 || C2
	msgBytes, err := aesGcm.Open(nil, cipherText.Nonce, cipherText.Aead, aad)
	if err != nil {
		return nil, nil, nil, errs.NewFailed("cannot open AES GCM")
	}
	msg := d.decryptionKey.x.Curve().Scalar().New(0)
	if cipherText.MsgIsHashed {
		msg, err = msg.SetBytes(msgBytes)
		if err != nil {
			return nil, nil, nil, errs.WrapFailed(err, "cannot set scalar")
		}
	} else {
		msg = msg.Hash(msgBytes)
	}
	if err != nil {
		return nil, nil, nil, errs.WrapFailed(err, "cannot hash message")
	}
	rhs := cipherText.C2.Sub(t)

	return msgBytes, msg, rhs, nil
}
