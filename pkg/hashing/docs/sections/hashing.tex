%------------------------------------------------------------------------------%
\subsubsection{Hashing}\label{sec:hashing}
%------------------------------------------------------------------------------%


A cryptographic hash function $\fn{H}(m)$ is a one-way function mapping arbitrary inputs, typically of a variable size, to seemingly uncorrelated outputs of a defined size~\cite[Chapter 4]{katz2007introduction}. We refer to the output of a hash function for a given input as its digest. A hash function holds several properties:
\begin{itemize}
    \item \textit{Preimage resistance}: Given a digest $d$, it should be difficult to find any input message $m$ such that $d = \fn{H}(m)$. This property is sometimes named "Security Strength" or "One-Way" in the literature.
    \item \textit{Second-preimage resistance}: for a specified input $m$, it is computationally infeasible to find an input $m'$ producing the same result $\fn{H}(m') = \fn{H}(m)$.
    \item \textit{Collision resistance}: It should be difficult to find a pair different messages $m_1$ and $m_2$ such that $\fn{H}(m_1) = \fn{H}(m_2)$. This pair is called a \textit{collision}. Due to the birthday attack, a digest size of at least $2n$ bits is required for $n$ bits of collision resistance.
\end{itemize}

In our protocols, we make extensive use of hash functions to convert interactive protocols into its non-interactive version via several transformations (more on \autoref{sec:proof_dlog}), to $\fn{Commit}$ on a secret value before opening it, and in general as a method to realize Random Oracles (ROs) by employing some agreed-upon fresh random value (the session ID or $sid$, but more of that on \autoref{sec:mpc_agreeonrandom}) alongside other arbitrary tags for domain separation.

Following the official recommendations from NIST, we limit our choice of hash functions mainly to SHA256, SHA512 (as defined in FIPS 180-4~\cite{FIPS1804}), the SHA-3 fixed-output-length hash functions and the Shake variable-output-length family (as defined in FIPS-202~\cite{FIPS202}). Additionally, we implement the hash-to-curve primitives from RFC 9380~\cite{rfc9380}, defining mechanisms to hash arbitrary strings into both fields of any order and elliptic curve points.