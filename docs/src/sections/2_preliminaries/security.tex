
%------------------------------------------------------------------------------%
\subsubsection{On Cryptographic Security}\label{sec:security}
%------------------------------------------------------------------------------%

The security of a cryptographic protocol/primitive is framed to provide guarantees that certain properties hold even when an adversary tries to break said protocol/primitive. As a result, the security of a cryptographic protocol is defined in terms of the adversary's ability to break these properties.

In cryptography, an \textit{adversary} is an algorithmic entity that attempts to compromise the security of a cryptographic system. The adversary is often assumed to be bounded, but it can be further restricted to be probabilistic, deterministic, or quantum. The adversary's goal is to break the security properties of the cryptographic system, such as confidentiality, integrity, authenticity, and non-repudiation.
Simulation-Based Security vs. Game-Based Security:
Both simulation-based and game-based approaches are used to define security properties of cryptographic protocols.
Game-Based Security:
Game-based definitions are easier to write proofs for.
However, they may not always provide the clearest security guarantees.
Example: IND-CPA (game-based) versus semantic security (simulation-based).
IND-CPA focuses on distinguishing ciphertexts, but it doesn‚Äôt directly imply strong security.
Semantic security, on the other hand, provides a clearer guarantee.
Simulation-Based Security:
Simulation-based definitions are often clearer in terms of security guarantees.
They allow us to reason about security under composition (combining multiple protocols).
Security under composition:
Sequential composition: Security holds when protocols are executed one after another.
Universal composability: Security holds even when combined with arbitrary other protocols.
Simulation-based definitions are qualitatively better in most cases due to their clear guarantees and composition properties.
Advantage of the Adversary:
The adversary‚Äôs advantage measures how successfully it can attack a cryptographic algorithm.
It quantifies the adversary‚Äôs ability to distinguish the real system from an idealized version (e.g., an oracle).

Computational vs. Statistical Security:
Computational Security:
Based on the assumption that certain computational problems are hard to solve.
Examples: Factoring large numbers, discrete logarithm problem.
Schemes like RSA and Diffie-Hellman rely on computational hardness.
Statistical Security:
Focuses on probabilities and statistical guarantees.
Examples: Perfect secrecy (Shannon‚Äôs theory), information-theoretic security.
Achieving statistical security doesn‚Äôt rely on computational assumptions.
In summary, cryptographic security involves designing protocols that withstand adversarial attacks, and we analyze their security using simulation-based or game-based definitions. The adversary‚Äôs advantage plays a crucial role, and we consider both computational and statistical aspects. üõ°Ô∏èüîí